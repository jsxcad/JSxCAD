import {
  canonicalize,
  getAnySurfaces,
  getPaths,
  isNotVoid,
  measureBoundingBox,
  toKeptGeometry,
  translate,
} from "@jsxcad/geometry-tagged";

import { outline } from "@jsxcad/geometry-surface";

const X = 0;
const Y = 1;

const toColorFromTags = (tags, otherwise = "black") => {
  if (tags !== undefined) {
    for (const tag of tags) {
      if (tag.startsWith("color/")) {
        return tag.substring(6);
      }
    }
  }
  return otherwise;
};

export const toSvg = async (baseGeometry, { padding = 0 } = {}) => {
  const [min, max] = measureBoundingBox(baseGeometry);
  const width = max[X] - min[X];
  const height = max[Y] - min[Y];
  const translated = translate([width / 2, height / 2, 0], baseGeometry);
  const geometry = canonicalize(toKeptGeometry(translated));

  const svg = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<!-- Generated by jsxcad -->`,
    `<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">`,
    `<svg baseProfile="tiny" height="${height}mm" width="${width}mm" viewBox="${-padding} ${-padding} ${
      width + 2 * padding
    } ${
      height + 2 * padding
    }" version="1.1" stroke="black" stroke-width=".1" fill="none" xmlns="http://www.w3.org/2000/svg">`,
  ];

  for (const { surface, z0Surface, tags } of getAnySurfaces(geometry).filter(
    isNotVoid
  )) {
    const anySurface = surface || z0Surface;
    if (anySurface === undefined) throw Error("die");
    const color = toColorFromTags(tags);
    const paths = [];
    for (const polygon of outline(anySurface)) {
      paths.push(
        `${polygon
          .map(
            (point, index) =>
              `${index === 0 ? "M" : "L"}${point[0]} ${point[1]}`
          )
          .join(" ")} z`
      );
    }
    svg.push(`<path fill="${color}" stroke="none" d="${paths.join(" ")}"/>`);
  }
  for (const { paths, tags } of getPaths(geometry).filter(isNotVoid)) {
    const color = toColorFromTags(tags);
    for (const path of paths) {
      if (path[0] === null) {
        svg.push(
          `<path stroke="${color}" fill="none" d="${path
            .slice(1)
            .map(
              (point, index) =>
                `${index === 0 ? "M" : "L"}${point[0]} ${point[1]}`
            )
            .join(" ")}"/>`
        );
      } else {
        svg.push(
          `<path stroke="${color}" fill="none" d="${path
            .map(
              (point, index) =>
                `${index === 0 ? "M" : "L"}${point[0]} ${point[1]}`
            )
            .join(" ")} z"/>`
        );
      }
    }
  }
  svg.push("</svg>");
  const output = svg.join("\n");
  return new TextEncoder("utf8").encode(output);
};
