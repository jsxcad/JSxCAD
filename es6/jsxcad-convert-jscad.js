var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var api = createCommonjsModule(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(commonjsGlobal, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/api/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./csg.js":
/*!****************!*\
  !*** ./csg.js ***!
  \****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n## License\n\nCopyright (c) 2014 bebbi (elghatta@gmail.com)\nCopyright (c) 2013 Eduard Bespalov (edwbes@gmail.com)\nCopyright (c) 2012 Joost Nieuwenhuijse (joost@newhouse.nl)\nCopyright (c) 2011 Evan Wallace (http://evanw.github.com/csg.js/)\nCopyright (c) 2012 Alexandre Girard (https://github.com/alx)\n\nAll code released under MIT license\n\n## Overview\n\nFor an overview of the CSG process see the original csg.js code:\nhttp://evanw.github.com/csg.js/\n\nCSG operations through BSP trees suffer from one problem: heavy fragmentation\nof polygons. If two CSG solids of n polygons are unified, the resulting solid may have\nin the order of n*n polygons, because each polygon is split by the planes of all other\npolygons. After a few operations the number of polygons explodes.\n\nThis version of CSG.js solves the problem in 3 ways:\n\n1. Every polygon split is recorded in a tree (CSG.PolygonTreeNode). This is a separate\ntree, not to be confused with the CSG tree. If a polygon is split into two parts but in\nthe end both fragments have not been discarded by the CSG operation, we can retrieve\nthe original unsplit polygon from the tree, instead of the two fragments.\n\nThis does not completely solve the issue though: if a polygon is split multiple times\nthe number of fragments depends on the order of subsequent splits, and we might still\nend up with unncessary splits:\nSuppose a polygon is first split into A and B, and then into A1, B1, A2, B2. Suppose B2 is\ndiscarded. We will end up with 2 polygons: A and B1. Depending on the actual split boundaries\nwe could still have joined A and B1 into one polygon. Therefore a second approach is used as well:\n\n2. After CSG operations all coplanar polygon fragments are joined by a retesselating\noperation. See CSG.reTesselated(). Retesselation is done through a\nlinear sweep over the polygon surface. The sweep line passes over the y coordinates\nof all vertices in the polygon. Polygons are split at each sweep line, and the fragments\nare joined horizontally and vertically into larger polygons (making sure that we\nwill end up with convex polygons).\nThis still doesn't solve the problem completely: due to floating point imprecisions\nwe may end up with small gaps between polygons, and polygons may not be exactly coplanar\nanymore, and as a result the retesselation algorithm may fail to join those polygons.\nTherefore:\n\n3. A canonicalization algorithm is implemented: it looks for vertices that have\napproximately the same coordinates (with a certain tolerance, say 1e-5) and replaces\nthem with the same vertex. If polygons share a vertex they will actually point to the\nsame CSG.Vertex instance. The same is done for polygon planes. See CSG.canonicalized().\n\nPerformance improvements to the original CSG.js:\n\nReplaced the flip() and invert() methods by flipped() and inverted() which don't\nmodify the source object. This allows to get rid of all clone() calls, so that\nmultiple polygons can refer to the same CSG.Plane instance etc.\n\nThe original union() used an extra invert(), clipTo(), invert() sequence just to remove the\ncoplanar front faces from b; this is now combined in a single b.clipTo(a, true) call.\n\nDetection whether a polygon is in front or in back of a plane: for each polygon\nwe are caching the coordinates of the bounding sphere. If the bounding sphere is\nin front or in back of the plane we don't have to check the individual vertices\nanymore.\n\nOther additions to the original CSG.js:\n\nCSG.Vector class has been renamed into CSG.Vector3D\n\nClasses for 3D lines, 2D vectors, 2D lines, and methods to find the intersection of\na line and a plane etc.\n\nTransformations: CSG.transform(), CSG.translate(), CSG.rotate(), CSG.scale()\n\nExpanding or contracting a solid: CSG.expand() and CSG.contract(). Creates nice\nsmooth corners.\n\nThe vertex normal has been removed since it complicates retesselation. It's not needed\nfor solid CAD anyway.\n\n*/\n\nconst { addTransformationMethodsToPrototype } = __webpack_require__(/*! ./src/core/mutators */ \"./src/core/mutators.js\");\nlet CSG = __webpack_require__(/*! ./src/core/CSG */ \"./src/core/CSG.js\");\nlet CAG = __webpack_require__(/*! ./src/core/CAG */ \"./src/core/CAG.js\");\n\n// FIXME: how many are actual usefull to be exposed as API ?? looks like a code smell\nconst {\n  _CSGDEBUG,\n  defaultResolution2D,\n  defaultResolution3D,\n  EPS,\n  angleEPS,\n  areaEPS,\n  all,\n  top,\n  bottom,\n  left,\n  right,\n  front,\n  back,\n  staticTag,\n  getTag,\n} = __webpack_require__(/*! ./src/core/constants */ \"./src/core/constants.js\");\n\nCSG._CSGDEBUG = _CSGDEBUG;\nCSG.defaultResolution2D = defaultResolution2D;\nCSG.defaultResolution3D = defaultResolution3D;\nCSG.EPS = EPS;\nCSG.angleEPS = angleEPS;\nCSG.areaEPS = areaEPS;\nCSG.all = all;\nCSG.top = top;\nCSG.bottom = bottom;\nCSG.left = left;\nCSG.right = right;\nCSG.front = front;\nCSG.back = back;\nCSG.staticTag = staticTag;\nCSG.getTag = getTag;\n\n// eek ! all this is kept for backwards compatibility...for now\nCSG.Vector2D = __webpack_require__(/*! ./src/core/math/Vector2 */ \"./src/core/math/Vector2.js\");\nCSG.Vector3D = __webpack_require__(/*! ./src/core/math/Vector3 */ \"./src/core/math/Vector3.js\");\nCSG.Vertex = __webpack_require__(/*! ./src/core/math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nCAG.Vertex = __webpack_require__(/*! ./src/core/math/Vertex2 */ \"./src/core/math/Vertex2.js\");\nCSG.Plane = __webpack_require__(/*! ./src/core/math/Plane */ \"./src/core/math/Plane.js\");\nCSG.Polygon = __webpack_require__(/*! ./src/core/math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nCSG.Polygon2D = __webpack_require__(/*! ./src/core/math/Polygon2 */ \"./src/core/math/Polygon2.js\");\nCSG.Line2D = __webpack_require__(/*! ./src/core/math/Line2 */ \"./src/core/math/Line2.js\");\nCSG.Line3D = __webpack_require__(/*! ./src/core/math/Line3 */ \"./src/core/math/Line3.js\");\nCSG.Path2D = __webpack_require__(/*! ./src/core/math/Path2 */ \"./src/core/math/Path2.js\");\nCSG.OrthoNormalBasis = __webpack_require__(/*! ./src/core/math/OrthoNormalBasis */ \"./src/core/math/OrthoNormalBasis.js\");\nCSG.Matrix4x4 = __webpack_require__(/*! ./src/core/math/Matrix4 */ \"./src/core/math/Matrix4.js\");\n\nCAG.Side = __webpack_require__(/*! ./src/core/math/Side */ \"./src/core/math/Side.js\");\n\nCSG.Connector = __webpack_require__(/*! ./src/core/connectors */ \"./src/core/connectors.js\").Connector;\nCSG.ConnectorList = __webpack_require__(/*! ./src/core/connectors */ \"./src/core/connectors.js\").ConnectorList;\nCSG.Properties = __webpack_require__(/*! ./src/core/Properties */ \"./src/core/Properties.js\");\n\nconst {\n  circle,\n  ellipse,\n  rectangle,\n  roundedRectangle,\n} = __webpack_require__(/*! ./src/api/primitives2d */ \"./src/api/primitives2d.js\");\nconst {\n  sphere,\n  cube,\n  roundedCube,\n  cylinder,\n  roundedCylinder,\n  cylinderElliptic,\n  polyhedron,\n} = __webpack_require__(/*! ./src/api/primitives3d */ \"./src/api/primitives3d.js\");\n\nCSG.sphere = sphere;\nCSG.cube = cube;\nCSG.roundedCube = roundedCube;\nCSG.cylinder = cylinder;\nCSG.roundedCylinder = roundedCylinder;\nCSG.cylinderElliptic = cylinderElliptic;\nCSG.polyhedron = polyhedron;\n\nCAG.circle = circle;\nCAG.ellipse = ellipse;\nCAG.rectangle = rectangle;\nCAG.roundedRectangle = roundedRectangle;\n\n// injecting factories\nconst {\n  fromPolygons,\n  fromCompactBinary,\n  fromObject,\n  fromSlices,\n} = __webpack_require__(/*! ./src/core/CSGFactories */ \"./src/core/CSGFactories.js\");\nCSG.fromCompactBinary = fromCompactBinary;\nCSG.fromObject = fromObject;\nCSG.fromSlices = fromSlices;\nCSG.fromPolygons = fromPolygons;\n\nCSG.toPointCloud = __webpack_require__(/*! ./src/api/debugHelpers */ \"./src/api/debugHelpers.js\").toPointCloud;\n\nconst CAGFactories = __webpack_require__(/*! ./src/core/CAGFactories */ \"./src/core/CAGFactories.js\");\nCAG.fromSides = CAGFactories.fromSides;\nCAG.fromObject = CAGFactories.fromObject;\nCAG.fromPoints = CAGFactories.fromPoints;\nCAG.fromPointsNoCheck = CAGFactories.fromPointsNoCheck;\nCAG.fromPath2 = CAGFactories.fromPath2;\nCAG.fromFakeCSG = CAGFactories.fromFakeCSG;\nCAG.fromCompactBinary = CAGFactories.fromCompactBinary;\n\n/// ////////////////////////////////////\n// option parsers\nconst optionsParsers = __webpack_require__(/*! ./src/api/optionParsers */ \"./src/api/optionParsers.js\");\n\n// ////////////////////////////////////\naddTransformationMethodsToPrototype(CSG.prototype);\naddTransformationMethodsToPrototype(CSG.Vector2D.prototype);\naddTransformationMethodsToPrototype(CSG.Vector3D.prototype);\naddTransformationMethodsToPrototype(CSG.Vertex.prototype);\naddTransformationMethodsToPrototype(CSG.Plane.prototype);\naddTransformationMethodsToPrototype(CSG.Polygon.prototype);\naddTransformationMethodsToPrototype(CSG.Line2D.prototype);\naddTransformationMethodsToPrototype(CSG.Line3D.prototype);\naddTransformationMethodsToPrototype(CSG.Path2D.prototype);\naddTransformationMethodsToPrototype(CSG.OrthoNormalBasis.prototype);\naddTransformationMethodsToPrototype(CSG.Connector.prototype);\n\naddTransformationMethodsToPrototype(CAG.prototype);\naddTransformationMethodsToPrototype(CAG.Side.prototype);\naddTransformationMethodsToPrototype(CAG.Vertex.prototype);\n\nCSG.parseOptionAs2DVector = optionsParsers.parseOptionAs3DVector;\nCSG.parseOptionAs3DVector = optionsParsers.parseOptionAs3DVector;\nCSG.parseOptionAs3DVectorList = optionsParsers.parseOptionAs3DVectorList;\nCSG.parseOptionAsBool = optionsParsers.parseOptionAsBool;\nCSG.parseOptionAsFloat = optionsParsers.parseOptionAsFloat;\nCSG.parseOptionAsInt = optionsParsers.parseOptionAsInt;\n// this is needed for now, otherwise there are missing features in Polygon2D\nCSG.Polygon2D.prototype = CAG.prototype;\n\n// utilities\nconst { isCAG, isCSG } = __webpack_require__(/*! ./src/core/utils */ \"./src/core/utils.js\");\n\nconst globalApi = Object.assign({}, { CSG, CAG }, optionsParsers, {\n  isCAG,\n  isCSG,\n});\n\nmodule.exports = globalApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jc2cuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9jc2cuanM/OWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIyMgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTQgYmViYmkgKGVsZ2hhdHRhQGdtYWlsLmNvbSlcbkNvcHlyaWdodCAoYykgMjAxMyBFZHVhcmQgQmVzcGFsb3YgKGVkd2Jlc0BnbWFpbC5jb20pXG5Db3B5cmlnaHQgKGMpIDIwMTIgSm9vc3QgTmlldXdlbmh1aWpzZSAoam9vc3RAbmV3aG91c2UubmwpXG5Db3B5cmlnaHQgKGMpIDIwMTEgRXZhbiBXYWxsYWNlIChodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9jc2cuanMvKVxuQ29weXJpZ2h0IChjKSAyMDEyIEFsZXhhbmRyZSBHaXJhcmQgKGh0dHBzOi8vZ2l0aHViLmNvbS9hbHgpXG5cbkFsbCBjb2RlIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG5cbiMjIE92ZXJ2aWV3XG5cbkZvciBhbiBvdmVydmlldyBvZiB0aGUgQ1NHIHByb2Nlc3Mgc2VlIHRoZSBvcmlnaW5hbCBjc2cuanMgY29kZTpcbmh0dHA6Ly9ldmFudy5naXRodWIuY29tL2NzZy5qcy9cblxuQ1NHIG9wZXJhdGlvbnMgdGhyb3VnaCBCU1AgdHJlZXMgc3VmZmVyIGZyb20gb25lIHByb2JsZW06IGhlYXZ5IGZyYWdtZW50YXRpb25cbm9mIHBvbHlnb25zLiBJZiB0d28gQ1NHIHNvbGlkcyBvZiBuIHBvbHlnb25zIGFyZSB1bmlmaWVkLCB0aGUgcmVzdWx0aW5nIHNvbGlkIG1heSBoYXZlXG5pbiB0aGUgb3JkZXIgb2YgbipuIHBvbHlnb25zLCBiZWNhdXNlIGVhY2ggcG9seWdvbiBpcyBzcGxpdCBieSB0aGUgcGxhbmVzIG9mIGFsbCBvdGhlclxucG9seWdvbnMuIEFmdGVyIGEgZmV3IG9wZXJhdGlvbnMgdGhlIG51bWJlciBvZiBwb2x5Z29ucyBleHBsb2Rlcy5cblxuVGhpcyB2ZXJzaW9uIG9mIENTRy5qcyBzb2x2ZXMgdGhlIHByb2JsZW0gaW4gMyB3YXlzOlxuXG4xLiBFdmVyeSBwb2x5Z29uIHNwbGl0IGlzIHJlY29yZGVkIGluIGEgdHJlZSAoQ1NHLlBvbHlnb25UcmVlTm9kZSkuIFRoaXMgaXMgYSBzZXBhcmF0ZVxudHJlZSwgbm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggdGhlIENTRyB0cmVlLiBJZiBhIHBvbHlnb24gaXMgc3BsaXQgaW50byB0d28gcGFydHMgYnV0IGluXG50aGUgZW5kIGJvdGggZnJhZ21lbnRzIGhhdmUgbm90IGJlZW4gZGlzY2FyZGVkIGJ5IHRoZSBDU0cgb3BlcmF0aW9uLCB3ZSBjYW4gcmV0cmlldmVcbnRoZSBvcmlnaW5hbCB1bnNwbGl0IHBvbHlnb24gZnJvbSB0aGUgdHJlZSwgaW5zdGVhZCBvZiB0aGUgdHdvIGZyYWdtZW50cy5cblxuVGhpcyBkb2VzIG5vdCBjb21wbGV0ZWx5IHNvbHZlIHRoZSBpc3N1ZSB0aG91Z2g6IGlmIGEgcG9seWdvbiBpcyBzcGxpdCBtdWx0aXBsZSB0aW1lc1xudGhlIG51bWJlciBvZiBmcmFnbWVudHMgZGVwZW5kcyBvbiB0aGUgb3JkZXIgb2Ygc3Vic2VxdWVudCBzcGxpdHMsIGFuZCB3ZSBtaWdodCBzdGlsbFxuZW5kIHVwIHdpdGggdW5uY2Vzc2FyeSBzcGxpdHM6XG5TdXBwb3NlIGEgcG9seWdvbiBpcyBmaXJzdCBzcGxpdCBpbnRvIEEgYW5kIEIsIGFuZCB0aGVuIGludG8gQTEsIEIxLCBBMiwgQjIuIFN1cHBvc2UgQjIgaXNcbmRpc2NhcmRlZC4gV2Ugd2lsbCBlbmQgdXAgd2l0aCAyIHBvbHlnb25zOiBBIGFuZCBCMS4gRGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgc3BsaXQgYm91bmRhcmllc1xud2UgY291bGQgc3RpbGwgaGF2ZSBqb2luZWQgQSBhbmQgQjEgaW50byBvbmUgcG9seWdvbi4gVGhlcmVmb3JlIGEgc2Vjb25kIGFwcHJvYWNoIGlzIHVzZWQgYXMgd2VsbDpcblxuMi4gQWZ0ZXIgQ1NHIG9wZXJhdGlvbnMgYWxsIGNvcGxhbmFyIHBvbHlnb24gZnJhZ21lbnRzIGFyZSBqb2luZWQgYnkgYSByZXRlc3NlbGF0aW5nXG5vcGVyYXRpb24uIFNlZSBDU0cucmVUZXNzZWxhdGVkKCkuIFJldGVzc2VsYXRpb24gaXMgZG9uZSB0aHJvdWdoIGFcbmxpbmVhciBzd2VlcCBvdmVyIHRoZSBwb2x5Z29uIHN1cmZhY2UuIFRoZSBzd2VlcCBsaW5lIHBhc3NlcyBvdmVyIHRoZSB5IGNvb3JkaW5hdGVzXG5vZiBhbGwgdmVydGljZXMgaW4gdGhlIHBvbHlnb24uIFBvbHlnb25zIGFyZSBzcGxpdCBhdCBlYWNoIHN3ZWVwIGxpbmUsIGFuZCB0aGUgZnJhZ21lbnRzXG5hcmUgam9pbmVkIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseSBpbnRvIGxhcmdlciBwb2x5Z29ucyAobWFraW5nIHN1cmUgdGhhdCB3ZVxud2lsbCBlbmQgdXAgd2l0aCBjb252ZXggcG9seWdvbnMpLlxuVGhpcyBzdGlsbCBkb2Vzbid0IHNvbHZlIHRoZSBwcm9ibGVtIGNvbXBsZXRlbHk6IGR1ZSB0byBmbG9hdGluZyBwb2ludCBpbXByZWNpc2lvbnNcbndlIG1heSBlbmQgdXAgd2l0aCBzbWFsbCBnYXBzIGJldHdlZW4gcG9seWdvbnMsIGFuZCBwb2x5Z29ucyBtYXkgbm90IGJlIGV4YWN0bHkgY29wbGFuYXJcbmFueW1vcmUsIGFuZCBhcyBhIHJlc3VsdCB0aGUgcmV0ZXNzZWxhdGlvbiBhbGdvcml0aG0gbWF5IGZhaWwgdG8gam9pbiB0aG9zZSBwb2x5Z29ucy5cblRoZXJlZm9yZTpcblxuMy4gQSBjYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobSBpcyBpbXBsZW1lbnRlZDogaXQgbG9va3MgZm9yIHZlcnRpY2VzIHRoYXQgaGF2ZVxuYXBwcm94aW1hdGVseSB0aGUgc2FtZSBjb29yZGluYXRlcyAod2l0aCBhIGNlcnRhaW4gdG9sZXJhbmNlLCBzYXkgMWUtNSkgYW5kIHJlcGxhY2VzXG50aGVtIHdpdGggdGhlIHNhbWUgdmVydGV4LiBJZiBwb2x5Z29ucyBzaGFyZSBhIHZlcnRleCB0aGV5IHdpbGwgYWN0dWFsbHkgcG9pbnQgdG8gdGhlXG5zYW1lIENTRy5WZXJ0ZXggaW5zdGFuY2UuIFRoZSBzYW1lIGlzIGRvbmUgZm9yIHBvbHlnb24gcGxhbmVzLiBTZWUgQ1NHLmNhbm9uaWNhbGl6ZWQoKS5cblxuUGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzIHRvIHRoZSBvcmlnaW5hbCBDU0cuanM6XG5cblJlcGxhY2VkIHRoZSBmbGlwKCkgYW5kIGludmVydCgpIG1ldGhvZHMgYnkgZmxpcHBlZCgpIGFuZCBpbnZlcnRlZCgpIHdoaWNoIGRvbid0XG5tb2RpZnkgdGhlIHNvdXJjZSBvYmplY3QuIFRoaXMgYWxsb3dzIHRvIGdldCByaWQgb2YgYWxsIGNsb25lKCkgY2FsbHMsIHNvIHRoYXRcbm11bHRpcGxlIHBvbHlnb25zIGNhbiByZWZlciB0byB0aGUgc2FtZSBDU0cuUGxhbmUgaW5zdGFuY2UgZXRjLlxuXG5UaGUgb3JpZ2luYWwgdW5pb24oKSB1c2VkIGFuIGV4dHJhIGludmVydCgpLCBjbGlwVG8oKSwgaW52ZXJ0KCkgc2VxdWVuY2UganVzdCB0byByZW1vdmUgdGhlXG5jb3BsYW5hciBmcm9udCBmYWNlcyBmcm9tIGI7IHRoaXMgaXMgbm93IGNvbWJpbmVkIGluIGEgc2luZ2xlIGIuY2xpcFRvKGEsIHRydWUpIGNhbGwuXG5cbkRldGVjdGlvbiB3aGV0aGVyIGEgcG9seWdvbiBpcyBpbiBmcm9udCBvciBpbiBiYWNrIG9mIGEgcGxhbmU6IGZvciBlYWNoIHBvbHlnb25cbndlIGFyZSBjYWNoaW5nIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgYm91bmRpbmcgc3BoZXJlLiBJZiB0aGUgYm91bmRpbmcgc3BoZXJlIGlzXG5pbiBmcm9udCBvciBpbiBiYWNrIG9mIHRoZSBwbGFuZSB3ZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZSBpbmRpdmlkdWFsIHZlcnRpY2VzXG5hbnltb3JlLlxuXG5PdGhlciBhZGRpdGlvbnMgdG8gdGhlIG9yaWdpbmFsIENTRy5qczpcblxuQ1NHLlZlY3RvciBjbGFzcyBoYXMgYmVlbiByZW5hbWVkIGludG8gQ1NHLlZlY3RvcjNEXG5cbkNsYXNzZXMgZm9yIDNEIGxpbmVzLCAyRCB2ZWN0b3JzLCAyRCBsaW5lcywgYW5kIG1ldGhvZHMgdG8gZmluZCB0aGUgaW50ZXJzZWN0aW9uIG9mXG5hIGxpbmUgYW5kIGEgcGxhbmUgZXRjLlxuXG5UcmFuc2Zvcm1hdGlvbnM6IENTRy50cmFuc2Zvcm0oKSwgQ1NHLnRyYW5zbGF0ZSgpLCBDU0cucm90YXRlKCksIENTRy5zY2FsZSgpXG5cbkV4cGFuZGluZyBvciBjb250cmFjdGluZyBhIHNvbGlkOiBDU0cuZXhwYW5kKCkgYW5kIENTRy5jb250cmFjdCgpLiBDcmVhdGVzIG5pY2VcbnNtb290aCBjb3JuZXJzLlxuXG5UaGUgdmVydGV4IG5vcm1hbCBoYXMgYmVlbiByZW1vdmVkIHNpbmNlIGl0IGNvbXBsaWNhdGVzIHJldGVzc2VsYXRpb24uIEl0J3Mgbm90IG5lZWRlZFxuZm9yIHNvbGlkIENBRCBhbnl3YXkuXG5cbiovXG5cbmNvbnN0IHsgYWRkVHJhbnNmb3JtYXRpb25NZXRob2RzVG9Qcm90b3R5cGUgfSA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbXV0YXRvcnMnKTtcbmxldCBDU0cgPSByZXF1aXJlKCcuL3NyYy9jb3JlL0NTRycpO1xubGV0IENBRyA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvQ0FHJyk7XG5cbi8vIEZJWE1FOiBob3cgbWFueSBhcmUgYWN0dWFsIHVzZWZ1bGwgdG8gYmUgZXhwb3NlZCBhcyBBUEkgPz8gbG9va3MgbGlrZSBhIGNvZGUgc21lbGxcbmNvbnN0IHtcbiAgX0NTR0RFQlVHLFxuICBkZWZhdWx0UmVzb2x1dGlvbjJELFxuICBkZWZhdWx0UmVzb2x1dGlvbjNELFxuICBFUFMsXG4gIGFuZ2xlRVBTLFxuICBhcmVhRVBTLFxuICBhbGwsXG4gIHRvcCxcbiAgYm90dG9tLFxuICBsZWZ0LFxuICByaWdodCxcbiAgZnJvbnQsXG4gIGJhY2ssXG4gIHN0YXRpY1RhZyxcbiAgZ2V0VGFnLFxufSA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvY29uc3RhbnRzJyk7XG5cbkNTRy5fQ1NHREVCVUcgPSBfQ1NHREVCVUc7XG5DU0cuZGVmYXVsdFJlc29sdXRpb24yRCA9IGRlZmF1bHRSZXNvbHV0aW9uMkQ7XG5DU0cuZGVmYXVsdFJlc29sdXRpb24zRCA9IGRlZmF1bHRSZXNvbHV0aW9uM0Q7XG5DU0cuRVBTID0gRVBTO1xuQ1NHLmFuZ2xlRVBTID0gYW5nbGVFUFM7XG5DU0cuYXJlYUVQUyA9IGFyZWFFUFM7XG5DU0cuYWxsID0gYWxsO1xuQ1NHLnRvcCA9IHRvcDtcbkNTRy5ib3R0b20gPSBib3R0b207XG5DU0cubGVmdCA9IGxlZnQ7XG5DU0cucmlnaHQgPSByaWdodDtcbkNTRy5mcm9udCA9IGZyb250O1xuQ1NHLmJhY2sgPSBiYWNrO1xuQ1NHLnN0YXRpY1RhZyA9IHN0YXRpY1RhZztcbkNTRy5nZXRUYWcgPSBnZXRUYWc7XG5cbi8vIGVlayAhIGFsbCB0aGlzIGlzIGtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5Li4uZm9yIG5vd1xuQ1NHLlZlY3RvcjJEID0gcmVxdWlyZSgnLi9zcmMvY29yZS9tYXRoL1ZlY3RvcjInKTtcbkNTRy5WZWN0b3IzRCA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbWF0aC9WZWN0b3IzJyk7XG5DU0cuVmVydGV4ID0gcmVxdWlyZSgnLi9zcmMvY29yZS9tYXRoL1ZlcnRleDMnKTtcbkNBRy5WZXJ0ZXggPSByZXF1aXJlKCcuL3NyYy9jb3JlL21hdGgvVmVydGV4MicpO1xuQ1NHLlBsYW5lID0gcmVxdWlyZSgnLi9zcmMvY29yZS9tYXRoL1BsYW5lJyk7XG5DU0cuUG9seWdvbiA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbWF0aC9Qb2x5Z29uMycpO1xuQ1NHLlBvbHlnb24yRCA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbWF0aC9Qb2x5Z29uMicpO1xuQ1NHLkxpbmUyRCA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbWF0aC9MaW5lMicpO1xuQ1NHLkxpbmUzRCA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbWF0aC9MaW5lMycpO1xuQ1NHLlBhdGgyRCA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbWF0aC9QYXRoMicpO1xuQ1NHLk9ydGhvTm9ybWFsQmFzaXMgPSByZXF1aXJlKCcuL3NyYy9jb3JlL21hdGgvT3J0aG9Ob3JtYWxCYXNpcycpO1xuQ1NHLk1hdHJpeDR4NCA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvbWF0aC9NYXRyaXg0Jyk7XG5cbkNBRy5TaWRlID0gcmVxdWlyZSgnLi9zcmMvY29yZS9tYXRoL1NpZGUnKTtcblxuQ1NHLkNvbm5lY3RvciA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvY29ubmVjdG9ycycpLkNvbm5lY3RvcjtcbkNTRy5Db25uZWN0b3JMaXN0ID0gcmVxdWlyZSgnLi9zcmMvY29yZS9jb25uZWN0b3JzJykuQ29ubmVjdG9yTGlzdDtcbkNTRy5Qcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9zcmMvY29yZS9Qcm9wZXJ0aWVzJyk7XG5cbmNvbnN0IHtcbiAgY2lyY2xlLFxuICBlbGxpcHNlLFxuICByZWN0YW5nbGUsXG4gIHJvdW5kZWRSZWN0YW5nbGUsXG59ID0gcmVxdWlyZSgnLi9zcmMvYXBpL3ByaW1pdGl2ZXMyZCcpO1xuY29uc3Qge1xuICBzcGhlcmUsXG4gIGN1YmUsXG4gIHJvdW5kZWRDdWJlLFxuICBjeWxpbmRlcixcbiAgcm91bmRlZEN5bGluZGVyLFxuICBjeWxpbmRlckVsbGlwdGljLFxuICBwb2x5aGVkcm9uLFxufSA9IHJlcXVpcmUoJy4vc3JjL2FwaS9wcmltaXRpdmVzM2QnKTtcblxuQ1NHLnNwaGVyZSA9IHNwaGVyZTtcbkNTRy5jdWJlID0gY3ViZTtcbkNTRy5yb3VuZGVkQ3ViZSA9IHJvdW5kZWRDdWJlO1xuQ1NHLmN5bGluZGVyID0gY3lsaW5kZXI7XG5DU0cucm91bmRlZEN5bGluZGVyID0gcm91bmRlZEN5bGluZGVyO1xuQ1NHLmN5bGluZGVyRWxsaXB0aWMgPSBjeWxpbmRlckVsbGlwdGljO1xuQ1NHLnBvbHloZWRyb24gPSBwb2x5aGVkcm9uO1xuXG5DQUcuY2lyY2xlID0gY2lyY2xlO1xuQ0FHLmVsbGlwc2UgPSBlbGxpcHNlO1xuQ0FHLnJlY3RhbmdsZSA9IHJlY3RhbmdsZTtcbkNBRy5yb3VuZGVkUmVjdGFuZ2xlID0gcm91bmRlZFJlY3RhbmdsZTtcblxuLy8gaW5qZWN0aW5nIGZhY3Rvcmllc1xuY29uc3Qge1xuICBmcm9tUG9seWdvbnMsXG4gIGZyb21Db21wYWN0QmluYXJ5LFxuICBmcm9tT2JqZWN0LFxuICBmcm9tU2xpY2VzLFxufSA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvQ1NHRmFjdG9yaWVzJyk7XG5DU0cuZnJvbUNvbXBhY3RCaW5hcnkgPSBmcm9tQ29tcGFjdEJpbmFyeTtcbkNTRy5mcm9tT2JqZWN0ID0gZnJvbU9iamVjdDtcbkNTRy5mcm9tU2xpY2VzID0gZnJvbVNsaWNlcztcbkNTRy5mcm9tUG9seWdvbnMgPSBmcm9tUG9seWdvbnM7XG5cbkNTRy50b1BvaW50Q2xvdWQgPSByZXF1aXJlKCcuL3NyYy9hcGkvZGVidWdIZWxwZXJzJykudG9Qb2ludENsb3VkO1xuXG5jb25zdCBDQUdGYWN0b3JpZXMgPSByZXF1aXJlKCcuL3NyYy9jb3JlL0NBR0ZhY3RvcmllcycpO1xuQ0FHLmZyb21TaWRlcyA9IENBR0ZhY3Rvcmllcy5mcm9tU2lkZXM7XG5DQUcuZnJvbU9iamVjdCA9IENBR0ZhY3Rvcmllcy5mcm9tT2JqZWN0O1xuQ0FHLmZyb21Qb2ludHMgPSBDQUdGYWN0b3JpZXMuZnJvbVBvaW50cztcbkNBRy5mcm9tUG9pbnRzTm9DaGVjayA9IENBR0ZhY3Rvcmllcy5mcm9tUG9pbnRzTm9DaGVjaztcbkNBRy5mcm9tUGF0aDIgPSBDQUdGYWN0b3JpZXMuZnJvbVBhdGgyO1xuQ0FHLmZyb21GYWtlQ1NHID0gQ0FHRmFjdG9yaWVzLmZyb21GYWtlQ1NHO1xuQ0FHLmZyb21Db21wYWN0QmluYXJ5ID0gQ0FHRmFjdG9yaWVzLmZyb21Db21wYWN0QmluYXJ5O1xuXG4vLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBvcHRpb24gcGFyc2Vyc1xuY29uc3Qgb3B0aW9uc1BhcnNlcnMgPSByZXF1aXJlKCcuL3NyYy9hcGkvb3B0aW9uUGFyc2VycycpO1xuXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENTRy5wcm90b3R5cGUpO1xuYWRkVHJhbnNmb3JtYXRpb25NZXRob2RzVG9Qcm90b3R5cGUoQ1NHLlZlY3RvcjJELnByb3RvdHlwZSk7XG5hZGRUcmFuc2Zvcm1hdGlvbk1ldGhvZHNUb1Byb3RvdHlwZShDU0cuVmVjdG9yM0QucHJvdG90eXBlKTtcbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENTRy5WZXJ0ZXgucHJvdG90eXBlKTtcbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENTRy5QbGFuZS5wcm90b3R5cGUpO1xuYWRkVHJhbnNmb3JtYXRpb25NZXRob2RzVG9Qcm90b3R5cGUoQ1NHLlBvbHlnb24ucHJvdG90eXBlKTtcbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENTRy5MaW5lMkQucHJvdG90eXBlKTtcbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENTRy5MaW5lM0QucHJvdG90eXBlKTtcbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENTRy5QYXRoMkQucHJvdG90eXBlKTtcbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENTRy5PcnRob05vcm1hbEJhc2lzLnByb3RvdHlwZSk7XG5hZGRUcmFuc2Zvcm1hdGlvbk1ldGhvZHNUb1Byb3RvdHlwZShDU0cuQ29ubmVjdG9yLnByb3RvdHlwZSk7XG5cbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENBRy5wcm90b3R5cGUpO1xuYWRkVHJhbnNmb3JtYXRpb25NZXRob2RzVG9Qcm90b3R5cGUoQ0FHLlNpZGUucHJvdG90eXBlKTtcbmFkZFRyYW5zZm9ybWF0aW9uTWV0aG9kc1RvUHJvdG90eXBlKENBRy5WZXJ0ZXgucHJvdG90eXBlKTtcblxuQ1NHLnBhcnNlT3B0aW9uQXMyRFZlY3RvciA9IG9wdGlvbnNQYXJzZXJzLnBhcnNlT3B0aW9uQXMzRFZlY3RvcjtcbkNTRy5wYXJzZU9wdGlvbkFzM0RWZWN0b3IgPSBvcHRpb25zUGFyc2Vycy5wYXJzZU9wdGlvbkFzM0RWZWN0b3I7XG5DU0cucGFyc2VPcHRpb25BczNEVmVjdG9yTGlzdCA9IG9wdGlvbnNQYXJzZXJzLnBhcnNlT3B0aW9uQXMzRFZlY3Rvckxpc3Q7XG5DU0cucGFyc2VPcHRpb25Bc0Jvb2wgPSBvcHRpb25zUGFyc2Vycy5wYXJzZU9wdGlvbkFzQm9vbDtcbkNTRy5wYXJzZU9wdGlvbkFzRmxvYXQgPSBvcHRpb25zUGFyc2Vycy5wYXJzZU9wdGlvbkFzRmxvYXQ7XG5DU0cucGFyc2VPcHRpb25Bc0ludCA9IG9wdGlvbnNQYXJzZXJzLnBhcnNlT3B0aW9uQXNJbnQ7XG4vLyB0aGlzIGlzIG5lZWRlZCBmb3Igbm93LCBvdGhlcndpc2UgdGhlcmUgYXJlIG1pc3NpbmcgZmVhdHVyZXMgaW4gUG9seWdvbjJEXG5DU0cuUG9seWdvbjJELnByb3RvdHlwZSA9IENBRy5wcm90b3R5cGU7XG5cbi8vIHV0aWxpdGllc1xuY29uc3QgeyBpc0NBRywgaXNDU0cgfSA9IHJlcXVpcmUoJy4vc3JjL2NvcmUvdXRpbHMnKTtcblxuY29uc3QgZ2xvYmFsQXBpID0gT2JqZWN0LmFzc2lnbih7fSwgeyBDU0csIENBRyB9LCBvcHRpb25zUGFyc2Vycywge1xuICBpc0NBRyxcbiAgaXNDU0csXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxBcGk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./csg.js\n");

/***/ }),

/***/ "./src/api/cagOutlinePaths.js":
/*!************************************!*\
  !*** ./src/api/cagOutlinePaths.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Path2D = __webpack_require__(/*! ../core/math/Path2 */ \"./src/core/math/Path2.js\");\n\nconst cagoutlinePaths = function (_cag) {\n  let cag = _cag.canonicalized();\n  let sideTagToSideMap = {};\n  let startVertexTagToSideTagMap = {};\n  cag.sides.map(function (side) {\n    let sidetag = side.getTag();\n    sideTagToSideMap[sidetag] = side;\n    let startvertextag = side.vertex0.getTag();\n    if (!(startvertextag in startVertexTagToSideTagMap)) {\n      startVertexTagToSideTagMap[startvertextag] = [];\n    }\n    startVertexTagToSideTagMap[startvertextag].push(sidetag);\n  });\n  let paths = [];\n  while (true) {\n    let startsidetag = null;\n    for (let aVertexTag in startVertexTagToSideTagMap) {\n      let sidesForcagVertex = startVertexTagToSideTagMap[aVertexTag];\n      startsidetag = sidesForcagVertex[0];\n      sidesForcagVertex.splice(0, 1);\n      if (sidesForcagVertex.length === 0) {\n        delete startVertexTagToSideTagMap[aVertexTag];\n      }\n      break;\n    }\n    if (startsidetag === null) break; // we've had all sides\n    let connectedVertexPoints = [];\n    let sidetag = startsidetag;\n    let cagside = sideTagToSideMap[sidetag];\n    let startvertextag = cagside.vertex0.getTag();\n    while (true) {\n      connectedVertexPoints.push(cagside.vertex0.pos);\n      let nextvertextag = cagside.vertex1.getTag();\n      if (nextvertextag === startvertextag) break; // we've closed the polygon\n      if (!(nextvertextag in startVertexTagToSideTagMap)) {\n        throw new Error('Area is not closed!');\n      }\n      let nextpossiblesidetags = startVertexTagToSideTagMap[nextvertextag];\n      let nextsideindex = -1;\n      if (nextpossiblesidetags.length === 1) {\n        nextsideindex = 0;\n      } else {\n        // more than one side starting at the same vertex. cag means we have\n        // two shapes touching at the same corner\n        let bestangle = null;\n        let cagangle = cagside.direction().angleDegrees();\n        for (\n          let sideindex = 0;\n          sideindex < nextpossiblesidetags.length;\n          sideindex++\n        ) {\n          let nextpossiblesidetag = nextpossiblesidetags[sideindex];\n          let possibleside = sideTagToSideMap[nextpossiblesidetag];\n          let angle = possibleside.direction().angleDegrees();\n          let angledif = angle - cagangle;\n          if (angledif < -180) angledif += 360;\n          if (angledif >= 180) angledif -= 360;\n          if (nextsideindex < 0 || angledif > bestangle) {\n            nextsideindex = sideindex;\n            bestangle = angledif;\n          }\n        }\n      }\n      let nextsidetag = nextpossiblesidetags[nextsideindex];\n      nextpossiblesidetags.splice(nextsideindex, 1);\n      if (nextpossiblesidetags.length === 0) {\n        delete startVertexTagToSideTagMap[nextvertextag];\n      }\n      cagside = sideTagToSideMap[nextsidetag];\n    } // inner loop\n    // due to the logic of fromPoints()\n    // move the first point to the last\n    if (connectedVertexPoints.length > 0) {\n      connectedVertexPoints.push(connectedVertexPoints.shift());\n    }\n    let path = new Path2D(connectedVertexPoints, true);\n    paths.push(path);\n  } // outer loop\n  return paths;\n};\n\nmodule.exports = cagoutlinePaths;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2NhZ091dGxpbmVQYXRocy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvY2FnT3V0bGluZVBhdGhzLmpzPzJkNTAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUGF0aDJEID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1BhdGgyJyk7XG5cbmNvbnN0IGNhZ291dGxpbmVQYXRocyA9IGZ1bmN0aW9uIChfY2FnKSB7XG4gIGxldCBjYWcgPSBfY2FnLmNhbm9uaWNhbGl6ZWQoKTtcbiAgbGV0IHNpZGVUYWdUb1NpZGVNYXAgPSB7fTtcbiAgbGV0IHN0YXJ0VmVydGV4VGFnVG9TaWRlVGFnTWFwID0ge307XG4gIGNhZy5zaWRlcy5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICBsZXQgc2lkZXRhZyA9IHNpZGUuZ2V0VGFnKCk7XG4gICAgc2lkZVRhZ1RvU2lkZU1hcFtzaWRldGFnXSA9IHNpZGU7XG4gICAgbGV0IHN0YXJ0dmVydGV4dGFnID0gc2lkZS52ZXJ0ZXgwLmdldFRhZygpO1xuICAgIGlmICghKHN0YXJ0dmVydGV4dGFnIGluIHN0YXJ0VmVydGV4VGFnVG9TaWRlVGFnTWFwKSkge1xuICAgICAgc3RhcnRWZXJ0ZXhUYWdUb1NpZGVUYWdNYXBbc3RhcnR2ZXJ0ZXh0YWddID0gW107XG4gICAgfVxuICAgIHN0YXJ0VmVydGV4VGFnVG9TaWRlVGFnTWFwW3N0YXJ0dmVydGV4dGFnXS5wdXNoKHNpZGV0YWcpO1xuICB9KTtcbiAgbGV0IHBhdGhzID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IHN0YXJ0c2lkZXRhZyA9IG51bGw7XG4gICAgZm9yIChsZXQgYVZlcnRleFRhZyBpbiBzdGFydFZlcnRleFRhZ1RvU2lkZVRhZ01hcCkge1xuICAgICAgbGV0IHNpZGVzRm9yY2FnVmVydGV4ID0gc3RhcnRWZXJ0ZXhUYWdUb1NpZGVUYWdNYXBbYVZlcnRleFRhZ107XG4gICAgICBzdGFydHNpZGV0YWcgPSBzaWRlc0ZvcmNhZ1ZlcnRleFswXTtcbiAgICAgIHNpZGVzRm9yY2FnVmVydGV4LnNwbGljZSgwLCAxKTtcbiAgICAgIGlmIChzaWRlc0ZvcmNhZ1ZlcnRleC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHN0YXJ0VmVydGV4VGFnVG9TaWRlVGFnTWFwW2FWZXJ0ZXhUYWddO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzdGFydHNpZGV0YWcgPT09IG51bGwpIGJyZWFrOyAvLyB3ZSd2ZSBoYWQgYWxsIHNpZGVzXG4gICAgbGV0IGNvbm5lY3RlZFZlcnRleFBvaW50cyA9IFtdO1xuICAgIGxldCBzaWRldGFnID0gc3RhcnRzaWRldGFnO1xuICAgIGxldCBjYWdzaWRlID0gc2lkZVRhZ1RvU2lkZU1hcFtzaWRldGFnXTtcbiAgICBsZXQgc3RhcnR2ZXJ0ZXh0YWcgPSBjYWdzaWRlLnZlcnRleDAuZ2V0VGFnKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbm5lY3RlZFZlcnRleFBvaW50cy5wdXNoKGNhZ3NpZGUudmVydGV4MC5wb3MpO1xuICAgICAgbGV0IG5leHR2ZXJ0ZXh0YWcgPSBjYWdzaWRlLnZlcnRleDEuZ2V0VGFnKCk7XG4gICAgICBpZiAobmV4dHZlcnRleHRhZyA9PT0gc3RhcnR2ZXJ0ZXh0YWcpIGJyZWFrOyAvLyB3ZSd2ZSBjbG9zZWQgdGhlIHBvbHlnb25cbiAgICAgIGlmICghKG5leHR2ZXJ0ZXh0YWcgaW4gc3RhcnRWZXJ0ZXhUYWdUb1NpZGVUYWdNYXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJlYSBpcyBub3QgY2xvc2VkIScpO1xuICAgICAgfVxuICAgICAgbGV0IG5leHRwb3NzaWJsZXNpZGV0YWdzID0gc3RhcnRWZXJ0ZXhUYWdUb1NpZGVUYWdNYXBbbmV4dHZlcnRleHRhZ107XG4gICAgICBsZXQgbmV4dHNpZGVpbmRleCA9IC0xO1xuICAgICAgaWYgKG5leHRwb3NzaWJsZXNpZGV0YWdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBuZXh0c2lkZWluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vcmUgdGhhbiBvbmUgc2lkZSBzdGFydGluZyBhdCB0aGUgc2FtZSB2ZXJ0ZXguIGNhZyBtZWFucyB3ZSBoYXZlXG4gICAgICAgIC8vIHR3byBzaGFwZXMgdG91Y2hpbmcgYXQgdGhlIHNhbWUgY29ybmVyXG4gICAgICAgIGxldCBiZXN0YW5nbGUgPSBudWxsO1xuICAgICAgICBsZXQgY2FnYW5nbGUgPSBjYWdzaWRlLmRpcmVjdGlvbigpLmFuZ2xlRGVncmVlcygpO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGxldCBzaWRlaW5kZXggPSAwO1xuICAgICAgICAgIHNpZGVpbmRleCA8IG5leHRwb3NzaWJsZXNpZGV0YWdzLmxlbmd0aDtcbiAgICAgICAgICBzaWRlaW5kZXgrK1xuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgbmV4dHBvc3NpYmxlc2lkZXRhZyA9IG5leHRwb3NzaWJsZXNpZGV0YWdzW3NpZGVpbmRleF07XG4gICAgICAgICAgbGV0IHBvc3NpYmxlc2lkZSA9IHNpZGVUYWdUb1NpZGVNYXBbbmV4dHBvc3NpYmxlc2lkZXRhZ107XG4gICAgICAgICAgbGV0IGFuZ2xlID0gcG9zc2libGVzaWRlLmRpcmVjdGlvbigpLmFuZ2xlRGVncmVlcygpO1xuICAgICAgICAgIGxldCBhbmdsZWRpZiA9IGFuZ2xlIC0gY2FnYW5nbGU7XG4gICAgICAgICAgaWYgKGFuZ2xlZGlmIDwgLTE4MCkgYW5nbGVkaWYgKz0gMzYwO1xuICAgICAgICAgIGlmIChhbmdsZWRpZiA+PSAxODApIGFuZ2xlZGlmIC09IDM2MDtcbiAgICAgICAgICBpZiAobmV4dHNpZGVpbmRleCA8IDAgfHwgYW5nbGVkaWYgPiBiZXN0YW5nbGUpIHtcbiAgICAgICAgICAgIG5leHRzaWRlaW5kZXggPSBzaWRlaW5kZXg7XG4gICAgICAgICAgICBiZXN0YW5nbGUgPSBhbmdsZWRpZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBuZXh0c2lkZXRhZyA9IG5leHRwb3NzaWJsZXNpZGV0YWdzW25leHRzaWRlaW5kZXhdO1xuICAgICAgbmV4dHBvc3NpYmxlc2lkZXRhZ3Muc3BsaWNlKG5leHRzaWRlaW5kZXgsIDEpO1xuICAgICAgaWYgKG5leHRwb3NzaWJsZXNpZGV0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgc3RhcnRWZXJ0ZXhUYWdUb1NpZGVUYWdNYXBbbmV4dHZlcnRleHRhZ107XG4gICAgICB9XG4gICAgICBjYWdzaWRlID0gc2lkZVRhZ1RvU2lkZU1hcFtuZXh0c2lkZXRhZ107XG4gICAgfSAvLyBpbm5lciBsb29wXG4gICAgLy8gZHVlIHRvIHRoZSBsb2dpYyBvZiBmcm9tUG9pbnRzKClcbiAgICAvLyBtb3ZlIHRoZSBmaXJzdCBwb2ludCB0byB0aGUgbGFzdFxuICAgIGlmIChjb25uZWN0ZWRWZXJ0ZXhQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgY29ubmVjdGVkVmVydGV4UG9pbnRzLnB1c2goY29ubmVjdGVkVmVydGV4UG9pbnRzLnNoaWZ0KCkpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IG5ldyBQYXRoMkQoY29ubmVjdGVkVmVydGV4UG9pbnRzLCB0cnVlKTtcbiAgICBwYXRocy5wdXNoKHBhdGgpO1xuICB9IC8vIG91dGVyIGxvb3BcbiAgcmV0dXJuIHBhdGhzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYWdvdXRsaW5lUGF0aHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/api/cagOutlinePaths.js\n");

/***/ }),

/***/ "./src/api/center.js":
/*!***************************!*\
  !*** ./src/api/center.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const toArray = __webpack_require__(/*! ../core/utils/toArray */ \"./src/core/utils/toArray.js\");\n\n/**\n * Centers the given object(s) using the given options (if any)\n * @param {Object} [options] - options for centering\n * @param {Array} [options.axes=[true,true,true]] - axis of which to center, true or false\n * @param {Array} [options.center=[0,0,0]] - point of which to center the object upon\n * @param {Object|Array} objects - the shape(s) to center\n * @return {Object|Array} objects\n *\n * @example\n * let csg = center({axes: [true,false,false]}, sphere()) // center about the X axis\n */\nconst center = function (options, objects) {\n  const defaults = {\n    axes: [true, true, true],\n    center: [0, 0, 0],\n    // TODO : Add addition 'methods' of centering; midpoint, centeriod\n  };\n  options = Object.assign({}, defaults, options);\n  const { axes, center } = options;\n  objects = toArray(objects);\n\n  const results = objects.map(function (object) {\n    let bounds = object.getBounds();\n    let offset = [0, 0, 0];\n    if (axes[0])\n      offset[0] = center[0] - (bounds[0].x + (bounds[1].x - bounds[0].x) / 2);\n    if (axes[1])\n      offset[1] = center[1] - (bounds[0].y + (bounds[1].y - bounds[0].y) / 2);\n    if (axes[2])\n      offset[2] = center[2] - (bounds[0].z + (bounds[1].y - bounds[0].y) / 2);\n    return object.translate(offset);\n  });\n  // if there is more than one result, return them all , otherwise a single one\n  return results.length === 1 ? results[0] : results;\n};\n\nmodule.exports = center;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2NlbnRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvY2VudGVyLmpzPzdjYmEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbHMvdG9BcnJheScpO1xuXG4vKipcbiAqIENlbnRlcnMgdGhlIGdpdmVuIG9iamVjdChzKSB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucyAoaWYgYW55KVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNlbnRlcmluZ1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYXhlcz1bdHJ1ZSx0cnVlLHRydWVdXSAtIGF4aXMgb2Ygd2hpY2ggdG8gY2VudGVyLCB0cnVlIG9yIGZhbHNlXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jZW50ZXI9WzAsMCwwXV0gLSBwb2ludCBvZiB3aGljaCB0byBjZW50ZXIgdGhlIG9iamVjdCB1cG9uXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqZWN0cyAtIHRoZSBzaGFwZShzKSB0byBjZW50ZXJcbiAqIEByZXR1cm4ge09iamVjdHxBcnJheX0gb2JqZWN0c1xuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgY3NnID0gY2VudGVyKHtheGVzOiBbdHJ1ZSxmYWxzZSxmYWxzZV19LCBzcGhlcmUoKSkgLy8gY2VudGVyIGFib3V0IHRoZSBYIGF4aXNcbiAqL1xuY29uc3QgY2VudGVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9iamVjdHMpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgYXhlczogW3RydWUsIHRydWUsIHRydWVdLFxuICAgIGNlbnRlcjogWzAsIDAsIDBdLFxuICAgIC8vIFRPRE8gOiBBZGQgYWRkaXRpb24gJ21ldGhvZHMnIG9mIGNlbnRlcmluZzsgbWlkcG9pbnQsIGNlbnRlcmlvZFxuICB9O1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICBjb25zdCB7IGF4ZXMsIGNlbnRlciB9ID0gb3B0aW9ucztcbiAgb2JqZWN0cyA9IHRvQXJyYXkob2JqZWN0cyk7XG5cbiAgY29uc3QgcmVzdWx0cyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBsZXQgYm91bmRzID0gb2JqZWN0LmdldEJvdW5kcygpO1xuICAgIGxldCBvZmZzZXQgPSBbMCwgMCwgMF07XG4gICAgaWYgKGF4ZXNbMF0pXG4gICAgICBvZmZzZXRbMF0gPSBjZW50ZXJbMF0gLSAoYm91bmRzWzBdLnggKyAoYm91bmRzWzFdLnggLSBib3VuZHNbMF0ueCkgLyAyKTtcbiAgICBpZiAoYXhlc1sxXSlcbiAgICAgIG9mZnNldFsxXSA9IGNlbnRlclsxXSAtIChib3VuZHNbMF0ueSArIChib3VuZHNbMV0ueSAtIGJvdW5kc1swXS55KSAvIDIpO1xuICAgIGlmIChheGVzWzJdKVxuICAgICAgb2Zmc2V0WzJdID0gY2VudGVyWzJdIC0gKGJvdW5kc1swXS56ICsgKGJvdW5kc1sxXS55IC0gYm91bmRzWzBdLnkpIC8gMik7XG4gICAgcmV0dXJuIG9iamVjdC50cmFuc2xhdGUob2Zmc2V0KTtcbiAgfSk7XG4gIC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcmVzdWx0LCByZXR1cm4gdGhlbSBhbGwgLCBvdGhlcndpc2UgYSBzaW5nbGUgb25lXG4gIHJldHVybiByZXN1bHRzLmxlbmd0aCA9PT0gMSA/IHJlc3VsdHNbMF0gOiByZXN1bHRzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjZW50ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/api/center.js\n");

/***/ }),

/***/ "./src/api/color.js":
/*!**************************!*\
  !*** ./src/api/color.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// color table from http://www.w3.org/TR/css3-color/\nconst cssColors = {\n  // basic color keywords\n  black: [0 / 255, 0 / 255, 0 / 255],\n  silver: [192 / 255, 192 / 255, 192 / 255],\n  gray: [128 / 255, 128 / 255, 128 / 255],\n  white: [255 / 255, 255 / 255, 255 / 255],\n  maroon: [128 / 255, 0 / 255, 0 / 255],\n  red: [255 / 255, 0 / 255, 0 / 255],\n  purple: [128 / 255, 0 / 255, 128 / 255],\n  fuchsia: [255 / 255, 0 / 255, 255 / 255],\n  green: [0 / 255, 128 / 255, 0 / 255],\n  lime: [0 / 255, 255 / 255, 0 / 255],\n  olive: [128 / 255, 128 / 255, 0 / 255],\n  yellow: [255 / 255, 255 / 255, 0 / 255],\n  navy: [0 / 255, 0 / 255, 128 / 255],\n  blue: [0 / 255, 0 / 255, 255 / 255],\n  teal: [0 / 255, 128 / 255, 128 / 255],\n  aqua: [0 / 255, 255 / 255, 255 / 255],\n  // extended color keywords\n  aliceblue: [240 / 255, 248 / 255, 255 / 255],\n  antiquewhite: [250 / 255, 235 / 255, 215 / 255],\n  // 'aqua': [ 0 / 255, 255 / 255, 255 / 255 ],\n  aquamarine: [127 / 255, 255 / 255, 212 / 255],\n  azure: [240 / 255, 255 / 255, 255 / 255],\n  beige: [245 / 255, 245 / 255, 220 / 255],\n  bisque: [255 / 255, 228 / 255, 196 / 255],\n  // 'black': [ 0 / 255, 0 / 255, 0 / 255 ],\n  blanchedalmond: [255 / 255, 235 / 255, 205 / 255],\n  // 'blue': [ 0 / 255, 0 / 255, 255 / 255 ],\n  blueviolet: [138 / 255, 43 / 255, 226 / 255],\n  brown: [165 / 255, 42 / 255, 42 / 255],\n  burlywood: [222 / 255, 184 / 255, 135 / 255],\n  cadetblue: [95 / 255, 158 / 255, 160 / 255],\n  chartreuse: [127 / 255, 255 / 255, 0 / 255],\n  chocolate: [210 / 255, 105 / 255, 30 / 255],\n  coral: [255 / 255, 127 / 255, 80 / 255],\n  cornflowerblue: [100 / 255, 149 / 255, 237 / 255],\n  cornsilk: [255 / 255, 248 / 255, 220 / 255],\n  crimson: [220 / 255, 20 / 255, 60 / 255],\n  cyan: [0 / 255, 255 / 255, 255 / 255],\n  darkblue: [0 / 255, 0 / 255, 139 / 255],\n  darkcyan: [0 / 255, 139 / 255, 139 / 255],\n  darkgoldenrod: [184 / 255, 134 / 255, 11 / 255],\n  darkgray: [169 / 255, 169 / 255, 169 / 255],\n  darkgreen: [0 / 255, 100 / 255, 0 / 255],\n  darkgrey: [169 / 255, 169 / 255, 169 / 255],\n  darkkhaki: [189 / 255, 183 / 255, 107 / 255],\n  darkmagenta: [139 / 255, 0 / 255, 139 / 255],\n  darkolivegreen: [85 / 255, 107 / 255, 47 / 255],\n  darkorange: [255 / 255, 140 / 255, 0 / 255],\n  darkorchid: [153 / 255, 50 / 255, 204 / 255],\n  darkred: [139 / 255, 0 / 255, 0 / 255],\n  darksalmon: [233 / 255, 150 / 255, 122 / 255],\n  darkseagreen: [143 / 255, 188 / 255, 143 / 255],\n  darkslateblue: [72 / 255, 61 / 255, 139 / 255],\n  darkslategray: [47 / 255, 79 / 255, 79 / 255],\n  darkslategrey: [47 / 255, 79 / 255, 79 / 255],\n  darkturquoise: [0 / 255, 206 / 255, 209 / 255],\n  darkviolet: [148 / 255, 0 / 255, 211 / 255],\n  deeppink: [255 / 255, 20 / 255, 147 / 255],\n  deepskyblue: [0 / 255, 191 / 255, 255 / 255],\n  dimgray: [105 / 255, 105 / 255, 105 / 255],\n  dimgrey: [105 / 255, 105 / 255, 105 / 255],\n  dodgerblue: [30 / 255, 144 / 255, 255 / 255],\n  firebrick: [178 / 255, 34 / 255, 34 / 255],\n  floralwhite: [255 / 255, 250 / 255, 240 / 255],\n  forestgreen: [34 / 255, 139 / 255, 34 / 255],\n  // 'fuchsia': [ 255 / 255, 0 / 255, 255 / 255 ],\n  gainsboro: [220 / 255, 220 / 255, 220 / 255],\n  ghostwhite: [248 / 255, 248 / 255, 255 / 255],\n  gold: [255 / 255, 215 / 255, 0 / 255],\n  goldenrod: [218 / 255, 165 / 255, 32 / 255],\n  // 'gray': [ 128 / 255, 128 / 255, 128 / 255 ],\n  // 'green': [ 0 / 255, 128 / 255, 0 / 255 ],\n  greenyellow: [173 / 255, 255 / 255, 47 / 255],\n  grey: [128 / 255, 128 / 255, 128 / 255],\n  honeydew: [240 / 255, 255 / 255, 240 / 255],\n  hotpink: [255 / 255, 105 / 255, 180 / 255],\n  indianred: [205 / 255, 92 / 255, 92 / 255],\n  indigo: [75 / 255, 0 / 255, 130 / 255],\n  ivory: [255 / 255, 255 / 255, 240 / 255],\n  khaki: [240 / 255, 230 / 255, 140 / 255],\n  lavender: [230 / 255, 230 / 255, 250 / 255],\n  lavenderblush: [255 / 255, 240 / 255, 245 / 255],\n  lawngreen: [124 / 255, 252 / 255, 0 / 255],\n  lemonchiffon: [255 / 255, 250 / 255, 205 / 255],\n  lightblue: [173 / 255, 216 / 255, 230 / 255],\n  lightcoral: [240 / 255, 128 / 255, 128 / 255],\n  lightcyan: [224 / 255, 255 / 255, 255 / 255],\n  lightgoldenrodyellow: [250 / 255, 250 / 255, 210 / 255],\n  lightgray: [211 / 255, 211 / 255, 211 / 255],\n  lightgreen: [144 / 255, 238 / 255, 144 / 255],\n  lightgrey: [211 / 255, 211 / 255, 211 / 255],\n  lightpink: [255 / 255, 182 / 255, 193 / 255],\n  lightsalmon: [255 / 255, 160 / 255, 122 / 255],\n  lightseagreen: [32 / 255, 178 / 255, 170 / 255],\n  lightskyblue: [135 / 255, 206 / 255, 250 / 255],\n  lightslategray: [119 / 255, 136 / 255, 153 / 255],\n  lightslategrey: [119 / 255, 136 / 255, 153 / 255],\n  lightsteelblue: [176 / 255, 196 / 255, 222 / 255],\n  lightyellow: [255 / 255, 255 / 255, 224 / 255],\n  // 'lime': [ 0 / 255, 255 / 255, 0 / 255 ],\n  limegreen: [50 / 255, 205 / 255, 50 / 255],\n  linen: [250 / 255, 240 / 255, 230 / 255],\n  magenta: [255 / 255, 0 / 255, 255 / 255],\n  // 'maroon': [ 128 / 255, 0 / 255, 0 / 255 ],\n  mediumaquamarine: [102 / 255, 205 / 255, 170 / 255],\n  mediumblue: [0 / 255, 0 / 255, 205 / 255],\n  mediumorchid: [186 / 255, 85 / 255, 211 / 255],\n  mediumpurple: [147 / 255, 112 / 255, 219 / 255],\n  mediumseagreen: [60 / 255, 179 / 255, 113 / 255],\n  mediumslateblue: [123 / 255, 104 / 255, 238 / 255],\n  mediumspringgreen: [0 / 255, 250 / 255, 154 / 255],\n  mediumturquoise: [72 / 255, 209 / 255, 204 / 255],\n  mediumvioletred: [199 / 255, 21 / 255, 133 / 255],\n  midnightblue: [25 / 255, 25 / 255, 112 / 255],\n  mintcream: [245 / 255, 255 / 255, 250 / 255],\n  mistyrose: [255 / 255, 228 / 255, 225 / 255],\n  moccasin: [255 / 255, 228 / 255, 181 / 255],\n  navajowhite: [255 / 255, 222 / 255, 173 / 255],\n  // 'navy': [ 0 / 255, 0 / 255, 128 / 255 ],\n  oldlace: [253 / 255, 245 / 255, 230 / 255],\n  // 'olive': [ 128 / 255, 128 / 255, 0 / 255 ],\n  olivedrab: [107 / 255, 142 / 255, 35 / 255],\n  orange: [255 / 255, 165 / 255, 0 / 255],\n  orangered: [255 / 255, 69 / 255, 0 / 255],\n  orchid: [218 / 255, 112 / 255, 214 / 255],\n  palegoldenrod: [238 / 255, 232 / 255, 170 / 255],\n  palegreen: [152 / 255, 251 / 255, 152 / 255],\n  paleturquoise: [175 / 255, 238 / 255, 238 / 255],\n  palevioletred: [219 / 255, 112 / 255, 147 / 255],\n  papayawhip: [255 / 255, 239 / 255, 213 / 255],\n  peachpuff: [255 / 255, 218 / 255, 185 / 255],\n  peru: [205 / 255, 133 / 255, 63 / 255],\n  pink: [255 / 255, 192 / 255, 203 / 255],\n  plum: [221 / 255, 160 / 255, 221 / 255],\n  powderblue: [176 / 255, 224 / 255, 230 / 255],\n  // 'purple': [ 128 / 255, 0 / 255, 128 / 255 ],\n  // 'red': [ 255 / 255, 0 / 255, 0 / 255 ],\n  rosybrown: [188 / 255, 143 / 255, 143 / 255],\n  royalblue: [65 / 255, 105 / 255, 225 / 255],\n  saddlebrown: [139 / 255, 69 / 255, 19 / 255],\n  salmon: [250 / 255, 128 / 255, 114 / 255],\n  sandybrown: [244 / 255, 164 / 255, 96 / 255],\n  seagreen: [46 / 255, 139 / 255, 87 / 255],\n  seashell: [255 / 255, 245 / 255, 238 / 255],\n  sienna: [160 / 255, 82 / 255, 45 / 255],\n  // 'silver': [ 192 / 255, 192 / 255, 192 / 255 ],\n  skyblue: [135 / 255, 206 / 255, 235 / 255],\n  slateblue: [106 / 255, 90 / 255, 205 / 255],\n  slategray: [112 / 255, 128 / 255, 144 / 255],\n  slategrey: [112 / 255, 128 / 255, 144 / 255],\n  snow: [255 / 255, 250 / 255, 250 / 255],\n  springgreen: [0 / 255, 255 / 255, 127 / 255],\n  steelblue: [70 / 255, 130 / 255, 180 / 255],\n  tan: [210 / 255, 180 / 255, 140 / 255],\n  // 'teal': [ 0 / 255, 128 / 255, 128 / 255 ],\n  thistle: [216 / 255, 191 / 255, 216 / 255],\n  tomato: [255 / 255, 99 / 255, 71 / 255],\n  turquoise: [64 / 255, 224 / 255, 208 / 255],\n  violet: [238 / 255, 130 / 255, 238 / 255],\n  wheat: [245 / 255, 222 / 255, 179 / 255],\n  // 'white': [ 255 / 255, 255 / 255, 255 / 255 ],\n  whitesmoke: [245 / 255, 245 / 255, 245 / 255],\n  // 'yellow': [ 255 / 255, 255 / 255, 0 / 255 ],\n  yellowgreen: [154 / 255, 205 / 255, 50 / 255],\n};\n\n/**\n * Converts an CSS color name to RGB color.\n *\n * @param   String  s       The CSS color name\n * @return  Array           The RGB representation, or [0,0,0] default\n */\nfunction css2rgb(s) {\n  return cssColors[s.toLowerCase()];\n}\n\n// color( (array[r,g,b] | css-string) [,alpha] (,array[objects] | list of objects) )\n/** apply the given color to the input object(s)\n * @param {Object} color - either an array or a hex string of color values\n * @param {Object|Array} objects either a single or multiple CSG/CAG objects to color\n * @returns {CSG} new CSG object , with the given color\n *\n * @example\n * let redSphere = color([1,0,0,1], sphere())\n */\nfunction color(color) {\n  let object;\n  let i = 1;\n  let a = arguments;\n\n  // assume first argument is RGB array\n  // but check if first argument is CSS string\n  if (typeof color === 'string') {\n    color = css2rgb(color);\n  }\n  // check if second argument is alpha\n  if (Number.isFinite(a[i])) {\n    color = color.concat(a[i]);\n    i++;\n  }\n  // check if next argument is an an array\n  if (Array.isArray(a[i])) {\n    a = a[i];\n    i = 0;\n  } // use this as the list of objects\n  for (object = a[i++]; i < a.length; i++) {\n    object = object.union(a[i]);\n  }\n  return object.setColor(color);\n}\n\n// from http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\n/**\n * Converts an RGB color value to HSL. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes r, g, and b are contained in the set [0, 1] and\n * returns h, s, and l in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSL representation\n */\nfunction rgb2hsl(r, g, b) {\n  if (r.length) {\n    b = r[2];\n    g = r[1];\n    r = r[0];\n  }\n  let max = Math.max(r, g, b);\n  let min = Math.min(r, g, b);\n  let h;\n  let s;\n  let l = (max + min) / 2;\n\n  if (max === min) {\n    h = s = 0; // achromatic\n  } else {\n    let d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n\n  return [h, s, l];\n}\n\n/**\n * Converts an HSL color value to RGB. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 1].\n *\n * @param   Number  h       The hue\n * @param   Number  s       The saturation\n * @param   Number  l       The lightness\n * @return  Array           The RGB representation\n */\nfunction hsl2rgb(h, s, l) {\n  if (h.length) {\n    h = h[0];\n    s = h[1];\n    l = h[2];\n  }\n  let r;\n  let g;\n  let b;\n\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    let p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return [r, g, b];\n}\n\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 1] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\n\nfunction rgb2hsv(r, g, b) {\n  if (r.length) {\n    r = r[0];\n    g = r[1];\n    b = r[2];\n  }\n  let max = Math.max(r, g, b);\n  let min = Math.min(r, g, b);\n  let h;\n  let s;\n  let v = max;\n\n  let d = max - min;\n  s = max === 0 ? 0 : d / max;\n\n  if (max === min) {\n    h = 0; // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n\n  return [h, s, v];\n}\n\n/**\n * Converts an HSV color value to RGB. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes h, s, and v are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 1].\n *\n * @param   Number  h       The hue\n * @param   Number  s       The saturation\n * @param   Number  v       The value\n * @return  Array           The RGB representation\n */\nfunction hsv2rgb(h, s, v) {\n  if (h.length) {\n    h = h[0];\n    s = h[1];\n    v = h[2];\n  }\n  let r, g, b;\n\n  let i = Math.floor(h * 6);\n  let f = h * 6 - i;\n  let p = v * (1 - s);\n  let q = v * (1 - f * s);\n  let t = v * (1 - (1 - f) * s);\n\n  switch (i % 6) {\n    case 0:\n      (r = v), (g = t), (b = p);\n      break;\n    case 1:\n      (r = q), (g = v), (b = p);\n      break;\n    case 2:\n      (r = p), (g = v), (b = t);\n      break;\n    case 3:\n      (r = p), (g = q), (b = v);\n      break;\n    case 4:\n      (r = t), (g = p), (b = v);\n      break;\n    case 5:\n      (r = v), (g = p), (b = q);\n      break;\n  }\n\n  return [r, g, b];\n}\n\n/**\n * Converts a HTML5 color value (string) to RGB values\n * See the color input type of HTML5 forms\n * Conversion formula:\n * - split the string; \"#RRGGBB\" into RGB components\n * - convert the HEX value into RGB values\n */\nfunction html2rgb(s) {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  if (s.length === 7) {\n    r = parseInt('0x' + s.slice(1, 3)) / 255;\n    g = parseInt('0x' + s.slice(3, 5)) / 255;\n    b = parseInt('0x' + s.slice(5, 7)) / 255;\n  }\n  return [r, g, b];\n}\n\n/**\n * Converts RGB color value to HTML5 color value (string)\n * Conversion forumla:\n * - convert R, G, B into HEX strings\n * - return HTML formatted string \"#RRGGBB\"\n */\nfunction rgb2html(r, g, b) {\n  if (r.length) {\n    r = r[0];\n    g = r[1];\n    b = r[2];\n  }\n  let s =\n    '#' +\n    Number(0x1000000 + r * 255 * 0x10000 + g * 255 * 0x100 + b * 255)\n      .toString(16)\n      .substring(1, 7);\n  return s;\n}\n\nmodule.exports = {\n  css2rgb,\n  color,\n  rgb2hsl,\n  hsl2rgb,\n  rgb2hsv,\n  hsv2rgb,\n  html2rgb,\n  rgb2html,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2NvbG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2FwaS9jb2xvci5qcz8wMzUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbG9yIHRhYmxlIGZyb20gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbmNvbnN0IGNzc0NvbG9ycyA9IHtcbiAgLy8gYmFzaWMgY29sb3Iga2V5d29yZHNcbiAgYmxhY2s6IFswIC8gMjU1LCAwIC8gMjU1LCAwIC8gMjU1XSxcbiAgc2lsdmVyOiBbMTkyIC8gMjU1LCAxOTIgLyAyNTUsIDE5MiAvIDI1NV0sXG4gIGdyYXk6IFsxMjggLyAyNTUsIDEyOCAvIDI1NSwgMTI4IC8gMjU1XSxcbiAgd2hpdGU6IFsyNTUgLyAyNTUsIDI1NSAvIDI1NSwgMjU1IC8gMjU1XSxcbiAgbWFyb29uOiBbMTI4IC8gMjU1LCAwIC8gMjU1LCAwIC8gMjU1XSxcbiAgcmVkOiBbMjU1IC8gMjU1LCAwIC8gMjU1LCAwIC8gMjU1XSxcbiAgcHVycGxlOiBbMTI4IC8gMjU1LCAwIC8gMjU1LCAxMjggLyAyNTVdLFxuICBmdWNoc2lhOiBbMjU1IC8gMjU1LCAwIC8gMjU1LCAyNTUgLyAyNTVdLFxuICBncmVlbjogWzAgLyAyNTUsIDEyOCAvIDI1NSwgMCAvIDI1NV0sXG4gIGxpbWU6IFswIC8gMjU1LCAyNTUgLyAyNTUsIDAgLyAyNTVdLFxuICBvbGl2ZTogWzEyOCAvIDI1NSwgMTI4IC8gMjU1LCAwIC8gMjU1XSxcbiAgeWVsbG93OiBbMjU1IC8gMjU1LCAyNTUgLyAyNTUsIDAgLyAyNTVdLFxuICBuYXZ5OiBbMCAvIDI1NSwgMCAvIDI1NSwgMTI4IC8gMjU1XSxcbiAgYmx1ZTogWzAgLyAyNTUsIDAgLyAyNTUsIDI1NSAvIDI1NV0sXG4gIHRlYWw6IFswIC8gMjU1LCAxMjggLyAyNTUsIDEyOCAvIDI1NV0sXG4gIGFxdWE6IFswIC8gMjU1LCAyNTUgLyAyNTUsIDI1NSAvIDI1NV0sXG4gIC8vIGV4dGVuZGVkIGNvbG9yIGtleXdvcmRzXG4gIGFsaWNlYmx1ZTogWzI0MCAvIDI1NSwgMjQ4IC8gMjU1LCAyNTUgLyAyNTVdLFxuICBhbnRpcXVld2hpdGU6IFsyNTAgLyAyNTUsIDIzNSAvIDI1NSwgMjE1IC8gMjU1XSxcbiAgLy8gJ2FxdWEnOiBbIDAgLyAyNTUsIDI1NSAvIDI1NSwgMjU1IC8gMjU1IF0sXG4gIGFxdWFtYXJpbmU6IFsxMjcgLyAyNTUsIDI1NSAvIDI1NSwgMjEyIC8gMjU1XSxcbiAgYXp1cmU6IFsyNDAgLyAyNTUsIDI1NSAvIDI1NSwgMjU1IC8gMjU1XSxcbiAgYmVpZ2U6IFsyNDUgLyAyNTUsIDI0NSAvIDI1NSwgMjIwIC8gMjU1XSxcbiAgYmlzcXVlOiBbMjU1IC8gMjU1LCAyMjggLyAyNTUsIDE5NiAvIDI1NV0sXG4gIC8vICdibGFjayc6IFsgMCAvIDI1NSwgMCAvIDI1NSwgMCAvIDI1NSBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSAvIDI1NSwgMjM1IC8gMjU1LCAyMDUgLyAyNTVdLFxuICAvLyAnYmx1ZSc6IFsgMCAvIDI1NSwgMCAvIDI1NSwgMjU1IC8gMjU1IF0sXG4gIGJsdWV2aW9sZXQ6IFsxMzggLyAyNTUsIDQzIC8gMjU1LCAyMjYgLyAyNTVdLFxuICBicm93bjogWzE2NSAvIDI1NSwgNDIgLyAyNTUsIDQyIC8gMjU1XSxcbiAgYnVybHl3b29kOiBbMjIyIC8gMjU1LCAxODQgLyAyNTUsIDEzNSAvIDI1NV0sXG4gIGNhZGV0Ymx1ZTogWzk1IC8gMjU1LCAxNTggLyAyNTUsIDE2MCAvIDI1NV0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcgLyAyNTUsIDI1NSAvIDI1NSwgMCAvIDI1NV0sXG4gIGNob2NvbGF0ZTogWzIxMCAvIDI1NSwgMTA1IC8gMjU1LCAzMCAvIDI1NV0sXG4gIGNvcmFsOiBbMjU1IC8gMjU1LCAxMjcgLyAyNTUsIDgwIC8gMjU1XSxcbiAgY29ybmZsb3dlcmJsdWU6IFsxMDAgLyAyNTUsIDE0OSAvIDI1NSwgMjM3IC8gMjU1XSxcbiAgY29ybnNpbGs6IFsyNTUgLyAyNTUsIDI0OCAvIDI1NSwgMjIwIC8gMjU1XSxcbiAgY3JpbXNvbjogWzIyMCAvIDI1NSwgMjAgLyAyNTUsIDYwIC8gMjU1XSxcbiAgY3lhbjogWzAgLyAyNTUsIDI1NSAvIDI1NSwgMjU1IC8gMjU1XSxcbiAgZGFya2JsdWU6IFswIC8gMjU1LCAwIC8gMjU1LCAxMzkgLyAyNTVdLFxuICBkYXJrY3lhbjogWzAgLyAyNTUsIDEzOSAvIDI1NSwgMTM5IC8gMjU1XSxcbiAgZGFya2dvbGRlbnJvZDogWzE4NCAvIDI1NSwgMTM0IC8gMjU1LCAxMSAvIDI1NV0sXG4gIGRhcmtncmF5OiBbMTY5IC8gMjU1LCAxNjkgLyAyNTUsIDE2OSAvIDI1NV0sXG4gIGRhcmtncmVlbjogWzAgLyAyNTUsIDEwMCAvIDI1NSwgMCAvIDI1NV0sXG4gIGRhcmtncmV5OiBbMTY5IC8gMjU1LCAxNjkgLyAyNTUsIDE2OSAvIDI1NV0sXG4gIGRhcmtraGFraTogWzE4OSAvIDI1NSwgMTgzIC8gMjU1LCAxMDcgLyAyNTVdLFxuICBkYXJrbWFnZW50YTogWzEzOSAvIDI1NSwgMCAvIDI1NSwgMTM5IC8gMjU1XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSAvIDI1NSwgMTA3IC8gMjU1LCA0NyAvIDI1NV0sXG4gIGRhcmtvcmFuZ2U6IFsyNTUgLyAyNTUsIDE0MCAvIDI1NSwgMCAvIDI1NV0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMgLyAyNTUsIDUwIC8gMjU1LCAyMDQgLyAyNTVdLFxuICBkYXJrcmVkOiBbMTM5IC8gMjU1LCAwIC8gMjU1LCAwIC8gMjU1XSxcbiAgZGFya3NhbG1vbjogWzIzMyAvIDI1NSwgMTUwIC8gMjU1LCAxMjIgLyAyNTVdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMgLyAyNTUsIDE4OCAvIDI1NSwgMTQzIC8gMjU1XSxcbiAgZGFya3NsYXRlYmx1ZTogWzcyIC8gMjU1LCA2MSAvIDI1NSwgMTM5IC8gMjU1XSxcbiAgZGFya3NsYXRlZ3JheTogWzQ3IC8gMjU1LCA3OSAvIDI1NSwgNzkgLyAyNTVdLFxuICBkYXJrc2xhdGVncmV5OiBbNDcgLyAyNTUsIDc5IC8gMjU1LCA3OSAvIDI1NV0sXG4gIGRhcmt0dXJxdW9pc2U6IFswIC8gMjU1LCAyMDYgLyAyNTUsIDIwOSAvIDI1NV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDggLyAyNTUsIDAgLyAyNTUsIDIxMSAvIDI1NV0sXG4gIGRlZXBwaW5rOiBbMjU1IC8gMjU1LCAyMCAvIDI1NSwgMTQ3IC8gMjU1XSxcbiAgZGVlcHNreWJsdWU6IFswIC8gMjU1LCAxOTEgLyAyNTUsIDI1NSAvIDI1NV0sXG4gIGRpbWdyYXk6IFsxMDUgLyAyNTUsIDEwNSAvIDI1NSwgMTA1IC8gMjU1XSxcbiAgZGltZ3JleTogWzEwNSAvIDI1NSwgMTA1IC8gMjU1LCAxMDUgLyAyNTVdLFxuICBkb2RnZXJibHVlOiBbMzAgLyAyNTUsIDE0NCAvIDI1NSwgMjU1IC8gMjU1XSxcbiAgZmlyZWJyaWNrOiBbMTc4IC8gMjU1LCAzNCAvIDI1NSwgMzQgLyAyNTVdLFxuICBmbG9yYWx3aGl0ZTogWzI1NSAvIDI1NSwgMjUwIC8gMjU1LCAyNDAgLyAyNTVdLFxuICBmb3Jlc3RncmVlbjogWzM0IC8gMjU1LCAxMzkgLyAyNTUsIDM0IC8gMjU1XSxcbiAgLy8gJ2Z1Y2hzaWEnOiBbIDI1NSAvIDI1NSwgMCAvIDI1NSwgMjU1IC8gMjU1IF0sXG4gIGdhaW5zYm9ybzogWzIyMCAvIDI1NSwgMjIwIC8gMjU1LCAyMjAgLyAyNTVdLFxuICBnaG9zdHdoaXRlOiBbMjQ4IC8gMjU1LCAyNDggLyAyNTUsIDI1NSAvIDI1NV0sXG4gIGdvbGQ6IFsyNTUgLyAyNTUsIDIxNSAvIDI1NSwgMCAvIDI1NV0sXG4gIGdvbGRlbnJvZDogWzIxOCAvIDI1NSwgMTY1IC8gMjU1LCAzMiAvIDI1NV0sXG4gIC8vICdncmF5JzogWyAxMjggLyAyNTUsIDEyOCAvIDI1NSwgMTI4IC8gMjU1IF0sXG4gIC8vICdncmVlbic6IFsgMCAvIDI1NSwgMTI4IC8gMjU1LCAwIC8gMjU1IF0sXG4gIGdyZWVueWVsbG93OiBbMTczIC8gMjU1LCAyNTUgLyAyNTUsIDQ3IC8gMjU1XSxcbiAgZ3JleTogWzEyOCAvIDI1NSwgMTI4IC8gMjU1LCAxMjggLyAyNTVdLFxuICBob25leWRldzogWzI0MCAvIDI1NSwgMjU1IC8gMjU1LCAyNDAgLyAyNTVdLFxuICBob3RwaW5rOiBbMjU1IC8gMjU1LCAxMDUgLyAyNTUsIDE4MCAvIDI1NV0sXG4gIGluZGlhbnJlZDogWzIwNSAvIDI1NSwgOTIgLyAyNTUsIDkyIC8gMjU1XSxcbiAgaW5kaWdvOiBbNzUgLyAyNTUsIDAgLyAyNTUsIDEzMCAvIDI1NV0sXG4gIGl2b3J5OiBbMjU1IC8gMjU1LCAyNTUgLyAyNTUsIDI0MCAvIDI1NV0sXG4gIGtoYWtpOiBbMjQwIC8gMjU1LCAyMzAgLyAyNTUsIDE0MCAvIDI1NV0sXG4gIGxhdmVuZGVyOiBbMjMwIC8gMjU1LCAyMzAgLyAyNTUsIDI1MCAvIDI1NV0sXG4gIGxhdmVuZGVyYmx1c2g6IFsyNTUgLyAyNTUsIDI0MCAvIDI1NSwgMjQ1IC8gMjU1XSxcbiAgbGF3bmdyZWVuOiBbMTI0IC8gMjU1LCAyNTIgLyAyNTUsIDAgLyAyNTVdLFxuICBsZW1vbmNoaWZmb246IFsyNTUgLyAyNTUsIDI1MCAvIDI1NSwgMjA1IC8gMjU1XSxcbiAgbGlnaHRibHVlOiBbMTczIC8gMjU1LCAyMTYgLyAyNTUsIDIzMCAvIDI1NV0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAgLyAyNTUsIDEyOCAvIDI1NSwgMTI4IC8gMjU1XSxcbiAgbGlnaHRjeWFuOiBbMjI0IC8gMjU1LCAyNTUgLyAyNTUsIDI1NSAvIDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwIC8gMjU1LCAyNTAgLyAyNTUsIDIxMCAvIDI1NV0sXG4gIGxpZ2h0Z3JheTogWzIxMSAvIDI1NSwgMjExIC8gMjU1LCAyMTEgLyAyNTVdLFxuICBsaWdodGdyZWVuOiBbMTQ0IC8gMjU1LCAyMzggLyAyNTUsIDE0NCAvIDI1NV0sXG4gIGxpZ2h0Z3JleTogWzIxMSAvIDI1NSwgMjExIC8gMjU1LCAyMTEgLyAyNTVdLFxuICBsaWdodHBpbms6IFsyNTUgLyAyNTUsIDE4MiAvIDI1NSwgMTkzIC8gMjU1XSxcbiAgbGlnaHRzYWxtb246IFsyNTUgLyAyNTUsIDE2MCAvIDI1NSwgMTIyIC8gMjU1XSxcbiAgbGlnaHRzZWFncmVlbjogWzMyIC8gMjU1LCAxNzggLyAyNTUsIDE3MCAvIDI1NV0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSAvIDI1NSwgMjA2IC8gMjU1LCAyNTAgLyAyNTVdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSAvIDI1NSwgMTM2IC8gMjU1LCAxNTMgLyAyNTVdLFxuICBsaWdodHNsYXRlZ3JleTogWzExOSAvIDI1NSwgMTM2IC8gMjU1LCAxNTMgLyAyNTVdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiAvIDI1NSwgMTk2IC8gMjU1LCAyMjIgLyAyNTVdLFxuICBsaWdodHllbGxvdzogWzI1NSAvIDI1NSwgMjU1IC8gMjU1LCAyMjQgLyAyNTVdLFxuICAvLyAnbGltZSc6IFsgMCAvIDI1NSwgMjU1IC8gMjU1LCAwIC8gMjU1IF0sXG4gIGxpbWVncmVlbjogWzUwIC8gMjU1LCAyMDUgLyAyNTUsIDUwIC8gMjU1XSxcbiAgbGluZW46IFsyNTAgLyAyNTUsIDI0MCAvIDI1NSwgMjMwIC8gMjU1XSxcbiAgbWFnZW50YTogWzI1NSAvIDI1NSwgMCAvIDI1NSwgMjU1IC8gMjU1XSxcbiAgLy8gJ21hcm9vbic6IFsgMTI4IC8gMjU1LCAwIC8gMjU1LCAwIC8gMjU1IF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIgLyAyNTUsIDIwNSAvIDI1NSwgMTcwIC8gMjU1XSxcbiAgbWVkaXVtYmx1ZTogWzAgLyAyNTUsIDAgLyAyNTUsIDIwNSAvIDI1NV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4NiAvIDI1NSwgODUgLyAyNTUsIDIxMSAvIDI1NV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NyAvIDI1NSwgMTEyIC8gMjU1LCAyMTkgLyAyNTVdLFxuICBtZWRpdW1zZWFncmVlbjogWzYwIC8gMjU1LCAxNzkgLyAyNTUsIDExMyAvIDI1NV0sXG4gIG1lZGl1bXNsYXRlYmx1ZTogWzEyMyAvIDI1NSwgMTA0IC8gMjU1LCAyMzggLyAyNTVdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogWzAgLyAyNTUsIDI1MCAvIDI1NSwgMTU0IC8gMjU1XSxcbiAgbWVkaXVtdHVycXVvaXNlOiBbNzIgLyAyNTUsIDIwOSAvIDI1NSwgMjA0IC8gMjU1XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5IC8gMjU1LCAyMSAvIDI1NSwgMTMzIC8gMjU1XSxcbiAgbWlkbmlnaHRibHVlOiBbMjUgLyAyNTUsIDI1IC8gMjU1LCAxMTIgLyAyNTVdLFxuICBtaW50Y3JlYW06IFsyNDUgLyAyNTUsIDI1NSAvIDI1NSwgMjUwIC8gMjU1XSxcbiAgbWlzdHlyb3NlOiBbMjU1IC8gMjU1LCAyMjggLyAyNTUsIDIyNSAvIDI1NV0sXG4gIG1vY2Nhc2luOiBbMjU1IC8gMjU1LCAyMjggLyAyNTUsIDE4MSAvIDI1NV0sXG4gIG5hdmFqb3doaXRlOiBbMjU1IC8gMjU1LCAyMjIgLyAyNTUsIDE3MyAvIDI1NV0sXG4gIC8vICduYXZ5JzogWyAwIC8gMjU1LCAwIC8gMjU1LCAxMjggLyAyNTUgXSxcbiAgb2xkbGFjZTogWzI1MyAvIDI1NSwgMjQ1IC8gMjU1LCAyMzAgLyAyNTVdLFxuICAvLyAnb2xpdmUnOiBbIDEyOCAvIDI1NSwgMTI4IC8gMjU1LCAwIC8gMjU1IF0sXG4gIG9saXZlZHJhYjogWzEwNyAvIDI1NSwgMTQyIC8gMjU1LCAzNSAvIDI1NV0sXG4gIG9yYW5nZTogWzI1NSAvIDI1NSwgMTY1IC8gMjU1LCAwIC8gMjU1XSxcbiAgb3JhbmdlcmVkOiBbMjU1IC8gMjU1LCA2OSAvIDI1NSwgMCAvIDI1NV0sXG4gIG9yY2hpZDogWzIxOCAvIDI1NSwgMTEyIC8gMjU1LCAyMTQgLyAyNTVdLFxuICBwYWxlZ29sZGVucm9kOiBbMjM4IC8gMjU1LCAyMzIgLyAyNTUsIDE3MCAvIDI1NV0sXG4gIHBhbGVncmVlbjogWzE1MiAvIDI1NSwgMjUxIC8gMjU1LCAxNTIgLyAyNTVdLFxuICBwYWxldHVycXVvaXNlOiBbMTc1IC8gMjU1LCAyMzggLyAyNTUsIDIzOCAvIDI1NV0sXG4gIHBhbGV2aW9sZXRyZWQ6IFsyMTkgLyAyNTUsIDExMiAvIDI1NSwgMTQ3IC8gMjU1XSxcbiAgcGFwYXlhd2hpcDogWzI1NSAvIDI1NSwgMjM5IC8gMjU1LCAyMTMgLyAyNTVdLFxuICBwZWFjaHB1ZmY6IFsyNTUgLyAyNTUsIDIxOCAvIDI1NSwgMTg1IC8gMjU1XSxcbiAgcGVydTogWzIwNSAvIDI1NSwgMTMzIC8gMjU1LCA2MyAvIDI1NV0sXG4gIHBpbms6IFsyNTUgLyAyNTUsIDE5MiAvIDI1NSwgMjAzIC8gMjU1XSxcbiAgcGx1bTogWzIyMSAvIDI1NSwgMTYwIC8gMjU1LCAyMjEgLyAyNTVdLFxuICBwb3dkZXJibHVlOiBbMTc2IC8gMjU1LCAyMjQgLyAyNTUsIDIzMCAvIDI1NV0sXG4gIC8vICdwdXJwbGUnOiBbIDEyOCAvIDI1NSwgMCAvIDI1NSwgMTI4IC8gMjU1IF0sXG4gIC8vICdyZWQnOiBbIDI1NSAvIDI1NSwgMCAvIDI1NSwgMCAvIDI1NSBdLFxuICByb3N5YnJvd246IFsxODggLyAyNTUsIDE0MyAvIDI1NSwgMTQzIC8gMjU1XSxcbiAgcm95YWxibHVlOiBbNjUgLyAyNTUsIDEwNSAvIDI1NSwgMjI1IC8gMjU1XSxcbiAgc2FkZGxlYnJvd246IFsxMzkgLyAyNTUsIDY5IC8gMjU1LCAxOSAvIDI1NV0sXG4gIHNhbG1vbjogWzI1MCAvIDI1NSwgMTI4IC8gMjU1LCAxMTQgLyAyNTVdLFxuICBzYW5keWJyb3duOiBbMjQ0IC8gMjU1LCAxNjQgLyAyNTUsIDk2IC8gMjU1XSxcbiAgc2VhZ3JlZW46IFs0NiAvIDI1NSwgMTM5IC8gMjU1LCA4NyAvIDI1NV0sXG4gIHNlYXNoZWxsOiBbMjU1IC8gMjU1LCAyNDUgLyAyNTUsIDIzOCAvIDI1NV0sXG4gIHNpZW5uYTogWzE2MCAvIDI1NSwgODIgLyAyNTUsIDQ1IC8gMjU1XSxcbiAgLy8gJ3NpbHZlcic6IFsgMTkyIC8gMjU1LCAxOTIgLyAyNTUsIDE5MiAvIDI1NSBdLFxuICBza3libHVlOiBbMTM1IC8gMjU1LCAyMDYgLyAyNTUsIDIzNSAvIDI1NV0sXG4gIHNsYXRlYmx1ZTogWzEwNiAvIDI1NSwgOTAgLyAyNTUsIDIwNSAvIDI1NV0sXG4gIHNsYXRlZ3JheTogWzExMiAvIDI1NSwgMTI4IC8gMjU1LCAxNDQgLyAyNTVdLFxuICBzbGF0ZWdyZXk6IFsxMTIgLyAyNTUsIDEyOCAvIDI1NSwgMTQ0IC8gMjU1XSxcbiAgc25vdzogWzI1NSAvIDI1NSwgMjUwIC8gMjU1LCAyNTAgLyAyNTVdLFxuICBzcHJpbmdncmVlbjogWzAgLyAyNTUsIDI1NSAvIDI1NSwgMTI3IC8gMjU1XSxcbiAgc3RlZWxibHVlOiBbNzAgLyAyNTUsIDEzMCAvIDI1NSwgMTgwIC8gMjU1XSxcbiAgdGFuOiBbMjEwIC8gMjU1LCAxODAgLyAyNTUsIDE0MCAvIDI1NV0sXG4gIC8vICd0ZWFsJzogWyAwIC8gMjU1LCAxMjggLyAyNTUsIDEyOCAvIDI1NSBdLFxuICB0aGlzdGxlOiBbMjE2IC8gMjU1LCAxOTEgLyAyNTUsIDIxNiAvIDI1NV0sXG4gIHRvbWF0bzogWzI1NSAvIDI1NSwgOTkgLyAyNTUsIDcxIC8gMjU1XSxcbiAgdHVycXVvaXNlOiBbNjQgLyAyNTUsIDIyNCAvIDI1NSwgMjA4IC8gMjU1XSxcbiAgdmlvbGV0OiBbMjM4IC8gMjU1LCAxMzAgLyAyNTUsIDIzOCAvIDI1NV0sXG4gIHdoZWF0OiBbMjQ1IC8gMjU1LCAyMjIgLyAyNTUsIDE3OSAvIDI1NV0sXG4gIC8vICd3aGl0ZSc6IFsgMjU1IC8gMjU1LCAyNTUgLyAyNTUsIDI1NSAvIDI1NSBdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1IC8gMjU1LCAyNDUgLyAyNTUsIDI0NSAvIDI1NV0sXG4gIC8vICd5ZWxsb3cnOiBbIDI1NSAvIDI1NSwgMjU1IC8gMjU1LCAwIC8gMjU1IF0sXG4gIHllbGxvd2dyZWVuOiBbMTU0IC8gMjU1LCAyMDUgLyAyNTUsIDUwIC8gMjU1XSxcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gQ1NTIGNvbG9yIG5hbWUgdG8gUkdCIGNvbG9yLlxuICpcbiAqIEBwYXJhbSAgIFN0cmluZyAgcyAgICAgICBUaGUgQ1NTIGNvbG9yIG5hbWVcbiAqIEByZXR1cm4gIEFycmF5ICAgICAgICAgICBUaGUgUkdCIHJlcHJlc2VudGF0aW9uLCBvciBbMCwwLDBdIGRlZmF1bHRcbiAqL1xuZnVuY3Rpb24gY3NzMnJnYihzKSB7XG4gIHJldHVybiBjc3NDb2xvcnNbcy50b0xvd2VyQ2FzZSgpXTtcbn1cblxuLy8gY29sb3IoIChhcnJheVtyLGcsYl0gfCBjc3Mtc3RyaW5nKSBbLGFscGhhXSAoLGFycmF5W29iamVjdHNdIHwgbGlzdCBvZiBvYmplY3RzKSApXG4vKiogYXBwbHkgdGhlIGdpdmVuIGNvbG9yIHRvIHRoZSBpbnB1dCBvYmplY3QocylcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvciAtIGVpdGhlciBhbiBhcnJheSBvciBhIGhleCBzdHJpbmcgb2YgY29sb3IgdmFsdWVzXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqZWN0cyBlaXRoZXIgYSBzaW5nbGUgb3IgbXVsdGlwbGUgQ1NHL0NBRyBvYmplY3RzIHRvIGNvbG9yXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgQ1NHIG9iamVjdCAsIHdpdGggdGhlIGdpdmVuIGNvbG9yXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByZWRTcGhlcmUgPSBjb2xvcihbMSwwLDAsMV0sIHNwaGVyZSgpKVxuICovXG5mdW5jdGlvbiBjb2xvcihjb2xvcikge1xuICBsZXQgb2JqZWN0O1xuICBsZXQgaSA9IDE7XG4gIGxldCBhID0gYXJndW1lbnRzO1xuXG4gIC8vIGFzc3VtZSBmaXJzdCBhcmd1bWVudCBpcyBSR0IgYXJyYXlcbiAgLy8gYnV0IGNoZWNrIGlmIGZpcnN0IGFyZ3VtZW50IGlzIENTUyBzdHJpbmdcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb2xvciA9IGNzczJyZ2IoY29sb3IpO1xuICB9XG4gIC8vIGNoZWNrIGlmIHNlY29uZCBhcmd1bWVudCBpcyBhbHBoYVxuICBpZiAoTnVtYmVyLmlzRmluaXRlKGFbaV0pKSB7XG4gICAgY29sb3IgPSBjb2xvci5jb25jYXQoYVtpXSk7XG4gICAgaSsrO1xuICB9XG4gIC8vIGNoZWNrIGlmIG5leHQgYXJndW1lbnQgaXMgYW4gYW4gYXJyYXlcbiAgaWYgKEFycmF5LmlzQXJyYXkoYVtpXSkpIHtcbiAgICBhID0gYVtpXTtcbiAgICBpID0gMDtcbiAgfSAvLyB1c2UgdGhpcyBhcyB0aGUgbGlzdCBvZiBvYmplY3RzXG4gIGZvciAob2JqZWN0ID0gYVtpKytdOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIG9iamVjdCA9IG9iamVjdC51bmlvbihhW2ldKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0LnNldENvbG9yKGNvbG9yKTtcbn1cblxuLy8gZnJvbSBodHRwOi8vYXhvbmZsdXguY29tL2hhbmR5LXJnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLiBDb252ZXJzaW9uIGZvcm11bGFcbiAqIGFkYXB0ZWQgZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cbiAqIEFzc3VtZXMgciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAxXSBhbmRcbiAqIHJldHVybnMgaCwgcywgYW5kIGwgaW4gdGhlIHNldCBbMCwgMV0uXG4gKlxuICogQHBhcmFtICAgTnVtYmVyICByICAgICAgIFRoZSByZWQgY29sb3IgdmFsdWVcbiAqIEBwYXJhbSAgIE51bWJlciAgZyAgICAgICBUaGUgZ3JlZW4gY29sb3IgdmFsdWVcbiAqIEBwYXJhbSAgIE51bWJlciAgYiAgICAgICBUaGUgYmx1ZSBjb2xvciB2YWx1ZVxuICogQHJldHVybiAgQXJyYXkgICAgICAgICAgIFRoZSBIU0wgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gcmdiMmhzbChyLCBnLCBiKSB7XG4gIGlmIChyLmxlbmd0aCkge1xuICAgIGIgPSByWzJdO1xuICAgIGcgPSByWzFdO1xuICAgIHIgPSByWzBdO1xuICB9XG4gIGxldCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgbGV0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBsZXQgaDtcbiAgbGV0IHM7XG4gIGxldCBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICB9IGVsc2Uge1xuICAgIGxldCBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgY2FzZSByOlxuICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnOlxuICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjpcbiAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGggLz0gNjtcbiAgfVxuXG4gIHJldHVybiBbaCwgcywgbF07XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gSFNMIGNvbG9yIHZhbHVlIHRvIFJHQi4gQ29udmVyc2lvbiBmb3JtdWxhXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXG4gKiBBc3N1bWVzIGgsIHMsIGFuZCBsIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMV0gYW5kXG4gKiByZXR1cm5zIHIsIGcsIGFuZCBiIGluIHRoZSBzZXQgWzAsIDFdLlxuICpcbiAqIEBwYXJhbSAgIE51bWJlciAgaCAgICAgICBUaGUgaHVlXG4gKiBAcGFyYW0gICBOdW1iZXIgIHMgICAgICAgVGhlIHNhdHVyYXRpb25cbiAqIEBwYXJhbSAgIE51bWJlciAgbCAgICAgICBUaGUgbGlnaHRuZXNzXG4gKiBAcmV0dXJuICBBcnJheSAgICAgICAgICAgVGhlIFJHQiByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcbiAgaWYgKGgubGVuZ3RoKSB7XG4gICAgaCA9IGhbMF07XG4gICAgcyA9IGhbMV07XG4gICAgbCA9IGhbMl07XG4gIH1cbiAgbGV0IHI7XG4gIGxldCBnO1xuICBsZXQgYjtcblxuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IGw7IC8vIGFjaHJvbWF0aWNcbiAgfSBlbHNlIHtcbiAgICBsZXQgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgbGV0IHAgPSAyICogbCAtIHE7XG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICB9XG5cbiAgcmV0dXJuIFtyLCBnLCBiXTtcbn1cblxuZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gIGlmICh0IDwgMCkgdCArPSAxO1xuICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU1YuIENvbnZlcnNpb24gZm9ybXVsYVxuICogYWRhcHRlZCBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNWX2NvbG9yX3NwYWNlLlxuICogQXNzdW1lcyByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDFdIGFuZFxuICogcmV0dXJucyBoLCBzLCBhbmQgdiBpbiB0aGUgc2V0IFswLCAxXS5cbiAqXG4gKiBAcGFyYW0gICBOdW1iZXIgIHIgICAgICAgVGhlIHJlZCBjb2xvciB2YWx1ZVxuICogQHBhcmFtICAgTnVtYmVyICBnICAgICAgIFRoZSBncmVlbiBjb2xvciB2YWx1ZVxuICogQHBhcmFtICAgTnVtYmVyICBiICAgICAgIFRoZSBibHVlIGNvbG9yIHZhbHVlXG4gKiBAcmV0dXJuICBBcnJheSAgICAgICAgICAgVGhlIEhTViByZXByZXNlbnRhdGlvblxuICovXG5cbmZ1bmN0aW9uIHJnYjJoc3YociwgZywgYikge1xuICBpZiAoci5sZW5ndGgpIHtcbiAgICByID0gclswXTtcbiAgICBnID0gclsxXTtcbiAgICBiID0gclsyXTtcbiAgfVxuICBsZXQgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGxldCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgbGV0IGg7XG4gIGxldCBzO1xuICBsZXQgdiA9IG1heDtcblxuICBsZXQgZCA9IG1heCAtIG1pbjtcbiAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xuXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgcjpcbiAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGI6XG4gICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBoIC89IDY7XG4gIH1cblxuICByZXR1cm4gW2gsIHMsIHZdO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEhTViBjb2xvciB2YWx1ZSB0byBSR0IuIENvbnZlcnNpb24gZm9ybXVsYVxuICogYWRhcHRlZCBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNWX2NvbG9yX3NwYWNlLlxuICogQXNzdW1lcyBoLCBzLCBhbmQgdiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDFdIGFuZFxuICogcmV0dXJucyByLCBnLCBhbmQgYiBpbiB0aGUgc2V0IFswLCAxXS5cbiAqXG4gKiBAcGFyYW0gICBOdW1iZXIgIGggICAgICAgVGhlIGh1ZVxuICogQHBhcmFtICAgTnVtYmVyICBzICAgICAgIFRoZSBzYXR1cmF0aW9uXG4gKiBAcGFyYW0gICBOdW1iZXIgIHYgICAgICAgVGhlIHZhbHVlXG4gKiBAcmV0dXJuICBBcnJheSAgICAgICAgICAgVGhlIFJHQiByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcbiAgaWYgKGgubGVuZ3RoKSB7XG4gICAgaCA9IGhbMF07XG4gICAgcyA9IGhbMV07XG4gICAgdiA9IGhbMl07XG4gIH1cbiAgbGV0IHIsIGcsIGI7XG5cbiAgbGV0IGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgbGV0IGYgPSBoICogNiAtIGk7XG4gIGxldCBwID0gdiAqICgxIC0gcyk7XG4gIGxldCBxID0gdiAqICgxIC0gZiAqIHMpO1xuICBsZXQgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgY2FzZSAwOlxuICAgICAgKHIgPSB2KSwgKGcgPSB0KSwgKGIgPSBwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIChyID0gcSksIChnID0gdiksIChiID0gcCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICAociA9IHApLCAoZyA9IHYpLCAoYiA9IHQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgKHIgPSBwKSwgKGcgPSBxKSwgKGIgPSB2KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIChyID0gdCksIChnID0gcCksIChiID0gdik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICAociA9IHYpLCAoZyA9IHApLCAoYiA9IHEpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IsIGcsIGJdO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgSFRNTDUgY29sb3IgdmFsdWUgKHN0cmluZykgdG8gUkdCIHZhbHVlc1xuICogU2VlIHRoZSBjb2xvciBpbnB1dCB0eXBlIG9mIEhUTUw1IGZvcm1zXG4gKiBDb252ZXJzaW9uIGZvcm11bGE6XG4gKiAtIHNwbGl0IHRoZSBzdHJpbmc7IFwiI1JSR0dCQlwiIGludG8gUkdCIGNvbXBvbmVudHNcbiAqIC0gY29udmVydCB0aGUgSEVYIHZhbHVlIGludG8gUkdCIHZhbHVlc1xuICovXG5mdW5jdGlvbiBodG1sMnJnYihzKSB7XG4gIGxldCByID0gMDtcbiAgbGV0IGcgPSAwO1xuICBsZXQgYiA9IDA7XG4gIGlmIChzLmxlbmd0aCA9PT0gNykge1xuICAgIHIgPSBwYXJzZUludCgnMHgnICsgcy5zbGljZSgxLCAzKSkgLyAyNTU7XG4gICAgZyA9IHBhcnNlSW50KCcweCcgKyBzLnNsaWNlKDMsIDUpKSAvIDI1NTtcbiAgICBiID0gcGFyc2VJbnQoJzB4JyArIHMuc2xpY2UoNSwgNykpIC8gMjU1O1xuICB9XG4gIHJldHVybiBbciwgZywgYl07XG59XG5cbi8qKlxuICogQ29udmVydHMgUkdCIGNvbG9yIHZhbHVlIHRvIEhUTUw1IGNvbG9yIHZhbHVlIChzdHJpbmcpXG4gKiBDb252ZXJzaW9uIGZvcnVtbGE6XG4gKiAtIGNvbnZlcnQgUiwgRywgQiBpbnRvIEhFWCBzdHJpbmdzXG4gKiAtIHJldHVybiBIVE1MIGZvcm1hdHRlZCBzdHJpbmcgXCIjUlJHR0JCXCJcbiAqL1xuZnVuY3Rpb24gcmdiMmh0bWwociwgZywgYikge1xuICBpZiAoci5sZW5ndGgpIHtcbiAgICByID0gclswXTtcbiAgICBnID0gclsxXTtcbiAgICBiID0gclsyXTtcbiAgfVxuICBsZXQgcyA9XG4gICAgJyMnICtcbiAgICBOdW1iZXIoMHgxMDAwMDAwICsgciAqIDI1NSAqIDB4MTAwMDAgKyBnICogMjU1ICogMHgxMDAgKyBiICogMjU1KVxuICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgLnN1YnN0cmluZygxLCA3KTtcbiAgcmV0dXJuIHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjc3MycmdiLFxuICBjb2xvcixcbiAgcmdiMmhzbCxcbiAgaHNsMnJnYixcbiAgcmdiMmhzdixcbiAgaHN2MnJnYixcbiAgaHRtbDJyZ2IsXG4gIHJnYjJodG1sLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/color.js\n");

/***/ }),

/***/ "./src/api/debug.js":
/*!**************************!*\
  !*** ./src/api/debug.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function echo() {\n  console.warn(\n    'echo() will be deprecated in the near future: please use console.log/warn/error instead'\n  );\n  var s = '',\n    a = arguments;\n  for (var i = 0; i < a.length; i++) {\n    if (i) s += ', ';\n    s += a[i];\n  }\n  // var t = (new Date()-global.time)/1000\n  // console.log(t,s)\n  console.log(s);\n}\n\nmodule.exports = {\n  echo,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2RlYnVnLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2FwaS9kZWJ1Zy5qcz9lMWQzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGVjaG8oKSB7XG4gIGNvbnNvbGUud2FybihcbiAgICAnZWNobygpIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgbmVhciBmdXR1cmU6IHBsZWFzZSB1c2UgY29uc29sZS5sb2cvd2Fybi9lcnJvciBpbnN0ZWFkJ1xuICApO1xuICB2YXIgcyA9ICcnLFxuICAgIGEgPSBhcmd1bWVudHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpKSBzICs9ICcsICc7XG4gICAgcyArPSBhW2ldO1xuICB9XG4gIC8vIHZhciB0ID0gKG5ldyBEYXRlKCktZ2xvYmFsLnRpbWUpLzEwMDBcbiAgLy8gY29uc29sZS5sb2codCxzKVxuICBjb25zb2xlLmxvZyhzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVjaG8sXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/debug.js\n");

/***/ }),

/***/ "./src/api/debugHelpers.js":
/*!*********************************!*\
  !*** ./src/api/debugHelpers.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CSG = __webpack_require__(/*! ../core/CSG */ \"./src/core/CSG.js\");\nconst { cube } = __webpack_require__(/*! ./primitives3d */ \"./src/api/primitives3d.js\");\n\n// For debugging\n// Creates a new solid with a tiny cube at every vertex of the source solid\n// this is seperated from the CSG class itself because of the dependency on cube\nconst toPointCloud = function (csg, cuberadius) {\n  csg = csg.reTesselated();\n\n  let result = new CSG();\n\n  // make a list of all unique vertices\n  // For each vertex we also collect the list of normals of the planes touching the vertices\n  let vertexmap = {};\n  csg.polygons.map(function (polygon) {\n    polygon.vertices.map(function (vertex) {\n      vertexmap[vertex.getTag()] = vertex.pos;\n    });\n  });\n\n  for (let vertextag in vertexmap) {\n    let pos = vertexmap[vertextag];\n    let _cube = cube({\n      center: pos,\n      radius: cuberadius,\n    });\n    result = result.unionSub(_cube, false, false);\n  }\n  result = result.reTesselated();\n  return result;\n};\n\nmodule.exports = { toPointCloud };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2RlYnVnSGVscGVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvZGVidWdIZWxwZXJzLmpzP2M0NmYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ1NHID0gcmVxdWlyZSgnLi4vY29yZS9DU0cnKTtcbmNvbnN0IHsgY3ViZSB9ID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzM2QnKTtcblxuLy8gRm9yIGRlYnVnZ2luZ1xuLy8gQ3JlYXRlcyBhIG5ldyBzb2xpZCB3aXRoIGEgdGlueSBjdWJlIGF0IGV2ZXJ5IHZlcnRleCBvZiB0aGUgc291cmNlIHNvbGlkXG4vLyB0aGlzIGlzIHNlcGVyYXRlZCBmcm9tIHRoZSBDU0cgY2xhc3MgaXRzZWxmIGJlY2F1c2Ugb2YgdGhlIGRlcGVuZGVuY3kgb24gY3ViZVxuY29uc3QgdG9Qb2ludENsb3VkID0gZnVuY3Rpb24gKGNzZywgY3ViZXJhZGl1cykge1xuICBjc2cgPSBjc2cucmVUZXNzZWxhdGVkKCk7XG5cbiAgbGV0IHJlc3VsdCA9IG5ldyBDU0coKTtcblxuICAvLyBtYWtlIGEgbGlzdCBvZiBhbGwgdW5pcXVlIHZlcnRpY2VzXG4gIC8vIEZvciBlYWNoIHZlcnRleCB3ZSBhbHNvIGNvbGxlY3QgdGhlIGxpc3Qgb2Ygbm9ybWFscyBvZiB0aGUgcGxhbmVzIHRvdWNoaW5nIHRoZSB2ZXJ0aWNlc1xuICBsZXQgdmVydGV4bWFwID0ge307XG4gIGNzZy5wb2x5Z29ucy5tYXAoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICBwb2x5Z29uLnZlcnRpY2VzLm1hcChmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICB2ZXJ0ZXhtYXBbdmVydGV4LmdldFRhZygpXSA9IHZlcnRleC5wb3M7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZvciAobGV0IHZlcnRleHRhZyBpbiB2ZXJ0ZXhtYXApIHtcbiAgICBsZXQgcG9zID0gdmVydGV4bWFwW3ZlcnRleHRhZ107XG4gICAgbGV0IF9jdWJlID0gY3ViZSh7XG4gICAgICBjZW50ZXI6IHBvcyxcbiAgICAgIHJhZGl1czogY3ViZXJhZGl1cyxcbiAgICB9KTtcbiAgICByZXN1bHQgPSByZXN1bHQudW5pb25TdWIoX2N1YmUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cbiAgcmVzdWx0ID0gcmVzdWx0LnJlVGVzc2VsYXRlZCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHRvUG9pbnRDbG91ZCB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/debugHelpers.js\n");

/***/ }),

/***/ "./src/api/helpers.js":
/*!****************************!*\
  !*** ./src/api/helpers.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vertex3 = __webpack_require__(/*! ../core/math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Vector3 = __webpack_require__(/*! ../core/math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Polygon3 = __webpack_require__(/*! ../core/math/Polygon3 */ \"./src/core/math/Polygon3.js\");\n\n// FIXME: this is to have more readable/less extremely verbose code below\nconst vertexFromVectorArray = (array) => {\n  return new Vertex3(new Vector3(array));\n};\n\nconst polygonFromPoints = (points) => {\n  // EEK talk about wrapping wrappers !\n  const vertices = points.map((point) => new Vertex3(new Vector3(point)));\n  return new Polygon3(vertices);\n};\n\n// Simplified, array vector rightMultiply1x3Vector\nconst rightMultiply1x3VectorToArray = (matrix, vector) => {\n  const [v0, v1, v2] = vector;\n  const v3 = 1;\n  let x =\n    v0 * matrix.elements[0] +\n    v1 * matrix.elements[1] +\n    v2 * matrix.elements[2] +\n    v3 * matrix.elements[3];\n  let y =\n    v0 * matrix.elements[4] +\n    v1 * matrix.elements[5] +\n    v2 * matrix.elements[6] +\n    v3 * matrix.elements[7];\n  let z =\n    v0 * matrix.elements[8] +\n    v1 * matrix.elements[9] +\n    v2 * matrix.elements[10] +\n    v3 * matrix.elements[11];\n  let w =\n    v0 * matrix.elements[12] +\n    v1 * matrix.elements[13] +\n    v2 * matrix.elements[14] +\n    v3 * matrix.elements[15];\n\n  // scale such that fourth element becomes 1:\n  if (w !== 1) {\n    const invw = 1.0 / w;\n    x *= invw;\n    y *= invw;\n    z *= invw;\n  }\n  return [x, y, z];\n};\n\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\nconst cagToPointsArray = (input) => {\n  let points;\n  if ('sides' in input) {\n    // this is a cag\n    points = [];\n    input.sides.forEach((side) => {\n      points.push([side.vertex0.pos.x, side.vertex0.pos.y]);\n      points.push([side.vertex1.pos.x, side.vertex1.pos.y]);\n    });\n    // cag.sides.map(side => [side.vertex0.pos.x, side.vertex0.pos.y])\n    //, side.vertex1.pos.x, side.vertex1.pos.y])\n    // due to the logic of CAG.fromPoints()\n    // move the first point to the last\n    /* if (points.length > 0) {\n      points.push(points.shift())\n    } */\n  } else if ('points' in input) {\n    points = input.points.map((p) => [p.x, p.y]);\n  }\n\n  return points;\n};\n\nconst degToRad = (deg) => (Math.PI / 180) * deg;\n\nmodule.exports = {\n  cagToPointsArray,\n  clamp,\n  rightMultiply1x3VectorToArray,\n  polygonFromPoints,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2hlbHBlcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvYXBpL2hlbHBlcnMuanM/MDQyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZXJ0ZXgzID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1ZlcnRleDMnKTtcbmNvbnN0IFZlY3RvcjMgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvVmVjdG9yMycpO1xuY29uc3QgUG9seWdvbjMgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvUG9seWdvbjMnKTtcblxuLy8gRklYTUU6IHRoaXMgaXMgdG8gaGF2ZSBtb3JlIHJlYWRhYmxlL2xlc3MgZXh0cmVtZWx5IHZlcmJvc2UgY29kZSBiZWxvd1xuY29uc3QgdmVydGV4RnJvbVZlY3RvckFycmF5ID0gKGFycmF5KSA9PiB7XG4gIHJldHVybiBuZXcgVmVydGV4MyhuZXcgVmVjdG9yMyhhcnJheSkpO1xufTtcblxuY29uc3QgcG9seWdvbkZyb21Qb2ludHMgPSAocG9pbnRzKSA9PiB7XG4gIC8vIEVFSyB0YWxrIGFib3V0IHdyYXBwaW5nIHdyYXBwZXJzICFcbiAgY29uc3QgdmVydGljZXMgPSBwb2ludHMubWFwKChwb2ludCkgPT4gbmV3IFZlcnRleDMobmV3IFZlY3RvcjMocG9pbnQpKSk7XG4gIHJldHVybiBuZXcgUG9seWdvbjModmVydGljZXMpO1xufTtcblxuLy8gU2ltcGxpZmllZCwgYXJyYXkgdmVjdG9yIHJpZ2h0TXVsdGlwbHkxeDNWZWN0b3JcbmNvbnN0IHJpZ2h0TXVsdGlwbHkxeDNWZWN0b3JUb0FycmF5ID0gKG1hdHJpeCwgdmVjdG9yKSA9PiB7XG4gIGNvbnN0IFt2MCwgdjEsIHYyXSA9IHZlY3RvcjtcbiAgY29uc3QgdjMgPSAxO1xuICBsZXQgeCA9XG4gICAgdjAgKiBtYXRyaXguZWxlbWVudHNbMF0gK1xuICAgIHYxICogbWF0cml4LmVsZW1lbnRzWzFdICtcbiAgICB2MiAqIG1hdHJpeC5lbGVtZW50c1syXSArXG4gICAgdjMgKiBtYXRyaXguZWxlbWVudHNbM107XG4gIGxldCB5ID1cbiAgICB2MCAqIG1hdHJpeC5lbGVtZW50c1s0XSArXG4gICAgdjEgKiBtYXRyaXguZWxlbWVudHNbNV0gK1xuICAgIHYyICogbWF0cml4LmVsZW1lbnRzWzZdICtcbiAgICB2MyAqIG1hdHJpeC5lbGVtZW50c1s3XTtcbiAgbGV0IHogPVxuICAgIHYwICogbWF0cml4LmVsZW1lbnRzWzhdICtcbiAgICB2MSAqIG1hdHJpeC5lbGVtZW50c1s5XSArXG4gICAgdjIgKiBtYXRyaXguZWxlbWVudHNbMTBdICtcbiAgICB2MyAqIG1hdHJpeC5lbGVtZW50c1sxMV07XG4gIGxldCB3ID1cbiAgICB2MCAqIG1hdHJpeC5lbGVtZW50c1sxMl0gK1xuICAgIHYxICogbWF0cml4LmVsZW1lbnRzWzEzXSArXG4gICAgdjIgKiBtYXRyaXguZWxlbWVudHNbMTRdICtcbiAgICB2MyAqIG1hdHJpeC5lbGVtZW50c1sxNV07XG5cbiAgLy8gc2NhbGUgc3VjaCB0aGF0IGZvdXJ0aCBlbGVtZW50IGJlY29tZXMgMTpcbiAgaWYgKHcgIT09IDEpIHtcbiAgICBjb25zdCBpbnZ3ID0gMS4wIC8gdztcbiAgICB4ICo9IGludnc7XG4gICAgeSAqPSBpbnZ3O1xuICAgIHogKj0gaW52dztcbiAgfVxuICByZXR1cm4gW3gsIHksIHpdO1xufTtcblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxuY29uc3QgY2FnVG9Qb2ludHNBcnJheSA9IChpbnB1dCkgPT4ge1xuICBsZXQgcG9pbnRzO1xuICBpZiAoJ3NpZGVzJyBpbiBpbnB1dCkge1xuICAgIC8vIHRoaXMgaXMgYSBjYWdcbiAgICBwb2ludHMgPSBbXTtcbiAgICBpbnB1dC5zaWRlcy5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgICBwb2ludHMucHVzaChbc2lkZS52ZXJ0ZXgwLnBvcy54LCBzaWRlLnZlcnRleDAucG9zLnldKTtcbiAgICAgIHBvaW50cy5wdXNoKFtzaWRlLnZlcnRleDEucG9zLngsIHNpZGUudmVydGV4MS5wb3MueV0pO1xuICAgIH0pO1xuICAgIC8vIGNhZy5zaWRlcy5tYXAoc2lkZSA9PiBbc2lkZS52ZXJ0ZXgwLnBvcy54LCBzaWRlLnZlcnRleDAucG9zLnldKVxuICAgIC8vLCBzaWRlLnZlcnRleDEucG9zLngsIHNpZGUudmVydGV4MS5wb3MueV0pXG4gICAgLy8gZHVlIHRvIHRoZSBsb2dpYyBvZiBDQUcuZnJvbVBvaW50cygpXG4gICAgLy8gbW92ZSB0aGUgZmlyc3QgcG9pbnQgdG8gdGhlIGxhc3RcbiAgICAvKiBpZiAocG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50cy5zaGlmdCgpKVxuICAgIH0gKi9cbiAgfSBlbHNlIGlmICgncG9pbnRzJyBpbiBpbnB1dCkge1xuICAgIHBvaW50cyA9IGlucHV0LnBvaW50cy5tYXAoKHApID0+IFtwLngsIHAueV0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbmNvbnN0IGRlZ1RvUmFkID0gKGRlZykgPT4gKE1hdGguUEkgLyAxODApICogZGVnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2FnVG9Qb2ludHNBcnJheSxcbiAgY2xhbXAsXG4gIHJpZ2h0TXVsdGlwbHkxeDNWZWN0b3JUb0FycmF5LFxuICBwb2x5Z29uRnJvbVBvaW50cyxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/helpers.js\n");

/***/ }),

/***/ "./src/api/index.js":
/*!**************************!*\
  !*** ./src/api/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const primitives3d = __webpack_require__(/*! ./primitives3d-api */ \"./src/api/primitives3d-api.js\");\nconst primitives2d = __webpack_require__(/*! ./primitives2d-api */ \"./src/api/primitives2d-api.js\");\nconst booleanOps = __webpack_require__(/*! ./ops-booleans */ \"./src/api/ops-booleans.js\");\nconst transformations = __webpack_require__(/*! ./ops-transformations */ \"./src/api/ops-transformations.js\");\nconst extrusions = __webpack_require__(/*! ./ops-extrusions */ \"./src/api/ops-extrusions.js\");\nconst color = __webpack_require__(/*! ./color */ \"./src/api/color.js\");\nconst maths = __webpack_require__(/*! ./maths */ \"./src/api/maths.js\");\nconst text = __webpack_require__(/*! ./text */ \"./src/api/text.js\");\nconst { echo } = __webpack_require__(/*! ./debug */ \"./src/api/debug.js\");\n\n// these are 'external' to this api and we basically just re-export for old api compatibility\n// ...needs to be reviewed\nconst { CAG, CSG } = __webpack_require__(/*! ../../csg */ \"./csg.js\");\nconst { log } = __webpack_require__(/*! ./log */ \"./src/api/log.js\"); // FIXME: this is a duplicate of the one in openjscad itself,*/\n\n// mostly likely needs to be removed since it is in the OpenJsCad namespace anyway, leaving here\n// for now\n\nconst exportedApi = {\n  csg: { CAG, CSG },\n  primitives2d,\n  primitives3d,\n  booleanOps,\n  transformations,\n  extrusions,\n  color,\n  maths,\n  text,\n  OpenJsCad: { OpenJsCad: { log } },\n  debug: { echo },\n};\n\nmodule.exports = exportedApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2FwaS9pbmRleC5qcz8zNjVjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHByaW1pdGl2ZXMzZCA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlczNkLWFwaScpO1xuY29uc3QgcHJpbWl0aXZlczJkID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzMmQtYXBpJyk7XG5jb25zdCBib29sZWFuT3BzID0gcmVxdWlyZSgnLi9vcHMtYm9vbGVhbnMnKTtcbmNvbnN0IHRyYW5zZm9ybWF0aW9ucyA9IHJlcXVpcmUoJy4vb3BzLXRyYW5zZm9ybWF0aW9ucycpO1xuY29uc3QgZXh0cnVzaW9ucyA9IHJlcXVpcmUoJy4vb3BzLWV4dHJ1c2lvbnMnKTtcbmNvbnN0IGNvbG9yID0gcmVxdWlyZSgnLi9jb2xvcicpO1xuY29uc3QgbWF0aHMgPSByZXF1aXJlKCcuL21hdGhzJyk7XG5jb25zdCB0ZXh0ID0gcmVxdWlyZSgnLi90ZXh0Jyk7XG5jb25zdCB7IGVjaG8gfSA9IHJlcXVpcmUoJy4vZGVidWcnKTtcblxuLy8gdGhlc2UgYXJlICdleHRlcm5hbCcgdG8gdGhpcyBhcGkgYW5kIHdlIGJhc2ljYWxseSBqdXN0IHJlLWV4cG9ydCBmb3Igb2xkIGFwaSBjb21wYXRpYmlsaXR5XG4vLyAuLi5uZWVkcyB0byBiZSByZXZpZXdlZFxuY29uc3QgeyBDQUcsIENTRyB9ID0gcmVxdWlyZSgnLi4vLi4vY3NnJyk7XG5jb25zdCB7IGxvZyB9ID0gcmVxdWlyZSgnLi9sb2cnKTsgLy8gRklYTUU6IHRoaXMgaXMgYSBkdXBsaWNhdGUgb2YgdGhlIG9uZSBpbiBvcGVuanNjYWQgaXRzZWxmLCovXG5cbi8vIG1vc3RseSBsaWtlbHkgbmVlZHMgdG8gYmUgcmVtb3ZlZCBzaW5jZSBpdCBpcyBpbiB0aGUgT3BlbkpzQ2FkIG5hbWVzcGFjZSBhbnl3YXksIGxlYXZpbmcgaGVyZVxuLy8gZm9yIG5vd1xuXG5jb25zdCBleHBvcnRlZEFwaSA9IHtcbiAgY3NnOiB7IENBRywgQ1NHIH0sXG4gIHByaW1pdGl2ZXMyZCxcbiAgcHJpbWl0aXZlczNkLFxuICBib29sZWFuT3BzLFxuICB0cmFuc2Zvcm1hdGlvbnMsXG4gIGV4dHJ1c2lvbnMsXG4gIGNvbG9yLFxuICBtYXRocyxcbiAgdGV4dCxcbiAgT3BlbkpzQ2FkOiB7IE9wZW5Kc0NhZDogeyBsb2cgfSB9LFxuICBkZWJ1ZzogeyBlY2hvIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkQXBpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/index.js\n");

/***/ }),

/***/ "./src/api/log.js":
/*!************************!*\
  !*** ./src/api/log.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function log(txt) {\n  console.warn(\n    'log() will be deprecated in the near future: please use console.log/warn/error instead'\n  );\n  var timeInMs = Date.now();\n  var prevtime; // OpenJsCad.log.prevLogTime\n  if (!prevtime) prevtime = timeInMs;\n  var deltatime = timeInMs - prevtime;\n  log.prevLogTime = timeInMs;\n  var timefmt = (deltatime * 0.001).toFixed(3);\n  txt = '[' + timefmt + '] ' + txt;\n  if (typeof console === 'object' && typeof console.log === 'function') {\n    console.log(txt);\n  } else if (\n    typeof self === 'object' &&\n    typeof self.postMessage === 'function'\n  ) {\n    self.postMessage({ cmd: 'log', txt: txt });\n  } else throw new Error('Cannot log');\n}\n\n// See Processor.setStatus()\n// Note: leave for compatibility\nfunction status(s) {\n  log(s);\n}\n\nmodule.exports = {\n  log,\n  status,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL2xvZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvbG9nLmpzPzg5MTYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbG9nKHR4dCkge1xuICBjb25zb2xlLndhcm4oXG4gICAgJ2xvZygpIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgbmVhciBmdXR1cmU6IHBsZWFzZSB1c2UgY29uc29sZS5sb2cvd2Fybi9lcnJvciBpbnN0ZWFkJ1xuICApO1xuICB2YXIgdGltZUluTXMgPSBEYXRlLm5vdygpO1xuICB2YXIgcHJldnRpbWU7IC8vIE9wZW5Kc0NhZC5sb2cucHJldkxvZ1RpbWVcbiAgaWYgKCFwcmV2dGltZSkgcHJldnRpbWUgPSB0aW1lSW5NcztcbiAgdmFyIGRlbHRhdGltZSA9IHRpbWVJbk1zIC0gcHJldnRpbWU7XG4gIGxvZy5wcmV2TG9nVGltZSA9IHRpbWVJbk1zO1xuICB2YXIgdGltZWZtdCA9IChkZWx0YXRpbWUgKiAwLjAwMSkudG9GaXhlZCgzKTtcbiAgdHh0ID0gJ1snICsgdGltZWZtdCArICddICcgKyB0eHQ7XG4gIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5sb2codHh0KTtcbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygc2VsZi5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgY21kOiAnbG9nJywgdHh0OiB0eHQgfSk7XG4gIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2cnKTtcbn1cblxuLy8gU2VlIFByb2Nlc3Nvci5zZXRTdGF0dXMoKVxuLy8gTm90ZTogbGVhdmUgZm9yIGNvbXBhdGliaWxpdHlcbmZ1bmN0aW9uIHN0YXR1cyhzKSB7XG4gIGxvZyhzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZyxcbiAgc3RhdHVzLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/log.js\n");

/***/ }),

/***/ "./src/api/maths.js":
/*!**************************!*\
  !*** ./src/api/maths.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// -- Math functions (360 deg based vs 2pi)\nfunction sin(a) {\n  return Math.sin((a / 360) * Math.PI * 2);\n}\nfunction cos(a) {\n  return Math.cos((a / 360) * Math.PI * 2);\n}\nfunction asin(a) {\n  return (Math.asin(a) / (Math.PI * 2)) * 360;\n}\nfunction acos(a) {\n  return (Math.acos(a) / (Math.PI * 2)) * 360;\n}\nfunction tan(a) {\n  return Math.tan((a / 360) * Math.PI * 2);\n}\nfunction atan(a) {\n  return (Math.atan(a) / (Math.PI * 2)) * 360;\n}\nfunction atan2(a, b) {\n  return (Math.atan2(a, b) / (Math.PI * 2)) * 360;\n}\nfunction ceil(a) {\n  return Math.ceil(a);\n}\nfunction floor(a) {\n  return Math.floor(a);\n}\nfunction abs(a) {\n  return Math.abs(a);\n}\nfunction min(a, b) {\n  return a < b ? a : b;\n}\nfunction max(a, b) {\n  return a > b ? a : b;\n}\nfunction rands(min, max, vn, seed) {\n  // -- seed is ignored for now, FIX IT (requires reimplementation of random())\n  //    see http://stackoverflow.com/questions/424292/how-to-create-my-own-javascript-random-number-generator-that-i-can-also-set-the\n  var v = new Array(vn);\n  for (var i = 0; i < vn; i++) {\n    v[i] = Math.random() * (max - min) + min;\n  }\n}\nfunction log(a) {\n  return Math.log(a);\n}\nfunction lookup(ix, v) {\n  var r = 0;\n  for (var i = 0; i < v.length; i++) {\n    var a0 = v[i];\n    if (a0[0] >= ix) {\n      i--;\n      a0 = v[i];\n      var a1 = v[i + 1];\n      var m = 0;\n      if (a0[0] !== a1[0]) {\n        m = abs((ix - a0[0]) / (a1[0] - a0[0]));\n      }\n      // echo(\">>\",i,ix,a0[0],a1[0],\";\",m,a0[1],a1[1])\n      if (m > 0) {\n        r = a0[1] * (1 - m) + a1[1] * m;\n      } else {\n        r = a0[1];\n      }\n      return r;\n    }\n  }\n  return r;\n}\n\nfunction pow(a, b) {\n  return Math.pow(a, b);\n}\n\nfunction sign(a) {\n  return a < 0 ? -1 : a > 1 ? 1 : 0;\n}\n\nfunction sqrt(a) {\n  return Math.sqrt(a);\n}\n\nfunction round(a) {\n  return floor(a + 0.5);\n}\n\nmodule.exports = {\n  sin,\n  cos,\n  asin,\n  acos,\n  tan,\n  atan,\n  atan2,\n  ceil,\n  floor,\n  abs,\n  min,\n  max,\n  rands,\n  log,\n  lookup,\n  pow,\n  sign,\n  sqrt,\n  round,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL21hdGhzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2FwaS9tYXRocy5qcz85NmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIC0tIE1hdGggZnVuY3Rpb25zICgzNjAgZGVnIGJhc2VkIHZzIDJwaSlcbmZ1bmN0aW9uIHNpbihhKSB7XG4gIHJldHVybiBNYXRoLnNpbigoYSAvIDM2MCkgKiBNYXRoLlBJICogMik7XG59XG5mdW5jdGlvbiBjb3MoYSkge1xuICByZXR1cm4gTWF0aC5jb3MoKGEgLyAzNjApICogTWF0aC5QSSAqIDIpO1xufVxuZnVuY3Rpb24gYXNpbihhKSB7XG4gIHJldHVybiAoTWF0aC5hc2luKGEpIC8gKE1hdGguUEkgKiAyKSkgKiAzNjA7XG59XG5mdW5jdGlvbiBhY29zKGEpIHtcbiAgcmV0dXJuIChNYXRoLmFjb3MoYSkgLyAoTWF0aC5QSSAqIDIpKSAqIDM2MDtcbn1cbmZ1bmN0aW9uIHRhbihhKSB7XG4gIHJldHVybiBNYXRoLnRhbigoYSAvIDM2MCkgKiBNYXRoLlBJICogMik7XG59XG5mdW5jdGlvbiBhdGFuKGEpIHtcbiAgcmV0dXJuIChNYXRoLmF0YW4oYSkgLyAoTWF0aC5QSSAqIDIpKSAqIDM2MDtcbn1cbmZ1bmN0aW9uIGF0YW4yKGEsIGIpIHtcbiAgcmV0dXJuIChNYXRoLmF0YW4yKGEsIGIpIC8gKE1hdGguUEkgKiAyKSkgKiAzNjA7XG59XG5mdW5jdGlvbiBjZWlsKGEpIHtcbiAgcmV0dXJuIE1hdGguY2VpbChhKTtcbn1cbmZ1bmN0aW9uIGZsb29yKGEpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYSk7XG59XG5mdW5jdGlvbiBhYnMoYSkge1xuICByZXR1cm4gTWF0aC5hYnMoYSk7XG59XG5mdW5jdGlvbiBtaW4oYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIG1heChhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gcmFuZHMobWluLCBtYXgsIHZuLCBzZWVkKSB7XG4gIC8vIC0tIHNlZWQgaXMgaWdub3JlZCBmb3Igbm93LCBGSVggSVQgKHJlcXVpcmVzIHJlaW1wbGVtZW50YXRpb24gb2YgcmFuZG9tKCkpXG4gIC8vICAgIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQyNDI5Mi9ob3ctdG8tY3JlYXRlLW15LW93bi1qYXZhc2NyaXB0LXJhbmRvbS1udW1iZXItZ2VuZXJhdG9yLXRoYXQtaS1jYW4tYWxzby1zZXQtdGhlXG4gIHZhciB2ID0gbmV3IEFycmF5KHZuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bjsgaSsrKSB7XG4gICAgdltpXSA9IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgfVxufVxuZnVuY3Rpb24gbG9nKGEpIHtcbiAgcmV0dXJuIE1hdGgubG9nKGEpO1xufVxuZnVuY3Rpb24gbG9va3VwKGl4LCB2KSB7XG4gIHZhciByID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGEwID0gdltpXTtcbiAgICBpZiAoYTBbMF0gPj0gaXgpIHtcbiAgICAgIGktLTtcbiAgICAgIGEwID0gdltpXTtcbiAgICAgIHZhciBhMSA9IHZbaSArIDFdO1xuICAgICAgdmFyIG0gPSAwO1xuICAgICAgaWYgKGEwWzBdICE9PSBhMVswXSkge1xuICAgICAgICBtID0gYWJzKChpeCAtIGEwWzBdKSAvIChhMVswXSAtIGEwWzBdKSk7XG4gICAgICB9XG4gICAgICAvLyBlY2hvKFwiPj5cIixpLGl4LGEwWzBdLGExWzBdLFwiO1wiLG0sYTBbMV0sYTFbMV0pXG4gICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgciA9IGEwWzFdICogKDEgLSBtKSArIGExWzFdICogbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSBhMFsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gcG93KGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgucG93KGEsIGIpO1xufVxuXG5mdW5jdGlvbiBzaWduKGEpIHtcbiAgcmV0dXJuIGEgPCAwID8gLTEgOiBhID4gMSA/IDEgOiAwO1xufVxuXG5mdW5jdGlvbiBzcXJ0KGEpIHtcbiAgcmV0dXJuIE1hdGguc3FydChhKTtcbn1cblxuZnVuY3Rpb24gcm91bmQoYSkge1xuICByZXR1cm4gZmxvb3IoYSArIDAuNSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaW4sXG4gIGNvcyxcbiAgYXNpbixcbiAgYWNvcyxcbiAgdGFuLFxuICBhdGFuLFxuICBhdGFuMixcbiAgY2VpbCxcbiAgZmxvb3IsXG4gIGFicyxcbiAgbWluLFxuICBtYXgsXG4gIHJhbmRzLFxuICBsb2csXG4gIGxvb2t1cCxcbiAgcG93LFxuICBzaWduLFxuICBzcXJ0LFxuICByb3VuZCxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/maths.js\n");

/***/ }),

/***/ "./src/api/ops-booleans.js":
/*!*********************************!*\
  !*** ./src/api/ops-booleans.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { isCAG } = __webpack_require__(/*! ../core/utils */ \"./src/core/utils.js\");\n// boolean operations\n\n// FIXME should this be lazy ? in which case, how do we deal with 2D/3D combined\n// TODO we should have an option to set behaviour as first parameter\n/** union/ combine the given shapes\n * @param {Object(s)|Array} objects - objects to combine : can be given\n * - one by one: union(a,b,c) or\n * - as an array: union([a,b,c])\n * @returns {CSG} new CSG object, the union of all input shapes\n *\n * @example\n * let unionOfSpherAndCube = union(sphere(), cube())\n */\nfunction union() {\n  let options = {};\n  const defaults = {\n    extrude2d: false,\n  };\n  let o;\n  let i = 0;\n  let a = arguments;\n  if (a[0].length) a = a[0];\n  if ('extrude2d' in a[0]) {\n    // first parameter is options\n    options = Object.assign({}, defaults, a[0]);\n    o = a[i++];\n  }\n\n  o = a[i++];\n\n  // TODO: add option to be able to set this?\n  if (typeof a[i] === 'object' && isCAG(a[i]) && options.extrude2d) {\n    o = a[i].extrude({ offset: [0, 0, 0.1] }); // -- convert a 2D shape to a thin solid, note: do not a[i] = a[i].extrude()\n  }\n  for (; i < a.length; i++) {\n    let obj = a[i];\n\n    if (typeof a[i] === 'object' && isCAG(a[i]) && options.extrude2d) {\n      obj = a[i].extrude({ offset: [0, 0, 0.1] }); // -- convert a 2D shape to a thin solid:\n    }\n    o = o.union(obj);\n  }\n  return o;\n}\n\n/** difference/ subtraction of the given shapes ie:\n * cut out C From B From A ie : a - b - c etc\n * @param {Object(s)|Array} objects - objects to subtract\n * can be given\n * - one by one: difference(a,b,c) or\n * - as an array: difference([a,b,c])\n * @returns {CSG} new CSG object, the difference of all input shapes\n *\n * @example\n * let differenceOfSpherAndCube = difference(sphere(), cube())\n */\nfunction difference() {\n  let object;\n  let i = 0;\n  let a = arguments;\n  if (a[0].length) a = a[0];\n  for (object = a[i++]; i < a.length; i++) {\n    if (isCAG(a[i])) {\n      object = object.subtract(a[i]);\n    } else {\n      object = object.subtract(a[i].setColor(1, 1, 0)); // -- color the cuts\n    }\n  }\n  return object;\n}\n\n/** intersection of the given shapes: ie keep only the common parts between the given shapes\n * @param {Object(s)|Array} objects - objects to intersect\n * can be given\n * - one by one: intersection(a,b,c) or\n * - as an array: intersection([a,b,c])\n * @returns {CSG} new CSG object, the intersection of all input shapes\n *\n * @example\n * let intersectionOfSpherAndCube = intersection(sphere(), cube())\n */\nfunction intersection() {\n  let object;\n  let i = 0;\n  let a = arguments;\n  if (a[0].length) a = a[0];\n  for (object = a[i++]; i < a.length; i++) {\n    if (isCAG(a[i])) {\n      object = object.intersect(a[i]);\n    } else {\n      object = object.intersect(a[i].setColor(1, 1, 0)); // -- color the cuts\n    }\n  }\n  return object;\n}\n\nmodule.exports = {\n  union,\n  difference,\n  intersection,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL29wcy1ib29sZWFucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvb3BzLWJvb2xlYW5zLmpzPzhjMmIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBpc0NBRyB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlscycpO1xuLy8gYm9vbGVhbiBvcGVyYXRpb25zXG5cbi8vIEZJWE1FIHNob3VsZCB0aGlzIGJlIGxhenkgPyBpbiB3aGljaCBjYXNlLCBob3cgZG8gd2UgZGVhbCB3aXRoIDJELzNEIGNvbWJpbmVkXG4vLyBUT0RPIHdlIHNob3VsZCBoYXZlIGFuIG9wdGlvbiB0byBzZXQgYmVoYXZpb3VyIGFzIGZpcnN0IHBhcmFtZXRlclxuLyoqIHVuaW9uLyBjb21iaW5lIHRoZSBnaXZlbiBzaGFwZXNcbiAqIEBwYXJhbSB7T2JqZWN0KHMpfEFycmF5fSBvYmplY3RzIC0gb2JqZWN0cyB0byBjb21iaW5lIDogY2FuIGJlIGdpdmVuXG4gKiAtIG9uZSBieSBvbmU6IHVuaW9uKGEsYixjKSBvclxuICogLSBhcyBhbiBhcnJheTogdW5pb24oW2EsYixjXSlcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0LCB0aGUgdW5pb24gb2YgYWxsIGlucHV0IHNoYXBlc1xuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgdW5pb25PZlNwaGVyQW5kQ3ViZSA9IHVuaW9uKHNwaGVyZSgpLCBjdWJlKCkpXG4gKi9cbmZ1bmN0aW9uIHVuaW9uKCkge1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICBleHRydWRlMmQ6IGZhbHNlLFxuICB9O1xuICBsZXQgbztcbiAgbGV0IGkgPSAwO1xuICBsZXQgYSA9IGFyZ3VtZW50cztcbiAgaWYgKGFbMF0ubGVuZ3RoKSBhID0gYVswXTtcbiAgaWYgKCdleHRydWRlMmQnIGluIGFbMF0pIHtcbiAgICAvLyBmaXJzdCBwYXJhbWV0ZXIgaXMgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgYVswXSk7XG4gICAgbyA9IGFbaSsrXTtcbiAgfVxuXG4gIG8gPSBhW2krK107XG5cbiAgLy8gVE9ETzogYWRkIG9wdGlvbiB0byBiZSBhYmxlIHRvIHNldCB0aGlzP1xuICBpZiAodHlwZW9mIGFbaV0gPT09ICdvYmplY3QnICYmIGlzQ0FHKGFbaV0pICYmIG9wdGlvbnMuZXh0cnVkZTJkKSB7XG4gICAgbyA9IGFbaV0uZXh0cnVkZSh7IG9mZnNldDogWzAsIDAsIDAuMV0gfSk7IC8vIC0tIGNvbnZlcnQgYSAyRCBzaGFwZSB0byBhIHRoaW4gc29saWQsIG5vdGU6IGRvIG5vdCBhW2ldID0gYVtpXS5leHRydWRlKClcbiAgfVxuICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgb2JqID0gYVtpXTtcblxuICAgIGlmICh0eXBlb2YgYVtpXSA9PT0gJ29iamVjdCcgJiYgaXNDQUcoYVtpXSkgJiYgb3B0aW9ucy5leHRydWRlMmQpIHtcbiAgICAgIG9iaiA9IGFbaV0uZXh0cnVkZSh7IG9mZnNldDogWzAsIDAsIDAuMV0gfSk7IC8vIC0tIGNvbnZlcnQgYSAyRCBzaGFwZSB0byBhIHRoaW4gc29saWQ6XG4gICAgfVxuICAgIG8gPSBvLnVuaW9uKG9iaik7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKiBkaWZmZXJlbmNlLyBzdWJ0cmFjdGlvbiBvZiB0aGUgZ2l2ZW4gc2hhcGVzIGllOlxuICogY3V0IG91dCBDIEZyb20gQiBGcm9tIEEgaWUgOiBhIC0gYiAtIGMgZXRjXG4gKiBAcGFyYW0ge09iamVjdChzKXxBcnJheX0gb2JqZWN0cyAtIG9iamVjdHMgdG8gc3VidHJhY3RcbiAqIGNhbiBiZSBnaXZlblxuICogLSBvbmUgYnkgb25lOiBkaWZmZXJlbmNlKGEsYixjKSBvclxuICogLSBhcyBhbiBhcnJheTogZGlmZmVyZW5jZShbYSxiLGNdKVxuICogQHJldHVybnMge0NTR30gbmV3IENTRyBvYmplY3QsIHRoZSBkaWZmZXJlbmNlIG9mIGFsbCBpbnB1dCBzaGFwZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGRpZmZlcmVuY2VPZlNwaGVyQW5kQ3ViZSA9IGRpZmZlcmVuY2Uoc3BoZXJlKCksIGN1YmUoKSlcbiAqL1xuZnVuY3Rpb24gZGlmZmVyZW5jZSgpIHtcbiAgbGV0IG9iamVjdDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgYSA9IGFyZ3VtZW50cztcbiAgaWYgKGFbMF0ubGVuZ3RoKSBhID0gYVswXTtcbiAgZm9yIChvYmplY3QgPSBhW2krK107IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQ0FHKGFbaV0pKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3Quc3VidHJhY3QoYVtpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdC5zdWJ0cmFjdChhW2ldLnNldENvbG9yKDEsIDEsIDApKTsgLy8gLS0gY29sb3IgdGhlIGN1dHNcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqIGludGVyc2VjdGlvbiBvZiB0aGUgZ2l2ZW4gc2hhcGVzOiBpZSBrZWVwIG9ubHkgdGhlIGNvbW1vbiBwYXJ0cyBiZXR3ZWVuIHRoZSBnaXZlbiBzaGFwZXNcbiAqIEBwYXJhbSB7T2JqZWN0KHMpfEFycmF5fSBvYmplY3RzIC0gb2JqZWN0cyB0byBpbnRlcnNlY3RcbiAqIGNhbiBiZSBnaXZlblxuICogLSBvbmUgYnkgb25lOiBpbnRlcnNlY3Rpb24oYSxiLGMpIG9yXG4gKiAtIGFzIGFuIGFycmF5OiBpbnRlcnNlY3Rpb24oW2EsYixjXSlcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0LCB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBpbnB1dCBzaGFwZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGludGVyc2VjdGlvbk9mU3BoZXJBbmRDdWJlID0gaW50ZXJzZWN0aW9uKHNwaGVyZSgpLCBjdWJlKCkpXG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgbGV0IG9iamVjdDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgYSA9IGFyZ3VtZW50cztcbiAgaWYgKGFbMF0ubGVuZ3RoKSBhID0gYVswXTtcbiAgZm9yIChvYmplY3QgPSBhW2krK107IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQ0FHKGFbaV0pKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3QuaW50ZXJzZWN0KGFbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QgPSBvYmplY3QuaW50ZXJzZWN0KGFbaV0uc2V0Q29sb3IoMSwgMSwgMCkpOyAvLyAtLSBjb2xvciB0aGUgY3V0c1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdW5pb24sXG4gIGRpZmZlcmVuY2UsXG4gIGludGVyc2VjdGlvbixcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/api/ops-booleans.js\n");

/***/ }),

/***/ "./src/api/ops-cnc.js":
/*!****************************!*\
  !*** ./src/api/ops-cnc.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Matrix4x4 = __webpack_require__(/*! ../core/math/Matrix4.js */ \"./src/core/math/Matrix4.js\");\nconst Vector3D = __webpack_require__(/*! ../core/math/Vector3.js */ \"./src/core/math/Vector3.js\");\nconst { Connector } = __webpack_require__(/*! ../core/connectors.js */ \"./src/core/connectors.js\");\nconst { fromPoints } = __webpack_require__(/*! ../core/CAGFactories */ \"./src/core/CAGFactories.js\");\nconst Vector2D = __webpack_require__(/*! ../core/math/Vector2 */ \"./src/core/math/Vector2.js\");\n\n// Get the transformation that transforms this CSG such that it is lying on the z=0 plane,\n// as flat as possible (i.e. the least z-height).\n// So that it is in an orientation suitable for CNC milling\nconst getTransformationAndInverseTransformationToFlatLying = function (_csg) {\n  if (_csg.polygons.length === 0) {\n    let m = new Matrix4x4(); // unity\n    return [m, m];\n  } else {\n    // get a list of unique planes in the CSG:\n    let csg = _csg.canonicalized();\n    let planemap = {};\n    csg.polygons.map(function (polygon) {\n      planemap[polygon.plane.getTag()] = polygon.plane;\n    });\n    // try each plane in the CSG and find the plane that, when we align it flat onto z=0,\n    // gives the least height in z-direction.\n    // If two planes give the same height, pick the plane that originally had a normal closest\n    // to [0,0,-1].\n    let xvector = new Vector3D(1, 0, 0);\n    let yvector = new Vector3D(0, 1, 0);\n    let zvector = new Vector3D(0, 0, 1);\n    let z0connectorx = new Connector([0, 0, 0], [0, 0, -1], xvector);\n    let z0connectory = new Connector([0, 0, 0], [0, 0, -1], yvector);\n    let isfirst = true;\n    let minheight = 0;\n    let maxdotz = 0;\n    let besttransformation, bestinversetransformation;\n    for (let planetag in planemap) {\n      let plane = planemap[planetag];\n      let pointonplane = plane.normal.times(plane.w);\n      let transformation, inversetransformation;\n      // We need a normal vecrtor for the transformation\n      // determine which is more perpendicular to the plane normal: x or y?\n      // we will align this as much as possible to the x or y axis vector\n      let xorthogonality = plane.normal.cross(xvector).length();\n      let yorthogonality = plane.normal.cross(yvector).length();\n      if (xorthogonality > yorthogonality) {\n        // x is better:\n        let planeconnector = new Connector(pointonplane, plane.normal, xvector);\n        transformation = planeconnector.getTransformationTo(\n          z0connectorx,\n          false,\n          0\n        );\n        inversetransformation = z0connectorx.getTransformationTo(\n          planeconnector,\n          false,\n          0\n        );\n      } else {\n        // y is better:\n        let planeconnector = new Connector(pointonplane, plane.normal, yvector);\n        transformation = planeconnector.getTransformationTo(\n          z0connectory,\n          false,\n          0\n        );\n        inversetransformation = z0connectory.getTransformationTo(\n          planeconnector,\n          false,\n          0\n        );\n      }\n      let transformedcsg = csg.transform(transformation);\n      let dotz = -plane.normal.dot(zvector);\n      let bounds = transformedcsg.getBounds();\n      let zheight = bounds[1].z - bounds[0].z;\n      let isbetter = isfirst;\n      if (!isbetter) {\n        if (zheight < minheight) {\n          isbetter = true;\n        } else if (zheight === minheight) {\n          if (dotz > maxdotz) isbetter = true;\n        }\n      }\n      if (isbetter) {\n        // translate the transformation around the z-axis and onto the z plane:\n        let translation = new Vector3D([\n          -0.5 * (bounds[1].x + bounds[0].x),\n          -0.5 * (bounds[1].y + bounds[0].y),\n          -bounds[0].z,\n        ]);\n        transformation = transformation.multiply(\n          Matrix4x4.translation(translation)\n        );\n        inversetransformation = Matrix4x4.translation(\n          translation.negated()\n        ).multiply(inversetransformation);\n        minheight = zheight;\n        maxdotz = dotz;\n        besttransformation = transformation;\n        bestinversetransformation = inversetransformation;\n      }\n      isfirst = false;\n    }\n    return [besttransformation, bestinversetransformation];\n  }\n};\n\nconst getTransformationToFlatLying = function (csg) {\n  let result = csg.getTransformationAndInverseTransformationToFlatLying();\n  return result[0];\n};\n\nconst lieFlat = function (csg) {\n  let transformation = csg.getTransformationToFlatLying();\n  return csg.transform(transformation);\n};\n\n/** cag = cag.overCutInsideCorners(cutterradius);\n * Using a CNC router it's impossible to cut out a true sharp inside corner. The inside corner\n * will be rounded due to the radius of the cutter. This function compensates for this by creating\n * an extra cutout at each inner corner so that the actual cut out shape will be at least as large\n * as needed.\n * @param {Object} _cag - input cag\n * @param {Float} cutterradius - radius to cut inside corners by\n * @returns {CAG} cag with overcutInsideCorners\n */\nconst overCutInsideCorners = function (_cag, cutterradius) {\n  let cag = _cag.canonicalized();\n  // for each vertex determine the 'incoming' side and 'outgoing' side:\n  let pointmap = {}; // tag => {pos: coord, from: [], to: []}\n  cag.sides.map(function (side) {\n    if (!(side.vertex0.getTag() in pointmap)) {\n      pointmap[side.vertex0.getTag()] = {\n        pos: side.vertex0.pos,\n        from: [],\n        to: [],\n      };\n    }\n    pointmap[side.vertex0.getTag()].to.push(side.vertex1.pos);\n    if (!(side.vertex1.getTag() in pointmap)) {\n      pointmap[side.vertex1.getTag()] = {\n        pos: side.vertex1.pos,\n        from: [],\n        to: [],\n      };\n    }\n    pointmap[side.vertex1.getTag()].from.push(side.vertex0.pos);\n  });\n  // overcut all sharp corners:\n  let cutouts = [];\n  for (let pointtag in pointmap) {\n    let pointobj = pointmap[pointtag];\n    if (pointobj.from.length === 1 && pointobj.to.length === 1) {\n      // ok, 1 incoming side and 1 outgoing side:\n      let fromcoord = pointobj.from[0];\n      let pointcoord = pointobj.pos;\n      let tocoord = pointobj.to[0];\n      let v1 = pointcoord.minus(fromcoord).unit();\n      let v2 = tocoord.minus(pointcoord).unit();\n      let crossproduct = v1.cross(v2);\n      let isInnerCorner = crossproduct < 0.001;\n      if (isInnerCorner) {\n        // yes it's a sharp corner:\n        let alpha = v2.angleRadians() - v1.angleRadians() + Math.PI;\n        if (alpha < 0) {\n          alpha += 2 * Math.PI;\n        } else if (alpha >= 2 * Math.PI) {\n          alpha -= 2 * Math.PI;\n        }\n        let midvector = v2.minus(v1).unit();\n        let circlesegmentangle = (30 / 180) * Math.PI; // resolution of the circle: segments of 30 degrees\n        // we need to increase the radius slightly so that our imperfect circle will contain a perfect circle of cutterradius\n        let radiuscorrected = cutterradius / Math.cos(circlesegmentangle / 2);\n        let circlecenter = pointcoord.plus(midvector.times(radiuscorrected));\n        // we don't need to create a full circle; a pie is enough. Find the angles for the pie:\n        let startangle = alpha + midvector.angleRadians();\n        let deltaangle = 2 * (Math.PI - alpha);\n        let numsteps = 2 * Math.ceil(deltaangle / circlesegmentangle / 2); // should be even\n        // build the pie:\n        let points = [circlecenter];\n        for (let i = 0; i <= numsteps; i++) {\n          let angle = startangle + (i / numsteps) * deltaangle;\n          let p = Vector2D.fromAngleRadians(angle)\n            .times(radiuscorrected)\n            .plus(circlecenter);\n          points.push(p);\n        }\n        cutouts.push(fromPoints(points));\n      }\n    }\n  }\n  return cag.subtract(cutouts);\n};\n\nmodule.exports = {\n  lieFlat,\n  getTransformationToFlatLying,\n  getTransformationAndInverseTransformationToFlatLying,\n  overCutInsideCorners,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL29wcy1jbmMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvYXBpL29wcy1jbmMuanM/NjlmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNYXRyaXg0eDQgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvTWF0cml4NC5qcycpO1xuY29uc3QgVmVjdG9yM0QgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvVmVjdG9yMy5qcycpO1xuY29uc3QgeyBDb25uZWN0b3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdG9ycy5qcycpO1xuY29uc3QgeyBmcm9tUG9pbnRzIH0gPSByZXF1aXJlKCcuLi9jb3JlL0NBR0ZhY3RvcmllcycpO1xuY29uc3QgVmVjdG9yMkQgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvVmVjdG9yMicpO1xuXG4vLyBHZXQgdGhlIHRyYW5zZm9ybWF0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGlzIENTRyBzdWNoIHRoYXQgaXQgaXMgbHlpbmcgb24gdGhlIHo9MCBwbGFuZSxcbi8vIGFzIGZsYXQgYXMgcG9zc2libGUgKGkuZS4gdGhlIGxlYXN0IHotaGVpZ2h0KS5cbi8vIFNvIHRoYXQgaXQgaXMgaW4gYW4gb3JpZW50YXRpb24gc3VpdGFibGUgZm9yIENOQyBtaWxsaW5nXG5jb25zdCBnZXRUcmFuc2Zvcm1hdGlvbkFuZEludmVyc2VUcmFuc2Zvcm1hdGlvblRvRmxhdEx5aW5nID0gZnVuY3Rpb24gKF9jc2cpIHtcbiAgaWYgKF9jc2cucG9seWdvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgbGV0IG0gPSBuZXcgTWF0cml4NHg0KCk7IC8vIHVuaXR5XG4gICAgcmV0dXJuIFttLCBtXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnZXQgYSBsaXN0IG9mIHVuaXF1ZSBwbGFuZXMgaW4gdGhlIENTRzpcbiAgICBsZXQgY3NnID0gX2NzZy5jYW5vbmljYWxpemVkKCk7XG4gICAgbGV0IHBsYW5lbWFwID0ge307XG4gICAgY3NnLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgcGxhbmVtYXBbcG9seWdvbi5wbGFuZS5nZXRUYWcoKV0gPSBwb2x5Z29uLnBsYW5lO1xuICAgIH0pO1xuICAgIC8vIHRyeSBlYWNoIHBsYW5lIGluIHRoZSBDU0cgYW5kIGZpbmQgdGhlIHBsYW5lIHRoYXQsIHdoZW4gd2UgYWxpZ24gaXQgZmxhdCBvbnRvIHo9MCxcbiAgICAvLyBnaXZlcyB0aGUgbGVhc3QgaGVpZ2h0IGluIHotZGlyZWN0aW9uLlxuICAgIC8vIElmIHR3byBwbGFuZXMgZ2l2ZSB0aGUgc2FtZSBoZWlnaHQsIHBpY2sgdGhlIHBsYW5lIHRoYXQgb3JpZ2luYWxseSBoYWQgYSBub3JtYWwgY2xvc2VzdFxuICAgIC8vIHRvIFswLDAsLTFdLlxuICAgIGxldCB4dmVjdG9yID0gbmV3IFZlY3RvcjNEKDEsIDAsIDApO1xuICAgIGxldCB5dmVjdG9yID0gbmV3IFZlY3RvcjNEKDAsIDEsIDApO1xuICAgIGxldCB6dmVjdG9yID0gbmV3IFZlY3RvcjNEKDAsIDAsIDEpO1xuICAgIGxldCB6MGNvbm5lY3RvcnggPSBuZXcgQ29ubmVjdG9yKFswLCAwLCAwXSwgWzAsIDAsIC0xXSwgeHZlY3Rvcik7XG4gICAgbGV0IHowY29ubmVjdG9yeSA9IG5ldyBDb25uZWN0b3IoWzAsIDAsIDBdLCBbMCwgMCwgLTFdLCB5dmVjdG9yKTtcbiAgICBsZXQgaXNmaXJzdCA9IHRydWU7XG4gICAgbGV0IG1pbmhlaWdodCA9IDA7XG4gICAgbGV0IG1heGRvdHogPSAwO1xuICAgIGxldCBiZXN0dHJhbnNmb3JtYXRpb24sIGJlc3RpbnZlcnNldHJhbnNmb3JtYXRpb247XG4gICAgZm9yIChsZXQgcGxhbmV0YWcgaW4gcGxhbmVtYXApIHtcbiAgICAgIGxldCBwbGFuZSA9IHBsYW5lbWFwW3BsYW5ldGFnXTtcbiAgICAgIGxldCBwb2ludG9ucGxhbmUgPSBwbGFuZS5ub3JtYWwudGltZXMocGxhbmUudyk7XG4gICAgICBsZXQgdHJhbnNmb3JtYXRpb24sIGludmVyc2V0cmFuc2Zvcm1hdGlvbjtcbiAgICAgIC8vIFdlIG5lZWQgYSBub3JtYWwgdmVjcnRvciBmb3IgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggaXMgbW9yZSBwZXJwZW5kaWN1bGFyIHRvIHRoZSBwbGFuZSBub3JtYWw6IHggb3IgeT9cbiAgICAgIC8vIHdlIHdpbGwgYWxpZ24gdGhpcyBhcyBtdWNoIGFzIHBvc3NpYmxlIHRvIHRoZSB4IG9yIHkgYXhpcyB2ZWN0b3JcbiAgICAgIGxldCB4b3J0aG9nb25hbGl0eSA9IHBsYW5lLm5vcm1hbC5jcm9zcyh4dmVjdG9yKS5sZW5ndGgoKTtcbiAgICAgIGxldCB5b3J0aG9nb25hbGl0eSA9IHBsYW5lLm5vcm1hbC5jcm9zcyh5dmVjdG9yKS5sZW5ndGgoKTtcbiAgICAgIGlmICh4b3J0aG9nb25hbGl0eSA+IHlvcnRob2dvbmFsaXR5KSB7XG4gICAgICAgIC8vIHggaXMgYmV0dGVyOlxuICAgICAgICBsZXQgcGxhbmVjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKHBvaW50b25wbGFuZSwgcGxhbmUubm9ybWFsLCB4dmVjdG9yKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb24gPSBwbGFuZWNvbm5lY3Rvci5nZXRUcmFuc2Zvcm1hdGlvblRvKFxuICAgICAgICAgIHowY29ubmVjdG9yeCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGludmVyc2V0cmFuc2Zvcm1hdGlvbiA9IHowY29ubmVjdG9yeC5nZXRUcmFuc2Zvcm1hdGlvblRvKFxuICAgICAgICAgIHBsYW5lY29ubmVjdG9yLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHkgaXMgYmV0dGVyOlxuICAgICAgICBsZXQgcGxhbmVjb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKHBvaW50b25wbGFuZSwgcGxhbmUubm9ybWFsLCB5dmVjdG9yKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb24gPSBwbGFuZWNvbm5lY3Rvci5nZXRUcmFuc2Zvcm1hdGlvblRvKFxuICAgICAgICAgIHowY29ubmVjdG9yeSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGludmVyc2V0cmFuc2Zvcm1hdGlvbiA9IHowY29ubmVjdG9yeS5nZXRUcmFuc2Zvcm1hdGlvblRvKFxuICAgICAgICAgIHBsYW5lY29ubmVjdG9yLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGxldCB0cmFuc2Zvcm1lZGNzZyA9IGNzZy50cmFuc2Zvcm0odHJhbnNmb3JtYXRpb24pO1xuICAgICAgbGV0IGRvdHogPSAtcGxhbmUubm9ybWFsLmRvdCh6dmVjdG9yKTtcbiAgICAgIGxldCBib3VuZHMgPSB0cmFuc2Zvcm1lZGNzZy5nZXRCb3VuZHMoKTtcbiAgICAgIGxldCB6aGVpZ2h0ID0gYm91bmRzWzFdLnogLSBib3VuZHNbMF0uejtcbiAgICAgIGxldCBpc2JldHRlciA9IGlzZmlyc3Q7XG4gICAgICBpZiAoIWlzYmV0dGVyKSB7XG4gICAgICAgIGlmICh6aGVpZ2h0IDwgbWluaGVpZ2h0KSB7XG4gICAgICAgICAgaXNiZXR0ZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHpoZWlnaHQgPT09IG1pbmhlaWdodCkge1xuICAgICAgICAgIGlmIChkb3R6ID4gbWF4ZG90eikgaXNiZXR0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNiZXR0ZXIpIHtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSB0cmFuc2Zvcm1hdGlvbiBhcm91bmQgdGhlIHotYXhpcyBhbmQgb250byB0aGUgeiBwbGFuZTpcbiAgICAgICAgbGV0IHRyYW5zbGF0aW9uID0gbmV3IFZlY3RvcjNEKFtcbiAgICAgICAgICAtMC41ICogKGJvdW5kc1sxXS54ICsgYm91bmRzWzBdLngpLFxuICAgICAgICAgIC0wLjUgKiAoYm91bmRzWzFdLnkgKyBib3VuZHNbMF0ueSksXG4gICAgICAgICAgLWJvdW5kc1swXS56LFxuICAgICAgICBdKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbi5tdWx0aXBseShcbiAgICAgICAgICBNYXRyaXg0eDQudHJhbnNsYXRpb24odHJhbnNsYXRpb24pXG4gICAgICAgICk7XG4gICAgICAgIGludmVyc2V0cmFuc2Zvcm1hdGlvbiA9IE1hdHJpeDR4NC50cmFuc2xhdGlvbihcbiAgICAgICAgICB0cmFuc2xhdGlvbi5uZWdhdGVkKClcbiAgICAgICAgKS5tdWx0aXBseShpbnZlcnNldHJhbnNmb3JtYXRpb24pO1xuICAgICAgICBtaW5oZWlnaHQgPSB6aGVpZ2h0O1xuICAgICAgICBtYXhkb3R6ID0gZG90ejtcbiAgICAgICAgYmVzdHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb247XG4gICAgICAgIGJlc3RpbnZlcnNldHJhbnNmb3JtYXRpb24gPSBpbnZlcnNldHJhbnNmb3JtYXRpb247XG4gICAgICB9XG4gICAgICBpc2ZpcnN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBbYmVzdHRyYW5zZm9ybWF0aW9uLCBiZXN0aW52ZXJzZXRyYW5zZm9ybWF0aW9uXTtcbiAgfVxufTtcblxuY29uc3QgZ2V0VHJhbnNmb3JtYXRpb25Ub0ZsYXRMeWluZyA9IGZ1bmN0aW9uIChjc2cpIHtcbiAgbGV0IHJlc3VsdCA9IGNzZy5nZXRUcmFuc2Zvcm1hdGlvbkFuZEludmVyc2VUcmFuc2Zvcm1hdGlvblRvRmxhdEx5aW5nKCk7XG4gIHJldHVybiByZXN1bHRbMF07XG59O1xuXG5jb25zdCBsaWVGbGF0ID0gZnVuY3Rpb24gKGNzZykge1xuICBsZXQgdHJhbnNmb3JtYXRpb24gPSBjc2cuZ2V0VHJhbnNmb3JtYXRpb25Ub0ZsYXRMeWluZygpO1xuICByZXR1cm4gY3NnLnRyYW5zZm9ybSh0cmFuc2Zvcm1hdGlvbik7XG59O1xuXG4vKiogY2FnID0gY2FnLm92ZXJDdXRJbnNpZGVDb3JuZXJzKGN1dHRlcnJhZGl1cyk7XG4gKiBVc2luZyBhIENOQyByb3V0ZXIgaXQncyBpbXBvc3NpYmxlIHRvIGN1dCBvdXQgYSB0cnVlIHNoYXJwIGluc2lkZSBjb3JuZXIuIFRoZSBpbnNpZGUgY29ybmVyXG4gKiB3aWxsIGJlIHJvdW5kZWQgZHVlIHRvIHRoZSByYWRpdXMgb2YgdGhlIGN1dHRlci4gVGhpcyBmdW5jdGlvbiBjb21wZW5zYXRlcyBmb3IgdGhpcyBieSBjcmVhdGluZ1xuICogYW4gZXh0cmEgY3V0b3V0IGF0IGVhY2ggaW5uZXIgY29ybmVyIHNvIHRoYXQgdGhlIGFjdHVhbCBjdXQgb3V0IHNoYXBlIHdpbGwgYmUgYXQgbGVhc3QgYXMgbGFyZ2VcbiAqIGFzIG5lZWRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBfY2FnIC0gaW5wdXQgY2FnXG4gKiBAcGFyYW0ge0Zsb2F0fSBjdXR0ZXJyYWRpdXMgLSByYWRpdXMgdG8gY3V0IGluc2lkZSBjb3JuZXJzIGJ5XG4gKiBAcmV0dXJucyB7Q0FHfSBjYWcgd2l0aCBvdmVyY3V0SW5zaWRlQ29ybmVyc1xuICovXG5jb25zdCBvdmVyQ3V0SW5zaWRlQ29ybmVycyA9IGZ1bmN0aW9uIChfY2FnLCBjdXR0ZXJyYWRpdXMpIHtcbiAgbGV0IGNhZyA9IF9jYWcuY2Fub25pY2FsaXplZCgpO1xuICAvLyBmb3IgZWFjaCB2ZXJ0ZXggZGV0ZXJtaW5lIHRoZSAnaW5jb21pbmcnIHNpZGUgYW5kICdvdXRnb2luZycgc2lkZTpcbiAgbGV0IHBvaW50bWFwID0ge307IC8vIHRhZyA9PiB7cG9zOiBjb29yZCwgZnJvbTogW10sIHRvOiBbXX1cbiAgY2FnLnNpZGVzLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIGlmICghKHNpZGUudmVydGV4MC5nZXRUYWcoKSBpbiBwb2ludG1hcCkpIHtcbiAgICAgIHBvaW50bWFwW3NpZGUudmVydGV4MC5nZXRUYWcoKV0gPSB7XG4gICAgICAgIHBvczogc2lkZS52ZXJ0ZXgwLnBvcyxcbiAgICAgICAgZnJvbTogW10sXG4gICAgICAgIHRvOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICAgIHBvaW50bWFwW3NpZGUudmVydGV4MC5nZXRUYWcoKV0udG8ucHVzaChzaWRlLnZlcnRleDEucG9zKTtcbiAgICBpZiAoIShzaWRlLnZlcnRleDEuZ2V0VGFnKCkgaW4gcG9pbnRtYXApKSB7XG4gICAgICBwb2ludG1hcFtzaWRlLnZlcnRleDEuZ2V0VGFnKCldID0ge1xuICAgICAgICBwb3M6IHNpZGUudmVydGV4MS5wb3MsXG4gICAgICAgIGZyb206IFtdLFxuICAgICAgICB0bzogW10sXG4gICAgICB9O1xuICAgIH1cbiAgICBwb2ludG1hcFtzaWRlLnZlcnRleDEuZ2V0VGFnKCldLmZyb20ucHVzaChzaWRlLnZlcnRleDAucG9zKTtcbiAgfSk7XG4gIC8vIG92ZXJjdXQgYWxsIHNoYXJwIGNvcm5lcnM6XG4gIGxldCBjdXRvdXRzID0gW107XG4gIGZvciAobGV0IHBvaW50dGFnIGluIHBvaW50bWFwKSB7XG4gICAgbGV0IHBvaW50b2JqID0gcG9pbnRtYXBbcG9pbnR0YWddO1xuICAgIGlmIChwb2ludG9iai5mcm9tLmxlbmd0aCA9PT0gMSAmJiBwb2ludG9iai50by5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIG9rLCAxIGluY29taW5nIHNpZGUgYW5kIDEgb3V0Z29pbmcgc2lkZTpcbiAgICAgIGxldCBmcm9tY29vcmQgPSBwb2ludG9iai5mcm9tWzBdO1xuICAgICAgbGV0IHBvaW50Y29vcmQgPSBwb2ludG9iai5wb3M7XG4gICAgICBsZXQgdG9jb29yZCA9IHBvaW50b2JqLnRvWzBdO1xuICAgICAgbGV0IHYxID0gcG9pbnRjb29yZC5taW51cyhmcm9tY29vcmQpLnVuaXQoKTtcbiAgICAgIGxldCB2MiA9IHRvY29vcmQubWludXMocG9pbnRjb29yZCkudW5pdCgpO1xuICAgICAgbGV0IGNyb3NzcHJvZHVjdCA9IHYxLmNyb3NzKHYyKTtcbiAgICAgIGxldCBpc0lubmVyQ29ybmVyID0gY3Jvc3Nwcm9kdWN0IDwgMC4wMDE7XG4gICAgICBpZiAoaXNJbm5lckNvcm5lcikge1xuICAgICAgICAvLyB5ZXMgaXQncyBhIHNoYXJwIGNvcm5lcjpcbiAgICAgICAgbGV0IGFscGhhID0gdjIuYW5nbGVSYWRpYW5zKCkgLSB2MS5hbmdsZVJhZGlhbnMoKSArIE1hdGguUEk7XG4gICAgICAgIGlmIChhbHBoYSA8IDApIHtcbiAgICAgICAgICBhbHBoYSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfSBlbHNlIGlmIChhbHBoYSA+PSAyICogTWF0aC5QSSkge1xuICAgICAgICAgIGFscGhhIC09IDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtaWR2ZWN0b3IgPSB2Mi5taW51cyh2MSkudW5pdCgpO1xuICAgICAgICBsZXQgY2lyY2xlc2VnbWVudGFuZ2xlID0gKDMwIC8gMTgwKSAqIE1hdGguUEk7IC8vIHJlc29sdXRpb24gb2YgdGhlIGNpcmNsZTogc2VnbWVudHMgb2YgMzAgZGVncmVlc1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGluY3JlYXNlIHRoZSByYWRpdXMgc2xpZ2h0bHkgc28gdGhhdCBvdXIgaW1wZXJmZWN0IGNpcmNsZSB3aWxsIGNvbnRhaW4gYSBwZXJmZWN0IGNpcmNsZSBvZiBjdXR0ZXJyYWRpdXNcbiAgICAgICAgbGV0IHJhZGl1c2NvcnJlY3RlZCA9IGN1dHRlcnJhZGl1cyAvIE1hdGguY29zKGNpcmNsZXNlZ21lbnRhbmdsZSAvIDIpO1xuICAgICAgICBsZXQgY2lyY2xlY2VudGVyID0gcG9pbnRjb29yZC5wbHVzKG1pZHZlY3Rvci50aW1lcyhyYWRpdXNjb3JyZWN0ZWQpKTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgYSBmdWxsIGNpcmNsZTsgYSBwaWUgaXMgZW5vdWdoLiBGaW5kIHRoZSBhbmdsZXMgZm9yIHRoZSBwaWU6XG4gICAgICAgIGxldCBzdGFydGFuZ2xlID0gYWxwaGEgKyBtaWR2ZWN0b3IuYW5nbGVSYWRpYW5zKCk7XG4gICAgICAgIGxldCBkZWx0YWFuZ2xlID0gMiAqIChNYXRoLlBJIC0gYWxwaGEpO1xuICAgICAgICBsZXQgbnVtc3RlcHMgPSAyICogTWF0aC5jZWlsKGRlbHRhYW5nbGUgLyBjaXJjbGVzZWdtZW50YW5nbGUgLyAyKTsgLy8gc2hvdWxkIGJlIGV2ZW5cbiAgICAgICAgLy8gYnVpbGQgdGhlIHBpZTpcbiAgICAgICAgbGV0IHBvaW50cyA9IFtjaXJjbGVjZW50ZXJdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1zdGVwczsgaSsrKSB7XG4gICAgICAgICAgbGV0IGFuZ2xlID0gc3RhcnRhbmdsZSArIChpIC8gbnVtc3RlcHMpICogZGVsdGFhbmdsZTtcbiAgICAgICAgICBsZXQgcCA9IFZlY3RvcjJELmZyb21BbmdsZVJhZGlhbnMoYW5nbGUpXG4gICAgICAgICAgICAudGltZXMocmFkaXVzY29ycmVjdGVkKVxuICAgICAgICAgICAgLnBsdXMoY2lyY2xlY2VudGVyKTtcbiAgICAgICAgICBwb2ludHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICBjdXRvdXRzLnB1c2goZnJvbVBvaW50cyhwb2ludHMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhZy5zdWJ0cmFjdChjdXRvdXRzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsaWVGbGF0LFxuICBnZXRUcmFuc2Zvcm1hdGlvblRvRmxhdEx5aW5nLFxuICBnZXRUcmFuc2Zvcm1hdGlvbkFuZEludmVyc2VUcmFuc2Zvcm1hdGlvblRvRmxhdEx5aW5nLFxuICBvdmVyQ3V0SW5zaWRlQ29ybmVycyxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/api/ops-cnc.js\n");

/***/ }),

/***/ "./src/api/ops-cuts.js":
/*!*****************************!*\
  !*** ./src/api/ops-cuts.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS } = __webpack_require__(/*! ../core/constants */ \"./src/core/constants.js\");\nconst Plane = __webpack_require__(/*! ../core/math/Plane */ \"./src/core/math/Plane.js\");\nconst Vector2 = __webpack_require__(/*! ../core/math/Vector2 */ \"./src/core/math/Vector2.js\");\nconst Vertex3 = __webpack_require__(/*! ../core/math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Polygon3 = __webpack_require__(/*! ../core/math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst OrthoNormalBasis = __webpack_require__(/*! ../core/math/OrthoNormalBasis */ \"./src/core/math/OrthoNormalBasis.js\");\n\n/** cuts a csg along a orthobasis\n * @param  {CSG} csg the csg object to cut\n * @param  {Orthobasis} orthobasis the orthobasis to cut along\n */\nconst sectionCut = function (csg, orthobasis) {\n  let plane1 = orthobasis.plane;\n  let plane2 = orthobasis.plane.flipped();\n  plane1 = new Plane(plane1.normal, plane1.w);\n  plane2 = new Plane(plane2.normal, plane2.w + 5 * EPS);\n  let cut3d = csg.cutByPlane(plane1);\n  cut3d = cut3d.cutByPlane(plane2);\n  return cut3d.projectToOrthoNormalBasis(orthobasis);\n};\n\n/** Cut the solid by a plane. Returns the solid on the back side of the plane\n * @param  {Plane} plane\n * @returns {CSG} the solid on the back side of the plane\n */\nconst cutByPlane = function (csg, plane) {\n  if (csg.polygons.length === 0) {\n    const CSG = __webpack_require__(/*! ../core/CSG */ \"./src/core/CSG.js\"); // FIXME: circular dependency ! CSG => cutByPlane => CSG\n    return new CSG();\n  }\n  // Ideally we would like to do an intersection with a polygon of inifinite size\n  // but this is not supported by our implementation. As a workaround, we will create\n  // a cube, with one face on the plane, and a size larger enough so that the entire\n  // solid fits in the cube.\n  // find the max distance of any vertex to the center of the plane:\n  let planecenter = plane.normal.times(plane.w);\n  let maxdistance = 0;\n  csg.polygons.map(function (polygon) {\n    polygon.vertices.map(function (vertex) {\n      let distance = vertex.pos.distanceToSquared(planecenter);\n      if (distance > maxdistance) maxdistance = distance;\n    });\n  });\n  maxdistance = Math.sqrt(maxdistance);\n  maxdistance *= 1.01; // make sure it's really larger\n  // Now build a polygon on the plane, at any point farther than maxdistance from the plane center:\n  let vertices = [];\n  let orthobasis = new OrthoNormalBasis(plane);\n  vertices.push(\n    new Vertex3(orthobasis.to3D(new Vector2(maxdistance, -maxdistance)))\n  );\n  vertices.push(\n    new Vertex3(orthobasis.to3D(new Vector2(-maxdistance, -maxdistance)))\n  );\n  vertices.push(\n    new Vertex3(orthobasis.to3D(new Vector2(-maxdistance, maxdistance)))\n  );\n  vertices.push(\n    new Vertex3(orthobasis.to3D(new Vector2(maxdistance, maxdistance)))\n  );\n  const polygon = new Polygon3(vertices, null, plane.flipped());\n\n  // and extrude the polygon into a cube, backwards of the plane:\n  const cube = polygon.extrude(plane.normal.times(-maxdistance));\n\n  // Now we can do the intersection:\n  let result = csg.intersect(cube);\n  result.properties = csg.properties; // keep original properties\n  return result;\n};\n\nmodule.exports = { sectionCut, cutByPlane };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL29wcy1jdXRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2FwaS9vcHMtY3V0cy5qcz80YWRkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgRVBTIH0gPSByZXF1aXJlKCcuLi9jb3JlL2NvbnN0YW50cycpO1xuY29uc3QgUGxhbmUgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvUGxhbmUnKTtcbmNvbnN0IFZlY3RvcjIgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvVmVjdG9yMicpO1xuY29uc3QgVmVydGV4MyA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9WZXJ0ZXgzJyk7XG5jb25zdCBQb2x5Z29uMyA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9Qb2x5Z29uMycpO1xuY29uc3QgT3J0aG9Ob3JtYWxCYXNpcyA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9PcnRob05vcm1hbEJhc2lzJyk7XG5cbi8qKiBjdXRzIGEgY3NnIGFsb25nIGEgb3J0aG9iYXNpc1xuICogQHBhcmFtICB7Q1NHfSBjc2cgdGhlIGNzZyBvYmplY3QgdG8gY3V0XG4gKiBAcGFyYW0gIHtPcnRob2Jhc2lzfSBvcnRob2Jhc2lzIHRoZSBvcnRob2Jhc2lzIHRvIGN1dCBhbG9uZ1xuICovXG5jb25zdCBzZWN0aW9uQ3V0ID0gZnVuY3Rpb24gKGNzZywgb3J0aG9iYXNpcykge1xuICBsZXQgcGxhbmUxID0gb3J0aG9iYXNpcy5wbGFuZTtcbiAgbGV0IHBsYW5lMiA9IG9ydGhvYmFzaXMucGxhbmUuZmxpcHBlZCgpO1xuICBwbGFuZTEgPSBuZXcgUGxhbmUocGxhbmUxLm5vcm1hbCwgcGxhbmUxLncpO1xuICBwbGFuZTIgPSBuZXcgUGxhbmUocGxhbmUyLm5vcm1hbCwgcGxhbmUyLncgKyA1ICogRVBTKTtcbiAgbGV0IGN1dDNkID0gY3NnLmN1dEJ5UGxhbmUocGxhbmUxKTtcbiAgY3V0M2QgPSBjdXQzZC5jdXRCeVBsYW5lKHBsYW5lMik7XG4gIHJldHVybiBjdXQzZC5wcm9qZWN0VG9PcnRob05vcm1hbEJhc2lzKG9ydGhvYmFzaXMpO1xufTtcblxuLyoqIEN1dCB0aGUgc29saWQgYnkgYSBwbGFuZS4gUmV0dXJucyB0aGUgc29saWQgb24gdGhlIGJhY2sgc2lkZSBvZiB0aGUgcGxhbmVcbiAqIEBwYXJhbSAge1BsYW5lfSBwbGFuZVxuICogQHJldHVybnMge0NTR30gdGhlIHNvbGlkIG9uIHRoZSBiYWNrIHNpZGUgb2YgdGhlIHBsYW5lXG4gKi9cbmNvbnN0IGN1dEJ5UGxhbmUgPSBmdW5jdGlvbiAoY3NnLCBwbGFuZSkge1xuICBpZiAoY3NnLnBvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IENTRyA9IHJlcXVpcmUoJy4uL2NvcmUvQ1NHJyk7IC8vIEZJWE1FOiBjaXJjdWxhciBkZXBlbmRlbmN5ICEgQ1NHID0+IGN1dEJ5UGxhbmUgPT4gQ1NHXG4gICAgcmV0dXJuIG5ldyBDU0coKTtcbiAgfVxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGxpa2UgdG8gZG8gYW4gaW50ZXJzZWN0aW9uIHdpdGggYSBwb2x5Z29uIG9mIGluaWZpbml0ZSBzaXplXG4gIC8vIGJ1dCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIGltcGxlbWVudGF0aW9uLiBBcyBhIHdvcmthcm91bmQsIHdlIHdpbGwgY3JlYXRlXG4gIC8vIGEgY3ViZSwgd2l0aCBvbmUgZmFjZSBvbiB0aGUgcGxhbmUsIGFuZCBhIHNpemUgbGFyZ2VyIGVub3VnaCBzbyB0aGF0IHRoZSBlbnRpcmVcbiAgLy8gc29saWQgZml0cyBpbiB0aGUgY3ViZS5cbiAgLy8gZmluZCB0aGUgbWF4IGRpc3RhbmNlIG9mIGFueSB2ZXJ0ZXggdG8gdGhlIGNlbnRlciBvZiB0aGUgcGxhbmU6XG4gIGxldCBwbGFuZWNlbnRlciA9IHBsYW5lLm5vcm1hbC50aW1lcyhwbGFuZS53KTtcbiAgbGV0IG1heGRpc3RhbmNlID0gMDtcbiAgY3NnLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHBvbHlnb24udmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgIGxldCBkaXN0YW5jZSA9IHZlcnRleC5wb3MuZGlzdGFuY2VUb1NxdWFyZWQocGxhbmVjZW50ZXIpO1xuICAgICAgaWYgKGRpc3RhbmNlID4gbWF4ZGlzdGFuY2UpIG1heGRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSk7XG4gIH0pO1xuICBtYXhkaXN0YW5jZSA9IE1hdGguc3FydChtYXhkaXN0YW5jZSk7XG4gIG1heGRpc3RhbmNlICo9IDEuMDE7IC8vIG1ha2Ugc3VyZSBpdCdzIHJlYWxseSBsYXJnZXJcbiAgLy8gTm93IGJ1aWxkIGEgcG9seWdvbiBvbiB0aGUgcGxhbmUsIGF0IGFueSBwb2ludCBmYXJ0aGVyIHRoYW4gbWF4ZGlzdGFuY2UgZnJvbSB0aGUgcGxhbmUgY2VudGVyOlxuICBsZXQgdmVydGljZXMgPSBbXTtcbiAgbGV0IG9ydGhvYmFzaXMgPSBuZXcgT3J0aG9Ob3JtYWxCYXNpcyhwbGFuZSk7XG4gIHZlcnRpY2VzLnB1c2goXG4gICAgbmV3IFZlcnRleDMob3J0aG9iYXNpcy50bzNEKG5ldyBWZWN0b3IyKG1heGRpc3RhbmNlLCAtbWF4ZGlzdGFuY2UpKSlcbiAgKTtcbiAgdmVydGljZXMucHVzaChcbiAgICBuZXcgVmVydGV4MyhvcnRob2Jhc2lzLnRvM0QobmV3IFZlY3RvcjIoLW1heGRpc3RhbmNlLCAtbWF4ZGlzdGFuY2UpKSlcbiAgKTtcbiAgdmVydGljZXMucHVzaChcbiAgICBuZXcgVmVydGV4MyhvcnRob2Jhc2lzLnRvM0QobmV3IFZlY3RvcjIoLW1heGRpc3RhbmNlLCBtYXhkaXN0YW5jZSkpKVxuICApO1xuICB2ZXJ0aWNlcy5wdXNoKFxuICAgIG5ldyBWZXJ0ZXgzKG9ydGhvYmFzaXMudG8zRChuZXcgVmVjdG9yMihtYXhkaXN0YW5jZSwgbWF4ZGlzdGFuY2UpKSlcbiAgKTtcbiAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uMyh2ZXJ0aWNlcywgbnVsbCwgcGxhbmUuZmxpcHBlZCgpKTtcblxuICAvLyBhbmQgZXh0cnVkZSB0aGUgcG9seWdvbiBpbnRvIGEgY3ViZSwgYmFja3dhcmRzIG9mIHRoZSBwbGFuZTpcbiAgY29uc3QgY3ViZSA9IHBvbHlnb24uZXh0cnVkZShwbGFuZS5ub3JtYWwudGltZXMoLW1heGRpc3RhbmNlKSk7XG5cbiAgLy8gTm93IHdlIGNhbiBkbyB0aGUgaW50ZXJzZWN0aW9uOlxuICBsZXQgcmVzdWx0ID0gY3NnLmludGVyc2VjdChjdWJlKTtcbiAgcmVzdWx0LnByb3BlcnRpZXMgPSBjc2cucHJvcGVydGllczsgLy8ga2VlcCBvcmlnaW5hbCBwcm9wZXJ0aWVzXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgc2VjdGlvbkN1dCwgY3V0QnlQbGFuZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/ops-cuts.js\n");

/***/ }),

/***/ "./src/api/ops-expandContract.js":
/*!***************************************!*\
  !*** ./src/api/ops-expandContract.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS, angleEPS } = __webpack_require__(/*! ../core/constants */ \"./src/core/constants.js\");\nconst Vertex = __webpack_require__(/*! ../core/math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Vector2D = __webpack_require__(/*! ../core/math/Vector2 */ \"./src/core/math/Vector2.js\");\nconst Polygon = __webpack_require__(/*! ../core/math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst { fnNumberSort, isCSG } = __webpack_require__(/*! ../core/utils */ \"./src/core/utils.js\");\nconst { fromPoints, fromPointsNoCheck } = __webpack_require__(/*! ../core/CAGFactories */ \"./src/core/CAGFactories.js\");\n\nconst expand = function (shape, radius, resolution) {\n  let result;\n  if (isCSG(shape)) {\n    result = shape.union(expandedShellOfCCSG(shape, radius, resolution));\n    result = result.reTesselated();\n    result.properties = shape.properties; // keep original properties\n  } else {\n    result = shape.union(expandedShellOfCAG(shape, radius, resolution));\n  }\n  return result;\n};\n\nconst contract = function (shape, radius, resolution) {\n  let result;\n  if (isCSG(shape)) {\n    result = shape.subtract(expandedShellOfCCSG(shape, radius, resolution));\n    result = result.reTesselated();\n    result.properties = shape.properties; // keep original properties\n  } else {\n    result = shape.subtract(expandedShellOfCAG(shape, radius, resolution));\n  }\n  return result;\n};\n\nconst expandedShellOfCAG = function (_cag, radius, resolution) {\n  const CAG = __webpack_require__(/*! ../core/CAG */ \"./src/core/CAG.js\"); // FIXME, circular dependency !!\n  resolution = resolution || 8;\n  if (resolution < 4) resolution = 4;\n  let cags = [];\n  let pointmap = {};\n  let cag = _cag.canonicalized();\n  cag.sides.map(function (side) {\n    let d = side.vertex1.pos.minus(side.vertex0.pos);\n    let dl = d.length();\n    if (dl > EPS) {\n      d = d.times(1.0 / dl);\n      let normal = d.normal().times(radius);\n      let shellpoints = [\n        side.vertex1.pos.plus(normal),\n        side.vertex1.pos.minus(normal),\n        side.vertex0.pos.minus(normal),\n        side.vertex0.pos.plus(normal),\n      ];\n      //      let newcag = fromPointsNoCheck(shellpoints);\n      let newcag = fromPoints(shellpoints);\n      cags.push(newcag);\n      for (let step = 0; step < 2; step++) {\n        let p1 = step === 0 ? side.vertex0.pos : side.vertex1.pos;\n        let p2 = step === 0 ? side.vertex1.pos : side.vertex0.pos;\n        let tag = p1.x + ' ' + p1.y;\n        if (!(tag in pointmap)) {\n          pointmap[tag] = [];\n        }\n        pointmap[tag].push({\n          p1: p1,\n          p2: p2,\n        });\n      }\n    }\n  });\n  for (let tag in pointmap) {\n    let m = pointmap[tag];\n    let angle1, angle2;\n    let pcenter = m[0].p1;\n    if (m.length === 2) {\n      let end1 = m[0].p2;\n      let end2 = m[1].p2;\n      angle1 = end1.minus(pcenter).angleDegrees();\n      angle2 = end2.minus(pcenter).angleDegrees();\n      if (angle2 < angle1) angle2 += 360;\n      if (angle2 >= angle1 + 360) angle2 -= 360;\n      if (angle2 < angle1 + 180) {\n        let t = angle2;\n        angle2 = angle1 + 360;\n        angle1 = t;\n      }\n      angle1 += 90;\n      angle2 -= 90;\n    } else {\n      angle1 = 0;\n      angle2 = 360;\n    }\n    let fullcircle = angle2 > angle1 + 359.999;\n    if (fullcircle) {\n      angle1 = 0;\n      angle2 = 360;\n    }\n    if (angle2 > angle1 + angleEPS) {\n      let points = [];\n      if (!fullcircle) {\n        points.push(pcenter);\n      }\n      let numsteps = Math.round((resolution * (angle2 - angle1)) / 360);\n      if (numsteps < 1) numsteps = 1;\n      for (let step = 0; step <= numsteps; step++) {\n        let angle = angle1 + (step / numsteps) * (angle2 - angle1);\n        if (step === numsteps) angle = angle2; // prevent rounding errors\n        let point = pcenter.plus(\n          Vector2D.fromAngleDegrees(angle).times(radius)\n        );\n        if (!fullcircle || step > 0) {\n          points.push(point);\n        }\n      }\n      let newcag = fromPointsNoCheck(points);\n      cags.push(newcag);\n    }\n  }\n  let result = new CAG();\n  result = result.union(cags);\n  return result;\n};\n\n/**\n * Create the expanded shell of the solid:\n * All faces are extruded to get a thickness of 2*radius\n * Cylinders are constructed around every side\n * Spheres are placed on every vertex\n * unionWithThis: if true, the resulting solid will be united with 'this' solid;\n * the result is a true expansion of the solid\n * If false, returns only the shell\n * @param  {Float} radius\n * @param  {Integer} resolution\n * @param  {Boolean} unionWithThis\n */\nconst expandedShellOfCCSG = function (_csg, radius, resolution, unionWithThis) {\n  const CSG = __webpack_require__(/*! ../core/CSG */ \"./src/core/CSG.js\"); // FIXME: circular dependency ! CSG => this => CSG\n  const { fromPolygons } = __webpack_require__(/*! ../core/CSGFactories */ \"./src/core/CSGFactories.js\"); // FIXME: circular dependency !\n  // const {sphere} = require('./primitives3d') // FIXME: circular dependency !\n  let csg = _csg.reTesselated();\n  let result;\n  if (unionWithThis) {\n    result = csg;\n  } else {\n    result = new CSG();\n  }\n\n  // first extrude all polygons:\n  csg.polygons.map(function (polygon) {\n    let extrudevector = polygon.plane.normal.unit().times(2 * radius);\n    let translatedpolygon = polygon.translate(extrudevector.times(-0.5));\n    let extrudedface = translatedpolygon.extrude(extrudevector);\n    result = result.unionSub(extrudedface, false, false);\n  });\n\n  // Make a list of all unique vertex pairs (i.e. all sides of the solid)\n  // For each vertex pair we collect the following:\n  //   v1: first coordinate\n  //   v2: second coordinate\n  //   planenormals: array of normal vectors of all planes touching this side\n  let vertexpairs = {}; // map of 'vertex pair tag' to {v1, v2, planenormals}\n  csg.polygons.map(function (polygon) {\n    let numvertices = polygon.vertices.length;\n    let prevvertex = polygon.vertices[numvertices - 1];\n    let prevvertextag = prevvertex.getTag();\n    for (let i = 0; i < numvertices; i++) {\n      let vertex = polygon.vertices[i];\n      let vertextag = vertex.getTag();\n      let vertextagpair;\n      if (vertextag < prevvertextag) {\n        vertextagpair = vertextag + '-' + prevvertextag;\n      } else {\n        vertextagpair = prevvertextag + '-' + vertextag;\n      }\n      let obj;\n      if (vertextagpair in vertexpairs) {\n        obj = vertexpairs[vertextagpair];\n      } else {\n        obj = {\n          v1: prevvertex,\n          v2: vertex,\n          planenormals: [],\n        };\n        vertexpairs[vertextagpair] = obj;\n      }\n      obj.planenormals.push(polygon.plane.normal);\n\n      prevvertextag = vertextag;\n      prevvertex = vertex;\n    }\n  });\n\n  // now construct a cylinder on every side\n  // The cylinder is always an approximation of a true cylinder: it will have <resolution> polygons\n  // around the sides. We will make sure though that the cylinder will have an edge at every\n  // face that touches this side. This ensures that we will get a smooth fill even\n  // if two edges are at, say, 10 degrees and the resolution is low.\n  // Note: the result is not retesselated yet but it really should be!\n  for (let vertextagpair in vertexpairs) {\n    let vertexpair = vertexpairs[vertextagpair];\n    let startpoint = vertexpair.v1.pos;\n    let endpoint = vertexpair.v2.pos;\n    // our x,y and z vectors:\n    let zbase = endpoint.minus(startpoint).unit();\n    let xbase = vertexpair.planenormals[0].unit();\n    let ybase = xbase.cross(zbase);\n\n    // make a list of angles that the cylinder should traverse:\n    let angles = [];\n\n    // first of all equally spaced around the cylinder:\n    for (let i = 0; i < resolution; i++) {\n      angles.push((i * Math.PI * 2) / resolution);\n    }\n\n    // and also at every normal of all touching planes:\n    for (let i = 0, iMax = vertexpair.planenormals.length; i < iMax; i++) {\n      let planenormal = vertexpair.planenormals[i];\n      let si = ybase.dot(planenormal);\n      let co = xbase.dot(planenormal);\n      let angle = Math.atan2(si, co);\n\n      if (angle < 0) angle += Math.PI * 2;\n      angles.push(angle);\n      angle = Math.atan2(-si, -co);\n      if (angle < 0) angle += Math.PI * 2;\n      angles.push(angle);\n    }\n\n    // this will result in some duplicate angles but we will get rid of those later.\n    // Sort:\n    angles = angles.sort(fnNumberSort);\n\n    // Now construct the cylinder by traversing all angles:\n    let numangles = angles.length;\n    let prevp1;\n    let prevp2;\n    let startfacevertices = [];\n    let endfacevertices = [];\n    let polygons = [];\n    for (let i = -1; i < numangles; i++) {\n      let angle = angles[i < 0 ? i + numangles : i];\n      let si = Math.sin(angle);\n      let co = Math.cos(angle);\n      let p = xbase.times(co * radius).plus(ybase.times(si * radius));\n      let p1 = startpoint.plus(p);\n      let p2 = endpoint.plus(p);\n      let skip = false;\n      if (i >= 0) {\n        if (p1.distanceTo(prevp1) < EPS) {\n          skip = true;\n        }\n      }\n      if (!skip) {\n        if (i >= 0) {\n          startfacevertices.push(new Vertex(p1));\n          endfacevertices.push(new Vertex(p2));\n          let polygonvertices = [\n            new Vertex(prevp2),\n            new Vertex(p2),\n            new Vertex(p1),\n            new Vertex(prevp1),\n          ];\n          let polygon = new Polygon(polygonvertices);\n          polygons.push(polygon);\n        }\n        prevp1 = p1;\n        prevp2 = p2;\n      }\n    }\n    endfacevertices.reverse();\n    polygons.push(new Polygon(startfacevertices));\n    polygons.push(new Polygon(endfacevertices));\n    let cylinder = fromPolygons(polygons);\n    result = result.unionSub(cylinder, false, false);\n  }\n\n  // make a list of all unique vertices\n  // For each vertex we also collect the list of normals of the planes touching the vertices\n  let vertexmap = {};\n  csg.polygons.map(function (polygon) {\n    polygon.vertices.map(function (vertex) {\n      let vertextag = vertex.getTag();\n      let obj;\n      if (vertextag in vertexmap) {\n        obj = vertexmap[vertextag];\n      } else {\n        obj = {\n          pos: vertex.pos,\n          normals: [],\n        };\n        vertexmap[vertextag] = obj;\n      }\n      obj.normals.push(polygon.plane.normal);\n    });\n  });\n\n  // and build spheres at each vertex\n  // We will try to set the x and z axis to the normals of 2 planes\n  // This will ensure that our sphere tesselation somewhat matches 2 planes\n  for (let vertextag in vertexmap) {\n    let vertexobj = vertexmap[vertextag];\n    // use the first normal to be the x axis of our sphere:\n    let xaxis = vertexobj.normals[0].unit();\n    // and find a suitable z axis. We will use the normal which is most perpendicular to the x axis:\n    let bestzaxis = null;\n    let bestzaxisorthogonality = 0;\n    for (let i = 1; i < vertexobj.normals.length; i++) {\n      let normal = vertexobj.normals[i].unit();\n      let cross = xaxis.cross(normal);\n      let crosslength = cross.length();\n      if (crosslength > 0.05) {\n        if (crosslength > bestzaxisorthogonality) {\n          bestzaxisorthogonality = crosslength;\n          bestzaxis = normal;\n        }\n      }\n    }\n    if (!bestzaxis) {\n      bestzaxis = xaxis.randomNonParallelVector();\n    }\n    let yaxis = xaxis.cross(bestzaxis).unit();\n    let zaxis = yaxis.cross(xaxis);\n    let _sphere = CSG.sphere({\n      center: vertexobj.pos,\n      radius: radius,\n      resolution: resolution,\n      axes: [xaxis, yaxis, zaxis],\n    });\n    result = result.unionSub(_sphere, false, false);\n  }\n\n  return result;\n};\n\nmodule.exports = {\n  expand,\n  contract,\n  expandedShellOfCAG,\n  expandedShellOfCCSG,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL29wcy1leHBhbmRDb250cmFjdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvb3BzLWV4cGFuZENvbnRyYWN0LmpzPzljMmYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBFUFMsIGFuZ2xlRVBTIH0gPSByZXF1aXJlKCcuLi9jb3JlL2NvbnN0YW50cycpO1xuY29uc3QgVmVydGV4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1ZlcnRleDMnKTtcbmNvbnN0IFZlY3RvcjJEID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1ZlY3RvcjInKTtcbmNvbnN0IFBvbHlnb24gPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvUG9seWdvbjMnKTtcbmNvbnN0IHsgZm5OdW1iZXJTb3J0LCBpc0NTRyB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlscycpO1xuY29uc3QgeyBmcm9tUG9pbnRzLCBmcm9tUG9pbnRzTm9DaGVjayB9ID0gcmVxdWlyZSgnLi4vY29yZS9DQUdGYWN0b3JpZXMnKTtcblxuY29uc3QgZXhwYW5kID0gZnVuY3Rpb24gKHNoYXBlLCByYWRpdXMsIHJlc29sdXRpb24pIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGlzQ1NHKHNoYXBlKSkge1xuICAgIHJlc3VsdCA9IHNoYXBlLnVuaW9uKGV4cGFuZGVkU2hlbGxPZkNDU0coc2hhcGUsIHJhZGl1cywgcmVzb2x1dGlvbikpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZVRlc3NlbGF0ZWQoKTtcbiAgICByZXN1bHQucHJvcGVydGllcyA9IHNoYXBlLnByb3BlcnRpZXM7IC8vIGtlZXAgb3JpZ2luYWwgcHJvcGVydGllc1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHNoYXBlLnVuaW9uKGV4cGFuZGVkU2hlbGxPZkNBRyhzaGFwZSwgcmFkaXVzLCByZXNvbHV0aW9uKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGNvbnRyYWN0ID0gZnVuY3Rpb24gKHNoYXBlLCByYWRpdXMsIHJlc29sdXRpb24pIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKGlzQ1NHKHNoYXBlKSkge1xuICAgIHJlc3VsdCA9IHNoYXBlLnN1YnRyYWN0KGV4cGFuZGVkU2hlbGxPZkNDU0coc2hhcGUsIHJhZGl1cywgcmVzb2x1dGlvbikpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZVRlc3NlbGF0ZWQoKTtcbiAgICByZXN1bHQucHJvcGVydGllcyA9IHNoYXBlLnByb3BlcnRpZXM7IC8vIGtlZXAgb3JpZ2luYWwgcHJvcGVydGllc1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHNoYXBlLnN1YnRyYWN0KGV4cGFuZGVkU2hlbGxPZkNBRyhzaGFwZSwgcmFkaXVzLCByZXNvbHV0aW9uKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGV4cGFuZGVkU2hlbGxPZkNBRyA9IGZ1bmN0aW9uIChfY2FnLCByYWRpdXMsIHJlc29sdXRpb24pIHtcbiAgY29uc3QgQ0FHID0gcmVxdWlyZSgnLi4vY29yZS9DQUcnKTsgLy8gRklYTUUsIGNpcmN1bGFyIGRlcGVuZGVuY3kgISFcbiAgcmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgODtcbiAgaWYgKHJlc29sdXRpb24gPCA0KSByZXNvbHV0aW9uID0gNDtcbiAgbGV0IGNhZ3MgPSBbXTtcbiAgbGV0IHBvaW50bWFwID0ge307XG4gIGxldCBjYWcgPSBfY2FnLmNhbm9uaWNhbGl6ZWQoKTtcbiAgY2FnLnNpZGVzLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIGxldCBkID0gc2lkZS52ZXJ0ZXgxLnBvcy5taW51cyhzaWRlLnZlcnRleDAucG9zKTtcbiAgICBsZXQgZGwgPSBkLmxlbmd0aCgpO1xuICAgIGlmIChkbCA+IEVQUykge1xuICAgICAgZCA9IGQudGltZXMoMS4wIC8gZGwpO1xuICAgICAgbGV0IG5vcm1hbCA9IGQubm9ybWFsKCkudGltZXMocmFkaXVzKTtcbiAgICAgIGxldCBzaGVsbHBvaW50cyA9IFtcbiAgICAgICAgc2lkZS52ZXJ0ZXgxLnBvcy5wbHVzKG5vcm1hbCksXG4gICAgICAgIHNpZGUudmVydGV4MS5wb3MubWludXMobm9ybWFsKSxcbiAgICAgICAgc2lkZS52ZXJ0ZXgwLnBvcy5taW51cyhub3JtYWwpLFxuICAgICAgICBzaWRlLnZlcnRleDAucG9zLnBsdXMobm9ybWFsKSxcbiAgICAgIF07XG4gICAgICAvLyAgICAgIGxldCBuZXdjYWcgPSBmcm9tUG9pbnRzTm9DaGVjayhzaGVsbHBvaW50cyk7XG4gICAgICBsZXQgbmV3Y2FnID0gZnJvbVBvaW50cyhzaGVsbHBvaW50cyk7XG4gICAgICBjYWdzLnB1c2gobmV3Y2FnKTtcbiAgICAgIGZvciAobGV0IHN0ZXAgPSAwOyBzdGVwIDwgMjsgc3RlcCsrKSB7XG4gICAgICAgIGxldCBwMSA9IHN0ZXAgPT09IDAgPyBzaWRlLnZlcnRleDAucG9zIDogc2lkZS52ZXJ0ZXgxLnBvcztcbiAgICAgICAgbGV0IHAyID0gc3RlcCA9PT0gMCA/IHNpZGUudmVydGV4MS5wb3MgOiBzaWRlLnZlcnRleDAucG9zO1xuICAgICAgICBsZXQgdGFnID0gcDEueCArICcgJyArIHAxLnk7XG4gICAgICAgIGlmICghKHRhZyBpbiBwb2ludG1hcCkpIHtcbiAgICAgICAgICBwb2ludG1hcFt0YWddID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnRtYXBbdGFnXS5wdXNoKHtcbiAgICAgICAgICBwMTogcDEsXG4gICAgICAgICAgcDI6IHAyLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBmb3IgKGxldCB0YWcgaW4gcG9pbnRtYXApIHtcbiAgICBsZXQgbSA9IHBvaW50bWFwW3RhZ107XG4gICAgbGV0IGFuZ2xlMSwgYW5nbGUyO1xuICAgIGxldCBwY2VudGVyID0gbVswXS5wMTtcbiAgICBpZiAobS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGxldCBlbmQxID0gbVswXS5wMjtcbiAgICAgIGxldCBlbmQyID0gbVsxXS5wMjtcbiAgICAgIGFuZ2xlMSA9IGVuZDEubWludXMocGNlbnRlcikuYW5nbGVEZWdyZWVzKCk7XG4gICAgICBhbmdsZTIgPSBlbmQyLm1pbnVzKHBjZW50ZXIpLmFuZ2xlRGVncmVlcygpO1xuICAgICAgaWYgKGFuZ2xlMiA8IGFuZ2xlMSkgYW5nbGUyICs9IDM2MDtcbiAgICAgIGlmIChhbmdsZTIgPj0gYW5nbGUxICsgMzYwKSBhbmdsZTIgLT0gMzYwO1xuICAgICAgaWYgKGFuZ2xlMiA8IGFuZ2xlMSArIDE4MCkge1xuICAgICAgICBsZXQgdCA9IGFuZ2xlMjtcbiAgICAgICAgYW5nbGUyID0gYW5nbGUxICsgMzYwO1xuICAgICAgICBhbmdsZTEgPSB0O1xuICAgICAgfVxuICAgICAgYW5nbGUxICs9IDkwO1xuICAgICAgYW5nbGUyIC09IDkwO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZTEgPSAwO1xuICAgICAgYW5nbGUyID0gMzYwO1xuICAgIH1cbiAgICBsZXQgZnVsbGNpcmNsZSA9IGFuZ2xlMiA+IGFuZ2xlMSArIDM1OS45OTk7XG4gICAgaWYgKGZ1bGxjaXJjbGUpIHtcbiAgICAgIGFuZ2xlMSA9IDA7XG4gICAgICBhbmdsZTIgPSAzNjA7XG4gICAgfVxuICAgIGlmIChhbmdsZTIgPiBhbmdsZTEgKyBhbmdsZUVQUykge1xuICAgICAgbGV0IHBvaW50cyA9IFtdO1xuICAgICAgaWYgKCFmdWxsY2lyY2xlKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHBjZW50ZXIpO1xuICAgICAgfVxuICAgICAgbGV0IG51bXN0ZXBzID0gTWF0aC5yb3VuZCgocmVzb2x1dGlvbiAqIChhbmdsZTIgLSBhbmdsZTEpKSAvIDM2MCk7XG4gICAgICBpZiAobnVtc3RlcHMgPCAxKSBudW1zdGVwcyA9IDE7XG4gICAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8PSBudW1zdGVwczsgc3RlcCsrKSB7XG4gICAgICAgIGxldCBhbmdsZSA9IGFuZ2xlMSArIChzdGVwIC8gbnVtc3RlcHMpICogKGFuZ2xlMiAtIGFuZ2xlMSk7XG4gICAgICAgIGlmIChzdGVwID09PSBudW1zdGVwcykgYW5nbGUgPSBhbmdsZTI7IC8vIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzXG4gICAgICAgIGxldCBwb2ludCA9IHBjZW50ZXIucGx1cyhcbiAgICAgICAgICBWZWN0b3IyRC5mcm9tQW5nbGVEZWdyZWVzKGFuZ2xlKS50aW1lcyhyYWRpdXMpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghZnVsbGNpcmNsZSB8fCBzdGVwID4gMCkge1xuICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5ld2NhZyA9IGZyb21Qb2ludHNOb0NoZWNrKHBvaW50cyk7XG4gICAgICBjYWdzLnB1c2gobmV3Y2FnKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IG5ldyBDQUcoKTtcbiAgcmVzdWx0ID0gcmVzdWx0LnVuaW9uKGNhZ3MpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGV4cGFuZGVkIHNoZWxsIG9mIHRoZSBzb2xpZDpcbiAqIEFsbCBmYWNlcyBhcmUgZXh0cnVkZWQgdG8gZ2V0IGEgdGhpY2tuZXNzIG9mIDIqcmFkaXVzXG4gKiBDeWxpbmRlcnMgYXJlIGNvbnN0cnVjdGVkIGFyb3VuZCBldmVyeSBzaWRlXG4gKiBTcGhlcmVzIGFyZSBwbGFjZWQgb24gZXZlcnkgdmVydGV4XG4gKiB1bmlvbldpdGhUaGlzOiBpZiB0cnVlLCB0aGUgcmVzdWx0aW5nIHNvbGlkIHdpbGwgYmUgdW5pdGVkIHdpdGggJ3RoaXMnIHNvbGlkO1xuICogdGhlIHJlc3VsdCBpcyBhIHRydWUgZXhwYW5zaW9uIG9mIHRoZSBzb2xpZFxuICogSWYgZmFsc2UsIHJldHVybnMgb25seSB0aGUgc2hlbGxcbiAqIEBwYXJhbSAge0Zsb2F0fSByYWRpdXNcbiAqIEBwYXJhbSAge0ludGVnZXJ9IHJlc29sdXRpb25cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHVuaW9uV2l0aFRoaXNcbiAqL1xuY29uc3QgZXhwYW5kZWRTaGVsbE9mQ0NTRyA9IGZ1bmN0aW9uIChfY3NnLCByYWRpdXMsIHJlc29sdXRpb24sIHVuaW9uV2l0aFRoaXMpIHtcbiAgY29uc3QgQ1NHID0gcmVxdWlyZSgnLi4vY29yZS9DU0cnKTsgLy8gRklYTUU6IGNpcmN1bGFyIGRlcGVuZGVuY3kgISBDU0cgPT4gdGhpcyA9PiBDU0dcbiAgY29uc3QgeyBmcm9tUG9seWdvbnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvQ1NHRmFjdG9yaWVzJyk7IC8vIEZJWE1FOiBjaXJjdWxhciBkZXBlbmRlbmN5ICFcbiAgLy8gY29uc3Qge3NwaGVyZX0gPSByZXF1aXJlKCcuL3ByaW1pdGl2ZXMzZCcpIC8vIEZJWE1FOiBjaXJjdWxhciBkZXBlbmRlbmN5ICFcbiAgbGV0IGNzZyA9IF9jc2cucmVUZXNzZWxhdGVkKCk7XG4gIGxldCByZXN1bHQ7XG4gIGlmICh1bmlvbldpdGhUaGlzKSB7XG4gICAgcmVzdWx0ID0gY3NnO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IG5ldyBDU0coKTtcbiAgfVxuXG4gIC8vIGZpcnN0IGV4dHJ1ZGUgYWxsIHBvbHlnb25zOlxuICBjc2cucG9seWdvbnMubWFwKGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgbGV0IGV4dHJ1ZGV2ZWN0b3IgPSBwb2x5Z29uLnBsYW5lLm5vcm1hbC51bml0KCkudGltZXMoMiAqIHJhZGl1cyk7XG4gICAgbGV0IHRyYW5zbGF0ZWRwb2x5Z29uID0gcG9seWdvbi50cmFuc2xhdGUoZXh0cnVkZXZlY3Rvci50aW1lcygtMC41KSk7XG4gICAgbGV0IGV4dHJ1ZGVkZmFjZSA9IHRyYW5zbGF0ZWRwb2x5Z29uLmV4dHJ1ZGUoZXh0cnVkZXZlY3Rvcik7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnVuaW9uU3ViKGV4dHJ1ZGVkZmFjZSwgZmFsc2UsIGZhbHNlKTtcbiAgfSk7XG5cbiAgLy8gTWFrZSBhIGxpc3Qgb2YgYWxsIHVuaXF1ZSB2ZXJ0ZXggcGFpcnMgKGkuZS4gYWxsIHNpZGVzIG9mIHRoZSBzb2xpZClcbiAgLy8gRm9yIGVhY2ggdmVydGV4IHBhaXIgd2UgY29sbGVjdCB0aGUgZm9sbG93aW5nOlxuICAvLyAgIHYxOiBmaXJzdCBjb29yZGluYXRlXG4gIC8vICAgdjI6IHNlY29uZCBjb29yZGluYXRlXG4gIC8vICAgcGxhbmVub3JtYWxzOiBhcnJheSBvZiBub3JtYWwgdmVjdG9ycyBvZiBhbGwgcGxhbmVzIHRvdWNoaW5nIHRoaXMgc2lkZVxuICBsZXQgdmVydGV4cGFpcnMgPSB7fTsgLy8gbWFwIG9mICd2ZXJ0ZXggcGFpciB0YWcnIHRvIHt2MSwgdjIsIHBsYW5lbm9ybWFsc31cbiAgY3NnLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgIGxldCBudW12ZXJ0aWNlcyA9IHBvbHlnb24udmVydGljZXMubGVuZ3RoO1xuICAgIGxldCBwcmV2dmVydGV4ID0gcG9seWdvbi52ZXJ0aWNlc1tudW12ZXJ0aWNlcyAtIDFdO1xuICAgIGxldCBwcmV2dmVydGV4dGFnID0gcHJldnZlcnRleC5nZXRUYWcoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXZlcnRpY2VzOyBpKyspIHtcbiAgICAgIGxldCB2ZXJ0ZXggPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgbGV0IHZlcnRleHRhZyA9IHZlcnRleC5nZXRUYWcoKTtcbiAgICAgIGxldCB2ZXJ0ZXh0YWdwYWlyO1xuICAgICAgaWYgKHZlcnRleHRhZyA8IHByZXZ2ZXJ0ZXh0YWcpIHtcbiAgICAgICAgdmVydGV4dGFncGFpciA9IHZlcnRleHRhZyArICctJyArIHByZXZ2ZXJ0ZXh0YWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJ0ZXh0YWdwYWlyID0gcHJldnZlcnRleHRhZyArICctJyArIHZlcnRleHRhZztcbiAgICAgIH1cbiAgICAgIGxldCBvYmo7XG4gICAgICBpZiAodmVydGV4dGFncGFpciBpbiB2ZXJ0ZXhwYWlycykge1xuICAgICAgICBvYmogPSB2ZXJ0ZXhwYWlyc1t2ZXJ0ZXh0YWdwYWlyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHtcbiAgICAgICAgICB2MTogcHJldnZlcnRleCxcbiAgICAgICAgICB2MjogdmVydGV4LFxuICAgICAgICAgIHBsYW5lbm9ybWFsczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHZlcnRleHBhaXJzW3ZlcnRleHRhZ3BhaXJdID0gb2JqO1xuICAgICAgfVxuICAgICAgb2JqLnBsYW5lbm9ybWFscy5wdXNoKHBvbHlnb24ucGxhbmUubm9ybWFsKTtcblxuICAgICAgcHJldnZlcnRleHRhZyA9IHZlcnRleHRhZztcbiAgICAgIHByZXZ2ZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgfVxuICB9KTtcblxuICAvLyBub3cgY29uc3RydWN0IGEgY3lsaW5kZXIgb24gZXZlcnkgc2lkZVxuICAvLyBUaGUgY3lsaW5kZXIgaXMgYWx3YXlzIGFuIGFwcHJveGltYXRpb24gb2YgYSB0cnVlIGN5bGluZGVyOiBpdCB3aWxsIGhhdmUgPHJlc29sdXRpb24+IHBvbHlnb25zXG4gIC8vIGFyb3VuZCB0aGUgc2lkZXMuIFdlIHdpbGwgbWFrZSBzdXJlIHRob3VnaCB0aGF0IHRoZSBjeWxpbmRlciB3aWxsIGhhdmUgYW4gZWRnZSBhdCBldmVyeVxuICAvLyBmYWNlIHRoYXQgdG91Y2hlcyB0aGlzIHNpZGUuIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGwgZ2V0IGEgc21vb3RoIGZpbGwgZXZlblxuICAvLyBpZiB0d28gZWRnZXMgYXJlIGF0LCBzYXksIDEwIGRlZ3JlZXMgYW5kIHRoZSByZXNvbHV0aW9uIGlzIGxvdy5cbiAgLy8gTm90ZTogdGhlIHJlc3VsdCBpcyBub3QgcmV0ZXNzZWxhdGVkIHlldCBidXQgaXQgcmVhbGx5IHNob3VsZCBiZSFcbiAgZm9yIChsZXQgdmVydGV4dGFncGFpciBpbiB2ZXJ0ZXhwYWlycykge1xuICAgIGxldCB2ZXJ0ZXhwYWlyID0gdmVydGV4cGFpcnNbdmVydGV4dGFncGFpcl07XG4gICAgbGV0IHN0YXJ0cG9pbnQgPSB2ZXJ0ZXhwYWlyLnYxLnBvcztcbiAgICBsZXQgZW5kcG9pbnQgPSB2ZXJ0ZXhwYWlyLnYyLnBvcztcbiAgICAvLyBvdXIgeCx5IGFuZCB6IHZlY3RvcnM6XG4gICAgbGV0IHpiYXNlID0gZW5kcG9pbnQubWludXMoc3RhcnRwb2ludCkudW5pdCgpO1xuICAgIGxldCB4YmFzZSA9IHZlcnRleHBhaXIucGxhbmVub3JtYWxzWzBdLnVuaXQoKTtcbiAgICBsZXQgeWJhc2UgPSB4YmFzZS5jcm9zcyh6YmFzZSk7XG5cbiAgICAvLyBtYWtlIGEgbGlzdCBvZiBhbmdsZXMgdGhhdCB0aGUgY3lsaW5kZXIgc2hvdWxkIHRyYXZlcnNlOlxuICAgIGxldCBhbmdsZXMgPSBbXTtcblxuICAgIC8vIGZpcnN0IG9mIGFsbCBlcXVhbGx5IHNwYWNlZCBhcm91bmQgdGhlIGN5bGluZGVyOlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x1dGlvbjsgaSsrKSB7XG4gICAgICBhbmdsZXMucHVzaCgoaSAqIE1hdGguUEkgKiAyKSAvIHJlc29sdXRpb24pO1xuICAgIH1cblxuICAgIC8vIGFuZCBhbHNvIGF0IGV2ZXJ5IG5vcm1hbCBvZiBhbGwgdG91Y2hpbmcgcGxhbmVzOlxuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdmVydGV4cGFpci5wbGFuZW5vcm1hbHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBsZXQgcGxhbmVub3JtYWwgPSB2ZXJ0ZXhwYWlyLnBsYW5lbm9ybWFsc1tpXTtcbiAgICAgIGxldCBzaSA9IHliYXNlLmRvdChwbGFuZW5vcm1hbCk7XG4gICAgICBsZXQgY28gPSB4YmFzZS5kb3QocGxhbmVub3JtYWwpO1xuICAgICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihzaSwgY28pO1xuXG4gICAgICBpZiAoYW5nbGUgPCAwKSBhbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICAgIGFuZ2xlcy5wdXNoKGFuZ2xlKTtcbiAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMigtc2ksIC1jbyk7XG4gICAgICBpZiAoYW5nbGUgPCAwKSBhbmdsZSArPSBNYXRoLlBJICogMjtcbiAgICAgIGFuZ2xlcy5wdXNoKGFuZ2xlKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIHNvbWUgZHVwbGljYXRlIGFuZ2xlcyBidXQgd2Ugd2lsbCBnZXQgcmlkIG9mIHRob3NlIGxhdGVyLlxuICAgIC8vIFNvcnQ6XG4gICAgYW5nbGVzID0gYW5nbGVzLnNvcnQoZm5OdW1iZXJTb3J0KTtcblxuICAgIC8vIE5vdyBjb25zdHJ1Y3QgdGhlIGN5bGluZGVyIGJ5IHRyYXZlcnNpbmcgYWxsIGFuZ2xlczpcbiAgICBsZXQgbnVtYW5nbGVzID0gYW5nbGVzLmxlbmd0aDtcbiAgICBsZXQgcHJldnAxO1xuICAgIGxldCBwcmV2cDI7XG4gICAgbGV0IHN0YXJ0ZmFjZXZlcnRpY2VzID0gW107XG4gICAgbGV0IGVuZGZhY2V2ZXJ0aWNlcyA9IFtdO1xuICAgIGxldCBwb2x5Z29ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAtMTsgaSA8IG51bWFuZ2xlczsgaSsrKSB7XG4gICAgICBsZXQgYW5nbGUgPSBhbmdsZXNbaSA8IDAgPyBpICsgbnVtYW5nbGVzIDogaV07XG4gICAgICBsZXQgc2kgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICBsZXQgY28gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICBsZXQgcCA9IHhiYXNlLnRpbWVzKGNvICogcmFkaXVzKS5wbHVzKHliYXNlLnRpbWVzKHNpICogcmFkaXVzKSk7XG4gICAgICBsZXQgcDEgPSBzdGFydHBvaW50LnBsdXMocCk7XG4gICAgICBsZXQgcDIgPSBlbmRwb2ludC5wbHVzKHApO1xuICAgICAgbGV0IHNraXAgPSBmYWxzZTtcbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgaWYgKHAxLmRpc3RhbmNlVG8ocHJldnAxKSA8IEVQUykge1xuICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgIHN0YXJ0ZmFjZXZlcnRpY2VzLnB1c2gobmV3IFZlcnRleChwMSkpO1xuICAgICAgICAgIGVuZGZhY2V2ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgocDIpKTtcbiAgICAgICAgICBsZXQgcG9seWdvbnZlcnRpY2VzID0gW1xuICAgICAgICAgICAgbmV3IFZlcnRleChwcmV2cDIpLFxuICAgICAgICAgICAgbmV3IFZlcnRleChwMiksXG4gICAgICAgICAgICBuZXcgVmVydGV4KHAxKSxcbiAgICAgICAgICAgIG5ldyBWZXJ0ZXgocHJldnAxKSxcbiAgICAgICAgICBdO1xuICAgICAgICAgIGxldCBwb2x5Z29uID0gbmV3IFBvbHlnb24ocG9seWdvbnZlcnRpY2VzKTtcbiAgICAgICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgICAgICB9XG4gICAgICAgIHByZXZwMSA9IHAxO1xuICAgICAgICBwcmV2cDIgPSBwMjtcbiAgICAgIH1cbiAgICB9XG4gICAgZW5kZmFjZXZlcnRpY2VzLnJldmVyc2UoKTtcbiAgICBwb2x5Z29ucy5wdXNoKG5ldyBQb2x5Z29uKHN0YXJ0ZmFjZXZlcnRpY2VzKSk7XG4gICAgcG9seWdvbnMucHVzaChuZXcgUG9seWdvbihlbmRmYWNldmVydGljZXMpKTtcbiAgICBsZXQgY3lsaW5kZXIgPSBmcm9tUG9seWdvbnMocG9seWdvbnMpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC51bmlvblN1YihjeWxpbmRlciwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIG1ha2UgYSBsaXN0IG9mIGFsbCB1bmlxdWUgdmVydGljZXNcbiAgLy8gRm9yIGVhY2ggdmVydGV4IHdlIGFsc28gY29sbGVjdCB0aGUgbGlzdCBvZiBub3JtYWxzIG9mIHRoZSBwbGFuZXMgdG91Y2hpbmcgdGhlIHZlcnRpY2VzXG4gIGxldCB2ZXJ0ZXhtYXAgPSB7fTtcbiAgY3NnLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHBvbHlnb24udmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgIGxldCB2ZXJ0ZXh0YWcgPSB2ZXJ0ZXguZ2V0VGFnKCk7XG4gICAgICBsZXQgb2JqO1xuICAgICAgaWYgKHZlcnRleHRhZyBpbiB2ZXJ0ZXhtYXApIHtcbiAgICAgICAgb2JqID0gdmVydGV4bWFwW3ZlcnRleHRhZ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSB7XG4gICAgICAgICAgcG9zOiB2ZXJ0ZXgucG9zLFxuICAgICAgICAgIG5vcm1hbHM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB2ZXJ0ZXhtYXBbdmVydGV4dGFnXSA9IG9iajtcbiAgICAgIH1cbiAgICAgIG9iai5ub3JtYWxzLnB1c2gocG9seWdvbi5wbGFuZS5ub3JtYWwpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhbmQgYnVpbGQgc3BoZXJlcyBhdCBlYWNoIHZlcnRleFxuICAvLyBXZSB3aWxsIHRyeSB0byBzZXQgdGhlIHggYW5kIHogYXhpcyB0byB0aGUgbm9ybWFscyBvZiAyIHBsYW5lc1xuICAvLyBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgb3VyIHNwaGVyZSB0ZXNzZWxhdGlvbiBzb21ld2hhdCBtYXRjaGVzIDIgcGxhbmVzXG4gIGZvciAobGV0IHZlcnRleHRhZyBpbiB2ZXJ0ZXhtYXApIHtcbiAgICBsZXQgdmVydGV4b2JqID0gdmVydGV4bWFwW3ZlcnRleHRhZ107XG4gICAgLy8gdXNlIHRoZSBmaXJzdCBub3JtYWwgdG8gYmUgdGhlIHggYXhpcyBvZiBvdXIgc3BoZXJlOlxuICAgIGxldCB4YXhpcyA9IHZlcnRleG9iai5ub3JtYWxzWzBdLnVuaXQoKTtcbiAgICAvLyBhbmQgZmluZCBhIHN1aXRhYmxlIHogYXhpcy4gV2Ugd2lsbCB1c2UgdGhlIG5vcm1hbCB3aGljaCBpcyBtb3N0IHBlcnBlbmRpY3VsYXIgdG8gdGhlIHggYXhpczpcbiAgICBsZXQgYmVzdHpheGlzID0gbnVsbDtcbiAgICBsZXQgYmVzdHpheGlzb3J0aG9nb25hbGl0eSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2ZXJ0ZXhvYmoubm9ybWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5vcm1hbCA9IHZlcnRleG9iai5ub3JtYWxzW2ldLnVuaXQoKTtcbiAgICAgIGxldCBjcm9zcyA9IHhheGlzLmNyb3NzKG5vcm1hbCk7XG4gICAgICBsZXQgY3Jvc3NsZW5ndGggPSBjcm9zcy5sZW5ndGgoKTtcbiAgICAgIGlmIChjcm9zc2xlbmd0aCA+IDAuMDUpIHtcbiAgICAgICAgaWYgKGNyb3NzbGVuZ3RoID4gYmVzdHpheGlzb3J0aG9nb25hbGl0eSkge1xuICAgICAgICAgIGJlc3R6YXhpc29ydGhvZ29uYWxpdHkgPSBjcm9zc2xlbmd0aDtcbiAgICAgICAgICBiZXN0emF4aXMgPSBub3JtYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFiZXN0emF4aXMpIHtcbiAgICAgIGJlc3R6YXhpcyA9IHhheGlzLnJhbmRvbU5vblBhcmFsbGVsVmVjdG9yKCk7XG4gICAgfVxuICAgIGxldCB5YXhpcyA9IHhheGlzLmNyb3NzKGJlc3R6YXhpcykudW5pdCgpO1xuICAgIGxldCB6YXhpcyA9IHlheGlzLmNyb3NzKHhheGlzKTtcbiAgICBsZXQgX3NwaGVyZSA9IENTRy5zcGhlcmUoe1xuICAgICAgY2VudGVyOiB2ZXJ0ZXhvYmoucG9zLFxuICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgYXhlczogW3hheGlzLCB5YXhpcywgemF4aXNdLFxuICAgIH0pO1xuICAgIHJlc3VsdCA9IHJlc3VsdC51bmlvblN1Yihfc3BoZXJlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHBhbmQsXG4gIGNvbnRyYWN0LFxuICBleHBhbmRlZFNoZWxsT2ZDQUcsXG4gIGV4cGFuZGVkU2hlbGxPZkNDU0csXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/ops-expandContract.js\n");

/***/ }),

/***/ "./src/api/ops-extrusions.js":
/*!***********************************!*\
  !*** ./src/api/ops-extrusions.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS, defaultResolution3D } = __webpack_require__(/*! ../core/constants */ \"./src/core/constants.js\");\nconst OrthoNormalBasis = __webpack_require__(/*! ../core/math/OrthoNormalBasis */ \"./src/core/math/OrthoNormalBasis.js\");\nconst {\n  parseOptionAs3DVector,\n  parseOptionAsBool,\n  parseOptionAsFloat,\n  parseOptionAsInt,\n} = __webpack_require__(/*! ./optionParsers */ \"./src/api/optionParsers.js\");\nconst Vector3D = __webpack_require__(/*! ../core/math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Matrix4 = __webpack_require__(/*! ../core/math/Matrix4 */ \"./src/core/math/Matrix4.js\");\nconst Path2D = __webpack_require__(/*! ../core/math/Path2 */ \"./src/core/math/Path2.js\");\nconst { Connector } = __webpack_require__(/*! ../core/connectors */ \"./src/core/connectors.js\");\nconst { fromPolygons } = __webpack_require__(/*! ../core/CSGFactories */ \"./src/core/CSGFactories.js\");\nconst {\n  cagToPointsArray,\n  clamp,\n  rightMultiply1x3VectorToArray,\n  polygonFromPoints,\n} = __webpack_require__(/*! ./helpers */ \"./src/api/helpers.js\");\nconst { fromPoints } = __webpack_require__(/*! ../core/CAGFactories */ \"./src/core/CAGFactories.js\");\n\n/** extrude the CAG in a certain plane.\n * Giving just a plane is not enough, multiple different extrusions in the same plane would be possible\n * by rotating around the plane's origin. An additional right-hand vector should be specified as well,\n * and this is exactly a OrthoNormalBasis.\n * @param  {CAG} cag the cag to extrude\n * @param  {Orthonormalbasis} orthonormalbasis characterizes the plane in which to extrude\n * @param  {Float} depth thickness of the extruded shape. Extrusion is done upwards from the plane\n *  (unless symmetrical option is set, see below)\n * @param  {Object} [options] - options for construction\n * @param {Boolean} [options.symmetrical=true] - extrude symmetrically in two directions about the plane\n */\nconst extrudeInOrthonormalBasis = function (\n  cag,\n  orthonormalbasis,\n  depth,\n  options\n) {\n  // first extrude in the regular Z plane:\n  if (!(orthonormalbasis instanceof OrthoNormalBasis)) {\n    throw new Error(\n      'extrudeInPlane: the first parameter should be a OrthoNormalBasis'\n    );\n  }\n  let extruded = cag.extrude({\n    offset: [0, 0, depth],\n  });\n  if (parseOptionAsBool(options, 'symmetrical', false)) {\n    extruded = extruded.translate([0, 0, -depth / 2]);\n  }\n  let matrix = orthonormalbasis.getInverseProjectionMatrix();\n  extruded = extruded.transform(matrix);\n  return extruded;\n};\n\n/** Extrude in a standard cartesian plane, specified by two axis identifiers. Each identifier can be\n * one of [\"X\",\"Y\",\"Z\",\"-X\",\"-Y\",\"-Z\"]\n * The 2d x axis will map to the first given 3D axis, the 2d y axis will map to the second.\n * See OrthoNormalBasis.GetCartesian for details.\n * @param  {CAG} cag the cag to extrude\n * @param  {String} axis1 the first axis\n * @param  {String} axis2 the second axis\n * @param  {Float} depth thickness of the extruded shape. Extrusion is done upwards from the plane\n * @param  {Object} [options] - options for construction\n * @param {Boolean} [options.symmetrical=true] - extrude symmetrically in two directions about the plane\n */\nconst extrudeInPlane = function (cag, axis1, axis2, depth, options) {\n  return extrudeInOrthonormalBasis(\n    cag,\n    OrthoNormalBasis.GetCartesian(axis1, axis2),\n    depth,\n    options\n  );\n};\n\n/** linear extrusion of 2D shape, with optional twist\n * @param  {CAG} cag the cag to extrude\n * @param  {Object} [options] - options for construction\n * @param {Array} [options.offset=[0,0,1]] - The 2d shape is placed in in z=0 plane and extruded into direction <offset>\n * (a 3D vector as a 3 component array)\n * @param {Boolean} [options.twiststeps=defaultResolution3D] - twiststeps determines the resolution of the twist (should be >= 1)\n * @param {Boolean} [options.twistangle=0] - twistangle The final face is rotated <twistangle> degrees. Rotation is done around the origin of the 2d shape (i.e. x=0, y=0)\n * @returns {CSG} the extrude shape, as a CSG object\n * @example extruded=cag.extrude({offset: [0,0,10], twistangle: 360, twiststeps: 100});\n */\nconst extrude = function (cag, options) {\n  const CSG = __webpack_require__(/*! ../core/CSG */ \"./src/core/CSG.js\"); // FIXME: circular dependencies CAG=>CSG=>CAG\n  if (cag.sides.length === 0) {\n    // empty! : FIXME: should this throw ?\n    return new CSG();\n  }\n  let offsetVector = parseOptionAs3DVector(options, 'offset', [0, 0, 1]);\n  let twistangle = parseOptionAsFloat(options, 'twistangle', 0);\n  let twiststeps = parseOptionAsInt(options, 'twiststeps', defaultResolution3D);\n  if (offsetVector.z === 0) {\n    throw new Error('offset cannot be orthogonal to Z axis');\n  }\n  if (twistangle === 0 || twiststeps < 1) {\n    twiststeps = 1;\n  }\n  let normalVector = Vector3D.Create(0, 1, 0);\n\n  let polygons = [];\n  // bottom and top\n  polygons = polygons.concat(\n    cag._toPlanePolygons({\n      translation: [0, 0, 0],\n      normalVector: normalVector,\n      flipped: !(offsetVector.z < 0),\n    })\n  );\n  polygons = polygons.concat(\n    cag._toPlanePolygons({\n      translation: offsetVector,\n      normalVector: normalVector.rotateZ(twistangle),\n      flipped: offsetVector.z < 0,\n    })\n  );\n  // walls\n  for (let i = 0; i < twiststeps; i++) {\n    let c1 = new Connector(\n      offsetVector.times(i / twiststeps),\n      [0, 0, offsetVector.z],\n      normalVector.rotateZ((i * twistangle) / twiststeps)\n    );\n    let c2 = new Connector(\n      offsetVector.times((i + 1) / twiststeps),\n      [0, 0, offsetVector.z],\n      normalVector.rotateZ(((i + 1) * twistangle) / twiststeps)\n    );\n    polygons = polygons.concat(\n      cag._toWallPolygons({ toConnector1: c1, toConnector2: c2 })\n    );\n  }\n\n  return fromPolygons(polygons);\n};\n\n// THIS IS AN OLD untested !!! version of rotate extrude\n/** Extrude to into a 3D solid by rotating the origin around the Y axis.\n * (and turning everything into XY plane)\n * @param {Object} options - options for construction\n * @param {Number} [options.angle=360] - angle of rotation\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n */\nconst rotateExtrude = function (cag, options) {\n  // FIXME options should be optional\n  let alpha = parseOptionAsFloat(options, 'angle', 360);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n\n  alpha = alpha > 360 ? alpha % 360 : alpha;\n  let origin = [0, 0, 0];\n  let axisV = Vector3D.Create(0, 1, 0);\n  let normalV = [0, 0, 1];\n  let polygons = [];\n  // planes only needed if alpha > 0\n  let connS = new Connector(origin, axisV, normalV);\n  if (alpha > 0 && alpha < 360) {\n    // we need to rotate negative to satisfy wall function condition of\n    // building in the direction of axis vector\n    let connE = new Connector(origin, axisV.rotateZ(-alpha), normalV);\n    polygons = polygons.concat(\n      cag._toPlanePolygons({ toConnector: connS, flipped: true })\n    );\n    polygons = polygons.concat(cag._toPlanePolygons({ toConnector: connE }));\n  }\n  let connT1 = connS;\n  let connT2;\n  let step = alpha / resolution;\n  for (let a = step; a <= alpha + EPS; a += step) {\n    // FIXME Should this be angelEPS?\n    connT2 = new Connector(origin, axisV.rotateZ(-a), normalV);\n    polygons = polygons.concat(\n      cag._toWallPolygons({ toConnector1: connT1, toConnector2: connT2 })\n    );\n    connT1 = connT2;\n  }\n  return fromPolygons(polygons).reTesselated();\n};\n\n// FIXME: right now linear & rotate extrude take params first, while rectangular_extrude\n// takes params second ! confusing and incoherent ! needs to be changed (BREAKING CHANGE !)\n\n/** linear extrusion of the input 2d shape\n * @param {Object} [options] - options for construction\n * @param {Float} [options.height=1] - height of the extruded shape\n * @param {Integer} [options.slices=10] - number of intermediary steps/slices\n * @param {Integer} [options.twist=0] - angle (in degrees to twist the extusion by)\n * @param {Boolean} [options.center=false] - whether to center extrusion or not\n * @param {CAG} baseShape input 2d shape\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = linear_extrude({height: 10}, square())\n */\nfunction linear_extrude(params, baseShape) {\n  const defaults = {\n    height: 1,\n    slices: 10,\n    twist: 0,\n    center: false,\n  };\n  /* convexity = 10, */\n  const { height, twist, slices, center } = Object.assign({}, defaults, params);\n\n  // if(params.convexity) convexity = params.convexity      // abandoned\n  let output = baseShape.extrude({\n    offset: [0, 0, height],\n    twistangle: twist,\n    twiststeps: slices,\n  });\n  if (center === true) {\n    const b = output.getBounds(); // b[0] = min, b[1] = max\n    const offset = b[1].plus(b[0]).times(-0.5);\n    output = output.translate(offset);\n  }\n  return output;\n}\n\n/** rotate extrusion / revolve of the given 2d shape\n * @param {Object} [options] - options for construction\n * @param {Integer} [options.fn=1] - resolution/number of segments of the extrusion\n * @param {Float} [options.startAngle=1] - start angle of the extrusion, in degrees\n * @param {Float} [options.angle=1] - angle of the extrusion, in degrees\n * @param {Float} [options.overflow='cap'] - what to do with points outside of bounds (+ / - x) :\n * defaults to capping those points to 0 (only supported behaviour for now)\n * @param {CAG} baseShape input 2d shape\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = rotate_extrude({fn: 10}, square())\n */\nfunction rotate_extrude(params, baseShape) {\n  // note, we should perhaps alias this to revolve() as well\n  const defaults = {\n    fn: 32,\n    startAngle: 0,\n    angle: 360,\n    overflow: 'cap',\n  };\n  params = Object.assign({}, defaults, params);\n  let { fn, startAngle, angle, overflow } = params;\n  if (overflow !== 'cap') {\n    throw new Error('only capping of overflowing points is supported !');\n  }\n\n  if (arguments.length < 2) {\n    // FIXME: what the hell ??? just put params second !\n    baseShape = params;\n  }\n  // are we dealing with a positive or negative angle (for normals flipping)\n  const flipped = angle > 0;\n  // limit actual angle between 0 & 360, regardless of direction\n  const totalAngle = flipped\n    ? clamp(startAngle + angle, 0, 360)\n    : clamp(startAngle + angle, -360, 0);\n  // adapt to the totalAngle : 1 extra segment per 45 degs if not 360 deg extrusion\n  // needs to be at least one and higher then the input resolution\n  const segments = Math.max(Math.floor(Math.abs(totalAngle) / 45), 1, fn);\n  // maximum distance per axis between two points before considering them to be the same\n  const overlapTolerance = 0.00001;\n  // convert baseshape to just an array of points, easier to deal with\n  let shapePoints = cagToPointsArray(baseShape);\n\n  // determine if the rotate_extrude can be computed in the first place\n  // ie all the points have to be either x > 0 or x < 0\n\n  // generic solution to always have a valid solid, even if points go beyond x/ -x\n  // 1. split points up between all those on the 'left' side of the axis (x<0) & those on the 'righ' (x>0)\n  // 2. for each set of points do the extrusion operation IN OPOSITE DIRECTIONS\n  // 3. union the two resulting solids\n\n  // 1. alt : OR : just cap of points at the axis ?\n\n  // console.log('shapePoints BEFORE', shapePoints, baseShape.sides)\n\n  const pointsWithNegativeX = shapePoints.filter((x) => x[0] < 0);\n  const pointsWithPositiveX = shapePoints.filter((x) => x[0] >= 0);\n  const arePointsWithNegAndPosX =\n    pointsWithNegativeX.length > 0 && pointsWithPositiveX.length > 0;\n\n  if (arePointsWithNegAndPosX && overflow === 'cap') {\n    if (pointsWithNegativeX.length > pointsWithPositiveX.length) {\n      shapePoints = shapePoints.map(function (point) {\n        return [Math.min(point[0], 0), point[1]];\n      });\n    } else if (pointsWithPositiveX.length >= pointsWithNegativeX.length) {\n      shapePoints = shapePoints.map(function (point) {\n        return [Math.max(point[0], 0), point[1]];\n      });\n    }\n  }\n\n  // console.log('negXs', pointsWithNegativeX, 'pointsWithPositiveX', pointsWithPositiveX, 'arePointsWithNegAndPosX', arePointsWithNegAndPosX)\n  //  console.log('shapePoints AFTER', shapePoints, baseShape.sides)\n\n  let polygons = [];\n\n  // for each of the intermediary steps in the extrusion\n  for (let i = 1; i < segments + 1; i++) {\n    // for each side of the 2d shape\n    for (let j = 0; j < shapePoints.length - 1; j++) {\n      // 2 points of a side\n      const curPoint = shapePoints[j];\n      const nextPoint = shapePoints[j + 1];\n\n      // compute matrix for current and next segment angle\n      let prevMatrix = Matrix4.rotationZ(\n        ((i - 1) / segments) * angle + startAngle\n      );\n      let curMatrix = Matrix4.rotationZ((i / segments) * angle + startAngle);\n\n      const pointA = rightMultiply1x3VectorToArray(prevMatrix, [\n        curPoint[0],\n        0,\n        curPoint[1],\n      ]);\n      const pointAP = rightMultiply1x3VectorToArray(curMatrix, [\n        curPoint[0],\n        0,\n        curPoint[1],\n      ]);\n      const pointB = rightMultiply1x3VectorToArray(prevMatrix, [\n        nextPoint[0],\n        0,\n        nextPoint[1],\n      ]);\n      const pointBP = rightMultiply1x3VectorToArray(curMatrix, [\n        nextPoint[0],\n        0,\n        nextPoint[1],\n      ]);\n\n      // console.log(`point ${j} edge connecting ${j} to ${j + 1}`)\n      let overlappingPoints = false;\n      if (\n        Math.abs(pointA[0] - pointAP[0]) < overlapTolerance &&\n        Math.abs(pointB[1] - pointBP[1]) < overlapTolerance\n      ) {\n        // console.log('identical / overlapping points (from current angle and next one), what now ?')\n        overlappingPoints = true;\n      }\n\n      // we do not generate a single quad because:\n      // 1. it does not allow eliminating unneeded triangles in case of overlapping points\n      // 2. the current cleanup routines of csg.js create degenerate shapes from those quads\n      // let polyPoints = [pointA, pointB, pointBP, pointAP]\n      // polygons.push(polygonFromPoints(polyPoints))\n\n      if (flipped) {\n        // CW\n        polygons.push(polygonFromPoints([pointA, pointB, pointBP]));\n        if (!overlappingPoints) {\n          polygons.push(polygonFromPoints([pointBP, pointAP, pointA]));\n        }\n      } else {\n        // CCW\n        if (!overlappingPoints) {\n          polygons.push(polygonFromPoints([pointA, pointAP, pointBP]));\n        }\n        polygons.push(polygonFromPoints([pointBP, pointB, pointA]));\n      }\n    }\n    // if we do not do a full extrusion, we want caps at both ends (closed volume)\n    if (Math.abs(angle) < 360) {\n      // we need to recreate the side with capped points where applicable\n      const sideShape = fromPoints(shapePoints);\n      const endMatrix = Matrix4.rotationX(90).multiply(\n        Matrix4.rotationZ(-startAngle)\n      );\n      const endCap = sideShape\n        ._toPlanePolygons({ flipped: flipped })\n        .map((x) => x.transform(endMatrix));\n\n      const startMatrix = Matrix4.rotationX(90).multiply(\n        Matrix4.rotationZ(-angle - startAngle)\n      );\n      const startCap = sideShape\n        ._toPlanePolygons({ flipped: !flipped })\n        .map((x) => x.transform(startMatrix));\n      polygons = polygons.concat(endCap).concat(startCap);\n    }\n  }\n  return fromPolygons(polygons).reTesselated().canonicalized();\n}\n\n/** rectangular extrusion of the given array of points\n * @param {Array} basePoints array of points (nested) to extrude from\n * layed out like [ [0,0], [10,0], [5,10], [0,10] ]\n * @param {Object} [options] - options for construction\n * @param {Float} [options.h=1] - height of the extruded shape\n * @param {Float} [options.w=10] - width of the extruded shape\n * @param {Integer} [options.fn=1] - resolution/number of segments of the extrusion\n * @param {Boolean} [options.closed=false] - whether to close the input path for the extrusion or not\n * @param {Boolean} [options.round=true] - whether to round the extrusion or not\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = rectangular_extrude({height: 10}, square())\n */\nfunction rectangular_extrude(basePoints, params) {\n  const defaults = {\n    w: 1,\n    h: 1,\n    fn: 8,\n    closed: false,\n    round: true,\n  };\n  const { w, h, fn, closed, round } = Object.assign({}, defaults, params);\n  return new Path2D(basePoints, closed).rectangularExtrude(w, h, fn, round);\n}\n\nmodule.exports = {\n  extrudeInOrthonormalBasis,\n  extrudeInPlane,\n  extrude,\n  linear_extrude,\n  rotate_extrude,\n  rotateExtrude,\n  rectangular_extrude,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL29wcy1leHRydXNpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2FwaS9vcHMtZXh0cnVzaW9ucy5qcz9hYjg3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgRVBTLCBkZWZhdWx0UmVzb2x1dGlvbjNEIH0gPSByZXF1aXJlKCcuLi9jb3JlL2NvbnN0YW50cycpO1xuY29uc3QgT3J0aG9Ob3JtYWxCYXNpcyA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9PcnRob05vcm1hbEJhc2lzJyk7XG5jb25zdCB7XG4gIHBhcnNlT3B0aW9uQXMzRFZlY3RvcixcbiAgcGFyc2VPcHRpb25Bc0Jvb2wsXG4gIHBhcnNlT3B0aW9uQXNGbG9hdCxcbiAgcGFyc2VPcHRpb25Bc0ludCxcbn0gPSByZXF1aXJlKCcuL29wdGlvblBhcnNlcnMnKTtcbmNvbnN0IFZlY3RvcjNEID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1ZlY3RvcjMnKTtcbmNvbnN0IE1hdHJpeDQgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvTWF0cml4NCcpO1xuY29uc3QgUGF0aDJEID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1BhdGgyJyk7XG5jb25zdCB7IENvbm5lY3RvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9jb25uZWN0b3JzJyk7XG5jb25zdCB7IGZyb21Qb2x5Z29ucyB9ID0gcmVxdWlyZSgnLi4vY29yZS9DU0dGYWN0b3JpZXMnKTtcbmNvbnN0IHtcbiAgY2FnVG9Qb2ludHNBcnJheSxcbiAgY2xhbXAsXG4gIHJpZ2h0TXVsdGlwbHkxeDNWZWN0b3JUb0FycmF5LFxuICBwb2x5Z29uRnJvbVBvaW50cyxcbn0gPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcbmNvbnN0IHsgZnJvbVBvaW50cyB9ID0gcmVxdWlyZSgnLi4vY29yZS9DQUdGYWN0b3JpZXMnKTtcblxuLyoqIGV4dHJ1ZGUgdGhlIENBRyBpbiBhIGNlcnRhaW4gcGxhbmUuXG4gKiBHaXZpbmcganVzdCBhIHBsYW5lIGlzIG5vdCBlbm91Z2gsIG11bHRpcGxlIGRpZmZlcmVudCBleHRydXNpb25zIGluIHRoZSBzYW1lIHBsYW5lIHdvdWxkIGJlIHBvc3NpYmxlXG4gKiBieSByb3RhdGluZyBhcm91bmQgdGhlIHBsYW5lJ3Mgb3JpZ2luLiBBbiBhZGRpdGlvbmFsIHJpZ2h0LWhhbmQgdmVjdG9yIHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgd2VsbCxcbiAqIGFuZCB0aGlzIGlzIGV4YWN0bHkgYSBPcnRob05vcm1hbEJhc2lzLlxuICogQHBhcmFtICB7Q0FHfSBjYWcgdGhlIGNhZyB0byBleHRydWRlXG4gKiBAcGFyYW0gIHtPcnRob25vcm1hbGJhc2lzfSBvcnRob25vcm1hbGJhc2lzIGNoYXJhY3Rlcml6ZXMgdGhlIHBsYW5lIGluIHdoaWNoIHRvIGV4dHJ1ZGVcbiAqIEBwYXJhbSAge0Zsb2F0fSBkZXB0aCB0aGlja25lc3Mgb2YgdGhlIGV4dHJ1ZGVkIHNoYXBlLiBFeHRydXNpb24gaXMgZG9uZSB1cHdhcmRzIGZyb20gdGhlIHBsYW5lXG4gKiAgKHVubGVzcyBzeW1tZXRyaWNhbCBvcHRpb24gaXMgc2V0LCBzZWUgYmVsb3cpXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zeW1tZXRyaWNhbD10cnVlXSAtIGV4dHJ1ZGUgc3ltbWV0cmljYWxseSBpbiB0d28gZGlyZWN0aW9ucyBhYm91dCB0aGUgcGxhbmVcbiAqL1xuY29uc3QgZXh0cnVkZUluT3J0aG9ub3JtYWxCYXNpcyA9IGZ1bmN0aW9uIChcbiAgY2FnLFxuICBvcnRob25vcm1hbGJhc2lzLFxuICBkZXB0aCxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIGZpcnN0IGV4dHJ1ZGUgaW4gdGhlIHJlZ3VsYXIgWiBwbGFuZTpcbiAgaWYgKCEob3J0aG9ub3JtYWxiYXNpcyBpbnN0YW5jZW9mIE9ydGhvTm9ybWFsQmFzaXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2V4dHJ1ZGVJblBsYW5lOiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBhIE9ydGhvTm9ybWFsQmFzaXMnXG4gICAgKTtcbiAgfVxuICBsZXQgZXh0cnVkZWQgPSBjYWcuZXh0cnVkZSh7XG4gICAgb2Zmc2V0OiBbMCwgMCwgZGVwdGhdLFxuICB9KTtcbiAgaWYgKHBhcnNlT3B0aW9uQXNCb29sKG9wdGlvbnMsICdzeW1tZXRyaWNhbCcsIGZhbHNlKSkge1xuICAgIGV4dHJ1ZGVkID0gZXh0cnVkZWQudHJhbnNsYXRlKFswLCAwLCAtZGVwdGggLyAyXSk7XG4gIH1cbiAgbGV0IG1hdHJpeCA9IG9ydGhvbm9ybWFsYmFzaXMuZ2V0SW52ZXJzZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgZXh0cnVkZWQgPSBleHRydWRlZC50cmFuc2Zvcm0obWF0cml4KTtcbiAgcmV0dXJuIGV4dHJ1ZGVkO1xufTtcblxuLyoqIEV4dHJ1ZGUgaW4gYSBzdGFuZGFyZCBjYXJ0ZXNpYW4gcGxhbmUsIHNwZWNpZmllZCBieSB0d28gYXhpcyBpZGVudGlmaWVycy4gRWFjaCBpZGVudGlmaWVyIGNhbiBiZVxuICogb25lIG9mIFtcIlhcIixcIllcIixcIlpcIixcIi1YXCIsXCItWVwiLFwiLVpcIl1cbiAqIFRoZSAyZCB4IGF4aXMgd2lsbCBtYXAgdG8gdGhlIGZpcnN0IGdpdmVuIDNEIGF4aXMsIHRoZSAyZCB5IGF4aXMgd2lsbCBtYXAgdG8gdGhlIHNlY29uZC5cbiAqIFNlZSBPcnRob05vcm1hbEJhc2lzLkdldENhcnRlc2lhbiBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSAge0NBR30gY2FnIHRoZSBjYWcgdG8gZXh0cnVkZVxuICogQHBhcmFtICB7U3RyaW5nfSBheGlzMSB0aGUgZmlyc3QgYXhpc1xuICogQHBhcmFtICB7U3RyaW5nfSBheGlzMiB0aGUgc2Vjb25kIGF4aXNcbiAqIEBwYXJhbSAge0Zsb2F0fSBkZXB0aCB0aGlja25lc3Mgb2YgdGhlIGV4dHJ1ZGVkIHNoYXBlLiBFeHRydXNpb24gaXMgZG9uZSB1cHdhcmRzIGZyb20gdGhlIHBsYW5lXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zeW1tZXRyaWNhbD10cnVlXSAtIGV4dHJ1ZGUgc3ltbWV0cmljYWxseSBpbiB0d28gZGlyZWN0aW9ucyBhYm91dCB0aGUgcGxhbmVcbiAqL1xuY29uc3QgZXh0cnVkZUluUGxhbmUgPSBmdW5jdGlvbiAoY2FnLCBheGlzMSwgYXhpczIsIGRlcHRoLCBvcHRpb25zKSB7XG4gIHJldHVybiBleHRydWRlSW5PcnRob25vcm1hbEJhc2lzKFxuICAgIGNhZyxcbiAgICBPcnRob05vcm1hbEJhc2lzLkdldENhcnRlc2lhbihheGlzMSwgYXhpczIpLFxuICAgIGRlcHRoLFxuICAgIG9wdGlvbnNcbiAgKTtcbn07XG5cbi8qKiBsaW5lYXIgZXh0cnVzaW9uIG9mIDJEIHNoYXBlLCB3aXRoIG9wdGlvbmFsIHR3aXN0XG4gKiBAcGFyYW0gIHtDQUd9IGNhZyB0aGUgY2FnIHRvIGV4dHJ1ZGVcbiAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vZmZzZXQ9WzAsMCwxXV0gLSBUaGUgMmQgc2hhcGUgaXMgcGxhY2VkIGluIGluIHo9MCBwbGFuZSBhbmQgZXh0cnVkZWQgaW50byBkaXJlY3Rpb24gPG9mZnNldD5cbiAqIChhIDNEIHZlY3RvciBhcyBhIDMgY29tcG9uZW50IGFycmF5KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50d2lzdHN0ZXBzPWRlZmF1bHRSZXNvbHV0aW9uM0RdIC0gdHdpc3RzdGVwcyBkZXRlcm1pbmVzIHRoZSByZXNvbHV0aW9uIG9mIHRoZSB0d2lzdCAoc2hvdWxkIGJlID49IDEpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnR3aXN0YW5nbGU9MF0gLSB0d2lzdGFuZ2xlIFRoZSBmaW5hbCBmYWNlIGlzIHJvdGF0ZWQgPHR3aXN0YW5nbGU+IGRlZ3JlZXMuIFJvdGF0aW9uIGlzIGRvbmUgYXJvdW5kIHRoZSBvcmlnaW4gb2YgdGhlIDJkIHNoYXBlIChpLmUuIHg9MCwgeT0wKVxuICogQHJldHVybnMge0NTR30gdGhlIGV4dHJ1ZGUgc2hhcGUsIGFzIGEgQ1NHIG9iamVjdFxuICogQGV4YW1wbGUgZXh0cnVkZWQ9Y2FnLmV4dHJ1ZGUoe29mZnNldDogWzAsMCwxMF0sIHR3aXN0YW5nbGU6IDM2MCwgdHdpc3RzdGVwczogMTAwfSk7XG4gKi9cbmNvbnN0IGV4dHJ1ZGUgPSBmdW5jdGlvbiAoY2FnLCBvcHRpb25zKSB7XG4gIGNvbnN0IENTRyA9IHJlcXVpcmUoJy4uL2NvcmUvQ1NHJyk7IC8vIEZJWE1FOiBjaXJjdWxhciBkZXBlbmRlbmNpZXMgQ0FHPT5DU0c9PkNBR1xuICBpZiAoY2FnLnNpZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGVtcHR5ISA6IEZJWE1FOiBzaG91bGQgdGhpcyB0aHJvdyA/XG4gICAgcmV0dXJuIG5ldyBDU0coKTtcbiAgfVxuICBsZXQgb2Zmc2V0VmVjdG9yID0gcGFyc2VPcHRpb25BczNEVmVjdG9yKG9wdGlvbnMsICdvZmZzZXQnLCBbMCwgMCwgMV0pO1xuICBsZXQgdHdpc3RhbmdsZSA9IHBhcnNlT3B0aW9uQXNGbG9hdChvcHRpb25zLCAndHdpc3RhbmdsZScsIDApO1xuICBsZXQgdHdpc3RzdGVwcyA9IHBhcnNlT3B0aW9uQXNJbnQob3B0aW9ucywgJ3R3aXN0c3RlcHMnLCBkZWZhdWx0UmVzb2x1dGlvbjNEKTtcbiAgaWYgKG9mZnNldFZlY3Rvci56ID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvZmZzZXQgY2Fubm90IGJlIG9ydGhvZ29uYWwgdG8gWiBheGlzJyk7XG4gIH1cbiAgaWYgKHR3aXN0YW5nbGUgPT09IDAgfHwgdHdpc3RzdGVwcyA8IDEpIHtcbiAgICB0d2lzdHN0ZXBzID0gMTtcbiAgfVxuICBsZXQgbm9ybWFsVmVjdG9yID0gVmVjdG9yM0QuQ3JlYXRlKDAsIDEsIDApO1xuXG4gIGxldCBwb2x5Z29ucyA9IFtdO1xuICAvLyBib3R0b20gYW5kIHRvcFxuICBwb2x5Z29ucyA9IHBvbHlnb25zLmNvbmNhdChcbiAgICBjYWcuX3RvUGxhbmVQb2x5Z29ucyh7XG4gICAgICB0cmFuc2xhdGlvbjogWzAsIDAsIDBdLFxuICAgICAgbm9ybWFsVmVjdG9yOiBub3JtYWxWZWN0b3IsXG4gICAgICBmbGlwcGVkOiAhKG9mZnNldFZlY3Rvci56IDwgMCksXG4gICAgfSlcbiAgKTtcbiAgcG9seWdvbnMgPSBwb2x5Z29ucy5jb25jYXQoXG4gICAgY2FnLl90b1BsYW5lUG9seWdvbnMoe1xuICAgICAgdHJhbnNsYXRpb246IG9mZnNldFZlY3RvcixcbiAgICAgIG5vcm1hbFZlY3Rvcjogbm9ybWFsVmVjdG9yLnJvdGF0ZVoodHdpc3RhbmdsZSksXG4gICAgICBmbGlwcGVkOiBvZmZzZXRWZWN0b3IueiA8IDAsXG4gICAgfSlcbiAgKTtcbiAgLy8gd2FsbHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0d2lzdHN0ZXBzOyBpKyspIHtcbiAgICBsZXQgYzEgPSBuZXcgQ29ubmVjdG9yKFxuICAgICAgb2Zmc2V0VmVjdG9yLnRpbWVzKGkgLyB0d2lzdHN0ZXBzKSxcbiAgICAgIFswLCAwLCBvZmZzZXRWZWN0b3Iuel0sXG4gICAgICBub3JtYWxWZWN0b3Iucm90YXRlWigoaSAqIHR3aXN0YW5nbGUpIC8gdHdpc3RzdGVwcylcbiAgICApO1xuICAgIGxldCBjMiA9IG5ldyBDb25uZWN0b3IoXG4gICAgICBvZmZzZXRWZWN0b3IudGltZXMoKGkgKyAxKSAvIHR3aXN0c3RlcHMpLFxuICAgICAgWzAsIDAsIG9mZnNldFZlY3Rvci56XSxcbiAgICAgIG5vcm1hbFZlY3Rvci5yb3RhdGVaKCgoaSArIDEpICogdHdpc3RhbmdsZSkgLyB0d2lzdHN0ZXBzKVxuICAgICk7XG4gICAgcG9seWdvbnMgPSBwb2x5Z29ucy5jb25jYXQoXG4gICAgICBjYWcuX3RvV2FsbFBvbHlnb25zKHsgdG9Db25uZWN0b3IxOiBjMSwgdG9Db25uZWN0b3IyOiBjMiB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZnJvbVBvbHlnb25zKHBvbHlnb25zKTtcbn07XG5cbi8vIFRISVMgSVMgQU4gT0xEIHVudGVzdGVkICEhISB2ZXJzaW9uIG9mIHJvdGF0ZSBleHRydWRlXG4vKiogRXh0cnVkZSB0byBpbnRvIGEgM0Qgc29saWQgYnkgcm90YXRpbmcgdGhlIG9yaWdpbiBhcm91bmQgdGhlIFkgYXhpcy5cbiAqIChhbmQgdHVybmluZyBldmVyeXRoaW5nIGludG8gWFkgcGxhbmUpXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlPTM2MF0gLSBhbmdsZSBvZiByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249ZGVmYXVsdFJlc29sdXRpb24zRF0gLSBudW1iZXIgb2YgcG9seWdvbnMgcGVyIDM2MCBkZWdyZWUgcmV2b2x1dGlvblxuICogQHJldHVybnMge0NTR30gbmV3IDNEIHNvbGlkXG4gKi9cbmNvbnN0IHJvdGF0ZUV4dHJ1ZGUgPSBmdW5jdGlvbiAoY2FnLCBvcHRpb25zKSB7XG4gIC8vIEZJWE1FIG9wdGlvbnMgc2hvdWxkIGJlIG9wdGlvbmFsXG4gIGxldCBhbHBoYSA9IHBhcnNlT3B0aW9uQXNGbG9hdChvcHRpb25zLCAnYW5nbGUnLCAzNjApO1xuICBsZXQgcmVzb2x1dGlvbiA9IHBhcnNlT3B0aW9uQXNJbnQob3B0aW9ucywgJ3Jlc29sdXRpb24nLCBkZWZhdWx0UmVzb2x1dGlvbjNEKTtcblxuICBhbHBoYSA9IGFscGhhID4gMzYwID8gYWxwaGEgJSAzNjAgOiBhbHBoYTtcbiAgbGV0IG9yaWdpbiA9IFswLCAwLCAwXTtcbiAgbGV0IGF4aXNWID0gVmVjdG9yM0QuQ3JlYXRlKDAsIDEsIDApO1xuICBsZXQgbm9ybWFsViA9IFswLCAwLCAxXTtcbiAgbGV0IHBvbHlnb25zID0gW107XG4gIC8vIHBsYW5lcyBvbmx5IG5lZWRlZCBpZiBhbHBoYSA+IDBcbiAgbGV0IGNvbm5TID0gbmV3IENvbm5lY3RvcihvcmlnaW4sIGF4aXNWLCBub3JtYWxWKTtcbiAgaWYgKGFscGhhID4gMCAmJiBhbHBoYSA8IDM2MCkge1xuICAgIC8vIHdlIG5lZWQgdG8gcm90YXRlIG5lZ2F0aXZlIHRvIHNhdGlzZnkgd2FsbCBmdW5jdGlvbiBjb25kaXRpb24gb2ZcbiAgICAvLyBidWlsZGluZyBpbiB0aGUgZGlyZWN0aW9uIG9mIGF4aXMgdmVjdG9yXG4gICAgbGV0IGNvbm5FID0gbmV3IENvbm5lY3RvcihvcmlnaW4sIGF4aXNWLnJvdGF0ZVooLWFscGhhKSwgbm9ybWFsVik7XG4gICAgcG9seWdvbnMgPSBwb2x5Z29ucy5jb25jYXQoXG4gICAgICBjYWcuX3RvUGxhbmVQb2x5Z29ucyh7IHRvQ29ubmVjdG9yOiBjb25uUywgZmxpcHBlZDogdHJ1ZSB9KVxuICAgICk7XG4gICAgcG9seWdvbnMgPSBwb2x5Z29ucy5jb25jYXQoY2FnLl90b1BsYW5lUG9seWdvbnMoeyB0b0Nvbm5lY3RvcjogY29ubkUgfSkpO1xuICB9XG4gIGxldCBjb25uVDEgPSBjb25uUztcbiAgbGV0IGNvbm5UMjtcbiAgbGV0IHN0ZXAgPSBhbHBoYSAvIHJlc29sdXRpb247XG4gIGZvciAobGV0IGEgPSBzdGVwOyBhIDw9IGFscGhhICsgRVBTOyBhICs9IHN0ZXApIHtcbiAgICAvLyBGSVhNRSBTaG91bGQgdGhpcyBiZSBhbmdlbEVQUz9cbiAgICBjb25uVDIgPSBuZXcgQ29ubmVjdG9yKG9yaWdpbiwgYXhpc1Yucm90YXRlWigtYSksIG5vcm1hbFYpO1xuICAgIHBvbHlnb25zID0gcG9seWdvbnMuY29uY2F0KFxuICAgICAgY2FnLl90b1dhbGxQb2x5Z29ucyh7IHRvQ29ubmVjdG9yMTogY29ublQxLCB0b0Nvbm5lY3RvcjI6IGNvbm5UMiB9KVxuICAgICk7XG4gICAgY29ublQxID0gY29ublQyO1xuICB9XG4gIHJldHVybiBmcm9tUG9seWdvbnMocG9seWdvbnMpLnJlVGVzc2VsYXRlZCgpO1xufTtcblxuLy8gRklYTUU6IHJpZ2h0IG5vdyBsaW5lYXIgJiByb3RhdGUgZXh0cnVkZSB0YWtlIHBhcmFtcyBmaXJzdCwgd2hpbGUgcmVjdGFuZ3VsYXJfZXh0cnVkZVxuLy8gdGFrZXMgcGFyYW1zIHNlY29uZCAhIGNvbmZ1c2luZyBhbmQgaW5jb2hlcmVudCAhIG5lZWRzIHRvIGJlIGNoYW5nZWQgKEJSRUFLSU5HIENIQU5HRSAhKVxuXG4vKiogbGluZWFyIGV4dHJ1c2lvbiBvZiB0aGUgaW5wdXQgMmQgc2hhcGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBjb25zdHJ1Y3Rpb25cbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmhlaWdodD0xXSAtIGhlaWdodCBvZiB0aGUgZXh0cnVkZWQgc2hhcGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuc2xpY2VzPTEwXSAtIG51bWJlciBvZiBpbnRlcm1lZGlhcnkgc3RlcHMvc2xpY2VzXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLnR3aXN0PTBdIC0gYW5nbGUgKGluIGRlZ3JlZXMgdG8gdHdpc3QgdGhlIGV4dHVzaW9uIGJ5KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jZW50ZXI9ZmFsc2VdIC0gd2hldGhlciB0byBjZW50ZXIgZXh0cnVzaW9uIG9yIG5vdFxuICogQHBhcmFtIHtDQUd9IGJhc2VTaGFwZSBpbnB1dCAyZCBzaGFwZVxuICogQHJldHVybnMge0NTR30gbmV3IGV4dHJ1ZGVkIHNoYXBlXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByZXZvbHZlZCA9IGxpbmVhcl9leHRydWRlKHtoZWlnaHQ6IDEwfSwgc3F1YXJlKCkpXG4gKi9cbmZ1bmN0aW9uIGxpbmVhcl9leHRydWRlKHBhcmFtcywgYmFzZVNoYXBlKSB7XG4gIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGhlaWdodDogMSxcbiAgICBzbGljZXM6IDEwLFxuICAgIHR3aXN0OiAwLFxuICAgIGNlbnRlcjogZmFsc2UsXG4gIH07XG4gIC8qIGNvbnZleGl0eSA9IDEwLCAqL1xuICBjb25zdCB7IGhlaWdodCwgdHdpc3QsIHNsaWNlcywgY2VudGVyIH0gPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcblxuICAvLyBpZihwYXJhbXMuY29udmV4aXR5KSBjb252ZXhpdHkgPSBwYXJhbXMuY29udmV4aXR5ICAgICAgLy8gYWJhbmRvbmVkXG4gIGxldCBvdXRwdXQgPSBiYXNlU2hhcGUuZXh0cnVkZSh7XG4gICAgb2Zmc2V0OiBbMCwgMCwgaGVpZ2h0XSxcbiAgICB0d2lzdGFuZ2xlOiB0d2lzdCxcbiAgICB0d2lzdHN0ZXBzOiBzbGljZXMsXG4gIH0pO1xuICBpZiAoY2VudGVyID09PSB0cnVlKSB7XG4gICAgY29uc3QgYiA9IG91dHB1dC5nZXRCb3VuZHMoKTsgLy8gYlswXSA9IG1pbiwgYlsxXSA9IG1heFxuICAgIGNvbnN0IG9mZnNldCA9IGJbMV0ucGx1cyhiWzBdKS50aW1lcygtMC41KTtcbiAgICBvdXRwdXQgPSBvdXRwdXQudHJhbnNsYXRlKG9mZnNldCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqIHJvdGF0ZSBleHRydXNpb24gLyByZXZvbHZlIG9mIHRoZSBnaXZlbiAyZCBzaGFwZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5mbj0xXSAtIHJlc29sdXRpb24vbnVtYmVyIG9mIHNlZ21lbnRzIG9mIHRoZSBleHRydXNpb25cbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLnN0YXJ0QW5nbGU9MV0gLSBzdGFydCBhbmdsZSBvZiB0aGUgZXh0cnVzaW9uLCBpbiBkZWdyZWVzXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5hbmdsZT0xXSAtIGFuZ2xlIG9mIHRoZSBleHRydXNpb24sIGluIGRlZ3JlZXNcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLm92ZXJmbG93PSdjYXAnXSAtIHdoYXQgdG8gZG8gd2l0aCBwb2ludHMgb3V0c2lkZSBvZiBib3VuZHMgKCsgLyAtIHgpIDpcbiAqIGRlZmF1bHRzIHRvIGNhcHBpbmcgdGhvc2UgcG9pbnRzIHRvIDAgKG9ubHkgc3VwcG9ydGVkIGJlaGF2aW91ciBmb3Igbm93KVxuICogQHBhcmFtIHtDQUd9IGJhc2VTaGFwZSBpbnB1dCAyZCBzaGFwZVxuICogQHJldHVybnMge0NTR30gbmV3IGV4dHJ1ZGVkIHNoYXBlXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByZXZvbHZlZCA9IHJvdGF0ZV9leHRydWRlKHtmbjogMTB9LCBzcXVhcmUoKSlcbiAqL1xuZnVuY3Rpb24gcm90YXRlX2V4dHJ1ZGUocGFyYW1zLCBiYXNlU2hhcGUpIHtcbiAgLy8gbm90ZSwgd2Ugc2hvdWxkIHBlcmhhcHMgYWxpYXMgdGhpcyB0byByZXZvbHZlKCkgYXMgd2VsbFxuICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICBmbjogMzIsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgICBhbmdsZTogMzYwLFxuICAgIG92ZXJmbG93OiAnY2FwJyxcbiAgfTtcbiAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gIGxldCB7IGZuLCBzdGFydEFuZ2xlLCBhbmdsZSwgb3ZlcmZsb3cgfSA9IHBhcmFtcztcbiAgaWYgKG92ZXJmbG93ICE9PSAnY2FwJykge1xuICAgIHRocm93IG5ldyBFcnJvcignb25seSBjYXBwaW5nIG9mIG92ZXJmbG93aW5nIHBvaW50cyBpcyBzdXBwb3J0ZWQgIScpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgLy8gRklYTUU6IHdoYXQgdGhlIGhlbGwgPz8/IGp1c3QgcHV0IHBhcmFtcyBzZWNvbmQgIVxuICAgIGJhc2VTaGFwZSA9IHBhcmFtcztcbiAgfVxuICAvLyBhcmUgd2UgZGVhbGluZyB3aXRoIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgYW5nbGUgKGZvciBub3JtYWxzIGZsaXBwaW5nKVxuICBjb25zdCBmbGlwcGVkID0gYW5nbGUgPiAwO1xuICAvLyBsaW1pdCBhY3R1YWwgYW5nbGUgYmV0d2VlbiAwICYgMzYwLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICBjb25zdCB0b3RhbEFuZ2xlID0gZmxpcHBlZFxuICAgID8gY2xhbXAoc3RhcnRBbmdsZSArIGFuZ2xlLCAwLCAzNjApXG4gICAgOiBjbGFtcChzdGFydEFuZ2xlICsgYW5nbGUsIC0zNjAsIDApO1xuICAvLyBhZGFwdCB0byB0aGUgdG90YWxBbmdsZSA6IDEgZXh0cmEgc2VnbWVudCBwZXIgNDUgZGVncyBpZiBub3QgMzYwIGRlZyBleHRydXNpb25cbiAgLy8gbmVlZHMgdG8gYmUgYXQgbGVhc3Qgb25lIGFuZCBoaWdoZXIgdGhlbiB0aGUgaW5wdXQgcmVzb2x1dGlvblxuICBjb25zdCBzZWdtZW50cyA9IE1hdGgubWF4KE1hdGguZmxvb3IoTWF0aC5hYnModG90YWxBbmdsZSkgLyA0NSksIDEsIGZuKTtcbiAgLy8gbWF4aW11bSBkaXN0YW5jZSBwZXIgYXhpcyBiZXR3ZWVuIHR3byBwb2ludHMgYmVmb3JlIGNvbnNpZGVyaW5nIHRoZW0gdG8gYmUgdGhlIHNhbWVcbiAgY29uc3Qgb3ZlcmxhcFRvbGVyYW5jZSA9IDAuMDAwMDE7XG4gIC8vIGNvbnZlcnQgYmFzZXNoYXBlIHRvIGp1c3QgYW4gYXJyYXkgb2YgcG9pbnRzLCBlYXNpZXIgdG8gZGVhbCB3aXRoXG4gIGxldCBzaGFwZVBvaW50cyA9IGNhZ1RvUG9pbnRzQXJyYXkoYmFzZVNoYXBlKTtcblxuICAvLyBkZXRlcm1pbmUgaWYgdGhlIHJvdGF0ZV9leHRydWRlIGNhbiBiZSBjb21wdXRlZCBpbiB0aGUgZmlyc3QgcGxhY2VcbiAgLy8gaWUgYWxsIHRoZSBwb2ludHMgaGF2ZSB0byBiZSBlaXRoZXIgeCA+IDAgb3IgeCA8IDBcblxuICAvLyBnZW5lcmljIHNvbHV0aW9uIHRvIGFsd2F5cyBoYXZlIGEgdmFsaWQgc29saWQsIGV2ZW4gaWYgcG9pbnRzIGdvIGJleW9uZCB4LyAteFxuICAvLyAxLiBzcGxpdCBwb2ludHMgdXAgYmV0d2VlbiBhbGwgdGhvc2Ugb24gdGhlICdsZWZ0JyBzaWRlIG9mIHRoZSBheGlzICh4PDApICYgdGhvc2Ugb24gdGhlICdyaWdoJyAoeD4wKVxuICAvLyAyLiBmb3IgZWFjaCBzZXQgb2YgcG9pbnRzIGRvIHRoZSBleHRydXNpb24gb3BlcmF0aW9uIElOIE9QT1NJVEUgRElSRUNUSU9OU1xuICAvLyAzLiB1bmlvbiB0aGUgdHdvIHJlc3VsdGluZyBzb2xpZHNcblxuICAvLyAxLiBhbHQgOiBPUiA6IGp1c3QgY2FwIG9mIHBvaW50cyBhdCB0aGUgYXhpcyA/XG5cbiAgLy8gY29uc29sZS5sb2coJ3NoYXBlUG9pbnRzIEJFRk9SRScsIHNoYXBlUG9pbnRzLCBiYXNlU2hhcGUuc2lkZXMpXG5cbiAgY29uc3QgcG9pbnRzV2l0aE5lZ2F0aXZlWCA9IHNoYXBlUG9pbnRzLmZpbHRlcigoeCkgPT4geFswXSA8IDApO1xuICBjb25zdCBwb2ludHNXaXRoUG9zaXRpdmVYID0gc2hhcGVQb2ludHMuZmlsdGVyKCh4KSA9PiB4WzBdID49IDApO1xuICBjb25zdCBhcmVQb2ludHNXaXRoTmVnQW5kUG9zWCA9XG4gICAgcG9pbnRzV2l0aE5lZ2F0aXZlWC5sZW5ndGggPiAwICYmIHBvaW50c1dpdGhQb3NpdGl2ZVgubGVuZ3RoID4gMDtcblxuICBpZiAoYXJlUG9pbnRzV2l0aE5lZ0FuZFBvc1ggJiYgb3ZlcmZsb3cgPT09ICdjYXAnKSB7XG4gICAgaWYgKHBvaW50c1dpdGhOZWdhdGl2ZVgubGVuZ3RoID4gcG9pbnRzV2l0aFBvc2l0aXZlWC5sZW5ndGgpIHtcbiAgICAgIHNoYXBlUG9pbnRzID0gc2hhcGVQb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gW01hdGgubWluKHBvaW50WzBdLCAwKSwgcG9pbnRbMV1dO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNXaXRoUG9zaXRpdmVYLmxlbmd0aCA+PSBwb2ludHNXaXRoTmVnYXRpdmVYLmxlbmd0aCkge1xuICAgICAgc2hhcGVQb2ludHMgPSBzaGFwZVBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5tYXgocG9pbnRbMF0sIDApLCBwb2ludFsxXV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZygnbmVnWHMnLCBwb2ludHNXaXRoTmVnYXRpdmVYLCAncG9pbnRzV2l0aFBvc2l0aXZlWCcsIHBvaW50c1dpdGhQb3NpdGl2ZVgsICdhcmVQb2ludHNXaXRoTmVnQW5kUG9zWCcsIGFyZVBvaW50c1dpdGhOZWdBbmRQb3NYKVxuICAvLyAgY29uc29sZS5sb2coJ3NoYXBlUG9pbnRzIEFGVEVSJywgc2hhcGVQb2ludHMsIGJhc2VTaGFwZS5zaWRlcylcblxuICBsZXQgcG9seWdvbnMgPSBbXTtcblxuICAvLyBmb3IgZWFjaCBvZiB0aGUgaW50ZXJtZWRpYXJ5IHN0ZXBzIGluIHRoZSBleHRydXNpb25cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWdtZW50cyArIDE7IGkrKykge1xuICAgIC8vIGZvciBlYWNoIHNpZGUgb2YgdGhlIDJkIHNoYXBlXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFwZVBvaW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgIC8vIDIgcG9pbnRzIG9mIGEgc2lkZVxuICAgICAgY29uc3QgY3VyUG9pbnQgPSBzaGFwZVBvaW50c1tqXTtcbiAgICAgIGNvbnN0IG5leHRQb2ludCA9IHNoYXBlUG9pbnRzW2ogKyAxXTtcblxuICAgICAgLy8gY29tcHV0ZSBtYXRyaXggZm9yIGN1cnJlbnQgYW5kIG5leHQgc2VnbWVudCBhbmdsZVxuICAgICAgbGV0IHByZXZNYXRyaXggPSBNYXRyaXg0LnJvdGF0aW9uWihcbiAgICAgICAgKChpIC0gMSkgLyBzZWdtZW50cykgKiBhbmdsZSArIHN0YXJ0QW5nbGVcbiAgICAgICk7XG4gICAgICBsZXQgY3VyTWF0cml4ID0gTWF0cml4NC5yb3RhdGlvblooKGkgLyBzZWdtZW50cykgKiBhbmdsZSArIHN0YXJ0QW5nbGUpO1xuXG4gICAgICBjb25zdCBwb2ludEEgPSByaWdodE11bHRpcGx5MXgzVmVjdG9yVG9BcnJheShwcmV2TWF0cml4LCBbXG4gICAgICAgIGN1clBvaW50WzBdLFxuICAgICAgICAwLFxuICAgICAgICBjdXJQb2ludFsxXSxcbiAgICAgIF0pO1xuICAgICAgY29uc3QgcG9pbnRBUCA9IHJpZ2h0TXVsdGlwbHkxeDNWZWN0b3JUb0FycmF5KGN1ck1hdHJpeCwgW1xuICAgICAgICBjdXJQb2ludFswXSxcbiAgICAgICAgMCxcbiAgICAgICAgY3VyUG9pbnRbMV0sXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IHBvaW50QiA9IHJpZ2h0TXVsdGlwbHkxeDNWZWN0b3JUb0FycmF5KHByZXZNYXRyaXgsIFtcbiAgICAgICAgbmV4dFBvaW50WzBdLFxuICAgICAgICAwLFxuICAgICAgICBuZXh0UG9pbnRbMV0sXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IHBvaW50QlAgPSByaWdodE11bHRpcGx5MXgzVmVjdG9yVG9BcnJheShjdXJNYXRyaXgsIFtcbiAgICAgICAgbmV4dFBvaW50WzBdLFxuICAgICAgICAwLFxuICAgICAgICBuZXh0UG9pbnRbMV0sXG4gICAgICBdKTtcblxuICAgICAgLy8gY29uc29sZS5sb2coYHBvaW50ICR7an0gZWRnZSBjb25uZWN0aW5nICR7an0gdG8gJHtqICsgMX1gKVxuICAgICAgbGV0IG92ZXJsYXBwaW5nUG9pbnRzID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIE1hdGguYWJzKHBvaW50QVswXSAtIHBvaW50QVBbMF0pIDwgb3ZlcmxhcFRvbGVyYW5jZSAmJlxuICAgICAgICBNYXRoLmFicyhwb2ludEJbMV0gLSBwb2ludEJQWzFdKSA8IG92ZXJsYXBUb2xlcmFuY2VcbiAgICAgICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaWRlbnRpY2FsIC8gb3ZlcmxhcHBpbmcgcG9pbnRzIChmcm9tIGN1cnJlbnQgYW5nbGUgYW5kIG5leHQgb25lKSwgd2hhdCBub3cgPycpXG4gICAgICAgIG92ZXJsYXBwaW5nUG9pbnRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgZG8gbm90IGdlbmVyYXRlIGEgc2luZ2xlIHF1YWQgYmVjYXVzZTpcbiAgICAgIC8vIDEuIGl0IGRvZXMgbm90IGFsbG93IGVsaW1pbmF0aW5nIHVubmVlZGVkIHRyaWFuZ2xlcyBpbiBjYXNlIG9mIG92ZXJsYXBwaW5nIHBvaW50c1xuICAgICAgLy8gMi4gdGhlIGN1cnJlbnQgY2xlYW51cCByb3V0aW5lcyBvZiBjc2cuanMgY3JlYXRlIGRlZ2VuZXJhdGUgc2hhcGVzIGZyb20gdGhvc2UgcXVhZHNcbiAgICAgIC8vIGxldCBwb2x5UG9pbnRzID0gW3BvaW50QSwgcG9pbnRCLCBwb2ludEJQLCBwb2ludEFQXVxuICAgICAgLy8gcG9seWdvbnMucHVzaChwb2x5Z29uRnJvbVBvaW50cyhwb2x5UG9pbnRzKSlcblxuICAgICAgaWYgKGZsaXBwZWQpIHtcbiAgICAgICAgLy8gQ1dcbiAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uRnJvbVBvaW50cyhbcG9pbnRBLCBwb2ludEIsIHBvaW50QlBdKSk7XG4gICAgICAgIGlmICghb3ZlcmxhcHBpbmdQb2ludHMpIHtcbiAgICAgICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb25Gcm9tUG9pbnRzKFtwb2ludEJQLCBwb2ludEFQLCBwb2ludEFdKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENDV1xuICAgICAgICBpZiAoIW92ZXJsYXBwaW5nUG9pbnRzKSB7XG4gICAgICAgICAgcG9seWdvbnMucHVzaChwb2x5Z29uRnJvbVBvaW50cyhbcG9pbnRBLCBwb2ludEFQLCBwb2ludEJQXSkpO1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbkZyb21Qb2ludHMoW3BvaW50QlAsIHBvaW50QiwgcG9pbnRBXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB3ZSBkbyBub3QgZG8gYSBmdWxsIGV4dHJ1c2lvbiwgd2Ugd2FudCBjYXBzIGF0IGJvdGggZW5kcyAoY2xvc2VkIHZvbHVtZSlcbiAgICBpZiAoTWF0aC5hYnMoYW5nbGUpIDwgMzYwKSB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlY3JlYXRlIHRoZSBzaWRlIHdpdGggY2FwcGVkIHBvaW50cyB3aGVyZSBhcHBsaWNhYmxlXG4gICAgICBjb25zdCBzaWRlU2hhcGUgPSBmcm9tUG9pbnRzKHNoYXBlUG9pbnRzKTtcbiAgICAgIGNvbnN0IGVuZE1hdHJpeCA9IE1hdHJpeDQucm90YXRpb25YKDkwKS5tdWx0aXBseShcbiAgICAgICAgTWF0cml4NC5yb3RhdGlvblooLXN0YXJ0QW5nbGUpXG4gICAgICApO1xuICAgICAgY29uc3QgZW5kQ2FwID0gc2lkZVNoYXBlXG4gICAgICAgIC5fdG9QbGFuZVBvbHlnb25zKHsgZmxpcHBlZDogZmxpcHBlZCB9KVxuICAgICAgICAubWFwKCh4KSA9PiB4LnRyYW5zZm9ybShlbmRNYXRyaXgpKTtcblxuICAgICAgY29uc3Qgc3RhcnRNYXRyaXggPSBNYXRyaXg0LnJvdGF0aW9uWCg5MCkubXVsdGlwbHkoXG4gICAgICAgIE1hdHJpeDQucm90YXRpb25aKC1hbmdsZSAtIHN0YXJ0QW5nbGUpXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhcnRDYXAgPSBzaWRlU2hhcGVcbiAgICAgICAgLl90b1BsYW5lUG9seWdvbnMoeyBmbGlwcGVkOiAhZmxpcHBlZCB9KVxuICAgICAgICAubWFwKCh4KSA9PiB4LnRyYW5zZm9ybShzdGFydE1hdHJpeCkpO1xuICAgICAgcG9seWdvbnMgPSBwb2x5Z29ucy5jb25jYXQoZW5kQ2FwKS5jb25jYXQoc3RhcnRDYXApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbVBvbHlnb25zKHBvbHlnb25zKS5yZVRlc3NlbGF0ZWQoKS5jYW5vbmljYWxpemVkKCk7XG59XG5cbi8qKiByZWN0YW5ndWxhciBleHRydXNpb24gb2YgdGhlIGdpdmVuIGFycmF5IG9mIHBvaW50c1xuICogQHBhcmFtIHtBcnJheX0gYmFzZVBvaW50cyBhcnJheSBvZiBwb2ludHMgKG5lc3RlZCkgdG8gZXh0cnVkZSBmcm9tXG4gKiBsYXllZCBvdXQgbGlrZSBbIFswLDBdLCBbMTAsMF0sIFs1LDEwXSwgWzAsMTBdIF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBjb25zdHJ1Y3Rpb25cbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmg9MV0gLSBoZWlnaHQgb2YgdGhlIGV4dHJ1ZGVkIHNoYXBlXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy53PTEwXSAtIHdpZHRoIG9mIHRoZSBleHRydWRlZCBzaGFwZVxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5mbj0xXSAtIHJlc29sdXRpb24vbnVtYmVyIG9mIHNlZ21lbnRzIG9mIHRoZSBleHRydXNpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xvc2VkPWZhbHNlXSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIGlucHV0IHBhdGggZm9yIHRoZSBleHRydXNpb24gb3Igbm90XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJvdW5kPXRydWVdIC0gd2hldGhlciB0byByb3VuZCB0aGUgZXh0cnVzaW9uIG9yIG5vdFxuICogQHJldHVybnMge0NTR30gbmV3IGV4dHJ1ZGVkIHNoYXBlXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByZXZvbHZlZCA9IHJlY3Rhbmd1bGFyX2V4dHJ1ZGUoe2hlaWdodDogMTB9LCBzcXVhcmUoKSlcbiAqL1xuZnVuY3Rpb24gcmVjdGFuZ3VsYXJfZXh0cnVkZShiYXNlUG9pbnRzLCBwYXJhbXMpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgdzogMSxcbiAgICBoOiAxLFxuICAgIGZuOiA4LFxuICAgIGNsb3NlZDogZmFsc2UsXG4gICAgcm91bmQ6IHRydWUsXG4gIH07XG4gIGNvbnN0IHsgdywgaCwgZm4sIGNsb3NlZCwgcm91bmQgfSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICByZXR1cm4gbmV3IFBhdGgyRChiYXNlUG9pbnRzLCBjbG9zZWQpLnJlY3Rhbmd1bGFyRXh0cnVkZSh3LCBoLCBmbiwgcm91bmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXh0cnVkZUluT3J0aG9ub3JtYWxCYXNpcyxcbiAgZXh0cnVkZUluUGxhbmUsXG4gIGV4dHJ1ZGUsXG4gIGxpbmVhcl9leHRydWRlLFxuICByb3RhdGVfZXh0cnVkZSxcbiAgcm90YXRlRXh0cnVkZSxcbiAgcmVjdGFuZ3VsYXJfZXh0cnVkZSxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/ops-extrusions.js\n");

/***/ }),

/***/ "./src/api/ops-transformations.js":
/*!****************************************!*\
  !*** ./src/api/ops-transformations.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Matrix4 = __webpack_require__(/*! ../core/math/Matrix4 */ \"./src/core/math/Matrix4.js\");\nconst Plane = __webpack_require__(/*! ../core/math/Plane */ \"./src/core/math/Plane.js\");\nconst Vector3 = __webpack_require__(/*! ../core/math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst { union } = __webpack_require__(/*! ./ops-booleans */ \"./src/api/ops-booleans.js\");\nconst { fromPoints } = __webpack_require__(/*! ../core/CAGFactories */ \"./src/core/CAGFactories.js\");\nconst { isCAG } = __webpack_require__(/*! ../core/utils */ \"./src/core/utils.js\");\n// -- 3D transformations (OpenSCAD like notion)\n\n/** translate an object in 2D/3D space\n * @param {Object} vector - 3D vector to translate the given object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to translate\n * @returns {CSG} new CSG object , translated by the given amount\n *\n * @example\n * let movedSphere = translate([10,2,0], sphere())\n */\nfunction translate(vector, ...objects) {\n  // v, obj or array\n  // workaround needed to determine if we are dealing with an array of objects\n  const _objects =\n    objects.length >= 1 && objects[0].length ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) {\n      // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  return object.translate(vector);\n}\n\n/** scale an object in 2D/3D space\n * @param {Float|Array} scale - either an array or simple number to scale object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to scale\n * @returns {CSG} new CSG object , scaled by the given amount\n *\n * @example\n * let scaledSphere = scale([0.2,15,1], sphere())\n */\nfunction scale(scale, ...objects) {\n  // v, obj or array\n  const _objects =\n    objects.length >= 1 && objects[0].length ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) {\n      // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  return object.scale(scale);\n}\n\n/** rotate an object in 2D/3D space\n * @param {Float|Array} rotation - either an array or simple number to rotate object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to rotate\n * @returns {CSG} new CSG object , rotated by the given amount\n *\n * @example\n * let rotatedSphere = rotate([0.2,15,1], sphere())\n */\nfunction rotate() {\n  let o;\n  let i;\n  let v;\n  let r = 1;\n  let a = arguments;\n  if (!a[0].length) {\n    // rotate(r,[x,y,z],o)\n    r = a[0];\n    v = a[1];\n    i = 2;\n    if (a[2].length) {\n      a = a[2];\n      i = 0;\n    }\n  } else {\n    // rotate([x,y,z],o)\n    v = a[0];\n    i = 1;\n    if (a[1].length) {\n      a = a[1];\n      i = 0;\n    }\n  }\n  for (o = a[i++]; i < a.length; i++) {\n    o = o.union(a[i]);\n  }\n  if (r !== 1) {\n    return o.rotate([0, 0, 0], v, r);\n  } else {\n    return o.rotateX(v[0]).rotateY(v[1]).rotateZ(v[2]);\n  }\n}\n\n/** apply the given matrix transform to the given objects\n * @param {Array} matrix - the 4x4 matrix to apply, as a simple 1d array of 16 elements\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to transform\n * @returns {CSG} new CSG object , transformed\n *\n * @example\n * const angle = 45\n * let transformedShape = transform([\n * cos(angle), -sin(angle), 0, 10,\n * sin(angle),  cos(angle), 0, 20,\n * 0         ,           0, 1, 30,\n * 0,           0, 0,  1\n * ], sphere())\n */\nfunction transform(matrix, ...objects) {\n  // v, obj or array\n  const _objects =\n    objects.length >= 1 && objects[0].length ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) {\n      // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n\n  let transformationMatrix;\n  if (!Array.isArray(matrix)) {\n    throw new Error('Matrix needs to be an array');\n  }\n  matrix.forEach((element) => {\n    if (!Number.isFinite(element)) {\n      throw new Error(\n        'you can only use a flat array of valid, finite numbers (float and integers)'\n      );\n    }\n  });\n  transformationMatrix = new Matrix4(matrix);\n  return object.transform(transformationMatrix);\n}\n\n/**\n * Center the given object(s) about the given axes\n * @param {Array|Boolean} axes=[true,true,true]|true  - an array of boolean values that indicate the axes (X,Y,Z) to center upon. A single boolean is also allowed.\n * @param {...Object} object one or more objects to center, i.e. objects are CSG or CAG\n * @returns {CSG} new CSG object , translated by the given amount\n *\n * @example\n * let csg = center([true,false,false], sphere()) // center about the X axis\n */\nfunction center(axes, ...objects) {\n  const _objects =\n    objects.length >= 1 && objects[0].length ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) {\n      // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  if (!Array.isArray(axes)) {\n    axes = [axes, axes, axes];\n  }\n  return object.center(axes);\n}\n\n/** mirror an object in 2D/3D space\n * @param {Array} vector - the axes to mirror the object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to mirror\n * @returns {CSG} new CSG object , mirrored\n *\n * @example\n * let rotatedSphere = mirror([0.2,15,1], sphere())\n */\nfunction mirror(vector, ...objects) {\n  const _objects =\n    objects.length >= 1 && objects[0].length ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) {\n      // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  const plane = new Plane(\n    new Vector3(vector[0], vector[1], vector[2]).unit(),\n    0\n  );\n  return object.mirrored(plane);\n}\n\n/** expand an object in 2D/3D space\n * @param {float} radius - the radius to expand by\n * @param {Object} object a CSG/CAG objects to expand\n * @returns {CSG/CAG} new CSG/CAG object , expanded\n *\n * @example\n * let expanededShape = expand([0.2,15,1], sphere())\n */\nfunction expand(radius, n, object) {\n  return object.expand(radius, n);\n}\n\n/** contract an object(s) in 2D/3D space\n * @param {float} radius - the radius to contract by\n * @param {Object} object a CSG/CAG objects to contract\n * @returns {CSG/CAG} new CSG/CAG object , contracted\n *\n * @example\n * let contractedShape = contract([0.2,15,1], sphere())\n */\nfunction contract(radius, n, object) {\n  return object.contract(radius, n);\n}\n\n/** create a minkowski sum of the given shapes\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a hull around\n * @returns {CSG} new CSG object , mirrored\n *\n * @example\n * let hulled = hull(rect(), circle())\n */\nfunction minkowski() {\n  console.log('minkowski() not yet implemented');\n}\n\n/** create a convex hull of the given shapes\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a hull around\n * @returns {CSG} new CSG object , a hull around the given shapes\n *\n * @example\n * let hulled = hull(rect(), circle())\n */\nfunction hull() {\n  let pts = [];\n\n  let a = arguments;\n  if (a[0].length) a = a[0];\n  let done = [];\n\n  for (let i = 0; i < a.length; i++) {\n    // extract all points of the CAG in the argument list\n    let cag = a[i];\n    if (!isCAG(cag)) {\n      throw new Error('ERROR: hull() accepts only 2D forms / CAG');\n    }\n    for (let j = 0; j < cag.sides.length; j++) {\n      let x = cag.sides[j].vertex0.pos.x;\n      let y = cag.sides[j].vertex0.pos.y;\n      // avoid some coord to appear multiple times\n      if (done['' + x + ',' + y]) {\n        continue;\n      }\n      pts.push({ x: x, y: y });\n      done['' + x + ',' + y]++;\n      // echo(x,y);\n    }\n  }\n  // echo(pts.length+\" points in\",pts);\n\n  // from http://www.psychedelicdevelopment.com/grahamscan/\n  //    see also at https://github.com/bkiers/GrahamScan/blob/master/src/main/cg/GrahamScan.java\n  let ConvexHullPoint = function (i, a, d) {\n    this.index = i;\n    this.angle = a;\n    this.distance = d;\n\n    this.compare = function (p) {\n      if (this.angle < p.angle) {\n        return -1;\n      } else if (this.angle > p.angle) {\n        return 1;\n      } else {\n        if (this.distance < p.distance) {\n          return -1;\n        } else if (this.distance > p.distance) {\n          return 1;\n        }\n      }\n      return 0;\n    };\n  };\n\n  let ConvexHull = function () {\n    this.points = null;\n    this.indices = null;\n\n    this.getIndices = function () {\n      return this.indices;\n    };\n\n    this.clear = function () {\n      this.indices = null;\n      this.points = null;\n    };\n\n    this.ccw = function (p1, p2, p3) {\n      let ccw =\n        (this.points[p2].x - this.points[p1].x) *\n          (this.points[p3].y - this.points[p1].y) -\n        (this.points[p2].y - this.points[p1].y) *\n          (this.points[p3].x - this.points[p1].x);\n      // we need this, otherwise sorting never ends, see https://github.com/Spiritdude/OpenJSCAD.org/issues/18\n      if (ccw < 1e-5) {\n        return 0;\n      }\n      return ccw;\n    };\n\n    this.angle = function (o, a) {\n      // return Math.atan((this.points[a].y-this.points[o].y) / (this.points[a].x - this.points[o].x));\n      return Math.atan2(\n        this.points[a].y - this.points[o].y,\n        this.points[a].x - this.points[o].x\n      );\n    };\n\n    this.distance = function (a, b) {\n      return (\n        (this.points[b].x - this.points[a].x) *\n          (this.points[b].x - this.points[a].x) +\n        (this.points[b].y - this.points[a].y) *\n          (this.points[b].y - this.points[a].y)\n      );\n    };\n\n    this.compute = function (_points) {\n      this.indices = null;\n      if (_points.length < 3) {\n        return;\n      }\n      this.points = _points;\n\n      // Find the lowest point\n      let min = 0;\n      for (let i = 1; i < this.points.length; i++) {\n        if (this.points[i].y === this.points[min].y) {\n          if (this.points[i].x < this.points[min].x) {\n            min = i;\n          }\n        } else if (this.points[i].y < this.points[min].y) {\n          min = i;\n        }\n      }\n\n      // Calculate angle and distance from base\n      let al = [];\n      let ang = 0.0;\n      let dist = 0.0;\n      for (let i = 0; i < this.points.length; i++) {\n        if (i === min) {\n          continue;\n        }\n        ang = this.angle(min, i);\n        if (ang < 0) {\n          ang += Math.PI;\n        }\n        dist = this.distance(min, i);\n        al.push(new ConvexHullPoint(i, ang, dist));\n      }\n\n      al.sort(function (a, b) {\n        return a.compare(b);\n      });\n\n      // Create stack\n      let stack = new Array(this.points.length + 1);\n      let j = 2;\n      for (let i = 0; i < this.points.length; i++) {\n        if (i === min) {\n          continue;\n        }\n        stack[j] = al[j - 2].index;\n        j++;\n      }\n      stack[0] = stack[this.points.length];\n      stack[1] = min;\n\n      let tmp;\n      let M = 2;\n      for (let i = 3; i <= this.points.length; i++) {\n        while (this.ccw(stack[M - 1], stack[M], stack[i]) <= 0) {\n          M--;\n        }\n        M++;\n        tmp = stack[i];\n        stack[i] = stack[M];\n        stack[M] = tmp;\n      }\n\n      this.indices = new Array(M);\n      for (let i = 0; i < M; i++) {\n        this.indices[i] = stack[i + 1];\n      }\n    };\n  };\n\n  let hull = new ConvexHull();\n\n  hull.compute(pts);\n  let indices = hull.getIndices();\n\n  if (indices && indices.length > 0) {\n    let ch = [];\n    for (let i = 0; i < indices.length; i++) {\n      ch.push(pts[indices[i]]);\n    }\n    return fromPoints(ch);\n  }\n}\n\n/** create a chain hull of the given shapes\n * Originally \"Whosa whatsis\" suggested \"Chain Hull\" ,\n * as described at https://plus.google.com/u/0/105535247347788377245/posts/aZGXKFX1ACN\n * essentially hull A+B, B+C, C+D and then union those\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a chain hull around\n * @returns {CSG} new CSG object ,which a chain hull of the inputs\n *\n * @example\n * let hulled = chain_hull(rect(), circle())\n */\nfunction chain_hull(params, objects) {\n  /*\n  const defaults = {\n    closed: false\n  }\n  const closed = Object.assign({}, defaults, params) */\n  let a = arguments;\n  let closed = false;\n  let j = 0;\n\n  if (a[j].closed !== undefined) {\n    closed = a[j++].closed;\n  }\n\n  if (a[j].length) {\n    a = a[j];\n  }\n\n  let hulls = [];\n  let hullsAmount = a.length - (closed ? 0 : 1);\n  for (let i = 0; i < hullsAmount; i++) {\n    hulls.push(hull(a[i], a[(i + 1) % a.length]));\n  }\n  return union(hulls);\n}\n\nmodule.exports = {\n  translate,\n  center,\n  scale,\n  rotate,\n  transform,\n  mirror,\n  expand,\n  contract,\n  minkowski,\n  hull,\n  chain_hull,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL29wcy10cmFuc2Zvcm1hdGlvbnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvYXBpL29wcy10cmFuc2Zvcm1hdGlvbnMuanM/NDFmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNYXRyaXg0ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL01hdHJpeDQnKTtcbmNvbnN0IFBsYW5lID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1BsYW5lJyk7XG5jb25zdCBWZWN0b3IzID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1ZlY3RvcjMnKTtcbmNvbnN0IHsgdW5pb24gfSA9IHJlcXVpcmUoJy4vb3BzLWJvb2xlYW5zJyk7XG5jb25zdCB7IGZyb21Qb2ludHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvQ0FHRmFjdG9yaWVzJyk7XG5jb25zdCB7IGlzQ0FHIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWxzJyk7XG4vLyAtLSAzRCB0cmFuc2Zvcm1hdGlvbnMgKE9wZW5TQ0FEIGxpa2Ugbm90aW9uKVxuXG4vKiogdHJhbnNsYXRlIGFuIG9iamVjdCBpbiAyRC8zRCBzcGFjZVxuICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciAtIDNEIHZlY3RvciB0byB0cmFuc2xhdGUgdGhlIGdpdmVuIG9iamVjdChzKSBieVxuICogQHBhcmFtIHtPYmplY3Qocyl8QXJyYXl9IG9iamVjdHMgZWl0aGVyIGEgc2luZ2xlIG9yIG11bHRpcGxlIENTRy9DQUcgb2JqZWN0cyB0byB0cmFuc2xhdGVcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0ICwgdHJhbnNsYXRlZCBieSB0aGUgZ2l2ZW4gYW1vdW50XG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBtb3ZlZFNwaGVyZSA9IHRyYW5zbGF0ZShbMTAsMiwwXSwgc3BoZXJlKCkpXG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2ZWN0b3IsIC4uLm9iamVjdHMpIHtcbiAgLy8gdiwgb2JqIG9yIGFycmF5XG4gIC8vIHdvcmthcm91bmQgbmVlZGVkIHRvIGRldGVybWluZSBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgY29uc3QgX29iamVjdHMgPVxuICAgIG9iamVjdHMubGVuZ3RoID49IDEgJiYgb2JqZWN0c1swXS5sZW5ndGggPyBvYmplY3RzWzBdIDogb2JqZWN0cztcbiAgbGV0IG9iamVjdCA9IF9vYmplY3RzWzBdO1xuXG4gIGlmIChfb2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBfb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gRklYTUUvIHdoeSBpcyB1bmlvbiByZWFsbHkgbmVlZGVkID8/XG4gICAgICBvYmplY3QgPSBvYmplY3QudW5pb24oX29iamVjdHNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0LnRyYW5zbGF0ZSh2ZWN0b3IpO1xufVxuXG4vKiogc2NhbGUgYW4gb2JqZWN0IGluIDJELzNEIHNwYWNlXG4gKiBAcGFyYW0ge0Zsb2F0fEFycmF5fSBzY2FsZSAtIGVpdGhlciBhbiBhcnJheSBvciBzaW1wbGUgbnVtYmVyIHRvIHNjYWxlIG9iamVjdChzKSBieVxuICogQHBhcmFtIHtPYmplY3Qocyl8QXJyYXl9IG9iamVjdHMgZWl0aGVyIGEgc2luZ2xlIG9yIG11bHRpcGxlIENTRy9DQUcgb2JqZWN0cyB0byBzY2FsZVxuICogQHJldHVybnMge0NTR30gbmV3IENTRyBvYmplY3QgLCBzY2FsZWQgYnkgdGhlIGdpdmVuIGFtb3VudFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgc2NhbGVkU3BoZXJlID0gc2NhbGUoWzAuMiwxNSwxXSwgc3BoZXJlKCkpXG4gKi9cbmZ1bmN0aW9uIHNjYWxlKHNjYWxlLCAuLi5vYmplY3RzKSB7XG4gIC8vIHYsIG9iaiBvciBhcnJheVxuICBjb25zdCBfb2JqZWN0cyA9XG4gICAgb2JqZWN0cy5sZW5ndGggPj0gMSAmJiBvYmplY3RzWzBdLmxlbmd0aCA/IG9iamVjdHNbMF0gOiBvYmplY3RzO1xuICBsZXQgb2JqZWN0ID0gX29iamVjdHNbMF07XG5cbiAgaWYgKF9vYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IF9vYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBGSVhNRS8gd2h5IGlzIHVuaW9uIHJlYWxseSBuZWVkZWQgPz9cbiAgICAgIG9iamVjdCA9IG9iamVjdC51bmlvbihfb2JqZWN0c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Quc2NhbGUoc2NhbGUpO1xufVxuXG4vKiogcm90YXRlIGFuIG9iamVjdCBpbiAyRC8zRCBzcGFjZVxuICogQHBhcmFtIHtGbG9hdHxBcnJheX0gcm90YXRpb24gLSBlaXRoZXIgYW4gYXJyYXkgb3Igc2ltcGxlIG51bWJlciB0byByb3RhdGUgb2JqZWN0KHMpIGJ5XG4gKiBAcGFyYW0ge09iamVjdChzKXxBcnJheX0gb2JqZWN0cyBlaXRoZXIgYSBzaW5nbGUgb3IgbXVsdGlwbGUgQ1NHL0NBRyBvYmplY3RzIHRvIHJvdGF0ZVxuICogQHJldHVybnMge0NTR30gbmV3IENTRyBvYmplY3QgLCByb3RhdGVkIGJ5IHRoZSBnaXZlbiBhbW91bnRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJvdGF0ZWRTcGhlcmUgPSByb3RhdGUoWzAuMiwxNSwxXSwgc3BoZXJlKCkpXG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZSgpIHtcbiAgbGV0IG87XG4gIGxldCBpO1xuICBsZXQgdjtcbiAgbGV0IHIgPSAxO1xuICBsZXQgYSA9IGFyZ3VtZW50cztcbiAgaWYgKCFhWzBdLmxlbmd0aCkge1xuICAgIC8vIHJvdGF0ZShyLFt4LHksel0sbylcbiAgICByID0gYVswXTtcbiAgICB2ID0gYVsxXTtcbiAgICBpID0gMjtcbiAgICBpZiAoYVsyXS5sZW5ndGgpIHtcbiAgICAgIGEgPSBhWzJdO1xuICAgICAgaSA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHJvdGF0ZShbeCx5LHpdLG8pXG4gICAgdiA9IGFbMF07XG4gICAgaSA9IDE7XG4gICAgaWYgKGFbMV0ubGVuZ3RoKSB7XG4gICAgICBhID0gYVsxXTtcbiAgICAgIGkgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IgKG8gPSBhW2krK107IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgbyA9IG8udW5pb24oYVtpXSk7XG4gIH1cbiAgaWYgKHIgIT09IDEpIHtcbiAgICByZXR1cm4gby5yb3RhdGUoWzAsIDAsIDBdLCB2LCByKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gby5yb3RhdGVYKHZbMF0pLnJvdGF0ZVkodlsxXSkucm90YXRlWih2WzJdKTtcbiAgfVxufVxuXG4vKiogYXBwbHkgdGhlIGdpdmVuIG1hdHJpeCB0cmFuc2Zvcm0gdG8gdGhlIGdpdmVuIG9iamVjdHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCAtIHRoZSA0eDQgbWF0cml4IHRvIGFwcGx5LCBhcyBhIHNpbXBsZSAxZCBhcnJheSBvZiAxNiBlbGVtZW50c1xuICogQHBhcmFtIHtPYmplY3Qocyl8QXJyYXl9IG9iamVjdHMgZWl0aGVyIGEgc2luZ2xlIG9yIG11bHRpcGxlIENTRy9DQUcgb2JqZWN0cyB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0ICwgdHJhbnNmb3JtZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYW5nbGUgPSA0NVxuICogbGV0IHRyYW5zZm9ybWVkU2hhcGUgPSB0cmFuc2Zvcm0oW1xuICogY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksIDAsIDEwLFxuICogc2luKGFuZ2xlKSwgIGNvcyhhbmdsZSksIDAsIDIwLFxuICogMCAgICAgICAgICwgICAgICAgICAgIDAsIDEsIDMwLFxuICogMCwgICAgICAgICAgIDAsIDAsICAxXG4gKiBdLCBzcGhlcmUoKSlcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKG1hdHJpeCwgLi4ub2JqZWN0cykge1xuICAvLyB2LCBvYmogb3IgYXJyYXlcbiAgY29uc3QgX29iamVjdHMgPVxuICAgIG9iamVjdHMubGVuZ3RoID49IDEgJiYgb2JqZWN0c1swXS5sZW5ndGggPyBvYmplY3RzWzBdIDogb2JqZWN0cztcbiAgbGV0IG9iamVjdCA9IF9vYmplY3RzWzBdO1xuXG4gIGlmIChfb2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBfb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gRklYTUUvIHdoeSBpcyB1bmlvbiByZWFsbHkgbmVlZGVkID8/XG4gICAgICBvYmplY3QgPSBvYmplY3QudW5pb24oX29iamVjdHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGxldCB0cmFuc2Zvcm1hdGlvbk1hdHJpeDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1hdHJpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBuZWVkcyB0byBiZSBhbiBhcnJheScpO1xuICB9XG4gIG1hdHJpeC5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3lvdSBjYW4gb25seSB1c2UgYSBmbGF0IGFycmF5IG9mIHZhbGlkLCBmaW5pdGUgbnVtYmVycyAoZmxvYXQgYW5kIGludGVnZXJzKSdcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgdHJhbnNmb3JtYXRpb25NYXRyaXggPSBuZXcgTWF0cml4NChtYXRyaXgpO1xuICByZXR1cm4gb2JqZWN0LnRyYW5zZm9ybSh0cmFuc2Zvcm1hdGlvbk1hdHJpeCk7XG59XG5cbi8qKlxuICogQ2VudGVyIHRoZSBnaXZlbiBvYmplY3QocykgYWJvdXQgdGhlIGdpdmVuIGF4ZXNcbiAqIEBwYXJhbSB7QXJyYXl8Qm9vbGVhbn0gYXhlcz1bdHJ1ZSx0cnVlLHRydWVdfHRydWUgIC0gYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgdGhhdCBpbmRpY2F0ZSB0aGUgYXhlcyAoWCxZLFopIHRvIGNlbnRlciB1cG9uLiBBIHNpbmdsZSBib29sZWFuIGlzIGFsc28gYWxsb3dlZC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3Qgb25lIG9yIG1vcmUgb2JqZWN0cyB0byBjZW50ZXIsIGkuZS4gb2JqZWN0cyBhcmUgQ1NHIG9yIENBR1xuICogQHJldHVybnMge0NTR30gbmV3IENTRyBvYmplY3QgLCB0cmFuc2xhdGVkIGJ5IHRoZSBnaXZlbiBhbW91bnRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGNzZyA9IGNlbnRlcihbdHJ1ZSxmYWxzZSxmYWxzZV0sIHNwaGVyZSgpKSAvLyBjZW50ZXIgYWJvdXQgdGhlIFggYXhpc1xuICovXG5mdW5jdGlvbiBjZW50ZXIoYXhlcywgLi4ub2JqZWN0cykge1xuICBjb25zdCBfb2JqZWN0cyA9XG4gICAgb2JqZWN0cy5sZW5ndGggPj0gMSAmJiBvYmplY3RzWzBdLmxlbmd0aCA/IG9iamVjdHNbMF0gOiBvYmplY3RzO1xuICBsZXQgb2JqZWN0ID0gX29iamVjdHNbMF07XG5cbiAgaWYgKF9vYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IF9vYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBGSVhNRS8gd2h5IGlzIHVuaW9uIHJlYWxseSBuZWVkZWQgPz9cbiAgICAgIG9iamVjdCA9IG9iamVjdC51bmlvbihfb2JqZWN0c1tpXSk7XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShheGVzKSkge1xuICAgIGF4ZXMgPSBbYXhlcywgYXhlcywgYXhlc107XG4gIH1cbiAgcmV0dXJuIG9iamVjdC5jZW50ZXIoYXhlcyk7XG59XG5cbi8qKiBtaXJyb3IgYW4gb2JqZWN0IGluIDJELzNEIHNwYWNlXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWN0b3IgLSB0aGUgYXhlcyB0byBtaXJyb3IgdGhlIG9iamVjdChzKSBieVxuICogQHBhcmFtIHtPYmplY3Qocyl8QXJyYXl9IG9iamVjdHMgZWl0aGVyIGEgc2luZ2xlIG9yIG11bHRpcGxlIENTRy9DQUcgb2JqZWN0cyB0byBtaXJyb3JcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0ICwgbWlycm9yZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJvdGF0ZWRTcGhlcmUgPSBtaXJyb3IoWzAuMiwxNSwxXSwgc3BoZXJlKCkpXG4gKi9cbmZ1bmN0aW9uIG1pcnJvcih2ZWN0b3IsIC4uLm9iamVjdHMpIHtcbiAgY29uc3QgX29iamVjdHMgPVxuICAgIG9iamVjdHMubGVuZ3RoID49IDEgJiYgb2JqZWN0c1swXS5sZW5ndGggPyBvYmplY3RzWzBdIDogb2JqZWN0cztcbiAgbGV0IG9iamVjdCA9IF9vYmplY3RzWzBdO1xuXG4gIGlmIChfb2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBfb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gRklYTUUvIHdoeSBpcyB1bmlvbiByZWFsbHkgbmVlZGVkID8/XG4gICAgICBvYmplY3QgPSBvYmplY3QudW5pb24oX29iamVjdHNbaV0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBwbGFuZSA9IG5ldyBQbGFuZShcbiAgICBuZXcgVmVjdG9yMyh2ZWN0b3JbMF0sIHZlY3RvclsxXSwgdmVjdG9yWzJdKS51bml0KCksXG4gICAgMFxuICApO1xuICByZXR1cm4gb2JqZWN0Lm1pcnJvcmVkKHBsYW5lKTtcbn1cblxuLyoqIGV4cGFuZCBhbiBvYmplY3QgaW4gMkQvM0Qgc3BhY2VcbiAqIEBwYXJhbSB7ZmxvYXR9IHJhZGl1cyAtIHRoZSByYWRpdXMgdG8gZXhwYW5kIGJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IGEgQ1NHL0NBRyBvYmplY3RzIHRvIGV4cGFuZFxuICogQHJldHVybnMge0NTRy9DQUd9IG5ldyBDU0cvQ0FHIG9iamVjdCAsIGV4cGFuZGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBleHBhbmVkZWRTaGFwZSA9IGV4cGFuZChbMC4yLDE1LDFdLCBzcGhlcmUoKSlcbiAqL1xuZnVuY3Rpb24gZXhwYW5kKHJhZGl1cywgbiwgb2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QuZXhwYW5kKHJhZGl1cywgbik7XG59XG5cbi8qKiBjb250cmFjdCBhbiBvYmplY3QocykgaW4gMkQvM0Qgc3BhY2VcbiAqIEBwYXJhbSB7ZmxvYXR9IHJhZGl1cyAtIHRoZSByYWRpdXMgdG8gY29udHJhY3QgYnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgYSBDU0cvQ0FHIG9iamVjdHMgdG8gY29udHJhY3RcbiAqIEByZXR1cm5zIHtDU0cvQ0FHfSBuZXcgQ1NHL0NBRyBvYmplY3QgLCBjb250cmFjdGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBjb250cmFjdGVkU2hhcGUgPSBjb250cmFjdChbMC4yLDE1LDFdLCBzcGhlcmUoKSlcbiAqL1xuZnVuY3Rpb24gY29udHJhY3QocmFkaXVzLCBuLCBvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdC5jb250cmFjdChyYWRpdXMsIG4pO1xufVxuXG4vKiogY3JlYXRlIGEgbWlua293c2tpIHN1bSBvZiB0aGUgZ2l2ZW4gc2hhcGVzXG4gKiBAcGFyYW0ge09iamVjdChzKXxBcnJheX0gb2JqZWN0cyBlaXRoZXIgYSBzaW5nbGUgb3IgbXVsdGlwbGUgQ1NHL0NBRyBvYmplY3RzIHRvIGNyZWF0ZSBhIGh1bGwgYXJvdW5kXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgQ1NHIG9iamVjdCAsIG1pcnJvcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBodWxsZWQgPSBodWxsKHJlY3QoKSwgY2lyY2xlKCkpXG4gKi9cbmZ1bmN0aW9uIG1pbmtvd3NraSgpIHtcbiAgY29uc29sZS5sb2coJ21pbmtvd3NraSgpIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbn1cblxuLyoqIGNyZWF0ZSBhIGNvbnZleCBodWxsIG9mIHRoZSBnaXZlbiBzaGFwZXNcbiAqIEBwYXJhbSB7T2JqZWN0KHMpfEFycmF5fSBvYmplY3RzIGVpdGhlciBhIHNpbmdsZSBvciBtdWx0aXBsZSBDU0cvQ0FHIG9iamVjdHMgdG8gY3JlYXRlIGEgaHVsbCBhcm91bmRcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0ICwgYSBodWxsIGFyb3VuZCB0aGUgZ2l2ZW4gc2hhcGVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBodWxsZWQgPSBodWxsKHJlY3QoKSwgY2lyY2xlKCkpXG4gKi9cbmZ1bmN0aW9uIGh1bGwoKSB7XG4gIGxldCBwdHMgPSBbXTtcblxuICBsZXQgYSA9IGFyZ3VtZW50cztcbiAgaWYgKGFbMF0ubGVuZ3RoKSBhID0gYVswXTtcbiAgbGV0IGRvbmUgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBleHRyYWN0IGFsbCBwb2ludHMgb2YgdGhlIENBRyBpbiB0aGUgYXJndW1lbnQgbGlzdFxuICAgIGxldCBjYWcgPSBhW2ldO1xuICAgIGlmICghaXNDQUcoY2FnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFUlJPUjogaHVsbCgpIGFjY2VwdHMgb25seSAyRCBmb3JtcyAvIENBRycpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNhZy5zaWRlcy5sZW5ndGg7IGorKykge1xuICAgICAgbGV0IHggPSBjYWcuc2lkZXNbal0udmVydGV4MC5wb3MueDtcbiAgICAgIGxldCB5ID0gY2FnLnNpZGVzW2pdLnZlcnRleDAucG9zLnk7XG4gICAgICAvLyBhdm9pZCBzb21lIGNvb3JkIHRvIGFwcGVhciBtdWx0aXBsZSB0aW1lc1xuICAgICAgaWYgKGRvbmVbJycgKyB4ICsgJywnICsgeV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwdHMucHVzaCh7IHg6IHgsIHk6IHkgfSk7XG4gICAgICBkb25lWycnICsgeCArICcsJyArIHldKys7XG4gICAgICAvLyBlY2hvKHgseSk7XG4gICAgfVxuICB9XG4gIC8vIGVjaG8ocHRzLmxlbmd0aCtcIiBwb2ludHMgaW5cIixwdHMpO1xuXG4gIC8vIGZyb20gaHR0cDovL3d3dy5wc3ljaGVkZWxpY2RldmVsb3BtZW50LmNvbS9ncmFoYW1zY2FuL1xuICAvLyAgICBzZWUgYWxzbyBhdCBodHRwczovL2dpdGh1Yi5jb20vYmtpZXJzL0dyYWhhbVNjYW4vYmxvYi9tYXN0ZXIvc3JjL21haW4vY2cvR3JhaGFtU2Nhbi5qYXZhXG4gIGxldCBDb252ZXhIdWxsUG9pbnQgPSBmdW5jdGlvbiAoaSwgYSwgZCkge1xuICAgIHRoaXMuaW5kZXggPSBpO1xuICAgIHRoaXMuYW5nbGUgPSBhO1xuICAgIHRoaXMuZGlzdGFuY2UgPSBkO1xuXG4gICAgdGhpcy5jb21wYXJlID0gZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmICh0aGlzLmFuZ2xlIDwgcC5hbmdsZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYW5nbGUgPiBwLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzdGFuY2UgPCBwLmRpc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlzdGFuY2UgPiBwLmRpc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gIH07XG5cbiAgbGV0IENvbnZleEh1bGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wb2ludHMgPSBudWxsO1xuICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG5cbiAgICB0aGlzLmdldEluZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRpY2VzO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5jY3cgPSBmdW5jdGlvbiAocDEsIHAyLCBwMykge1xuICAgICAgbGV0IGNjdyA9XG4gICAgICAgICh0aGlzLnBvaW50c1twMl0ueCAtIHRoaXMucG9pbnRzW3AxXS54KSAqXG4gICAgICAgICAgKHRoaXMucG9pbnRzW3AzXS55IC0gdGhpcy5wb2ludHNbcDFdLnkpIC1cbiAgICAgICAgKHRoaXMucG9pbnRzW3AyXS55IC0gdGhpcy5wb2ludHNbcDFdLnkpICpcbiAgICAgICAgICAodGhpcy5wb2ludHNbcDNdLnggLSB0aGlzLnBvaW50c1twMV0ueCk7XG4gICAgICAvLyB3ZSBuZWVkIHRoaXMsIG90aGVyd2lzZSBzb3J0aW5nIG5ldmVyIGVuZHMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vU3Bpcml0ZHVkZS9PcGVuSlNDQUQub3JnL2lzc3Vlcy8xOFxuICAgICAgaWYgKGNjdyA8IDFlLTUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2N3O1xuICAgIH07XG5cbiAgICB0aGlzLmFuZ2xlID0gZnVuY3Rpb24gKG8sIGEpIHtcbiAgICAgIC8vIHJldHVybiBNYXRoLmF0YW4oKHRoaXMucG9pbnRzW2FdLnktdGhpcy5wb2ludHNbb10ueSkgLyAodGhpcy5wb2ludHNbYV0ueCAtIHRoaXMucG9pbnRzW29dLngpKTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKFxuICAgICAgICB0aGlzLnBvaW50c1thXS55IC0gdGhpcy5wb2ludHNbb10ueSxcbiAgICAgICAgdGhpcy5wb2ludHNbYV0ueCAtIHRoaXMucG9pbnRzW29dLnhcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHRoaXMuZGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHRoaXMucG9pbnRzW2JdLnggLSB0aGlzLnBvaW50c1thXS54KSAqXG4gICAgICAgICAgKHRoaXMucG9pbnRzW2JdLnggLSB0aGlzLnBvaW50c1thXS54KSArXG4gICAgICAgICh0aGlzLnBvaW50c1tiXS55IC0gdGhpcy5wb2ludHNbYV0ueSkgKlxuICAgICAgICAgICh0aGlzLnBvaW50c1tiXS55IC0gdGhpcy5wb2ludHNbYV0ueSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHRoaXMuY29tcHV0ZSA9IGZ1bmN0aW9uIChfcG9pbnRzKSB7XG4gICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgICAgaWYgKF9wb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBvaW50cyA9IF9wb2ludHM7XG5cbiAgICAgIC8vIEZpbmQgdGhlIGxvd2VzdCBwb2ludFxuICAgICAgbGV0IG1pbiA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnBvaW50c1tpXS55ID09PSB0aGlzLnBvaW50c1ttaW5dLnkpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb2ludHNbaV0ueCA8IHRoaXMucG9pbnRzW21pbl0ueCkge1xuICAgICAgICAgICAgbWluID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wb2ludHNbaV0ueSA8IHRoaXMucG9pbnRzW21pbl0ueSkge1xuICAgICAgICAgIG1pbiA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIGFuZ2xlIGFuZCBkaXN0YW5jZSBmcm9tIGJhc2VcbiAgICAgIGxldCBhbCA9IFtdO1xuICAgICAgbGV0IGFuZyA9IDAuMDtcbiAgICAgIGxldCBkaXN0ID0gMC4wO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gbWluKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYW5nID0gdGhpcy5hbmdsZShtaW4sIGkpO1xuICAgICAgICBpZiAoYW5nIDwgMCkge1xuICAgICAgICAgIGFuZyArPSBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGRpc3QgPSB0aGlzLmRpc3RhbmNlKG1pbiwgaSk7XG4gICAgICAgIGFsLnB1c2gobmV3IENvbnZleEh1bGxQb2ludChpLCBhbmcsIGRpc3QpKTtcbiAgICAgIH1cblxuICAgICAgYWwuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5jb21wYXJlKGIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBzdGFja1xuICAgICAgbGV0IHN0YWNrID0gbmV3IEFycmF5KHRoaXMucG9pbnRzLmxlbmd0aCArIDEpO1xuICAgICAgbGV0IGogPSAyO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gbWluKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbal0gPSBhbFtqIC0gMl0uaW5kZXg7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIHN0YWNrWzBdID0gc3RhY2tbdGhpcy5wb2ludHMubGVuZ3RoXTtcbiAgICAgIHN0YWNrWzFdID0gbWluO1xuXG4gICAgICBsZXQgdG1wO1xuICAgICAgbGV0IE0gPSAyO1xuICAgICAgZm9yIChsZXQgaSA9IDM7IGkgPD0gdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2N3KHN0YWNrW00gLSAxXSwgc3RhY2tbTV0sIHN0YWNrW2ldKSA8PSAwKSB7XG4gICAgICAgICAgTS0tO1xuICAgICAgICB9XG4gICAgICAgIE0rKztcbiAgICAgICAgdG1wID0gc3RhY2tbaV07XG4gICAgICAgIHN0YWNrW2ldID0gc3RhY2tbTV07XG4gICAgICAgIHN0YWNrW01dID0gdG1wO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluZGljZXMgPSBuZXcgQXJyYXkoTSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE07IGkrKykge1xuICAgICAgICB0aGlzLmluZGljZXNbaV0gPSBzdGFja1tpICsgMV07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBsZXQgaHVsbCA9IG5ldyBDb252ZXhIdWxsKCk7XG5cbiAgaHVsbC5jb21wdXRlKHB0cyk7XG4gIGxldCBpbmRpY2VzID0gaHVsbC5nZXRJbmRpY2VzKCk7XG5cbiAgaWYgKGluZGljZXMgJiYgaW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IGNoID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaC5wdXNoKHB0c1tpbmRpY2VzW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tUG9pbnRzKGNoKTtcbiAgfVxufVxuXG4vKiogY3JlYXRlIGEgY2hhaW4gaHVsbCBvZiB0aGUgZ2l2ZW4gc2hhcGVzXG4gKiBPcmlnaW5hbGx5IFwiV2hvc2Egd2hhdHNpc1wiIHN1Z2dlc3RlZCBcIkNoYWluIEh1bGxcIiAsXG4gKiBhcyBkZXNjcmliZWQgYXQgaHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20vdS8wLzEwNTUzNTI0NzM0Nzc4ODM3NzI0NS9wb3N0cy9hWkdYS0ZYMUFDTlxuICogZXNzZW50aWFsbHkgaHVsbCBBK0IsIEIrQywgQytEIGFuZCB0aGVuIHVuaW9uIHRob3NlXG4gKiBAcGFyYW0ge09iamVjdChzKXxBcnJheX0gb2JqZWN0cyBlaXRoZXIgYSBzaW5nbGUgb3IgbXVsdGlwbGUgQ1NHL0NBRyBvYmplY3RzIHRvIGNyZWF0ZSBhIGNoYWluIGh1bGwgYXJvdW5kXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgQ1NHIG9iamVjdCAsd2hpY2ggYSBjaGFpbiBodWxsIG9mIHRoZSBpbnB1dHNcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGh1bGxlZCA9IGNoYWluX2h1bGwocmVjdCgpLCBjaXJjbGUoKSlcbiAqL1xuZnVuY3Rpb24gY2hhaW5faHVsbChwYXJhbXMsIG9iamVjdHMpIHtcbiAgLypcbiAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xvc2VkOiBmYWxzZVxuICB9XG4gIGNvbnN0IGNsb3NlZCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBwYXJhbXMpICovXG4gIGxldCBhID0gYXJndW1lbnRzO1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCBqID0gMDtcblxuICBpZiAoYVtqXS5jbG9zZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsb3NlZCA9IGFbaisrXS5jbG9zZWQ7XG4gIH1cblxuICBpZiAoYVtqXS5sZW5ndGgpIHtcbiAgICBhID0gYVtqXTtcbiAgfVxuXG4gIGxldCBodWxscyA9IFtdO1xuICBsZXQgaHVsbHNBbW91bnQgPSBhLmxlbmd0aCAtIChjbG9zZWQgPyAwIDogMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbHNBbW91bnQ7IGkrKykge1xuICAgIGh1bGxzLnB1c2goaHVsbChhW2ldLCBhWyhpICsgMSkgJSBhLmxlbmd0aF0pKTtcbiAgfVxuICByZXR1cm4gdW5pb24oaHVsbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNsYXRlLFxuICBjZW50ZXIsXG4gIHNjYWxlLFxuICByb3RhdGUsXG4gIHRyYW5zZm9ybSxcbiAgbWlycm9yLFxuICBleHBhbmQsXG4gIGNvbnRyYWN0LFxuICBtaW5rb3dza2ksXG4gIGh1bGwsXG4gIGNoYWluX2h1bGwsXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/api/ops-transformations.js\n");

/***/ }),

/***/ "./src/api/optionParsers.js":
/*!**********************************!*\
  !*** ./src/api/optionParsers.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ../core/math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Vector2D = __webpack_require__(/*! ../core/math/Vector2 */ \"./src/core/math/Vector2.js\");\n\n// Parse an option from the options object\n// If the option is not present, return the default value\nconst parseOption = function (options, optionname, defaultvalue) {\n  var result = defaultvalue;\n  if (options && optionname in options) {\n    result = options[optionname];\n  }\n  return result;\n};\n\n// Parse an option and force into a Vector3D. If a scalar is passed it is converted\n// into a vector with equal x,y,z\nconst parseOptionAs3DVector = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  result = new Vector3D(result);\n  return result;\n};\n\nconst parseOptionAs3DVectorList = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  return result.map(function (res) {\n    return new Vector3D(res);\n  });\n};\n\n// Parse an option and force into a Vector2D. If a scalar is passed it is converted\n// into a vector with equal x,y\nconst parseOptionAs2DVector = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  result = new Vector2D(result);\n  return result;\n};\n\nconst parseOptionAsFloat = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  if (typeof result === 'string') {\n    result = Number(result);\n  }\n  if (isNaN(result) || typeof result !== 'number') {\n    throw new Error('Parameter ' + optionname + ' should be a number');\n  }\n  return result;\n};\n\nconst parseOptionAsInt = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  result = Number(Math.floor(result));\n  if (isNaN(result)) {\n    throw new Error('Parameter ' + optionname + ' should be a number');\n  }\n  return result;\n};\n\nconst parseOptionAsBool = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  if (typeof result === 'string') {\n    if (result === 'true') result = true;\n    else if (result === 'false') result = false;\n    else if (result === 0) result = false;\n  }\n  result = !!result;\n  return result;\n};\n\nmodule.exports = {\n  parseOption,\n  parseOptionAsInt,\n  parseOptionAsFloat,\n  parseOptionAsBool,\n  parseOptionAs3DVector,\n  parseOptionAs2DVector,\n  parseOptionAs3DVectorList,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL29wdGlvblBhcnNlcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvYXBpL29wdGlvblBhcnNlcnMuanM/MDNjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IzRCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9WZWN0b3IzJyk7XG5jb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9WZWN0b3IyJyk7XG5cbi8vIFBhcnNlIGFuIG9wdGlvbiBmcm9tIHRoZSBvcHRpb25zIG9iamVjdFxuLy8gSWYgdGhlIG9wdGlvbiBpcyBub3QgcHJlc2VudCwgcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlXG5jb25zdCBwYXJzZU9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBvcHRpb25uYW1lLCBkZWZhdWx0dmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHR2YWx1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ubmFtZSBpbiBvcHRpb25zKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uc1tvcHRpb25uYW1lXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gUGFyc2UgYW4gb3B0aW9uIGFuZCBmb3JjZSBpbnRvIGEgVmVjdG9yM0QuIElmIGEgc2NhbGFyIGlzIHBhc3NlZCBpdCBpcyBjb252ZXJ0ZWRcbi8vIGludG8gYSB2ZWN0b3Igd2l0aCBlcXVhbCB4LHkselxuY29uc3QgcGFyc2VPcHRpb25BczNEVmVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGlvbm5hbWUsIGRlZmF1bHR2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gcGFyc2VPcHRpb24ob3B0aW9ucywgb3B0aW9ubmFtZSwgZGVmYXVsdHZhbHVlKTtcbiAgcmVzdWx0ID0gbmV3IFZlY3RvcjNEKHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBwYXJzZU9wdGlvbkFzM0RWZWN0b3JMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGlvbm5hbWUsIGRlZmF1bHR2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gcGFyc2VPcHRpb24ob3B0aW9ucywgb3B0aW9ubmFtZSwgZGVmYXVsdHZhbHVlKTtcbiAgcmV0dXJuIHJlc3VsdC5tYXAoZnVuY3Rpb24gKHJlcykge1xuICAgIHJldHVybiBuZXcgVmVjdG9yM0QocmVzKTtcbiAgfSk7XG59O1xuXG4vLyBQYXJzZSBhbiBvcHRpb24gYW5kIGZvcmNlIGludG8gYSBWZWN0b3IyRC4gSWYgYSBzY2FsYXIgaXMgcGFzc2VkIGl0IGlzIGNvbnZlcnRlZFxuLy8gaW50byBhIHZlY3RvciB3aXRoIGVxdWFsIHgseVxuY29uc3QgcGFyc2VPcHRpb25BczJEVmVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGlvbm5hbWUsIGRlZmF1bHR2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gcGFyc2VPcHRpb24ob3B0aW9ucywgb3B0aW9ubmFtZSwgZGVmYXVsdHZhbHVlKTtcbiAgcmVzdWx0ID0gbmV3IFZlY3RvcjJEKHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBwYXJzZU9wdGlvbkFzRmxvYXQgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW9ubmFtZSwgZGVmYXVsdHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBwYXJzZU9wdGlvbihvcHRpb25zLCBvcHRpb25uYW1lLCBkZWZhdWx0dmFsdWUpO1xuICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBOdW1iZXIocmVzdWx0KTtcbiAgfVxuICBpZiAoaXNOYU4ocmVzdWx0KSB8fCB0eXBlb2YgcmVzdWx0ICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyICcgKyBvcHRpb25uYW1lICsgJyBzaG91bGQgYmUgYSBudW1iZXInKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgcGFyc2VPcHRpb25Bc0ludCA9IGZ1bmN0aW9uIChvcHRpb25zLCBvcHRpb25uYW1lLCBkZWZhdWx0dmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHBhcnNlT3B0aW9uKG9wdGlvbnMsIG9wdGlvbm5hbWUsIGRlZmF1bHR2YWx1ZSk7XG4gIHJlc3VsdCA9IE51bWJlcihNYXRoLmZsb29yKHJlc3VsdCkpO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyICcgKyBvcHRpb25uYW1lICsgJyBzaG91bGQgYmUgYSBudW1iZXInKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgcGFyc2VPcHRpb25Bc0Jvb2wgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW9ubmFtZSwgZGVmYXVsdHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBwYXJzZU9wdGlvbihvcHRpb25zLCBvcHRpb25uYW1lLCBkZWZhdWx0dmFsdWUpO1xuICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocmVzdWx0ID09PSAndHJ1ZScpIHJlc3VsdCA9IHRydWU7XG4gICAgZWxzZSBpZiAocmVzdWx0ID09PSAnZmFsc2UnKSByZXN1bHQgPSBmYWxzZTtcbiAgICBlbHNlIGlmIChyZXN1bHQgPT09IDApIHJlc3VsdCA9IGZhbHNlO1xuICB9XG4gIHJlc3VsdCA9ICEhcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlT3B0aW9uLFxuICBwYXJzZU9wdGlvbkFzSW50LFxuICBwYXJzZU9wdGlvbkFzRmxvYXQsXG4gIHBhcnNlT3B0aW9uQXNCb29sLFxuICBwYXJzZU9wdGlvbkFzM0RWZWN0b3IsXG4gIHBhcnNlT3B0aW9uQXMyRFZlY3RvcixcbiAgcGFyc2VPcHRpb25BczNEVmVjdG9yTGlzdCxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/optionParsers.js\n");

/***/ }),

/***/ "./src/api/primitives2d-api.js":
/*!*************************************!*\
  !*** ./src/api/primitives2d-api.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { CAG } = __webpack_require__(/*! ../../csg */ \"./csg.js\"); // we have to import from top level otherwise prototypes are not complete..\nconst { fromPoints } = __webpack_require__(/*! ../core/CAGFactories */ \"./src/core/CAGFactories.js\");\n\n/** Construct a square/rectangle\n * @param {Object} [options] - options for construction\n * @param {Float} [options.size=1] - size of the square, either as array or scalar\n * @param {Boolean} [options.center=true] - wether to center the square/rectangle or not\n * @returns {CAG} new square\n *\n * @example\n * let square1 = square({\n *   size: 10\n * })\n */\nfunction square() {\n  let v = [1, 1];\n  let off;\n  let a = arguments;\n  let params = a[0];\n\n  if (params && Number.isFinite(params)) v = [params, params];\n  if (params && params.length) {\n    v = a[0];\n    params = a[1];\n  }\n  if (params && params.size && params.size.length) v = params.size;\n\n  off = [v[0] / 2, v[1] / 2];\n  if (params && params.center === true) off = [0, 0];\n\n  return CAG.rectangle({ center: off, radius: [v[0] / 2, v[1] / 2] });\n}\n\n/** Construct a circle\n * @param {Object} [options] - options for construction\n * @param {Float} [options.r=1] - radius of the circle\n * @param {Integer} [options.fn=32] - segments of circle (ie quality/ resolution)\n * @param {Boolean} [options.center=true] - wether to center the circle or not\n * @returns {CAG} new circle\n *\n * @example\n * let circle1 = circle({\n *   r: 10\n * })\n */\nfunction circle(params) {\n  const defaults = {\n    r: 1,\n    fn: 32,\n    center: false,\n  };\n  let { r, fn, center } = Object.assign({}, defaults, params);\n  if (params && !params.r && !params.fn && !params.center) r = params;\n  let offset = center === true ? [0, 0] : [r, r];\n  return CAG.circle({ center: offset, radius: r, resolution: fn });\n}\n\n/** Construct a polygon either from arrays of paths and points,\n * or just arrays of points nested paths (multiple paths) and flat paths are supported\n * @param {Object} [options] - options for construction or either flat or nested array of points\n * @param {Array} [options.points] - points of the polygon : either flat or nested array of points\n * @param {Array} [options.paths] - paths of the polygon : either flat or nested array of points index\n * @returns {CAG} new polygon\n *\n * @example\n * let roof = [[10,11], [0,11], [5,20]]\n * let wall = [[0,0], [10,0], [10,10], [0,10]]\n *\n * let poly = polygon(roof)\n * or\n * let poly = polygon([roof, wall])\n * or\n * let poly = polygon({ points: roof })\n * or\n * let poly = polygon({ points: [roof, wall] })\n * or\n * let poly = polygon({ points: roof, path: [0, 1, 2] })\n * or\n * let poly = polygon({ points: [roof, wall], path: [[0, 1, 2], [3, 4, 5, 6]] })\n * or\n * let poly = polygon({ points: roof.concat(wall), paths: [[0, 1, 2], [3, 4, 5], [3, 6, 5]] })\n */\nfunction polygon(params) {\n  // array of po(ints) and pa(ths)\n  let points = [];\n  if (params.paths && params.paths.length && params.paths[0].length) {\n    // pa(th): [[0,1,2],[2,3,1]] (two paths)\n    if (typeof params.points[0][0] !== 'number') {\n      // flatten points array\n      params.points = params.points.reduce((a, b) => a.concat(b));\n    }\n    params.paths.forEach((path, i) => {\n      points.push([]);\n      path.forEach((j) => points[i].push(params.points[j]));\n    });\n  } else if (params.paths && params.paths.length) {\n    // pa(th): [0,1,2,3,4] (single path)\n    params.paths.forEach((i) => points.push(params.points[i]));\n  } else {\n    // pa(th) = po(ints)\n    if (params.length) {\n      points = params;\n    } else {\n      points = params.points;\n    }\n  }\n  return fromPoints(points);\n}\n\n// FIXME: errr this is kinda just a special case of a polygon , why do we need it ?\n/** Construct a triangle\n * @returns {CAG} new triangle\n *\n * @example\n * let triangle = trangle({\n *   length: 10\n * })\n */\nfunction triangle() {\n  let a = arguments;\n  if (a[0] && a[0].length) a = a[0];\n  return fromPoints(a);\n}\n\nmodule.exports = {\n  circle,\n  square,\n  polygon,\n  triangle,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3ByaW1pdGl2ZXMyZC1hcGkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvYXBpL3ByaW1pdGl2ZXMyZC1hcGkuanM/ODMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IENBRyB9ID0gcmVxdWlyZSgnLi4vLi4vY3NnJyk7IC8vIHdlIGhhdmUgdG8gaW1wb3J0IGZyb20gdG9wIGxldmVsIG90aGVyd2lzZSBwcm90b3R5cGVzIGFyZSBub3QgY29tcGxldGUuLlxuY29uc3QgeyBmcm9tUG9pbnRzIH0gPSByZXF1aXJlKCcuLi9jb3JlL0NBR0ZhY3RvcmllcycpO1xuXG4vKiogQ29uc3RydWN0IGEgc3F1YXJlL3JlY3RhbmdsZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuc2l6ZT0xXSAtIHNpemUgb2YgdGhlIHNxdWFyZSwgZWl0aGVyIGFzIGFycmF5IG9yIHNjYWxhclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jZW50ZXI9dHJ1ZV0gLSB3ZXRoZXIgdG8gY2VudGVyIHRoZSBzcXVhcmUvcmVjdGFuZ2xlIG9yIG5vdFxuICogQHJldHVybnMge0NBR30gbmV3IHNxdWFyZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgc3F1YXJlMSA9IHNxdWFyZSh7XG4gKiAgIHNpemU6IDEwXG4gKiB9KVxuICovXG5mdW5jdGlvbiBzcXVhcmUoKSB7XG4gIGxldCB2ID0gWzEsIDFdO1xuICBsZXQgb2ZmO1xuICBsZXQgYSA9IGFyZ3VtZW50cztcbiAgbGV0IHBhcmFtcyA9IGFbMF07XG5cbiAgaWYgKHBhcmFtcyAmJiBOdW1iZXIuaXNGaW5pdGUocGFyYW1zKSkgdiA9IFtwYXJhbXMsIHBhcmFtc107XG4gIGlmIChwYXJhbXMgJiYgcGFyYW1zLmxlbmd0aCkge1xuICAgIHYgPSBhWzBdO1xuICAgIHBhcmFtcyA9IGFbMV07XG4gIH1cbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuc2l6ZSAmJiBwYXJhbXMuc2l6ZS5sZW5ndGgpIHYgPSBwYXJhbXMuc2l6ZTtcblxuICBvZmYgPSBbdlswXSAvIDIsIHZbMV0gLyAyXTtcbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuY2VudGVyID09PSB0cnVlKSBvZmYgPSBbMCwgMF07XG5cbiAgcmV0dXJuIENBRy5yZWN0YW5nbGUoeyBjZW50ZXI6IG9mZiwgcmFkaXVzOiBbdlswXSAvIDIsIHZbMV0gLyAyXSB9KTtcbn1cblxuLyoqIENvbnN0cnVjdCBhIGNpcmNsZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMucj0xXSAtIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmZuPTMyXSAtIHNlZ21lbnRzIG9mIGNpcmNsZSAoaWUgcXVhbGl0eS8gcmVzb2x1dGlvbilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2VudGVyPXRydWVdIC0gd2V0aGVyIHRvIGNlbnRlciB0aGUgY2lyY2xlIG9yIG5vdFxuICogQHJldHVybnMge0NBR30gbmV3IGNpcmNsZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgY2lyY2xlMSA9IGNpcmNsZSh7XG4gKiAgIHI6IDEwXG4gKiB9KVxuICovXG5mdW5jdGlvbiBjaXJjbGUocGFyYW1zKSB7XG4gIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgIHI6IDEsXG4gICAgZm46IDMyLFxuICAgIGNlbnRlcjogZmFsc2UsXG4gIH07XG4gIGxldCB7IHIsIGZuLCBjZW50ZXIgfSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICBpZiAocGFyYW1zICYmICFwYXJhbXMuciAmJiAhcGFyYW1zLmZuICYmICFwYXJhbXMuY2VudGVyKSByID0gcGFyYW1zO1xuICBsZXQgb2Zmc2V0ID0gY2VudGVyID09PSB0cnVlID8gWzAsIDBdIDogW3IsIHJdO1xuICByZXR1cm4gQ0FHLmNpcmNsZSh7IGNlbnRlcjogb2Zmc2V0LCByYWRpdXM6IHIsIHJlc29sdXRpb246IGZuIH0pO1xufVxuXG4vKiogQ29uc3RydWN0IGEgcG9seWdvbiBlaXRoZXIgZnJvbSBhcnJheXMgb2YgcGF0aHMgYW5kIHBvaW50cyxcbiAqIG9yIGp1c3QgYXJyYXlzIG9mIHBvaW50cyBuZXN0ZWQgcGF0aHMgKG11bHRpcGxlIHBhdGhzKSBhbmQgZmxhdCBwYXRocyBhcmUgc3VwcG9ydGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uIG9yIGVpdGhlciBmbGF0IG9yIG5lc3RlZCBhcnJheSBvZiBwb2ludHNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBvaW50c10gLSBwb2ludHMgb2YgdGhlIHBvbHlnb24gOiBlaXRoZXIgZmxhdCBvciBuZXN0ZWQgYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wYXRoc10gLSBwYXRocyBvZiB0aGUgcG9seWdvbiA6IGVpdGhlciBmbGF0IG9yIG5lc3RlZCBhcnJheSBvZiBwb2ludHMgaW5kZXhcbiAqIEByZXR1cm5zIHtDQUd9IG5ldyBwb2x5Z29uXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCByb29mID0gW1sxMCwxMV0sIFswLDExXSwgWzUsMjBdXVxuICogbGV0IHdhbGwgPSBbWzAsMF0sIFsxMCwwXSwgWzEwLDEwXSwgWzAsMTBdXVxuICpcbiAqIGxldCBwb2x5ID0gcG9seWdvbihyb29mKVxuICogb3JcbiAqIGxldCBwb2x5ID0gcG9seWdvbihbcm9vZiwgd2FsbF0pXG4gKiBvclxuICogbGV0IHBvbHkgPSBwb2x5Z29uKHsgcG9pbnRzOiByb29mIH0pXG4gKiBvclxuICogbGV0IHBvbHkgPSBwb2x5Z29uKHsgcG9pbnRzOiBbcm9vZiwgd2FsbF0gfSlcbiAqIG9yXG4gKiBsZXQgcG9seSA9IHBvbHlnb24oeyBwb2ludHM6IHJvb2YsIHBhdGg6IFswLCAxLCAyXSB9KVxuICogb3JcbiAqIGxldCBwb2x5ID0gcG9seWdvbih7IHBvaW50czogW3Jvb2YsIHdhbGxdLCBwYXRoOiBbWzAsIDEsIDJdLCBbMywgNCwgNSwgNl1dIH0pXG4gKiBvclxuICogbGV0IHBvbHkgPSBwb2x5Z29uKHsgcG9pbnRzOiByb29mLmNvbmNhdCh3YWxsKSwgcGF0aHM6IFtbMCwgMSwgMl0sIFszLCA0LCA1XSwgWzMsIDYsIDVdXSB9KVxuICovXG5mdW5jdGlvbiBwb2x5Z29uKHBhcmFtcykge1xuICAvLyBhcnJheSBvZiBwbyhpbnRzKSBhbmQgcGEodGhzKVxuICBsZXQgcG9pbnRzID0gW107XG4gIGlmIChwYXJhbXMucGF0aHMgJiYgcGFyYW1zLnBhdGhzLmxlbmd0aCAmJiBwYXJhbXMucGF0aHNbMF0ubGVuZ3RoKSB7XG4gICAgLy8gcGEodGgpOiBbWzAsMSwyXSxbMiwzLDFdXSAodHdvIHBhdGhzKVxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnBvaW50c1swXVswXSAhPT0gJ251bWJlcicpIHtcbiAgICAgIC8vIGZsYXR0ZW4gcG9pbnRzIGFycmF5XG4gICAgICBwYXJhbXMucG9pbnRzID0gcGFyYW1zLnBvaW50cy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICB9XG4gICAgcGFyYW1zLnBhdGhzLmZvckVhY2goKHBhdGgsIGkpID0+IHtcbiAgICAgIHBvaW50cy5wdXNoKFtdKTtcbiAgICAgIHBhdGguZm9yRWFjaCgoaikgPT4gcG9pbnRzW2ldLnB1c2gocGFyYW1zLnBvaW50c1tqXSkpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHBhcmFtcy5wYXRocyAmJiBwYXJhbXMucGF0aHMubGVuZ3RoKSB7XG4gICAgLy8gcGEodGgpOiBbMCwxLDIsMyw0XSAoc2luZ2xlIHBhdGgpXG4gICAgcGFyYW1zLnBhdGhzLmZvckVhY2goKGkpID0+IHBvaW50cy5wdXNoKHBhcmFtcy5wb2ludHNbaV0pKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwYSh0aCkgPSBwbyhpbnRzKVxuICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICBwb2ludHMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHBhcmFtcy5wb2ludHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tUG9pbnRzKHBvaW50cyk7XG59XG5cbi8vIEZJWE1FOiBlcnJyIHRoaXMgaXMga2luZGEganVzdCBhIHNwZWNpYWwgY2FzZSBvZiBhIHBvbHlnb24gLCB3aHkgZG8gd2UgbmVlZCBpdCA/XG4vKiogQ29uc3RydWN0IGEgdHJpYW5nbGVcbiAqIEByZXR1cm5zIHtDQUd9IG5ldyB0cmlhbmdsZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgdHJpYW5nbGUgPSB0cmFuZ2xlKHtcbiAqICAgbGVuZ3RoOiAxMFxuICogfSlcbiAqL1xuZnVuY3Rpb24gdHJpYW5nbGUoKSB7XG4gIGxldCBhID0gYXJndW1lbnRzO1xuICBpZiAoYVswXSAmJiBhWzBdLmxlbmd0aCkgYSA9IGFbMF07XG4gIHJldHVybiBmcm9tUG9pbnRzKGEpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2lyY2xlLFxuICBzcXVhcmUsXG4gIHBvbHlnb24sXG4gIHRyaWFuZ2xlLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/primitives2d-api.js\n");

/***/ }),

/***/ "./src/api/primitives2d.js":
/*!*********************************!*\
  !*** ./src/api/primitives2d.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CAG = __webpack_require__(/*! ../core/CAG */ \"./src/core/CAG.js\");\nconst {\n  parseOptionAs2DVector,\n  parseOptionAsFloat,\n  parseOptionAsInt,\n} = __webpack_require__(/*! ./optionParsers */ \"./src/api/optionParsers.js\");\nconst { defaultResolution2D } = __webpack_require__(/*! ../core/constants */ \"./src/core/constants.js\");\nconst Vector2D = __webpack_require__(/*! ../core/math/Vector2 */ \"./src/core/math/Vector2.js\");\nconst Vertex2 = __webpack_require__(/*! ../core/math/Vertex2 */ \"./src/core/math/Vertex2.js\");\nconst Path2D = __webpack_require__(/*! ../core/math/Path2 */ \"./src/core/math/Path2.js\");\nconst {\n  fromCompactBinary,\n  fromPoints,\n  fromPath2,\n  fromSides,\n} = __webpack_require__(/*! ../core/CAGFactories */ \"./src/core/CAGFactories.js\");\n\n/** Construct a circle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of circle\n * @param {Number} [options.radius=1] - radius of circle\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n */\nconst circle = function (options) {\n  options = options || {};\n  let center = parseOptionAs2DVector(options, 'center', [0, 0]);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n  let points = [];\n  for (let i = 0; i < resolution; i++) {\n    let radians = (2 * Math.PI * i) / resolution;\n    let point = Vector2D.fromAngleRadians(radians).times(radius).plus(center);\n    points.push(point);\n  }\n  return fromPoints(points);\n};\n\n/** Construct an ellispe.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of ellipse\n * @param {Vector2D} [options.radius=[1,1]] - radius of ellipse, width and height\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n */\nconst ellipse = function (options) {\n  options = options || {};\n  let c = parseOptionAs2DVector(options, 'center', [0, 0]);\n  let r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  r = r.abs(); // negative radii make no sense\n  let res = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n\n  let e2 = new Path2D([[c.x, c.y + r.y]]);\n  e2 = e2.appendArc([c.x, c.y - r.y], {\n    xradius: r.x,\n    yradius: r.y,\n    xaxisrotation: 0,\n    resolution: res,\n    clockwise: true,\n    large: false,\n  });\n  e2 = e2.appendArc([c.x, c.y + r.y], {\n    xradius: r.x,\n    yradius: r.y,\n    xaxisrotation: 0,\n    resolution: res,\n    clockwise: true,\n    large: false,\n  });\n  e2 = e2.close();\n  return fromPath2(e2);\n};\n\n/** Construct a rectangle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of rectangle\n * @param {Vector2D} [options.radius=[1,1]] - radius of rectangle, width and height\n * @param {Vector2D} [options.corner1=[0,0]] - bottom left corner of rectangle (alternate)\n * @param {Vector2D} [options.corner2=[0,0]] - upper right corner of rectangle (alternate)\n * @returns {CAG} new CAG object\n */\nconst rectangle = function (options) {\n  options = options || {};\n  let c, r;\n  if ('corner1' in options || 'corner2' in options) {\n    if ('center' in options || 'radius' in options) {\n      throw new Error(\n        'rectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter'\n      );\n    }\n    let corner1 = parseOptionAs2DVector(options, 'corner1', [0, 0]);\n    let corner2 = parseOptionAs2DVector(options, 'corner2', [1, 1]);\n    c = corner1.plus(corner2).times(0.5);\n    r = corner2.minus(corner1).times(0.5);\n  } else {\n    c = parseOptionAs2DVector(options, 'center', [0, 0]);\n    r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  }\n  r = r.abs(); // negative radii make no sense\n  let rswap = new Vector2D(r.x, -r.y);\n  let points = [c.plus(r), c.plus(rswap), c.minus(r), c.minus(rswap)];\n  return fromPoints(points);\n};\n\n/** Construct a rounded rectangle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of rounded rectangle\n * @param {Vector2D} [options.radius=[1,1]] - radius of rounded rectangle, width and height\n * @param {Vector2D} [options.corner1=[0,0]] - bottom left corner of rounded rectangle (alternate)\n * @param {Vector2D} [options.corner2=[0,0]] - upper right corner of rounded rectangle (alternate)\n * @param {Number} [options.roundradius=0.2] - round radius of corners\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n *\n * @example\n * let r = roundedRectangle({\n *   center: [0, 0],\n *   radius: [5, 10],\n *   roundradius: 2,\n *   resolution: 36,\n * });\n */\nconst roundedRectangle = function (options) {\n  options = options || {};\n  let center, radius;\n  if ('corner1' in options || 'corner2' in options) {\n    if ('center' in options || 'radius' in options) {\n      throw new Error(\n        'roundedRectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter'\n      );\n    }\n    let corner1 = parseOptionAs2DVector(options, 'corner1', [0, 0]);\n    let corner2 = parseOptionAs2DVector(options, 'corner2', [1, 1]);\n    center = corner1.plus(corner2).times(0.5);\n    radius = corner2.minus(corner1).times(0.5);\n  } else {\n    center = parseOptionAs2DVector(options, 'center', [0, 0]);\n    radius = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  }\n  radius = radius.abs(); // negative radii make no sense\n  let roundradius = parseOptionAsFloat(options, 'roundradius', 0.2);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n  let maxroundradius = Math.min(radius.x, radius.y);\n  maxroundradius -= 0.1;\n  roundradius = Math.min(roundradius, maxroundradius);\n  roundradius = Math.max(0, roundradius);\n  radius = new Vector2D(radius.x - roundradius, radius.y - roundradius);\n  let rect = rectangle({\n    center: center,\n    radius: radius,\n  });\n  if (roundradius > 0) {\n    rect = rect.expand(roundradius, resolution);\n  }\n  return rect;\n};\n\n/** Reconstruct a CAG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary()\n * @returns {CAG} new CAG object\n */\n/*fromCompactBinary = function (bin) {\n  if (bin['class'] !== 'CAG') throw new Error('Not a CAG')\n  let vertices = []\n  let vertexData = bin.vertexData\n  let numvertices = vertexData.length / 2\n  let arrayindex = 0\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    let x = vertexData[arrayindex++]\n    let y = vertexData[arrayindex++]\n    let pos = new Vector2D(x, y)\n    let vertex = new Vertex2(pos)\n    vertices.push(vertex)\n  }\n\n  let sides = []\n  let numsides = bin.sideVertexIndices.length / 2\n  arrayindex = 0\n  for (let sideindex = 0; sideindex < numsides; sideindex++) {\n    let vertexindex0 = bin.sideVertexIndices[arrayindex++]\n    let vertexindex1 = bin.sideVertexIndices[arrayindex++]\n    let side = new Side(vertices[vertexindex0], vertices[vertexindex1])\n    sides.push(side)\n  }\n  let cag = fromSides(sides)\n  cag.isCanonicalized = true\n  return cag\n}*/\n\nmodule.exports = {\n  circle,\n  ellipse,\n  rectangle,\n  roundedRectangle,\n  fromCompactBinary,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3ByaW1pdGl2ZXMyZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvcHJpbWl0aXZlczJkLmpzPzE5YmIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0FHID0gcmVxdWlyZSgnLi4vY29yZS9DQUcnKTtcbmNvbnN0IHtcbiAgcGFyc2VPcHRpb25BczJEVmVjdG9yLFxuICBwYXJzZU9wdGlvbkFzRmxvYXQsXG4gIHBhcnNlT3B0aW9uQXNJbnQsXG59ID0gcmVxdWlyZSgnLi9vcHRpb25QYXJzZXJzJyk7XG5jb25zdCB7IGRlZmF1bHRSZXNvbHV0aW9uMkQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvY29uc3RhbnRzJyk7XG5jb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9WZWN0b3IyJyk7XG5jb25zdCBWZXJ0ZXgyID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1ZlcnRleDInKTtcbmNvbnN0IFBhdGgyRCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9QYXRoMicpO1xuY29uc3Qge1xuICBmcm9tQ29tcGFjdEJpbmFyeSxcbiAgZnJvbVBvaW50cyxcbiAgZnJvbVBhdGgyLFxuICBmcm9tU2lkZXMsXG59ID0gcmVxdWlyZSgnLi4vY29yZS9DQUdGYWN0b3JpZXMnKTtcblxuLyoqIENvbnN0cnVjdCBhIGNpcmNsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBjb25zdHJ1Y3Rpb25cbiAqIEBwYXJhbSB7VmVjdG9yMkR9IFtvcHRpb25zLmNlbnRlcj1bMCwwXV0gLSBjZW50ZXIgb2YgY2lyY2xlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdIC0gcmFkaXVzIG9mIGNpcmNsZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249ZGVmYXVsdFJlc29sdXRpb24yRF0gLSBudW1iZXIgb2Ygc2lkZXMgcGVyIDM2MCByb3RhdGlvblxuICogQHJldHVybnMge0NBR30gbmV3IENBRyBvYmplY3RcbiAqL1xuY29uc3QgY2lyY2xlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxldCBjZW50ZXIgPSBwYXJzZU9wdGlvbkFzMkRWZWN0b3Iob3B0aW9ucywgJ2NlbnRlcicsIFswLCAwXSk7XG4gIGxldCByYWRpdXMgPSBwYXJzZU9wdGlvbkFzRmxvYXQob3B0aW9ucywgJ3JhZGl1cycsIDEpO1xuICBsZXQgcmVzb2x1dGlvbiA9IHBhcnNlT3B0aW9uQXNJbnQob3B0aW9ucywgJ3Jlc29sdXRpb24nLCBkZWZhdWx0UmVzb2x1dGlvbjJEKTtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdXRpb247IGkrKykge1xuICAgIGxldCByYWRpYW5zID0gKDIgKiBNYXRoLlBJICogaSkgLyByZXNvbHV0aW9uO1xuICAgIGxldCBwb2ludCA9IFZlY3RvcjJELmZyb21BbmdsZVJhZGlhbnMocmFkaWFucykudGltZXMocmFkaXVzKS5wbHVzKGNlbnRlcik7XG4gICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICB9XG4gIHJldHVybiBmcm9tUG9pbnRzKHBvaW50cyk7XG59O1xuXG4vKiogQ29uc3RydWN0IGFuIGVsbGlzcGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge1ZlY3RvcjJEfSBbb3B0aW9ucy5jZW50ZXI9WzAsMF1dIC0gY2VudGVyIG9mIGVsbGlwc2VcbiAqIEBwYXJhbSB7VmVjdG9yMkR9IFtvcHRpb25zLnJhZGl1cz1bMSwxXV0gLSByYWRpdXMgb2YgZWxsaXBzZSwgd2lkdGggYW5kIGhlaWdodFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249ZGVmYXVsdFJlc29sdXRpb24yRF0gLSBudW1iZXIgb2Ygc2lkZXMgcGVyIDM2MCByb3RhdGlvblxuICogQHJldHVybnMge0NBR30gbmV3IENBRyBvYmplY3RcbiAqL1xuY29uc3QgZWxsaXBzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgYyA9IHBhcnNlT3B0aW9uQXMyRFZlY3RvcihvcHRpb25zLCAnY2VudGVyJywgWzAsIDBdKTtcbiAgbGV0IHIgPSBwYXJzZU9wdGlvbkFzMkRWZWN0b3Iob3B0aW9ucywgJ3JhZGl1cycsIFsxLCAxXSk7XG4gIHIgPSByLmFicygpOyAvLyBuZWdhdGl2ZSByYWRpaSBtYWtlIG5vIHNlbnNlXG4gIGxldCByZXMgPSBwYXJzZU9wdGlvbkFzSW50KG9wdGlvbnMsICdyZXNvbHV0aW9uJywgZGVmYXVsdFJlc29sdXRpb24yRCk7XG5cbiAgbGV0IGUyID0gbmV3IFBhdGgyRChbW2MueCwgYy55ICsgci55XV0pO1xuICBlMiA9IGUyLmFwcGVuZEFyYyhbYy54LCBjLnkgLSByLnldLCB7XG4gICAgeHJhZGl1czogci54LFxuICAgIHlyYWRpdXM6IHIueSxcbiAgICB4YXhpc3JvdGF0aW9uOiAwLFxuICAgIHJlc29sdXRpb246IHJlcyxcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgbGFyZ2U6IGZhbHNlLFxuICB9KTtcbiAgZTIgPSBlMi5hcHBlbmRBcmMoW2MueCwgYy55ICsgci55XSwge1xuICAgIHhyYWRpdXM6IHIueCxcbiAgICB5cmFkaXVzOiByLnksXG4gICAgeGF4aXNyb3RhdGlvbjogMCxcbiAgICByZXNvbHV0aW9uOiByZXMsXG4gICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgIGxhcmdlOiBmYWxzZSxcbiAgfSk7XG4gIGUyID0gZTIuY2xvc2UoKTtcbiAgcmV0dXJuIGZyb21QYXRoMihlMik7XG59O1xuXG4vKiogQ29uc3RydWN0IGEgcmVjdGFuZ2xlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtWZWN0b3IyRH0gW29wdGlvbnMuY2VudGVyPVswLDBdXSAtIGNlbnRlciBvZiByZWN0YW5nbGVcbiAqIEBwYXJhbSB7VmVjdG9yMkR9IFtvcHRpb25zLnJhZGl1cz1bMSwxXV0gLSByYWRpdXMgb2YgcmVjdGFuZ2xlLCB3aWR0aCBhbmQgaGVpZ2h0XG4gKiBAcGFyYW0ge1ZlY3RvcjJEfSBbb3B0aW9ucy5jb3JuZXIxPVswLDBdXSAtIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiByZWN0YW5nbGUgKGFsdGVybmF0ZSlcbiAqIEBwYXJhbSB7VmVjdG9yMkR9IFtvcHRpb25zLmNvcm5lcjI9WzAsMF1dIC0gdXBwZXIgcmlnaHQgY29ybmVyIG9mIHJlY3RhbmdsZSAoYWx0ZXJuYXRlKVxuICogQHJldHVybnMge0NBR30gbmV3IENBRyBvYmplY3RcbiAqL1xuY29uc3QgcmVjdGFuZ2xlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxldCBjLCByO1xuICBpZiAoJ2Nvcm5lcjEnIGluIG9wdGlvbnMgfHwgJ2Nvcm5lcjInIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoJ2NlbnRlcicgaW4gb3B0aW9ucyB8fCAncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdyZWN0YW5nbGU6IHNob3VsZCBlaXRoZXIgZ2l2ZSBhIHJhZGl1cyBhbmQgY2VudGVyIHBhcmFtZXRlciwgb3IgYSBjb3JuZXIxIGFuZCBjb3JuZXIyIHBhcmFtZXRlcidcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBjb3JuZXIxID0gcGFyc2VPcHRpb25BczJEVmVjdG9yKG9wdGlvbnMsICdjb3JuZXIxJywgWzAsIDBdKTtcbiAgICBsZXQgY29ybmVyMiA9IHBhcnNlT3B0aW9uQXMyRFZlY3RvcihvcHRpb25zLCAnY29ybmVyMicsIFsxLCAxXSk7XG4gICAgYyA9IGNvcm5lcjEucGx1cyhjb3JuZXIyKS50aW1lcygwLjUpO1xuICAgIHIgPSBjb3JuZXIyLm1pbnVzKGNvcm5lcjEpLnRpbWVzKDAuNSk7XG4gIH0gZWxzZSB7XG4gICAgYyA9IHBhcnNlT3B0aW9uQXMyRFZlY3RvcihvcHRpb25zLCAnY2VudGVyJywgWzAsIDBdKTtcbiAgICByID0gcGFyc2VPcHRpb25BczJEVmVjdG9yKG9wdGlvbnMsICdyYWRpdXMnLCBbMSwgMV0pO1xuICB9XG4gIHIgPSByLmFicygpOyAvLyBuZWdhdGl2ZSByYWRpaSBtYWtlIG5vIHNlbnNlXG4gIGxldCByc3dhcCA9IG5ldyBWZWN0b3IyRChyLngsIC1yLnkpO1xuICBsZXQgcG9pbnRzID0gW2MucGx1cyhyKSwgYy5wbHVzKHJzd2FwKSwgYy5taW51cyhyKSwgYy5taW51cyhyc3dhcCldO1xuICByZXR1cm4gZnJvbVBvaW50cyhwb2ludHMpO1xufTtcblxuLyoqIENvbnN0cnVjdCBhIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtWZWN0b3IyRH0gW29wdGlvbnMuY2VudGVyPVswLDBdXSAtIGNlbnRlciBvZiByb3VuZGVkIHJlY3RhbmdsZVxuICogQHBhcmFtIHtWZWN0b3IyRH0gW29wdGlvbnMucmFkaXVzPVsxLDFdXSAtIHJhZGl1cyBvZiByb3VuZGVkIHJlY3RhbmdsZSwgd2lkdGggYW5kIGhlaWdodFxuICogQHBhcmFtIHtWZWN0b3IyRH0gW29wdGlvbnMuY29ybmVyMT1bMCwwXV0gLSBib3R0b20gbGVmdCBjb3JuZXIgb2Ygcm91bmRlZCByZWN0YW5nbGUgKGFsdGVybmF0ZSlcbiAqIEBwYXJhbSB7VmVjdG9yMkR9IFtvcHRpb25zLmNvcm5lcjI9WzAsMF1dIC0gdXBwZXIgcmlnaHQgY29ybmVyIG9mIHJvdW5kZWQgcmVjdGFuZ2xlIChhbHRlcm5hdGUpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm91bmRyYWRpdXM9MC4yXSAtIHJvdW5kIHJhZGl1cyBvZiBjb3JuZXJzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1kZWZhdWx0UmVzb2x1dGlvbjJEXSAtIG51bWJlciBvZiBzaWRlcyBwZXIgMzYwIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7Q0FHfSBuZXcgQ0FHIG9iamVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgciA9IHJvdW5kZWRSZWN0YW5nbGUoe1xuICogICBjZW50ZXI6IFswLCAwXSxcbiAqICAgcmFkaXVzOiBbNSwgMTBdLFxuICogICByb3VuZHJhZGl1czogMixcbiAqICAgcmVzb2x1dGlvbjogMzYsXG4gKiB9KTtcbiAqL1xuY29uc3Qgcm91bmRlZFJlY3RhbmdsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgY2VudGVyLCByYWRpdXM7XG4gIGlmICgnY29ybmVyMScgaW4gb3B0aW9ucyB8fCAnY29ybmVyMicgaW4gb3B0aW9ucykge1xuICAgIGlmICgnY2VudGVyJyBpbiBvcHRpb25zIHx8ICdyYWRpdXMnIGluIG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3JvdW5kZWRSZWN0YW5nbGU6IHNob3VsZCBlaXRoZXIgZ2l2ZSBhIHJhZGl1cyBhbmQgY2VudGVyIHBhcmFtZXRlciwgb3IgYSBjb3JuZXIxIGFuZCBjb3JuZXIyIHBhcmFtZXRlcidcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBjb3JuZXIxID0gcGFyc2VPcHRpb25BczJEVmVjdG9yKG9wdGlvbnMsICdjb3JuZXIxJywgWzAsIDBdKTtcbiAgICBsZXQgY29ybmVyMiA9IHBhcnNlT3B0aW9uQXMyRFZlY3RvcihvcHRpb25zLCAnY29ybmVyMicsIFsxLCAxXSk7XG4gICAgY2VudGVyID0gY29ybmVyMS5wbHVzKGNvcm5lcjIpLnRpbWVzKDAuNSk7XG4gICAgcmFkaXVzID0gY29ybmVyMi5taW51cyhjb3JuZXIxKS50aW1lcygwLjUpO1xuICB9IGVsc2Uge1xuICAgIGNlbnRlciA9IHBhcnNlT3B0aW9uQXMyRFZlY3RvcihvcHRpb25zLCAnY2VudGVyJywgWzAsIDBdKTtcbiAgICByYWRpdXMgPSBwYXJzZU9wdGlvbkFzMkRWZWN0b3Iob3B0aW9ucywgJ3JhZGl1cycsIFsxLCAxXSk7XG4gIH1cbiAgcmFkaXVzID0gcmFkaXVzLmFicygpOyAvLyBuZWdhdGl2ZSByYWRpaSBtYWtlIG5vIHNlbnNlXG4gIGxldCByb3VuZHJhZGl1cyA9IHBhcnNlT3B0aW9uQXNGbG9hdChvcHRpb25zLCAncm91bmRyYWRpdXMnLCAwLjIpO1xuICBsZXQgcmVzb2x1dGlvbiA9IHBhcnNlT3B0aW9uQXNJbnQob3B0aW9ucywgJ3Jlc29sdXRpb24nLCBkZWZhdWx0UmVzb2x1dGlvbjJEKTtcbiAgbGV0IG1heHJvdW5kcmFkaXVzID0gTWF0aC5taW4ocmFkaXVzLngsIHJhZGl1cy55KTtcbiAgbWF4cm91bmRyYWRpdXMgLT0gMC4xO1xuICByb3VuZHJhZGl1cyA9IE1hdGgubWluKHJvdW5kcmFkaXVzLCBtYXhyb3VuZHJhZGl1cyk7XG4gIHJvdW5kcmFkaXVzID0gTWF0aC5tYXgoMCwgcm91bmRyYWRpdXMpO1xuICByYWRpdXMgPSBuZXcgVmVjdG9yMkQocmFkaXVzLnggLSByb3VuZHJhZGl1cywgcmFkaXVzLnkgLSByb3VuZHJhZGl1cyk7XG4gIGxldCByZWN0ID0gcmVjdGFuZ2xlKHtcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgfSk7XG4gIGlmIChyb3VuZHJhZGl1cyA+IDApIHtcbiAgICByZWN0ID0gcmVjdC5leHBhbmQocm91bmRyYWRpdXMsIHJlc29sdXRpb24pO1xuICB9XG4gIHJldHVybiByZWN0O1xufTtcblxuLyoqIFJlY29uc3RydWN0IGEgQ0FHIGZyb20gdGhlIG91dHB1dCBvZiB0b0NvbXBhY3RCaW5hcnkoKS5cbiAqIEBwYXJhbSB7Q29tcGFjdEJpbmFyeX0gYmluIC0gc2VlIHRvQ29tcGFjdEJpbmFyeSgpXG4gKiBAcmV0dXJucyB7Q0FHfSBuZXcgQ0FHIG9iamVjdFxuICovXG4vKmZyb21Db21wYWN0QmluYXJ5ID0gZnVuY3Rpb24gKGJpbikge1xuICBpZiAoYmluWydjbGFzcyddICE9PSAnQ0FHJykgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBDQUcnKVxuICBsZXQgdmVydGljZXMgPSBbXVxuICBsZXQgdmVydGV4RGF0YSA9IGJpbi52ZXJ0ZXhEYXRhXG4gIGxldCBudW12ZXJ0aWNlcyA9IHZlcnRleERhdGEubGVuZ3RoIC8gMlxuICBsZXQgYXJyYXlpbmRleCA9IDBcbiAgZm9yIChsZXQgdmVydGV4aW5kZXggPSAwOyB2ZXJ0ZXhpbmRleCA8IG51bXZlcnRpY2VzOyB2ZXJ0ZXhpbmRleCsrKSB7XG4gICAgbGV0IHggPSB2ZXJ0ZXhEYXRhW2FycmF5aW5kZXgrK11cbiAgICBsZXQgeSA9IHZlcnRleERhdGFbYXJyYXlpbmRleCsrXVxuICAgIGxldCBwb3MgPSBuZXcgVmVjdG9yMkQoeCwgeSlcbiAgICBsZXQgdmVydGV4ID0gbmV3IFZlcnRleDIocG9zKVxuICAgIHZlcnRpY2VzLnB1c2godmVydGV4KVxuICB9XG5cbiAgbGV0IHNpZGVzID0gW11cbiAgbGV0IG51bXNpZGVzID0gYmluLnNpZGVWZXJ0ZXhJbmRpY2VzLmxlbmd0aCAvIDJcbiAgYXJyYXlpbmRleCA9IDBcbiAgZm9yIChsZXQgc2lkZWluZGV4ID0gMDsgc2lkZWluZGV4IDwgbnVtc2lkZXM7IHNpZGVpbmRleCsrKSB7XG4gICAgbGV0IHZlcnRleGluZGV4MCA9IGJpbi5zaWRlVmVydGV4SW5kaWNlc1thcnJheWluZGV4KytdXG4gICAgbGV0IHZlcnRleGluZGV4MSA9IGJpbi5zaWRlVmVydGV4SW5kaWNlc1thcnJheWluZGV4KytdXG4gICAgbGV0IHNpZGUgPSBuZXcgU2lkZSh2ZXJ0aWNlc1t2ZXJ0ZXhpbmRleDBdLCB2ZXJ0aWNlc1t2ZXJ0ZXhpbmRleDFdKVxuICAgIHNpZGVzLnB1c2goc2lkZSlcbiAgfVxuICBsZXQgY2FnID0gZnJvbVNpZGVzKHNpZGVzKVxuICBjYWcuaXNDYW5vbmljYWxpemVkID0gdHJ1ZVxuICByZXR1cm4gY2FnXG59Ki9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNpcmNsZSxcbiAgZWxsaXBzZSxcbiAgcmVjdGFuZ2xlLFxuICByb3VuZGVkUmVjdGFuZ2xlLFxuICBmcm9tQ29tcGFjdEJpbmFyeSxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/primitives2d.js\n");

/***/ }),

/***/ "./src/api/primitives3d-api.js":
/*!*************************************!*\
  !*** ./src/api/primitives3d-api.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/// //////////FUNCTIONAL API\nconst { CSG } = __webpack_require__(/*! ../../csg */ \"./csg.js\");\nconst { circle } = __webpack_require__(/*! ./primitives2d-api */ \"./src/api/primitives2d-api.js\");\nconst { rotate_extrude } = __webpack_require__(/*! ./ops-extrusions */ \"./src/api/ops-extrusions.js\");\nconst { translate, scale } = __webpack_require__(/*! ./ops-transformations */ \"./src/api/ops-transformations.js\");\nconst Polygon3 = __webpack_require__(/*! ../core/math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst Vector3 = __webpack_require__(/*! ../core/math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Vertex3 = __webpack_require__(/*! ../core/math/Vertex3 */ \"./src/core/math/Vertex3.js\");\n\n/** Construct a cuboid\n * @param {Object} [options] - options for construction\n * @param {Float} [options.size=1] - size of the side of the cuboid : can be either:\n * - a scalar : ie a single float, in which case all dimensions will be the same\n * - or an array: to specify different dimensions along x/y/z\n * @param {Integer} [options.fn=32] - segments of the sphere (ie quality/resolution)\n * @param {Integer} [options.fno=32] - segments of extrusion (ie quality)\n * @param {String} [options.type='normal'] - type of sphere : either 'normal' or 'geodesic'\n * @returns {CSG} new sphere\n *\n * @example\n * let cube1 = cube({\n *   r: 10,\n *   fn: 20\n * })\n */\nfunction cube(params) {\n  const defaults = {\n    size: 1,\n    offset: [0, 0, 0],\n    round: false,\n    radius: 0,\n    fn: 8,\n  };\n\n  let { round, radius, fn, size } = Object.assign({}, defaults, params);\n  let offset = [0, 0, 0];\n  let v = null;\n  if (params && params.length) v = params;\n  if (params && params.size && params.size.length) v = params.size; // { size: [1,2,3] }\n  if (params && params.size && !params.size.length) size = params.size; // { size: 1 }\n  if (params && typeof params !== 'object') size = params; // (2)\n  if (params && params.round === true) {\n    round = true;\n    radius = v && v.length ? (v[0] + v[1] + v[2]) / 30 : size / 10;\n  }\n  if (params && params.radius) {\n    round = true;\n    radius = params.radius;\n  }\n\n  let x = size;\n  let y = size;\n  let z = size;\n  if (v && v.length) {\n    [x, y, z] = v;\n  }\n  offset = [x / 2, y / 2, z / 2]; // center: false default\n  let object = round\n    ? CSG.roundedCube({\n        radius: [x / 2, y / 2, z / 2],\n        roundradius: radius,\n        resolution: fn,\n      })\n    : CSG.cube({ radius: [x / 2, y / 2, z / 2] });\n  if (params && params.center && params.center.length) {\n    offset = [\n      params.center[0] ? 0 : x / 2,\n      params.center[1] ? 0 : y / 2,\n      params.center[2] ? 0 : z / 2,\n    ];\n  } else if (params && params.center === true) {\n    offset = [0, 0, 0];\n  } else if (params && params.center === false) {\n    offset = [x / 2, y / 2, z / 2];\n  }\n  return offset[0] || offset[1] || offset[2]\n    ? translate(offset, object)\n    : object;\n}\n\n/** Construct a sphere\n * @param {Object} [options] - options for construction\n * @param {Float} [options.r=1] - radius of the sphere\n * @param {Integer} [options.fn=32] - segments of the sphere (ie quality/resolution)\n * @param {Integer} [options.fno=32] - segments of extrusion (ie quality)\n * @param {String} [options.type='normal'] - type of sphere : either 'normal' or 'geodesic'\n * @returns {CSG} new sphere\n *\n * @example\n * let sphere1 = sphere({\n *   r: 10,\n *   fn: 20\n * })\n */\nfunction sphere(params) {\n  const defaults = {\n    r: 1,\n    fn: 32,\n    type: 'normal',\n  };\n\n  let { r, fn, type } = Object.assign({}, defaults, params);\n  let offset = [0, 0, 0]; // center: false (default)\n  if (params && typeof params !== 'object') {\n    r = params;\n  }\n  // let zoffset = 0 // sphere() in openscad has no center:true|false\n\n  let output =\n    type === 'geodesic'\n      ? geodesicSphere(params)\n      : CSG.sphere({ radius: r, resolution: fn });\n\n  // preparing individual x,y,z center\n  if (params && params.center && params.center.length) {\n    offset = [\n      params.center[0] ? 0 : r,\n      params.center[1] ? 0 : r,\n      params.center[2] ? 0 : r,\n    ];\n  } else if (params && params.center === true) {\n    offset = [0, 0, 0];\n  } else if (params && params.center === false) {\n    offset = [r, r, r];\n  }\n  return offset[0] || offset[1] || offset[2]\n    ? translate(offset, output)\n    : output;\n}\n\nfunction geodesicSphere(params) {\n  const defaults = {\n    r: 1,\n    fn: 5,\n  };\n  let { r, fn } = Object.assign({}, defaults, params);\n\n  let ci = [\n    // hard-coded data of icosahedron (20 faces, all triangles)\n    [0.850651, 0.0, -0.525731],\n    [0.850651, -0.0, 0.525731],\n    [-0.850651, -0.0, 0.525731],\n    [-0.850651, 0.0, -0.525731],\n    [0.0, -0.525731, 0.850651],\n    [0.0, 0.525731, 0.850651],\n    [0.0, 0.525731, -0.850651],\n    [0.0, -0.525731, -0.850651],\n    [-0.525731, -0.850651, -0.0],\n    [0.525731, -0.850651, -0.0],\n    [0.525731, 0.850651, 0.0],\n    [-0.525731, 0.850651, 0.0],\n  ];\n\n  let ti = [\n    [0, 9, 1],\n    [1, 10, 0],\n    [6, 7, 0],\n    [10, 6, 0],\n    [7, 9, 0],\n    [5, 1, 4],\n    [4, 1, 9],\n    [5, 10, 1],\n    [2, 8, 3],\n    [3, 11, 2],\n    [2, 5, 4],\n    [4, 8, 2],\n    [2, 11, 5],\n    [3, 7, 6],\n    [6, 11, 3],\n    [8, 7, 3],\n    [9, 8, 4],\n    [11, 10, 5],\n    [10, 11, 6],\n    [8, 9, 7],\n  ];\n\n  let geodesicSubDivide = function (p, fn, offset) {\n    let p1 = p[0];\n    let p2 = p[1];\n    let p3 = p[2];\n    let n = offset;\n    let c = [];\n    let f = [];\n\n    //           p3\n    //           /\\\n    //          /__\\     fn = 3\n    //      i  /\\  /\\\n    //        /__\\/__\\       total triangles = 9 (fn*fn)\n    //       /\\  /\\  /\\\n    //     0/__\\/__\\/__\\\n    //    p1 0   j      p2\n\n    for (let i = 0; i < fn; i++) {\n      for (let j = 0; j < fn - i; j++) {\n        let t0 = i / fn;\n        let t1 = (i + 1) / fn;\n        let s0 = j / (fn - i);\n        let s1 = (j + 1) / (fn - i);\n        let s2 = fn - i - 1 ? j / (fn - i - 1) : 1;\n        let q = [];\n\n        q[0] = mix3(mix3(p1, p2, s0), p3, t0);\n        q[1] = mix3(mix3(p1, p2, s1), p3, t0);\n        q[2] = mix3(mix3(p1, p2, s2), p3, t1);\n\n        // -- normalize\n        for (let k = 0; k < 3; k++) {\n          let r = Math.sqrt(\n            q[k][0] * q[k][0] + q[k][1] * q[k][1] + q[k][2] * q[k][2]\n          );\n          for (let l = 0; l < 3; l++) {\n            q[k][l] /= r;\n          }\n        }\n        c.push(q[0], q[1], q[2]);\n        f.push([n, n + 1, n + 2]);\n        n += 3;\n\n        if (j < fn - i - 1) {\n          let s3 = fn - i - 1 ? (j + 1) / (fn - i - 1) : 1;\n          q[0] = mix3(mix3(p1, p2, s1), p3, t0);\n          q[1] = mix3(mix3(p1, p2, s3), p3, t1);\n          q[2] = mix3(mix3(p1, p2, s2), p3, t1);\n\n          // -- normalize\n          for (let k = 0; k < 3; k++) {\n            let r = Math.sqrt(\n              q[k][0] * q[k][0] + q[k][1] * q[k][1] + q[k][2] * q[k][2]\n            );\n            for (let l = 0; l < 3; l++) {\n              q[k][l] /= r;\n            }\n          }\n          c.push(q[0], q[1], q[2]);\n          f.push([n, n + 1, n + 2]);\n          n += 3;\n        }\n      }\n    }\n    return { points: c, triangles: f, offset: n };\n  };\n\n  const mix3 = function (a, b, f) {\n    let _f = 1 - f;\n    let c = [];\n    for (let i = 0; i < 3; i++) {\n      c[i] = a[i] * _f + b[i] * f;\n    }\n    return c;\n  };\n\n  if (params) {\n    if (params.fn) fn = Math.floor(params.fn / 6);\n  }\n\n  if (fn <= 0) fn = 1;\n\n  let c = [];\n  let f = [];\n  let offset = 0;\n\n  for (let i = 0; i < ti.length; i++) {\n    let g = geodesicSubDivide(\n      [ci[ti[i][0]], ci[ti[i][1]], ci[ti[i][2]]],\n      fn,\n      offset\n    );\n    c = c.concat(g.points);\n    f = f.concat(g.triangles);\n    offset = g.offset;\n  }\n  return scale(r, polyhedron({ points: c, triangles: f }));\n}\n\n/** Construct a cylinder\n * @param {Object} [options] - options for construction\n * @param {Float} [options.r=1] - radius of the cylinder\n * @param {Float} [options.r1=1] - radius of the top of the cylinder\n * @param {Float} [options.r2=1] - radius of the bottom of the cylinder\n * @param {Float} [options.d=1] - diameter of the cylinder\n * @param {Float} [options.d1=1] - diameter of the top of the cylinder\n * @param {Float} [options.d2=1] - diameter of the bottom of the cylinder\n * @param {Integer} [options.fn=32] - number of sides of the cylinder (ie quality/resolution)\n * @returns {CSG} new cylinder\n *\n * @example\n * let cylinder = cylinder({\n *   d: 10,\n *   fn: 20\n * })\n */\nfunction cylinder(params) {\n  const defaults = {\n    r: 1,\n    r1: 1,\n    r2: 1,\n    h: 1,\n    fn: 32,\n    round: false,\n  };\n  let { r1, r2, h, fn, round } = Object.assign({}, defaults, params);\n  let offset = [0, 0, 0];\n  let a = arguments;\n  if (params && params.d) {\n    r1 = r2 = params.d / 2;\n  }\n  if (params && params.r) {\n    r1 = params.r;\n    r2 = params.r;\n  }\n  if (params && params.h) {\n    h = params.h;\n  }\n  if (params && (params.r1 || params.r2)) {\n    r1 = params.r1;\n    r2 = params.r2;\n    if (params.h) h = params.h;\n  }\n  if (params && (params.d1 || params.d2)) {\n    r1 = params.d1 / 2;\n    r2 = params.d2 / 2;\n  }\n\n  if (a && a[0] && a[0].length) {\n    a = a[0];\n    r1 = a[0];\n    r2 = a[1];\n    h = a[2];\n    if (a.length === 4) fn = a[3];\n  }\n\n  let object;\n  if (params && params.start && params.end) {\n    object = round\n      ? CSG.roundedCylinder({\n          start: params.start,\n          end: params.end,\n          radiusStart: r1,\n          radiusEnd: r2,\n          resolution: fn,\n        })\n      : CSG.cylinder({\n          start: params.start,\n          end: params.end,\n          radiusStart: r1,\n          radiusEnd: r2,\n          resolution: fn,\n        });\n  } else {\n    object = round\n      ? CSG.roundedCylinder({\n          start: [0, 0, 0],\n          end: [0, 0, h],\n          radiusStart: r1,\n          radiusEnd: r2,\n          resolution: fn,\n        })\n      : CSG.cylinder({\n          start: [0, 0, 0],\n          end: [0, 0, h],\n          radiusStart: r1,\n          radiusEnd: r2,\n          resolution: fn,\n        });\n    let r = r1 > r2 ? r1 : r2;\n    if (params && params.center && params.center.length) {\n      // preparing individual x,y,z center\n      offset = [\n        params.center[0] ? 0 : r,\n        params.center[1] ? 0 : r,\n        params.center[2] ? -h / 2 : 0,\n      ];\n    } else if (params && params.center === true) {\n      offset = [0, 0, -h / 2];\n    } else if (params && params.center === false) {\n      offset = [0, 0, 0];\n    }\n    object =\n      offset[0] || offset[1] || offset[2] ? translate(offset, object) : object;\n  }\n  return object;\n}\n\n/** Construct a torus\n * @param {Object} [options] - options for construction\n * @param {Float} [options.ri=1] - radius of base circle\n * @param {Float} [options.ro=4] - radius offset\n * @param {Integer} [options.fni=16] - segments of base circle (ie quality)\n * @param {Integer} [options.fno=32] - segments of extrusion (ie quality)\n * @param {Integer} [options.roti=0] - rotation angle of base circle\n * @returns {CSG} new torus\n *\n * @example\n * let torus1 = torus({\n *   ri: 10\n * })\n */\nfunction torus(params) {\n  const defaults = {\n    ri: 1,\n    ro: 4,\n    fni: 16,\n    fno: 32,\n    roti: 0,\n  };\n  params = Object.assign({}, defaults, params);\n\n  /* possible enhancements ? declarative limits\n  const limits = {\n    fni: {min: 3},\n    fno: {min: 3}\n  } */\n\n  let { ri, ro, fni, fno, roti } = params;\n\n  if (fni < 3) fni = 3;\n  if (fno < 3) fno = 3;\n\n  let baseCircle = circle({ r: ri, fn: fni, center: true });\n\n  if (roti) baseCircle = baseCircle.rotateZ(roti);\n  let result = rotate_extrude({ fn: fno }, translate([ro, 0, 0], baseCircle));\n  // result = result.union(result)\n  return result;\n}\n\n/** Construct a polyhedron from the given triangles/ polygons/points\n * @param {Object} [options] - options for construction\n * @param {Array} [options.triangles] - triangles to build the polyhedron from\n * @param {Array} [options.polygons] - polygons to build the polyhedron from\n * @param {Array} [options.points] - points to build the polyhedron from\n * @param {Array} [options.colors] - colors to apply to the polyhedron\n * @returns {CSG} new polyhedron\n *\n * @example\n * let torus1 = polyhedron({\n *   points: [...]\n * })\n */\nfunction polyhedron(params) {\n  let pgs = [];\n  let ref = params.triangles || params.polygons;\n  let colors = params.colors || null;\n\n  for (let i = 0; i < ref.length; i++) {\n    let pp = [];\n    for (let j = 0; j < ref[i].length; j++) {\n      pp[j] = params.points[ref[i][j]];\n    }\n\n    let v = [];\n    for (let j = ref[i].length - 1; j >= 0; j--) {\n      // --- we reverse order for examples of OpenSCAD work\n      v.push(new Vertex3(new Vector3(pp[j][0], pp[j][1], pp[j][2])));\n    }\n    let s = Polygon3.defaultShared;\n    if (colors && colors[i]) {\n      s = Polygon3.Shared.fromColor(colors[i]);\n    }\n    pgs.push(new Polygon3(v, s));\n  }\n\n  // forced to import here, otherwise out of order imports mess things up\n  const { fromPolygons } = __webpack_require__(/*! ../core/CSGFactories */ \"./src/core/CSGFactories.js\");\n  return fromPolygons(pgs);\n}\n\nmodule.exports = {\n  cube,\n  sphere,\n  cylinder,\n  geodesicSphere,\n  torus,\n  polyhedron,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3ByaW1pdGl2ZXMzZC1hcGkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvYXBpL3ByaW1pdGl2ZXMzZC1hcGkuanM/OTQ5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gLy8vLy8vLy8vL0ZVTkNUSU9OQUwgQVBJXG5jb25zdCB7IENTRyB9ID0gcmVxdWlyZSgnLi4vLi4vY3NnJyk7XG5jb25zdCB7IGNpcmNsZSB9ID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzMmQtYXBpJyk7XG5jb25zdCB7IHJvdGF0ZV9leHRydWRlIH0gPSByZXF1aXJlKCcuL29wcy1leHRydXNpb25zJyk7XG5jb25zdCB7IHRyYW5zbGF0ZSwgc2NhbGUgfSA9IHJlcXVpcmUoJy4vb3BzLXRyYW5zZm9ybWF0aW9ucycpO1xuY29uc3QgUG9seWdvbjMgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvUG9seWdvbjMnKTtcbmNvbnN0IFZlY3RvcjMgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvVmVjdG9yMycpO1xuY29uc3QgVmVydGV4MyA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9WZXJ0ZXgzJyk7XG5cbi8qKiBDb25zdHJ1Y3QgYSBjdWJvaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBjb25zdHJ1Y3Rpb25cbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLnNpemU9MV0gLSBzaXplIG9mIHRoZSBzaWRlIG9mIHRoZSBjdWJvaWQgOiBjYW4gYmUgZWl0aGVyOlxuICogLSBhIHNjYWxhciA6IGllIGEgc2luZ2xlIGZsb2F0LCBpbiB3aGljaCBjYXNlIGFsbCBkaW1lbnNpb25zIHdpbGwgYmUgdGhlIHNhbWVcbiAqIC0gb3IgYW4gYXJyYXk6IHRvIHNwZWNpZnkgZGlmZmVyZW50IGRpbWVuc2lvbnMgYWxvbmcgeC95L3pcbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuZm49MzJdIC0gc2VnbWVudHMgb2YgdGhlIHNwaGVyZSAoaWUgcXVhbGl0eS9yZXNvbHV0aW9uKVxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5mbm89MzJdIC0gc2VnbWVudHMgb2YgZXh0cnVzaW9uIChpZSBxdWFsaXR5KVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGU9J25vcm1hbCddIC0gdHlwZSBvZiBzcGhlcmUgOiBlaXRoZXIgJ25vcm1hbCcgb3IgJ2dlb2Rlc2ljJ1xuICogQHJldHVybnMge0NTR30gbmV3IHNwaGVyZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgY3ViZTEgPSBjdWJlKHtcbiAqICAgcjogMTAsXG4gKiAgIGZuOiAyMFxuICogfSlcbiAqL1xuZnVuY3Rpb24gY3ViZShwYXJhbXMpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgc2l6ZTogMSxcbiAgICBvZmZzZXQ6IFswLCAwLCAwXSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgcmFkaXVzOiAwLFxuICAgIGZuOiA4LFxuICB9O1xuXG4gIGxldCB7IHJvdW5kLCByYWRpdXMsIGZuLCBzaXplIH0gPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgbGV0IG9mZnNldCA9IFswLCAwLCAwXTtcbiAgbGV0IHYgPSBudWxsO1xuICBpZiAocGFyYW1zICYmIHBhcmFtcy5sZW5ndGgpIHYgPSBwYXJhbXM7XG4gIGlmIChwYXJhbXMgJiYgcGFyYW1zLnNpemUgJiYgcGFyYW1zLnNpemUubGVuZ3RoKSB2ID0gcGFyYW1zLnNpemU7IC8vIHsgc2l6ZTogWzEsMiwzXSB9XG4gIGlmIChwYXJhbXMgJiYgcGFyYW1zLnNpemUgJiYgIXBhcmFtcy5zaXplLmxlbmd0aCkgc2l6ZSA9IHBhcmFtcy5zaXplOyAvLyB7IHNpemU6IDEgfVxuICBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSBzaXplID0gcGFyYW1zOyAvLyAoMilcbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucm91bmQgPT09IHRydWUpIHtcbiAgICByb3VuZCA9IHRydWU7XG4gICAgcmFkaXVzID0gdiAmJiB2Lmxlbmd0aCA/ICh2WzBdICsgdlsxXSArIHZbMl0pIC8gMzAgOiBzaXplIC8gMTA7XG4gIH1cbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucmFkaXVzKSB7XG4gICAgcm91bmQgPSB0cnVlO1xuICAgIHJhZGl1cyA9IHBhcmFtcy5yYWRpdXM7XG4gIH1cblxuICBsZXQgeCA9IHNpemU7XG4gIGxldCB5ID0gc2l6ZTtcbiAgbGV0IHogPSBzaXplO1xuICBpZiAodiAmJiB2Lmxlbmd0aCkge1xuICAgIFt4LCB5LCB6XSA9IHY7XG4gIH1cbiAgb2Zmc2V0ID0gW3ggLyAyLCB5IC8gMiwgeiAvIDJdOyAvLyBjZW50ZXI6IGZhbHNlIGRlZmF1bHRcbiAgbGV0IG9iamVjdCA9IHJvdW5kXG4gICAgPyBDU0cucm91bmRlZEN1YmUoe1xuICAgICAgICByYWRpdXM6IFt4IC8gMiwgeSAvIDIsIHogLyAyXSxcbiAgICAgICAgcm91bmRyYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgcmVzb2x1dGlvbjogZm4sXG4gICAgICB9KVxuICAgIDogQ1NHLmN1YmUoeyByYWRpdXM6IFt4IC8gMiwgeSAvIDIsIHogLyAyXSB9KTtcbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuY2VudGVyICYmIHBhcmFtcy5jZW50ZXIubGVuZ3RoKSB7XG4gICAgb2Zmc2V0ID0gW1xuICAgICAgcGFyYW1zLmNlbnRlclswXSA/IDAgOiB4IC8gMixcbiAgICAgIHBhcmFtcy5jZW50ZXJbMV0gPyAwIDogeSAvIDIsXG4gICAgICBwYXJhbXMuY2VudGVyWzJdID8gMCA6IHogLyAyLFxuICAgIF07XG4gIH0gZWxzZSBpZiAocGFyYW1zICYmIHBhcmFtcy5jZW50ZXIgPT09IHRydWUpIHtcbiAgICBvZmZzZXQgPSBbMCwgMCwgMF07XG4gIH0gZWxzZSBpZiAocGFyYW1zICYmIHBhcmFtcy5jZW50ZXIgPT09IGZhbHNlKSB7XG4gICAgb2Zmc2V0ID0gW3ggLyAyLCB5IC8gMiwgeiAvIDJdO1xuICB9XG4gIHJldHVybiBvZmZzZXRbMF0gfHwgb2Zmc2V0WzFdIHx8IG9mZnNldFsyXVxuICAgID8gdHJhbnNsYXRlKG9mZnNldCwgb2JqZWN0KVxuICAgIDogb2JqZWN0O1xufVxuXG4vKiogQ29uc3RydWN0IGEgc3BoZXJlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5yPTFdIC0gcmFkaXVzIG9mIHRoZSBzcGhlcmVcbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuZm49MzJdIC0gc2VnbWVudHMgb2YgdGhlIHNwaGVyZSAoaWUgcXVhbGl0eS9yZXNvbHV0aW9uKVxuICogQHBhcmFtIHtJbnRlZ2VyfSBbb3B0aW9ucy5mbm89MzJdIC0gc2VnbWVudHMgb2YgZXh0cnVzaW9uIChpZSBxdWFsaXR5KVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGU9J25vcm1hbCddIC0gdHlwZSBvZiBzcGhlcmUgOiBlaXRoZXIgJ25vcm1hbCcgb3IgJ2dlb2Rlc2ljJ1xuICogQHJldHVybnMge0NTR30gbmV3IHNwaGVyZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgc3BoZXJlMSA9IHNwaGVyZSh7XG4gKiAgIHI6IDEwLFxuICogICBmbjogMjBcbiAqIH0pXG4gKi9cbmZ1bmN0aW9uIHNwaGVyZShwYXJhbXMpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgcjogMSxcbiAgICBmbjogMzIsXG4gICAgdHlwZTogJ25vcm1hbCcsXG4gIH07XG5cbiAgbGV0IHsgciwgZm4sIHR5cGUgfSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICBsZXQgb2Zmc2V0ID0gWzAsIDAsIDBdOyAvLyBjZW50ZXI6IGZhbHNlIChkZWZhdWx0KVxuICBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgciA9IHBhcmFtcztcbiAgfVxuICAvLyBsZXQgem9mZnNldCA9IDAgLy8gc3BoZXJlKCkgaW4gb3BlbnNjYWQgaGFzIG5vIGNlbnRlcjp0cnVlfGZhbHNlXG5cbiAgbGV0IG91dHB1dCA9XG4gICAgdHlwZSA9PT0gJ2dlb2Rlc2ljJ1xuICAgICAgPyBnZW9kZXNpY1NwaGVyZShwYXJhbXMpXG4gICAgICA6IENTRy5zcGhlcmUoeyByYWRpdXM6IHIsIHJlc29sdXRpb246IGZuIH0pO1xuXG4gIC8vIHByZXBhcmluZyBpbmRpdmlkdWFsIHgseSx6IGNlbnRlclxuICBpZiAocGFyYW1zICYmIHBhcmFtcy5jZW50ZXIgJiYgcGFyYW1zLmNlbnRlci5sZW5ndGgpIHtcbiAgICBvZmZzZXQgPSBbXG4gICAgICBwYXJhbXMuY2VudGVyWzBdID8gMCA6IHIsXG4gICAgICBwYXJhbXMuY2VudGVyWzFdID8gMCA6IHIsXG4gICAgICBwYXJhbXMuY2VudGVyWzJdID8gMCA6IHIsXG4gICAgXTtcbiAgfSBlbHNlIGlmIChwYXJhbXMgJiYgcGFyYW1zLmNlbnRlciA9PT0gdHJ1ZSkge1xuICAgIG9mZnNldCA9IFswLCAwLCAwXTtcbiAgfSBlbHNlIGlmIChwYXJhbXMgJiYgcGFyYW1zLmNlbnRlciA9PT0gZmFsc2UpIHtcbiAgICBvZmZzZXQgPSBbciwgciwgcl07XG4gIH1cbiAgcmV0dXJuIG9mZnNldFswXSB8fCBvZmZzZXRbMV0gfHwgb2Zmc2V0WzJdXG4gICAgPyB0cmFuc2xhdGUob2Zmc2V0LCBvdXRwdXQpXG4gICAgOiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGdlb2Rlc2ljU3BoZXJlKHBhcmFtcykge1xuICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICByOiAxLFxuICAgIGZuOiA1LFxuICB9O1xuICBsZXQgeyByLCBmbiB9ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgbGV0IGNpID0gW1xuICAgIC8vIGhhcmQtY29kZWQgZGF0YSBvZiBpY29zYWhlZHJvbiAoMjAgZmFjZXMsIGFsbCB0cmlhbmdsZXMpXG4gICAgWzAuODUwNjUxLCAwLjAsIC0wLjUyNTczMV0sXG4gICAgWzAuODUwNjUxLCAtMC4wLCAwLjUyNTczMV0sXG4gICAgWy0wLjg1MDY1MSwgLTAuMCwgMC41MjU3MzFdLFxuICAgIFstMC44NTA2NTEsIDAuMCwgLTAuNTI1NzMxXSxcbiAgICBbMC4wLCAtMC41MjU3MzEsIDAuODUwNjUxXSxcbiAgICBbMC4wLCAwLjUyNTczMSwgMC44NTA2NTFdLFxuICAgIFswLjAsIDAuNTI1NzMxLCAtMC44NTA2NTFdLFxuICAgIFswLjAsIC0wLjUyNTczMSwgLTAuODUwNjUxXSxcbiAgICBbLTAuNTI1NzMxLCAtMC44NTA2NTEsIC0wLjBdLFxuICAgIFswLjUyNTczMSwgLTAuODUwNjUxLCAtMC4wXSxcbiAgICBbMC41MjU3MzEsIDAuODUwNjUxLCAwLjBdLFxuICAgIFstMC41MjU3MzEsIDAuODUwNjUxLCAwLjBdLFxuICBdO1xuXG4gIGxldCB0aSA9IFtcbiAgICBbMCwgOSwgMV0sXG4gICAgWzEsIDEwLCAwXSxcbiAgICBbNiwgNywgMF0sXG4gICAgWzEwLCA2LCAwXSxcbiAgICBbNywgOSwgMF0sXG4gICAgWzUsIDEsIDRdLFxuICAgIFs0LCAxLCA5XSxcbiAgICBbNSwgMTAsIDFdLFxuICAgIFsyLCA4LCAzXSxcbiAgICBbMywgMTEsIDJdLFxuICAgIFsyLCA1LCA0XSxcbiAgICBbNCwgOCwgMl0sXG4gICAgWzIsIDExLCA1XSxcbiAgICBbMywgNywgNl0sXG4gICAgWzYsIDExLCAzXSxcbiAgICBbOCwgNywgM10sXG4gICAgWzksIDgsIDRdLFxuICAgIFsxMSwgMTAsIDVdLFxuICAgIFsxMCwgMTEsIDZdLFxuICAgIFs4LCA5LCA3XSxcbiAgXTtcblxuICBsZXQgZ2VvZGVzaWNTdWJEaXZpZGUgPSBmdW5jdGlvbiAocCwgZm4sIG9mZnNldCkge1xuICAgIGxldCBwMSA9IHBbMF07XG4gICAgbGV0IHAyID0gcFsxXTtcbiAgICBsZXQgcDMgPSBwWzJdO1xuICAgIGxldCBuID0gb2Zmc2V0O1xuICAgIGxldCBjID0gW107XG4gICAgbGV0IGYgPSBbXTtcblxuICAgIC8vICAgICAgICAgICBwM1xuICAgIC8vICAgICAgICAgICAvXFxcbiAgICAvLyAgICAgICAgICAvX19cXCAgICAgZm4gPSAzXG4gICAgLy8gICAgICBpICAvXFwgIC9cXFxuICAgIC8vICAgICAgICAvX19cXC9fX1xcICAgICAgIHRvdGFsIHRyaWFuZ2xlcyA9IDkgKGZuKmZuKVxuICAgIC8vICAgICAgIC9cXCAgL1xcICAvXFxcbiAgICAvLyAgICAgMC9fX1xcL19fXFwvX19cXFxuICAgIC8vICAgIHAxIDAgICBqICAgICAgcDJcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm47IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmbiAtIGk7IGorKykge1xuICAgICAgICBsZXQgdDAgPSBpIC8gZm47XG4gICAgICAgIGxldCB0MSA9IChpICsgMSkgLyBmbjtcbiAgICAgICAgbGV0IHMwID0gaiAvIChmbiAtIGkpO1xuICAgICAgICBsZXQgczEgPSAoaiArIDEpIC8gKGZuIC0gaSk7XG4gICAgICAgIGxldCBzMiA9IGZuIC0gaSAtIDEgPyBqIC8gKGZuIC0gaSAtIDEpIDogMTtcbiAgICAgICAgbGV0IHEgPSBbXTtcblxuICAgICAgICBxWzBdID0gbWl4MyhtaXgzKHAxLCBwMiwgczApLCBwMywgdDApO1xuICAgICAgICBxWzFdID0gbWl4MyhtaXgzKHAxLCBwMiwgczEpLCBwMywgdDApO1xuICAgICAgICBxWzJdID0gbWl4MyhtaXgzKHAxLCBwMiwgczIpLCBwMywgdDEpO1xuXG4gICAgICAgIC8vIC0tIG5vcm1hbGl6ZVxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDM7IGsrKykge1xuICAgICAgICAgIGxldCByID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgcVtrXVswXSAqIHFba11bMF0gKyBxW2tdWzFdICogcVtrXVsxXSArIHFba11bMl0gKiBxW2tdWzJdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IDM7IGwrKykge1xuICAgICAgICAgICAgcVtrXVtsXSAvPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjLnB1c2gocVswXSwgcVsxXSwgcVsyXSk7XG4gICAgICAgIGYucHVzaChbbiwgbiArIDEsIG4gKyAyXSk7XG4gICAgICAgIG4gKz0gMztcblxuICAgICAgICBpZiAoaiA8IGZuIC0gaSAtIDEpIHtcbiAgICAgICAgICBsZXQgczMgPSBmbiAtIGkgLSAxID8gKGogKyAxKSAvIChmbiAtIGkgLSAxKSA6IDE7XG4gICAgICAgICAgcVswXSA9IG1peDMobWl4MyhwMSwgcDIsIHMxKSwgcDMsIHQwKTtcbiAgICAgICAgICBxWzFdID0gbWl4MyhtaXgzKHAxLCBwMiwgczMpLCBwMywgdDEpO1xuICAgICAgICAgIHFbMl0gPSBtaXgzKG1peDMocDEsIHAyLCBzMiksIHAzLCB0MSk7XG5cbiAgICAgICAgICAvLyAtLSBub3JtYWxpemVcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDM7IGsrKykge1xuICAgICAgICAgICAgbGV0IHIgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIHFba11bMF0gKiBxW2tdWzBdICsgcVtrXVsxXSAqIHFba11bMV0gKyBxW2tdWzJdICogcVtrXVsyXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgMzsgbCsrKSB7XG4gICAgICAgICAgICAgIHFba11bbF0gLz0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYy5wdXNoKHFbMF0sIHFbMV0sIHFbMl0pO1xuICAgICAgICAgIGYucHVzaChbbiwgbiArIDEsIG4gKyAyXSk7XG4gICAgICAgICAgbiArPSAzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHBvaW50czogYywgdHJpYW5nbGVzOiBmLCBvZmZzZXQ6IG4gfTtcbiAgfTtcblxuICBjb25zdCBtaXgzID0gZnVuY3Rpb24gKGEsIGIsIGYpIHtcbiAgICBsZXQgX2YgPSAxIC0gZjtcbiAgICBsZXQgYyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBjW2ldID0gYVtpXSAqIF9mICsgYltpXSAqIGY7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmZuKSBmbiA9IE1hdGguZmxvb3IocGFyYW1zLmZuIC8gNik7XG4gIH1cblxuICBpZiAoZm4gPD0gMCkgZm4gPSAxO1xuXG4gIGxldCBjID0gW107XG4gIGxldCBmID0gW107XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGkubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZyA9IGdlb2Rlc2ljU3ViRGl2aWRlKFxuICAgICAgW2NpW3RpW2ldWzBdXSwgY2lbdGlbaV1bMV1dLCBjaVt0aVtpXVsyXV1dLFxuICAgICAgZm4sXG4gICAgICBvZmZzZXRcbiAgICApO1xuICAgIGMgPSBjLmNvbmNhdChnLnBvaW50cyk7XG4gICAgZiA9IGYuY29uY2F0KGcudHJpYW5nbGVzKTtcbiAgICBvZmZzZXQgPSBnLm9mZnNldDtcbiAgfVxuICByZXR1cm4gc2NhbGUociwgcG9seWhlZHJvbih7IHBvaW50czogYywgdHJpYW5nbGVzOiBmIH0pKTtcbn1cblxuLyoqIENvbnN0cnVjdCBhIGN5bGluZGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5yPTFdIC0gcmFkaXVzIG9mIHRoZSBjeWxpbmRlclxuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMucjE9MV0gLSByYWRpdXMgb2YgdGhlIHRvcCBvZiB0aGUgY3lsaW5kZXJcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLnIyPTFdIC0gcmFkaXVzIG9mIHRoZSBib3R0b20gb2YgdGhlIGN5bGluZGVyXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kPTFdIC0gZGlhbWV0ZXIgb2YgdGhlIGN5bGluZGVyXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kMT0xXSAtIGRpYW1ldGVyIG9mIHRoZSB0b3Agb2YgdGhlIGN5bGluZGVyXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kMj0xXSAtIGRpYW1ldGVyIG9mIHRoZSBib3R0b20gb2YgdGhlIGN5bGluZGVyXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmZuPTMyXSAtIG51bWJlciBvZiBzaWRlcyBvZiB0aGUgY3lsaW5kZXIgKGllIHF1YWxpdHkvcmVzb2x1dGlvbilcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBjeWxpbmRlclxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgY3lsaW5kZXIgPSBjeWxpbmRlcih7XG4gKiAgIGQ6IDEwLFxuICogICBmbjogMjBcbiAqIH0pXG4gKi9cbmZ1bmN0aW9uIGN5bGluZGVyKHBhcmFtcykge1xuICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICByOiAxLFxuICAgIHIxOiAxLFxuICAgIHIyOiAxLFxuICAgIGg6IDEsXG4gICAgZm46IDMyLFxuICAgIHJvdW5kOiBmYWxzZSxcbiAgfTtcbiAgbGV0IHsgcjEsIHIyLCBoLCBmbiwgcm91bmQgfSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICBsZXQgb2Zmc2V0ID0gWzAsIDAsIDBdO1xuICBsZXQgYSA9IGFyZ3VtZW50cztcbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuZCkge1xuICAgIHIxID0gcjIgPSBwYXJhbXMuZCAvIDI7XG4gIH1cbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucikge1xuICAgIHIxID0gcGFyYW1zLnI7XG4gICAgcjIgPSBwYXJhbXMucjtcbiAgfVxuICBpZiAocGFyYW1zICYmIHBhcmFtcy5oKSB7XG4gICAgaCA9IHBhcmFtcy5oO1xuICB9XG4gIGlmIChwYXJhbXMgJiYgKHBhcmFtcy5yMSB8fCBwYXJhbXMucjIpKSB7XG4gICAgcjEgPSBwYXJhbXMucjE7XG4gICAgcjIgPSBwYXJhbXMucjI7XG4gICAgaWYgKHBhcmFtcy5oKSBoID0gcGFyYW1zLmg7XG4gIH1cbiAgaWYgKHBhcmFtcyAmJiAocGFyYW1zLmQxIHx8IHBhcmFtcy5kMikpIHtcbiAgICByMSA9IHBhcmFtcy5kMSAvIDI7XG4gICAgcjIgPSBwYXJhbXMuZDIgLyAyO1xuICB9XG5cbiAgaWYgKGEgJiYgYVswXSAmJiBhWzBdLmxlbmd0aCkge1xuICAgIGEgPSBhWzBdO1xuICAgIHIxID0gYVswXTtcbiAgICByMiA9IGFbMV07XG4gICAgaCA9IGFbMl07XG4gICAgaWYgKGEubGVuZ3RoID09PSA0KSBmbiA9IGFbM107XG4gIH1cblxuICBsZXQgb2JqZWN0O1xuICBpZiAocGFyYW1zICYmIHBhcmFtcy5zdGFydCAmJiBwYXJhbXMuZW5kKSB7XG4gICAgb2JqZWN0ID0gcm91bmRcbiAgICAgID8gQ1NHLnJvdW5kZWRDeWxpbmRlcih7XG4gICAgICAgICAgc3RhcnQ6IHBhcmFtcy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHBhcmFtcy5lbmQsXG4gICAgICAgICAgcmFkaXVzU3RhcnQ6IHIxLFxuICAgICAgICAgIHJhZGl1c0VuZDogcjIsXG4gICAgICAgICAgcmVzb2x1dGlvbjogZm4sXG4gICAgICAgIH0pXG4gICAgICA6IENTRy5jeWxpbmRlcih7XG4gICAgICAgICAgc3RhcnQ6IHBhcmFtcy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHBhcmFtcy5lbmQsXG4gICAgICAgICAgcmFkaXVzU3RhcnQ6IHIxLFxuICAgICAgICAgIHJhZGl1c0VuZDogcjIsXG4gICAgICAgICAgcmVzb2x1dGlvbjogZm4sXG4gICAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdCA9IHJvdW5kXG4gICAgICA/IENTRy5yb3VuZGVkQ3lsaW5kZXIoe1xuICAgICAgICAgIHN0YXJ0OiBbMCwgMCwgMF0sXG4gICAgICAgICAgZW5kOiBbMCwgMCwgaF0sXG4gICAgICAgICAgcmFkaXVzU3RhcnQ6IHIxLFxuICAgICAgICAgIHJhZGl1c0VuZDogcjIsXG4gICAgICAgICAgcmVzb2x1dGlvbjogZm4sXG4gICAgICAgIH0pXG4gICAgICA6IENTRy5jeWxpbmRlcih7XG4gICAgICAgICAgc3RhcnQ6IFswLCAwLCAwXSxcbiAgICAgICAgICBlbmQ6IFswLCAwLCBoXSxcbiAgICAgICAgICByYWRpdXNTdGFydDogcjEsXG4gICAgICAgICAgcmFkaXVzRW5kOiByMixcbiAgICAgICAgICByZXNvbHV0aW9uOiBmbixcbiAgICAgICAgfSk7XG4gICAgbGV0IHIgPSByMSA+IHIyID8gcjEgOiByMjtcbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5jZW50ZXIgJiYgcGFyYW1zLmNlbnRlci5sZW5ndGgpIHtcbiAgICAgIC8vIHByZXBhcmluZyBpbmRpdmlkdWFsIHgseSx6IGNlbnRlclxuICAgICAgb2Zmc2V0ID0gW1xuICAgICAgICBwYXJhbXMuY2VudGVyWzBdID8gMCA6IHIsXG4gICAgICAgIHBhcmFtcy5jZW50ZXJbMV0gPyAwIDogcixcbiAgICAgICAgcGFyYW1zLmNlbnRlclsyXSA/IC1oIC8gMiA6IDAsXG4gICAgICBdO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHBhcmFtcy5jZW50ZXIgPT09IHRydWUpIHtcbiAgICAgIG9mZnNldCA9IFswLCAwLCAtaCAvIDJdO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHBhcmFtcy5jZW50ZXIgPT09IGZhbHNlKSB7XG4gICAgICBvZmZzZXQgPSBbMCwgMCwgMF07XG4gICAgfVxuICAgIG9iamVjdCA9XG4gICAgICBvZmZzZXRbMF0gfHwgb2Zmc2V0WzFdIHx8IG9mZnNldFsyXSA/IHRyYW5zbGF0ZShvZmZzZXQsIG9iamVjdCkgOiBvYmplY3Q7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqIENvbnN0cnVjdCBhIHRvcnVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5yaT0xXSAtIHJhZGl1cyBvZiBiYXNlIGNpcmNsZVxuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMucm89NF0gLSByYWRpdXMgb2Zmc2V0XG4gKiBAcGFyYW0ge0ludGVnZXJ9IFtvcHRpb25zLmZuaT0xNl0gLSBzZWdtZW50cyBvZiBiYXNlIGNpcmNsZSAoaWUgcXVhbGl0eSlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMuZm5vPTMyXSAtIHNlZ21lbnRzIG9mIGV4dHJ1c2lvbiAoaWUgcXVhbGl0eSlcbiAqIEBwYXJhbSB7SW50ZWdlcn0gW29wdGlvbnMucm90aT0wXSAtIHJvdGF0aW9uIGFuZ2xlIG9mIGJhc2UgY2lyY2xlXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgdG9ydXNcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHRvcnVzMSA9IHRvcnVzKHtcbiAqICAgcmk6IDEwXG4gKiB9KVxuICovXG5mdW5jdGlvbiB0b3J1cyhwYXJhbXMpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgcmk6IDEsXG4gICAgcm86IDQsXG4gICAgZm5pOiAxNixcbiAgICBmbm86IDMyLFxuICAgIHJvdGk6IDAsXG4gIH07XG4gIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gIC8qIHBvc3NpYmxlIGVuaGFuY2VtZW50cyA/IGRlY2xhcmF0aXZlIGxpbWl0c1xuICBjb25zdCBsaW1pdHMgPSB7XG4gICAgZm5pOiB7bWluOiAzfSxcbiAgICBmbm86IHttaW46IDN9XG4gIH0gKi9cblxuICBsZXQgeyByaSwgcm8sIGZuaSwgZm5vLCByb3RpIH0gPSBwYXJhbXM7XG5cbiAgaWYgKGZuaSA8IDMpIGZuaSA9IDM7XG4gIGlmIChmbm8gPCAzKSBmbm8gPSAzO1xuXG4gIGxldCBiYXNlQ2lyY2xlID0gY2lyY2xlKHsgcjogcmksIGZuOiBmbmksIGNlbnRlcjogdHJ1ZSB9KTtcblxuICBpZiAocm90aSkgYmFzZUNpcmNsZSA9IGJhc2VDaXJjbGUucm90YXRlWihyb3RpKTtcbiAgbGV0IHJlc3VsdCA9IHJvdGF0ZV9leHRydWRlKHsgZm46IGZubyB9LCB0cmFuc2xhdGUoW3JvLCAwLCAwXSwgYmFzZUNpcmNsZSkpO1xuICAvLyByZXN1bHQgPSByZXN1bHQudW5pb24ocmVzdWx0KVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQ29uc3RydWN0IGEgcG9seWhlZHJvbiBmcm9tIHRoZSBnaXZlbiB0cmlhbmdsZXMvIHBvbHlnb25zL3BvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMudHJpYW5nbGVzXSAtIHRyaWFuZ2xlcyB0byBidWlsZCB0aGUgcG9seWhlZHJvbiBmcm9tXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wb2x5Z29uc10gLSBwb2x5Z29ucyB0byBidWlsZCB0aGUgcG9seWhlZHJvbiBmcm9tXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wb2ludHNdIC0gcG9pbnRzIHRvIGJ1aWxkIHRoZSBwb2x5aGVkcm9uIGZyb21cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbG9yc10gLSBjb2xvcnMgdG8gYXBwbHkgdG8gdGhlIHBvbHloZWRyb25cbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBwb2x5aGVkcm9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB0b3J1czEgPSBwb2x5aGVkcm9uKHtcbiAqICAgcG9pbnRzOiBbLi4uXVxuICogfSlcbiAqL1xuZnVuY3Rpb24gcG9seWhlZHJvbihwYXJhbXMpIHtcbiAgbGV0IHBncyA9IFtdO1xuICBsZXQgcmVmID0gcGFyYW1zLnRyaWFuZ2xlcyB8fCBwYXJhbXMucG9seWdvbnM7XG4gIGxldCBjb2xvcnMgPSBwYXJhbXMuY29sb3JzIHx8IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWYubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcHAgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlZltpXS5sZW5ndGg7IGorKykge1xuICAgICAgcHBbal0gPSBwYXJhbXMucG9pbnRzW3JlZltpXVtqXV07XG4gICAgfVxuXG4gICAgbGV0IHYgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gcmVmW2ldLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAvLyAtLS0gd2UgcmV2ZXJzZSBvcmRlciBmb3IgZXhhbXBsZXMgb2YgT3BlblNDQUQgd29ya1xuICAgICAgdi5wdXNoKG5ldyBWZXJ0ZXgzKG5ldyBWZWN0b3IzKHBwW2pdWzBdLCBwcFtqXVsxXSwgcHBbal1bMl0pKSk7XG4gICAgfVxuICAgIGxldCBzID0gUG9seWdvbjMuZGVmYXVsdFNoYXJlZDtcbiAgICBpZiAoY29sb3JzICYmIGNvbG9yc1tpXSkge1xuICAgICAgcyA9IFBvbHlnb24zLlNoYXJlZC5mcm9tQ29sb3IoY29sb3JzW2ldKTtcbiAgICB9XG4gICAgcGdzLnB1c2gobmV3IFBvbHlnb24zKHYsIHMpKTtcbiAgfVxuXG4gIC8vIGZvcmNlZCB0byBpbXBvcnQgaGVyZSwgb3RoZXJ3aXNlIG91dCBvZiBvcmRlciBpbXBvcnRzIG1lc3MgdGhpbmdzIHVwXG4gIGNvbnN0IHsgZnJvbVBvbHlnb25zIH0gPSByZXF1aXJlKCcuLi9jb3JlL0NTR0ZhY3RvcmllcycpO1xuICByZXR1cm4gZnJvbVBvbHlnb25zKHBncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjdWJlLFxuICBzcGhlcmUsXG4gIGN5bGluZGVyLFxuICBnZW9kZXNpY1NwaGVyZSxcbiAgdG9ydXMsXG4gIHBvbHloZWRyb24sXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/api/primitives3d-api.js\n");

/***/ }),

/***/ "./src/api/primitives3d.js":
/*!*********************************!*\
  !*** ./src/api/primitives3d.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  parseOption,\n  parseOptionAs3DVector,\n  parseOptionAs2DVector,\n  parseOptionAs3DVectorList,\n  parseOptionAsFloat,\n  parseOptionAsInt,\n} = __webpack_require__(/*! ./optionParsers */ \"./src/api/optionParsers.js\");\nconst {\n  defaultResolution3D,\n  defaultResolution2D,\n  EPS,\n} = __webpack_require__(/*! ../core/constants */ \"./src/core/constants.js\");\nconst Vector3 = __webpack_require__(/*! ../core/math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Vertex3 = __webpack_require__(/*! ../core/math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Polygon3 = __webpack_require__(/*! ../core/math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst { Connector } = __webpack_require__(/*! ../core/connectors */ \"./src/core/connectors.js\");\nconst Properties = __webpack_require__(/*! ../core/Properties */ \"./src/core/Properties.js\");\nconst { fromPolygons } = __webpack_require__(/*! ../core/CSGFactories */ \"./src/core/CSGFactories.js\");\n\n/** Construct an axis-aligned solid cuboid.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of cube\n * @param {Vector3} [options.radius=[1,1,1]] - radius of cube, single scalar also possible\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cube = CSG.cube({\n *   center: [5, 5, 5],\n *   radius: 5, // scalar radius\n * });\n */\nconst cube = function (options) {\n  let c;\n  let r;\n  let corner1;\n  let corner2;\n  options = options || {};\n  if ('corner1' in options || 'corner2' in options) {\n    if ('center' in options || 'radius' in options) {\n      throw new Error(\n        'cube: should either give a radius and center parameter, or a corner1 and corner2 parameter'\n      );\n    }\n    corner1 = parseOptionAs3DVector(options, 'corner1', [0, 0, 0]);\n    corner2 = parseOptionAs3DVector(options, 'corner2', [1, 1, 1]);\n    c = corner1.plus(corner2).times(0.5);\n    r = corner2.minus(corner1).times(0.5);\n  } else {\n    c = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n    r = parseOptionAs3DVector(options, 'radius', [1, 1, 1]);\n  }\n  r = r.abs(); // negative radii make no sense\n  let result = fromPolygons(\n    [\n      [\n        [0, 4, 6, 2],\n        [-1, 0, 0],\n      ],\n      [\n        [1, 3, 7, 5],\n        [+1, 0, 0],\n      ],\n      [\n        [0, 1, 5, 4],\n        [0, -1, 0],\n      ],\n      [\n        [2, 6, 7, 3],\n        [0, +1, 0],\n      ],\n      [\n        [0, 2, 3, 1],\n        [0, 0, -1],\n      ],\n      [\n        [4, 5, 7, 6],\n        [0, 0, +1],\n      ],\n    ].map(function (info) {\n      let vertices = info[0].map(function (i) {\n        let pos = new Vector3(\n          c.x + r.x * (2 * !!(i & 1) - 1),\n          c.y + r.y * (2 * !!(i & 2) - 1),\n          c.z + r.z * (2 * !!(i & 4) - 1)\n        );\n        return new Vertex3(pos);\n      });\n      return new Polygon3(vertices, null /* , plane */);\n    })\n  );\n  result.properties.cube = new Properties();\n  result.properties.cube.center = new Vector3(c);\n  // add 6 connectors, at the centers of each face:\n  result.properties.cube.facecenters = [\n    new Connector(new Vector3([r.x, 0, 0]).plus(c), [1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([-r.x, 0, 0]).plus(c), [-1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, r.y, 0]).plus(c), [0, 1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, -r.y, 0]).plus(c), [0, -1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, 0, r.z]).plus(c), [0, 0, 1], [1, 0, 0]),\n    new Connector(new Vector3([0, 0, -r.z]).plus(c), [0, 0, -1], [1, 0, 0]),\n  ];\n  return result;\n};\n\n/** Construct a solid sphere\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of sphere\n * @param {Number} [options.radius=1] - radius of sphere\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @param {Array} [options.axes] -  an array with 3 vectors for the x, y and z base vectors\n * @returns {CSG} new 3D solid\n *\n *\n * @example\n * let sphere = CSG.sphere({\n *   center: [0, 0, 0],\n *   radius: 2,\n *   resolution: 32,\n * });\n */\nconst sphere = function (options) {\n  options = options || {};\n  let center = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  let xvector, yvector, zvector;\n  if ('axes' in options) {\n    xvector = options.axes[0].unit().times(radius);\n    yvector = options.axes[1].unit().times(radius);\n    zvector = options.axes[2].unit().times(radius);\n  } else {\n    xvector = new Vector3([1, 0, 0]).times(radius);\n    yvector = new Vector3([0, -1, 0]).times(radius);\n    zvector = new Vector3([0, 0, 1]).times(radius);\n  }\n  if (resolution < 4) resolution = 4;\n  let qresolution = Math.round(resolution / 4);\n  let prevcylinderpoint;\n  let polygons = [];\n  for (let slice1 = 0; slice1 <= resolution; slice1++) {\n    let angle = (Math.PI * 2.0 * slice1) / resolution;\n    let cylinderpoint = xvector\n      .times(Math.cos(angle))\n      .plus(yvector.times(Math.sin(angle)));\n    if (slice1 > 0) {\n      // cylinder vertices:\n      let vertices = [];\n      let prevcospitch, prevsinpitch;\n      for (let slice2 = 0; slice2 <= qresolution; slice2++) {\n        let pitch = (0.5 * Math.PI * slice2) / qresolution;\n        let cospitch = Math.cos(pitch);\n        let sinpitch = Math.sin(pitch);\n        if (slice2 > 0) {\n          vertices = [];\n          vertices.push(\n            new Vertex3(\n              center.plus(\n                prevcylinderpoint\n                  .times(prevcospitch)\n                  .minus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          vertices.push(\n            new Vertex3(\n              center.plus(\n                cylinderpoint\n                  .times(prevcospitch)\n                  .minus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          if (slice2 < qresolution) {\n            vertices.push(\n              new Vertex3(\n                center.plus(\n                  cylinderpoint.times(cospitch).minus(zvector.times(sinpitch))\n                )\n              )\n            );\n          }\n          vertices.push(\n            new Vertex3(\n              center.plus(\n                prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch))\n              )\n            )\n          );\n          polygons.push(new Polygon3(vertices));\n          vertices = [];\n          vertices.push(\n            new Vertex3(\n              center.plus(\n                prevcylinderpoint\n                  .times(prevcospitch)\n                  .plus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          vertices.push(\n            new Vertex3(\n              center.plus(\n                cylinderpoint\n                  .times(prevcospitch)\n                  .plus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          if (slice2 < qresolution) {\n            vertices.push(\n              new Vertex3(\n                center.plus(\n                  cylinderpoint.times(cospitch).plus(zvector.times(sinpitch))\n                )\n              )\n            );\n          }\n          vertices.push(\n            new Vertex3(\n              center.plus(\n                prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch))\n              )\n            )\n          );\n          vertices.reverse();\n          polygons.push(new Polygon3(vertices));\n        }\n        prevcospitch = cospitch;\n        prevsinpitch = sinpitch;\n      }\n    }\n    prevcylinderpoint = cylinderpoint;\n  }\n  let result = fromPolygons(polygons);\n  result.properties.sphere = new Properties();\n  result.properties.sphere.center = new Vector3(center);\n  result.properties.sphere.facepoint = center.plus(xvector);\n  return result;\n};\n\n/** Construct a solid cylinder.\n * @param {Object} [options] - options for construction\n * @param {Vector} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector} [options.end=[0,1,0]] - end point of cylinder\n * @param {Number} [options.radius=1] - radius of cylinder, must be scalar\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cylinder = CSG.cylinder({\n *   start: [0, -10, 0],\n *   end: [0, 10, 0],\n *   radius: 10,\n *   resolution: 16\n * });\n */\nconst cylinder = function (options) {\n  let s = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  let e = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  let r = parseOptionAsFloat(options, 'radius', 1);\n  let rEnd = parseOptionAsFloat(options, 'radiusEnd', r);\n  let rStart = parseOptionAsFloat(options, 'radiusStart', r);\n  let alpha = parseOptionAsFloat(options, 'sectorAngle', 360);\n  alpha = alpha > 360 ? alpha % 360 : alpha;\n\n  if (rEnd < 0 || rStart < 0) {\n    throw new Error('Radius should be non-negative');\n  }\n  if (rEnd === 0 && rStart === 0) {\n    throw new Error('Either radiusStart or radiusEnd should be positive');\n  }\n\n  let slices = parseOptionAsInt(options, 'resolution', defaultResolution2D); // FIXME is this 3D?\n  let ray = e.minus(s);\n  let axisZ = ray.unit(); //, isY = (Math.abs(axisZ.y) > 0.5);\n  let axisX = axisZ.randomNonParallelVector().unit();\n\n  //  let axisX = new Vector3(isY, !isY, 0).cross(axisZ).unit();\n  let axisY = axisX.cross(axisZ).unit();\n  let start = new Vertex3(s);\n  let end = new Vertex3(e);\n  let polygons = [];\n\n  function point(stack, slice, radius) {\n    let angle = (slice * Math.PI * alpha) / 180;\n    let out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));\n    let pos = s.plus(ray.times(stack)).plus(out.times(radius));\n    return new Vertex3(pos);\n  }\n  if (alpha > 0) {\n    for (let i = 0; i < slices; i++) {\n      let t0 = i / slices;\n      let t1 = (i + 1) / slices;\n      if (rEnd === rStart) {\n        polygons.push(\n          new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)])\n        );\n        polygons.push(\n          new Polygon3([\n            point(0, t1, rEnd),\n            point(0, t0, rEnd),\n            point(1, t0, rEnd),\n            point(1, t1, rEnd),\n          ])\n        );\n        polygons.push(\n          new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)])\n        );\n      } else {\n        if (rStart > 0) {\n          polygons.push(\n            new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)])\n          );\n          polygons.push(\n            new Polygon3([\n              point(0, t0, rStart),\n              point(1, t0, rEnd),\n              point(0, t1, rStart),\n            ])\n          );\n        }\n        if (rEnd > 0) {\n          polygons.push(\n            new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)])\n          );\n          polygons.push(\n            new Polygon3([\n              point(1, t0, rEnd),\n              point(1, t1, rEnd),\n              point(0, t1, rStart),\n            ])\n          );\n        }\n      }\n    }\n    if (alpha < 360) {\n      polygons.push(new Polygon3([start, end, point(0, 0, rStart)]));\n      polygons.push(\n        new Polygon3([point(0, 0, rStart), end, point(1, 0, rEnd)])\n      );\n      polygons.push(new Polygon3([start, point(0, 1, rStart), end]));\n      polygons.push(\n        new Polygon3([point(0, 1, rStart), point(1, 1, rEnd), end])\n      );\n    }\n  }\n  let result = fromPolygons(polygons);\n  result.properties.cylinder = new Properties();\n  result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);\n  result.properties.cylinder.end = new Connector(e, axisZ, axisX);\n  let cylCenter = s.plus(ray.times(0.5));\n  let fptVec = axisX.rotate(s, axisZ, -alpha / 2).times((rStart + rEnd) / 2);\n  let fptVec90 = fptVec.cross(axisZ);\n  // note this one is NOT a face normal for a cone. - It's horizontal from cyl perspective\n  result.properties.cylinder.facepointH = new Connector(\n    cylCenter.plus(fptVec),\n    fptVec,\n    axisZ\n  );\n  result.properties.cylinder.facepointH90 = new Connector(\n    cylCenter.plus(fptVec90),\n    fptVec90,\n    axisZ\n  );\n  return result;\n};\n\n/** Construct a cylinder with rounded ends.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector3} [options.end=[0,1,0]] - end point of cylinder\n * @param {Number} [options.radius=1] - radius of rounded ends, must be scalar\n * @param {Vector3} [options.normal] - vector determining the starting angle for tesselation. Should be non-parallel to start.minus(end)\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cylinder = CSG.roundedCylinder({\n *   start: [0, -10, 0],\n *   end: [0, 10, 0],\n *   radius: 2,\n *   resolution: 16\n * });\n */\nconst roundedCylinder = function (options) {\n  let p1 = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  let p2 = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let direction = p2.minus(p1);\n  let defaultnormal;\n  if (Math.abs(direction.x) > Math.abs(direction.y)) {\n    defaultnormal = new Vector3(0, 1, 0);\n  } else {\n    defaultnormal = new Vector3(1, 0, 0);\n  }\n  let normal = parseOptionAs3DVector(options, 'normal', defaultnormal);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  if (resolution < 4) resolution = 4;\n  let polygons = [];\n  let qresolution = Math.floor(0.25 * resolution);\n  let length = direction.length();\n  if (length < EPS) {\n    return sphere({\n      center: p1,\n      radius: radius,\n      resolution: resolution,\n    });\n  }\n  let zvector = direction.unit().times(radius);\n  let xvector = zvector.cross(normal).unit().times(radius);\n  let yvector = xvector.cross(zvector).unit().times(radius);\n  let prevcylinderpoint;\n  for (let slice1 = 0; slice1 <= resolution; slice1++) {\n    let angle = (Math.PI * 2.0 * slice1) / resolution;\n    let cylinderpoint = xvector\n      .times(Math.cos(angle))\n      .plus(yvector.times(Math.sin(angle)));\n    if (slice1 > 0) {\n      // cylinder vertices:\n      let vertices = [];\n      vertices.push(new Vertex3(p1.plus(cylinderpoint)));\n      vertices.push(new Vertex3(p1.plus(prevcylinderpoint)));\n      vertices.push(new Vertex3(p2.plus(prevcylinderpoint)));\n      vertices.push(new Vertex3(p2.plus(cylinderpoint)));\n      polygons.push(new Polygon3(vertices));\n      let prevcospitch, prevsinpitch;\n      for (let slice2 = 0; slice2 <= qresolution; slice2++) {\n        let pitch = (0.5 * Math.PI * slice2) / qresolution;\n        // let pitch = Math.asin(slice2/qresolution);\n        let cospitch = Math.cos(pitch);\n        let sinpitch = Math.sin(pitch);\n        if (slice2 > 0) {\n          vertices = [];\n          vertices.push(\n            new Vertex3(\n              p1.plus(\n                prevcylinderpoint\n                  .times(prevcospitch)\n                  .minus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          vertices.push(\n            new Vertex3(\n              p1.plus(\n                cylinderpoint\n                  .times(prevcospitch)\n                  .minus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          if (slice2 < qresolution) {\n            vertices.push(\n              new Vertex3(\n                p1.plus(\n                  cylinderpoint.times(cospitch).minus(zvector.times(sinpitch))\n                )\n              )\n            );\n          }\n          vertices.push(\n            new Vertex3(\n              p1.plus(\n                prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch))\n              )\n            )\n          );\n          polygons.push(new Polygon3(vertices));\n          vertices = [];\n          vertices.push(\n            new Vertex3(\n              p2.plus(\n                prevcylinderpoint\n                  .times(prevcospitch)\n                  .plus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          vertices.push(\n            new Vertex3(\n              p2.plus(\n                cylinderpoint\n                  .times(prevcospitch)\n                  .plus(zvector.times(prevsinpitch))\n              )\n            )\n          );\n          if (slice2 < qresolution) {\n            vertices.push(\n              new Vertex3(\n                p2.plus(\n                  cylinderpoint.times(cospitch).plus(zvector.times(sinpitch))\n                )\n              )\n            );\n          }\n          vertices.push(\n            new Vertex3(\n              p2.plus(\n                prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch))\n              )\n            )\n          );\n          vertices.reverse();\n          polygons.push(new Polygon3(vertices));\n        }\n        prevcospitch = cospitch;\n        prevsinpitch = sinpitch;\n      }\n    }\n    prevcylinderpoint = cylinderpoint;\n  }\n  let result = fromPolygons(polygons);\n  let ray = zvector.unit();\n  let axisX = xvector.unit();\n  result.properties.roundedCylinder = new Properties();\n  result.properties.roundedCylinder.start = new Connector(\n    p1,\n    ray.negated(),\n    axisX\n  );\n  result.properties.roundedCylinder.end = new Connector(p2, ray, axisX);\n  result.properties.roundedCylinder.facepoint = p1.plus(xvector);\n  return result;\n};\n\n/** Construct an elliptic cylinder.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector3} [options.end=[0,1,0]] - end point of cylinder\n * @param {Vector2D} [options.radius=[1,1]] - radius of rounded ends, must be two dimensional array\n * @param {Vector2D} [options.radiusStart=[1,1]] - OPTIONAL radius of rounded start, must be two dimensional array\n * @param {Vector2D} [options.radiusEnd=[1,1]] - OPTIONAL radius of rounded end, must be two dimensional array\n * @param {Number} [options.resolution=defaultResolution2D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n *     let cylinder = CSG.cylinderElliptic({\n *       start: [0, -10, 0],\n *       end: [0, 10, 0],\n *       radiusStart: [10,5],\n *       radiusEnd: [8,3],\n *       resolution: 16\n *     });\n */\n\nconst cylinderElliptic = function (options) {\n  let s = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  let e = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  let r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  let rEnd = parseOptionAs2DVector(options, 'radiusEnd', r);\n  let rStart = parseOptionAs2DVector(options, 'radiusStart', r);\n\n  if (rEnd._x < 0 || rStart._x < 0 || rEnd._y < 0 || rStart._y < 0) {\n    throw new Error('Radius should be non-negative');\n  }\n  if (\n    (rEnd._x === 0 || rEnd._y === 0) &&\n    (rStart._x === 0 || rStart._y === 0)\n  ) {\n    throw new Error('Either radiusStart or radiusEnd should be positive');\n  }\n\n  let slices = parseOptionAsInt(options, 'resolution', defaultResolution2D); // FIXME is this correct?\n  let ray = e.minus(s);\n  let axisZ = ray.unit(); //, isY = (Math.abs(axisZ.y) > 0.5);\n  let axisX = axisZ.randomNonParallelVector().unit();\n\n  //  let axisX = new Vector3(isY, !isY, 0).cross(axisZ).unit();\n  let axisY = axisX.cross(axisZ).unit();\n  let start = new Vertex3(s);\n  let end = new Vertex3(e);\n  let polygons = [];\n\n  function point(stack, slice, radius) {\n    let angle = slice * Math.PI * 2;\n    let out = axisX\n      .times(radius._x * Math.cos(angle))\n      .plus(axisY.times(radius._y * Math.sin(angle)));\n    let pos = s.plus(ray.times(stack)).plus(out);\n    return new Vertex3(pos);\n  }\n  for (let i = 0; i < slices; i++) {\n    let t0 = i / slices;\n    let t1 = (i + 1) / slices;\n\n    if (rEnd._x === rStart._x && rEnd._y === rStart._y) {\n      polygons.push(\n        new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)])\n      );\n      polygons.push(\n        new Polygon3([\n          point(0, t1, rEnd),\n          point(0, t0, rEnd),\n          point(1, t0, rEnd),\n          point(1, t1, rEnd),\n        ])\n      );\n      polygons.push(\n        new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)])\n      );\n    } else {\n      if (rStart._x > 0) {\n        polygons.push(\n          new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)])\n        );\n        polygons.push(\n          new Polygon3([\n            point(0, t0, rStart),\n            point(1, t0, rEnd),\n            point(0, t1, rStart),\n          ])\n        );\n      }\n      if (rEnd._x > 0) {\n        polygons.push(\n          new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)])\n        );\n        polygons.push(\n          new Polygon3([\n            point(1, t0, rEnd),\n            point(1, t1, rEnd),\n            point(0, t1, rStart),\n          ])\n        );\n      }\n    }\n  }\n  let result = fromPolygons(polygons);\n  result.properties.cylinder = new Properties();\n  result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);\n  result.properties.cylinder.end = new Connector(e, axisZ, axisX);\n  result.properties.cylinder.facepoint = s.plus(axisX.times(rStart));\n  return result;\n};\n\n/** Construct an axis-aligned solid rounded cuboid.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of rounded cube\n * @param {Vector3} [options.radius=[1,1,1]] - radius of rounded cube, single scalar is possible\n * @param {Number} [options.roundradius=0.2] - radius of rounded edges\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cube = CSG.roundedCube({\n *   center: [2, 0, 2],\n *   radius: 15,\n *   roundradius: 2,\n *   resolution: 36,\n * });\n */\nconst roundedCube = function (options) {\n  let minRR = 1e-2; // minroundradius 1e-3 gives rounding errors already\n  let center;\n  let cuberadius;\n  let corner1;\n  let corner2;\n  options = options || {};\n  if ('corner1' in options || 'corner2' in options) {\n    if ('center' in options || 'radius' in options) {\n      throw new Error(\n        'roundedCube: should either give a radius and center parameter, or a corner1 and corner2 parameter'\n      );\n    }\n    corner1 = parseOptionAs3DVector(options, 'corner1', [0, 0, 0]);\n    corner2 = parseOptionAs3DVector(options, 'corner2', [1, 1, 1]);\n    center = corner1.plus(corner2).times(0.5);\n    cuberadius = corner2.minus(corner1).times(0.5);\n  } else {\n    center = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n    cuberadius = parseOptionAs3DVector(options, 'radius', [1, 1, 1]);\n  }\n  cuberadius = cuberadius.abs(); // negative radii make no sense\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  if (resolution < 4) resolution = 4;\n  if (resolution % 2 === 1 && resolution < 8) resolution = 8; // avoid ugly\n  let roundradius = parseOptionAs3DVector(options, 'roundradius', [\n    0.2,\n    0.2,\n    0.2,\n  ]);\n  // slight hack for now - total radius stays ok\n  roundradius = Vector3.Create(\n    Math.max(roundradius.x, minRR),\n    Math.max(roundradius.y, minRR),\n    Math.max(roundradius.z, minRR)\n  );\n  let innerradius = cuberadius.minus(roundradius);\n  if (innerradius.x < 0 || innerradius.y < 0 || innerradius.z < 0) {\n    throw new Error('roundradius <= radius!');\n  }\n  let res = sphere({ radius: 1, resolution: resolution });\n  res = res.scale(roundradius);\n  innerradius.x > EPS &&\n    (res = res.stretchAtPlane([1, 0, 0], [0, 0, 0], 2 * innerradius.x));\n  innerradius.y > EPS &&\n    (res = res.stretchAtPlane([0, 1, 0], [0, 0, 0], 2 * innerradius.y));\n  innerradius.z > EPS &&\n    (res = res.stretchAtPlane([0, 0, 1], [0, 0, 0], 2 * innerradius.z));\n  res = res.translate([\n    -innerradius.x + center.x,\n    -innerradius.y + center.y,\n    -innerradius.z + center.z,\n  ]);\n  res = res.reTesselated();\n  res.properties.roundedCube = new Properties();\n  res.properties.roundedCube.center = new Vertex3(center);\n  res.properties.roundedCube.facecenters = [\n    new Connector(\n      new Vector3([cuberadius.x, 0, 0]).plus(center),\n      [1, 0, 0],\n      [0, 0, 1]\n    ),\n    new Connector(\n      new Vector3([-cuberadius.x, 0, 0]).plus(center),\n      [-1, 0, 0],\n      [0, 0, 1]\n    ),\n    new Connector(\n      new Vector3([0, cuberadius.y, 0]).plus(center),\n      [0, 1, 0],\n      [0, 0, 1]\n    ),\n    new Connector(\n      new Vector3([0, -cuberadius.y, 0]).plus(center),\n      [0, -1, 0],\n      [0, 0, 1]\n    ),\n    new Connector(\n      new Vector3([0, 0, cuberadius.z]).plus(center),\n      [0, 0, 1],\n      [1, 0, 0]\n    ),\n    new Connector(\n      new Vector3([0, 0, -cuberadius.z]).plus(center),\n      [0, 0, -1],\n      [1, 0, 0]\n    ),\n  ];\n  return res;\n};\n\n/** Create a polyhedron using Openscad style arguments.\n * Define face vertices clockwise looking from outside.\n * @param {Object} [options] - options for construction\n * @returns {CSG} new 3D solid\n */\nconst polyhedron = function (options) {\n  options = options || {};\n  if ('points' in options !== 'faces' in options) {\n    throw new Error(\"polyhedron needs 'points' and 'faces' arrays\");\n  }\n  let vertices = parseOptionAs3DVectorList(options, 'points', [\n    [1, 1, 0],\n    [1, -1, 0],\n    [-1, -1, 0],\n    [-1, 1, 0],\n    [0, 0, 1],\n  ]).map(function (pt) {\n    return new Vertex3(pt);\n  });\n  let faces = parseOption(options, 'faces', [\n    [0, 1, 4],\n    [1, 2, 4],\n    [2, 3, 4],\n    [3, 0, 4],\n    [1, 0, 3],\n    [2, 1, 3],\n  ]);\n  // Openscad convention defines inward normals - so we have to invert here\n  faces.forEach(function (face) {\n    face.reverse();\n  });\n  let polygons = faces.map(function (face) {\n    return new Polygon3(\n      face.map(function (idx) {\n        return vertices[idx];\n      })\n    );\n  });\n\n  // TODO: facecenters as connectors? probably overkill. Maybe centroid\n  // the re-tesselation here happens because it's so easy for a user to\n  // create parametrized polyhedrons that end up with 1-2 dimensional polygons.\n  // These will create infinite loops at CSG.Tree()\n  return fromPolygons(polygons).reTesselated();\n};\n\nmodule.exports = {\n  cube,\n  sphere,\n  roundedCube,\n  cylinder,\n  roundedCylinder,\n  cylinderElliptic,\n  polyhedron,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3ByaW1pdGl2ZXMzZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvcHJpbWl0aXZlczNkLmpzPzgyNDEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge1xuICBwYXJzZU9wdGlvbixcbiAgcGFyc2VPcHRpb25BczNEVmVjdG9yLFxuICBwYXJzZU9wdGlvbkFzMkRWZWN0b3IsXG4gIHBhcnNlT3B0aW9uQXMzRFZlY3Rvckxpc3QsXG4gIHBhcnNlT3B0aW9uQXNGbG9hdCxcbiAgcGFyc2VPcHRpb25Bc0ludCxcbn0gPSByZXF1aXJlKCcuL29wdGlvblBhcnNlcnMnKTtcbmNvbnN0IHtcbiAgZGVmYXVsdFJlc29sdXRpb24zRCxcbiAgZGVmYXVsdFJlc29sdXRpb24yRCxcbiAgRVBTLFxufSA9IHJlcXVpcmUoJy4uL2NvcmUvY29uc3RhbnRzJyk7XG5jb25zdCBWZWN0b3IzID0gcmVxdWlyZSgnLi4vY29yZS9tYXRoL1ZlY3RvcjMnKTtcbmNvbnN0IFZlcnRleDMgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvVmVydGV4MycpO1xuY29uc3QgUG9seWdvbjMgPSByZXF1aXJlKCcuLi9jb3JlL21hdGgvUG9seWdvbjMnKTtcbmNvbnN0IHsgQ29ubmVjdG9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Nvbm5lY3RvcnMnKTtcbmNvbnN0IFByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9jb3JlL1Byb3BlcnRpZXMnKTtcbmNvbnN0IHsgZnJvbVBvbHlnb25zIH0gPSByZXF1aXJlKCcuLi9jb3JlL0NTR0ZhY3RvcmllcycpO1xuXG4vKiogQ29uc3RydWN0IGFuIGF4aXMtYWxpZ25lZCBzb2xpZCBjdWJvaWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLmNlbnRlcj1bMCwwLDBdXSAtIGNlbnRlciBvZiBjdWJlXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLnJhZGl1cz1bMSwxLDFdXSAtIHJhZGl1cyBvZiBjdWJlLCBzaW5nbGUgc2NhbGFyIGFsc28gcG9zc2libGVcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyAzRCBzb2xpZFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgY3ViZSA9IENTRy5jdWJlKHtcbiAqICAgY2VudGVyOiBbNSwgNSwgNV0sXG4gKiAgIHJhZGl1czogNSwgLy8gc2NhbGFyIHJhZGl1c1xuICogfSk7XG4gKi9cbmNvbnN0IGN1YmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBsZXQgYztcbiAgbGV0IHI7XG4gIGxldCBjb3JuZXIxO1xuICBsZXQgY29ybmVyMjtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnY29ybmVyMScgaW4gb3B0aW9ucyB8fCAnY29ybmVyMicgaW4gb3B0aW9ucykge1xuICAgIGlmICgnY2VudGVyJyBpbiBvcHRpb25zIHx8ICdyYWRpdXMnIGluIG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2N1YmU6IHNob3VsZCBlaXRoZXIgZ2l2ZSBhIHJhZGl1cyBhbmQgY2VudGVyIHBhcmFtZXRlciwgb3IgYSBjb3JuZXIxIGFuZCBjb3JuZXIyIHBhcmFtZXRlcidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvcm5lcjEgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ2Nvcm5lcjEnLCBbMCwgMCwgMF0pO1xuICAgIGNvcm5lcjIgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ2Nvcm5lcjInLCBbMSwgMSwgMV0pO1xuICAgIGMgPSBjb3JuZXIxLnBsdXMoY29ybmVyMikudGltZXMoMC41KTtcbiAgICByID0gY29ybmVyMi5taW51cyhjb3JuZXIxKS50aW1lcygwLjUpO1xuICB9IGVsc2Uge1xuICAgIGMgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ2NlbnRlcicsIFswLCAwLCAwXSk7XG4gICAgciA9IHBhcnNlT3B0aW9uQXMzRFZlY3RvcihvcHRpb25zLCAncmFkaXVzJywgWzEsIDEsIDFdKTtcbiAgfVxuICByID0gci5hYnMoKTsgLy8gbmVnYXRpdmUgcmFkaWkgbWFrZSBubyBzZW5zZVxuICBsZXQgcmVzdWx0ID0gZnJvbVBvbHlnb25zKFxuICAgIFtcbiAgICAgIFtcbiAgICAgICAgWzAsIDQsIDYsIDJdLFxuICAgICAgICBbLTEsIDAsIDBdLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzEsIDMsIDcsIDVdLFxuICAgICAgICBbKzEsIDAsIDBdLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzAsIDEsIDUsIDRdLFxuICAgICAgICBbMCwgLTEsIDBdLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzIsIDYsIDcsIDNdLFxuICAgICAgICBbMCwgKzEsIDBdLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzAsIDIsIDMsIDFdLFxuICAgICAgICBbMCwgMCwgLTFdLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgWzQsIDUsIDcsIDZdLFxuICAgICAgICBbMCwgMCwgKzFdLFxuICAgICAgXSxcbiAgICBdLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgbGV0IHZlcnRpY2VzID0gaW5mb1swXS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgbGV0IHBvcyA9IG5ldyBWZWN0b3IzKFxuICAgICAgICAgIGMueCArIHIueCAqICgyICogISEoaSAmIDEpIC0gMSksXG4gICAgICAgICAgYy55ICsgci55ICogKDIgKiAhIShpICYgMikgLSAxKSxcbiAgICAgICAgICBjLnogKyByLnogKiAoMiAqICEhKGkgJiA0KSAtIDEpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4Myhwb3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFBvbHlnb24zKHZlcnRpY2VzLCBudWxsIC8qICwgcGxhbmUgKi8pO1xuICAgIH0pXG4gICk7XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLmN1YmUgPSBuZXcgUHJvcGVydGllcygpO1xuICByZXN1bHQucHJvcGVydGllcy5jdWJlLmNlbnRlciA9IG5ldyBWZWN0b3IzKGMpO1xuICAvLyBhZGQgNiBjb25uZWN0b3JzLCBhdCB0aGUgY2VudGVycyBvZiBlYWNoIGZhY2U6XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLmN1YmUuZmFjZWNlbnRlcnMgPSBbXG4gICAgbmV3IENvbm5lY3RvcihuZXcgVmVjdG9yMyhbci54LCAwLCAwXSkucGx1cyhjKSwgWzEsIDAsIDBdLCBbMCwgMCwgMV0pLFxuICAgIG5ldyBDb25uZWN0b3IobmV3IFZlY3RvcjMoWy1yLngsIDAsIDBdKS5wbHVzKGMpLCBbLTEsIDAsIDBdLCBbMCwgMCwgMV0pLFxuICAgIG5ldyBDb25uZWN0b3IobmV3IFZlY3RvcjMoWzAsIHIueSwgMF0pLnBsdXMoYyksIFswLCAxLCAwXSwgWzAsIDAsIDFdKSxcbiAgICBuZXcgQ29ubmVjdG9yKG5ldyBWZWN0b3IzKFswLCAtci55LCAwXSkucGx1cyhjKSwgWzAsIC0xLCAwXSwgWzAsIDAsIDFdKSxcbiAgICBuZXcgQ29ubmVjdG9yKG5ldyBWZWN0b3IzKFswLCAwLCByLnpdKS5wbHVzKGMpLCBbMCwgMCwgMV0sIFsxLCAwLCAwXSksXG4gICAgbmV3IENvbm5lY3RvcihuZXcgVmVjdG9yMyhbMCwgMCwgLXIuel0pLnBsdXMoYyksIFswLCAwLCAtMV0sIFsxLCAwLCAwXSksXG4gIF07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiogQ29uc3RydWN0IGEgc29saWQgc3BoZXJlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLmNlbnRlcj1bMCwwLDBdXSAtIGNlbnRlciBvZiBzcGhlcmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MV0gLSByYWRpdXMgb2Ygc3BoZXJlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1kZWZhdWx0UmVzb2x1dGlvbjNEXSAtIG51bWJlciBvZiBwb2x5Z29ucyBwZXIgMzYwIGRlZ3JlZSByZXZvbHV0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5heGVzXSAtICBhbiBhcnJheSB3aXRoIDMgdmVjdG9ycyBmb3IgdGhlIHgsIHkgYW5kIHogYmFzZSB2ZWN0b3JzXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgM0Qgc29saWRcbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBzcGhlcmUgPSBDU0cuc3BoZXJlKHtcbiAqICAgY2VudGVyOiBbMCwgMCwgMF0sXG4gKiAgIHJhZGl1czogMixcbiAqICAgcmVzb2x1dGlvbjogMzIsXG4gKiB9KTtcbiAqL1xuY29uc3Qgc3BoZXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxldCBjZW50ZXIgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ2NlbnRlcicsIFswLCAwLCAwXSk7XG4gIGxldCByYWRpdXMgPSBwYXJzZU9wdGlvbkFzRmxvYXQob3B0aW9ucywgJ3JhZGl1cycsIDEpO1xuICBsZXQgcmVzb2x1dGlvbiA9IHBhcnNlT3B0aW9uQXNJbnQob3B0aW9ucywgJ3Jlc29sdXRpb24nLCBkZWZhdWx0UmVzb2x1dGlvbjNEKTtcbiAgbGV0IHh2ZWN0b3IsIHl2ZWN0b3IsIHp2ZWN0b3I7XG4gIGlmICgnYXhlcycgaW4gb3B0aW9ucykge1xuICAgIHh2ZWN0b3IgPSBvcHRpb25zLmF4ZXNbMF0udW5pdCgpLnRpbWVzKHJhZGl1cyk7XG4gICAgeXZlY3RvciA9IG9wdGlvbnMuYXhlc1sxXS51bml0KCkudGltZXMocmFkaXVzKTtcbiAgICB6dmVjdG9yID0gb3B0aW9ucy5heGVzWzJdLnVuaXQoKS50aW1lcyhyYWRpdXMpO1xuICB9IGVsc2Uge1xuICAgIHh2ZWN0b3IgPSBuZXcgVmVjdG9yMyhbMSwgMCwgMF0pLnRpbWVzKHJhZGl1cyk7XG4gICAgeXZlY3RvciA9IG5ldyBWZWN0b3IzKFswLCAtMSwgMF0pLnRpbWVzKHJhZGl1cyk7XG4gICAgenZlY3RvciA9IG5ldyBWZWN0b3IzKFswLCAwLCAxXSkudGltZXMocmFkaXVzKTtcbiAgfVxuICBpZiAocmVzb2x1dGlvbiA8IDQpIHJlc29sdXRpb24gPSA0O1xuICBsZXQgcXJlc29sdXRpb24gPSBNYXRoLnJvdW5kKHJlc29sdXRpb24gLyA0KTtcbiAgbGV0IHByZXZjeWxpbmRlcnBvaW50O1xuICBsZXQgcG9seWdvbnMgPSBbXTtcbiAgZm9yIChsZXQgc2xpY2UxID0gMDsgc2xpY2UxIDw9IHJlc29sdXRpb247IHNsaWNlMSsrKSB7XG4gICAgbGV0IGFuZ2xlID0gKE1hdGguUEkgKiAyLjAgKiBzbGljZTEpIC8gcmVzb2x1dGlvbjtcbiAgICBsZXQgY3lsaW5kZXJwb2ludCA9IHh2ZWN0b3JcbiAgICAgIC50aW1lcyhNYXRoLmNvcyhhbmdsZSkpXG4gICAgICAucGx1cyh5dmVjdG9yLnRpbWVzKE1hdGguc2luKGFuZ2xlKSkpO1xuICAgIGlmIChzbGljZTEgPiAwKSB7XG4gICAgICAvLyBjeWxpbmRlciB2ZXJ0aWNlczpcbiAgICAgIGxldCB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgbGV0IHByZXZjb3NwaXRjaCwgcHJldnNpbnBpdGNoO1xuICAgICAgZm9yIChsZXQgc2xpY2UyID0gMDsgc2xpY2UyIDw9IHFyZXNvbHV0aW9uOyBzbGljZTIrKykge1xuICAgICAgICBsZXQgcGl0Y2ggPSAoMC41ICogTWF0aC5QSSAqIHNsaWNlMikgLyBxcmVzb2x1dGlvbjtcbiAgICAgICAgbGV0IGNvc3BpdGNoID0gTWF0aC5jb3MocGl0Y2gpO1xuICAgICAgICBsZXQgc2lucGl0Y2ggPSBNYXRoLnNpbihwaXRjaCk7XG4gICAgICAgIGlmIChzbGljZTIgPiAwKSB7XG4gICAgICAgICAgdmVydGljZXMgPSBbXTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgIGNlbnRlci5wbHVzKFxuICAgICAgICAgICAgICAgIHByZXZjeWxpbmRlcnBvaW50XG4gICAgICAgICAgICAgICAgICAudGltZXMocHJldmNvc3BpdGNoKVxuICAgICAgICAgICAgICAgICAgLm1pbnVzKHp2ZWN0b3IudGltZXMocHJldnNpbnBpdGNoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBWZXJ0ZXgzKFxuICAgICAgICAgICAgICBjZW50ZXIucGx1cyhcbiAgICAgICAgICAgICAgICBjeWxpbmRlcnBvaW50XG4gICAgICAgICAgICAgICAgICAudGltZXMocHJldmNvc3BpdGNoKVxuICAgICAgICAgICAgICAgICAgLm1pbnVzKHp2ZWN0b3IudGltZXMocHJldnNpbnBpdGNoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHNsaWNlMiA8IHFyZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgICBuZXcgVmVydGV4MyhcbiAgICAgICAgICAgICAgICBjZW50ZXIucGx1cyhcbiAgICAgICAgICAgICAgICAgIGN5bGluZGVycG9pbnQudGltZXMoY29zcGl0Y2gpLm1pbnVzKHp2ZWN0b3IudGltZXMoc2lucGl0Y2gpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBWZXJ0ZXgzKFxuICAgICAgICAgICAgICBjZW50ZXIucGx1cyhcbiAgICAgICAgICAgICAgICBwcmV2Y3lsaW5kZXJwb2ludC50aW1lcyhjb3NwaXRjaCkubWludXMoenZlY3Rvci50aW1lcyhzaW5waXRjaCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHBvbHlnb25zLnB1c2gobmV3IFBvbHlnb24zKHZlcnRpY2VzKSk7XG4gICAgICAgICAgdmVydGljZXMgPSBbXTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgIGNlbnRlci5wbHVzKFxuICAgICAgICAgICAgICAgIHByZXZjeWxpbmRlcnBvaW50XG4gICAgICAgICAgICAgICAgICAudGltZXMocHJldmNvc3BpdGNoKVxuICAgICAgICAgICAgICAgICAgLnBsdXMoenZlY3Rvci50aW1lcyhwcmV2c2lucGl0Y2gpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgIGNlbnRlci5wbHVzKFxuICAgICAgICAgICAgICAgIGN5bGluZGVycG9pbnRcbiAgICAgICAgICAgICAgICAgIC50aW1lcyhwcmV2Y29zcGl0Y2gpXG4gICAgICAgICAgICAgICAgICAucGx1cyh6dmVjdG9yLnRpbWVzKHByZXZzaW5waXRjaCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzbGljZTIgPCBxcmVzb2x1dGlvbikge1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgICAgY2VudGVyLnBsdXMoXG4gICAgICAgICAgICAgICAgICBjeWxpbmRlcnBvaW50LnRpbWVzKGNvc3BpdGNoKS5wbHVzKHp2ZWN0b3IudGltZXMoc2lucGl0Y2gpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBWZXJ0ZXgzKFxuICAgICAgICAgICAgICBjZW50ZXIucGx1cyhcbiAgICAgICAgICAgICAgICBwcmV2Y3lsaW5kZXJwb2ludC50aW1lcyhjb3NwaXRjaCkucGx1cyh6dmVjdG9yLnRpbWVzKHNpbnBpdGNoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdmVydGljZXMucmV2ZXJzZSgpO1xuICAgICAgICAgIHBvbHlnb25zLnB1c2gobmV3IFBvbHlnb24zKHZlcnRpY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmNvc3BpdGNoID0gY29zcGl0Y2g7XG4gICAgICAgIHByZXZzaW5waXRjaCA9IHNpbnBpdGNoO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2Y3lsaW5kZXJwb2ludCA9IGN5bGluZGVycG9pbnQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGZyb21Qb2x5Z29ucyhwb2x5Z29ucyk7XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLnNwaGVyZSA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLnNwaGVyZS5jZW50ZXIgPSBuZXcgVmVjdG9yMyhjZW50ZXIpO1xuICByZXN1bHQucHJvcGVydGllcy5zcGhlcmUuZmFjZXBvaW50ID0gY2VudGVyLnBsdXMoeHZlY3Rvcik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiogQ29uc3RydWN0IGEgc29saWQgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge1ZlY3Rvcn0gW29wdGlvbnMuc3RhcnQ9WzAsLTEsMF1dIC0gc3RhcnQgcG9pbnQgb2YgY3lsaW5kZXJcbiAqIEBwYXJhbSB7VmVjdG9yfSBbb3B0aW9ucy5lbmQ9WzAsMSwwXV0gLSBlbmQgcG9pbnQgb2YgY3lsaW5kZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MV0gLSByYWRpdXMgb2YgY3lsaW5kZXIsIG11c3QgYmUgc2NhbGFyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1kZWZhdWx0UmVzb2x1dGlvbjNEXSAtIG51bWJlciBvZiBwb2x5Z29ucyBwZXIgMzYwIGRlZ3JlZSByZXZvbHV0aW9uXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgM0Qgc29saWRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGN5bGluZGVyID0gQ1NHLmN5bGluZGVyKHtcbiAqICAgc3RhcnQ6IFswLCAtMTAsIDBdLFxuICogICBlbmQ6IFswLCAxMCwgMF0sXG4gKiAgIHJhZGl1czogMTAsXG4gKiAgIHJlc29sdXRpb246IDE2XG4gKiB9KTtcbiAqL1xuY29uc3QgY3lsaW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBsZXQgcyA9IHBhcnNlT3B0aW9uQXMzRFZlY3RvcihvcHRpb25zLCAnc3RhcnQnLCBbMCwgLTEsIDBdKTtcbiAgbGV0IGUgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ2VuZCcsIFswLCAxLCAwXSk7XG4gIGxldCByID0gcGFyc2VPcHRpb25Bc0Zsb2F0KG9wdGlvbnMsICdyYWRpdXMnLCAxKTtcbiAgbGV0IHJFbmQgPSBwYXJzZU9wdGlvbkFzRmxvYXQob3B0aW9ucywgJ3JhZGl1c0VuZCcsIHIpO1xuICBsZXQgclN0YXJ0ID0gcGFyc2VPcHRpb25Bc0Zsb2F0KG9wdGlvbnMsICdyYWRpdXNTdGFydCcsIHIpO1xuICBsZXQgYWxwaGEgPSBwYXJzZU9wdGlvbkFzRmxvYXQob3B0aW9ucywgJ3NlY3RvckFuZ2xlJywgMzYwKTtcbiAgYWxwaGEgPSBhbHBoYSA+IDM2MCA/IGFscGhhICUgMzYwIDogYWxwaGE7XG5cbiAgaWYgKHJFbmQgPCAwIHx8IHJTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhZGl1cyBzaG91bGQgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gIH1cbiAgaWYgKHJFbmQgPT09IDAgJiYgclN0YXJ0ID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFaXRoZXIgcmFkaXVzU3RhcnQgb3IgcmFkaXVzRW5kIHNob3VsZCBiZSBwb3NpdGl2ZScpO1xuICB9XG5cbiAgbGV0IHNsaWNlcyA9IHBhcnNlT3B0aW9uQXNJbnQob3B0aW9ucywgJ3Jlc29sdXRpb24nLCBkZWZhdWx0UmVzb2x1dGlvbjJEKTsgLy8gRklYTUUgaXMgdGhpcyAzRD9cbiAgbGV0IHJheSA9IGUubWludXMocyk7XG4gIGxldCBheGlzWiA9IHJheS51bml0KCk7IC8vLCBpc1kgPSAoTWF0aC5hYnMoYXhpc1oueSkgPiAwLjUpO1xuICBsZXQgYXhpc1ggPSBheGlzWi5yYW5kb21Ob25QYXJhbGxlbFZlY3RvcigpLnVuaXQoKTtcblxuICAvLyAgbGV0IGF4aXNYID0gbmV3IFZlY3RvcjMoaXNZLCAhaXNZLCAwKS5jcm9zcyhheGlzWikudW5pdCgpO1xuICBsZXQgYXhpc1kgPSBheGlzWC5jcm9zcyhheGlzWikudW5pdCgpO1xuICBsZXQgc3RhcnQgPSBuZXcgVmVydGV4MyhzKTtcbiAgbGV0IGVuZCA9IG5ldyBWZXJ0ZXgzKGUpO1xuICBsZXQgcG9seWdvbnMgPSBbXTtcblxuICBmdW5jdGlvbiBwb2ludChzdGFjaywgc2xpY2UsIHJhZGl1cykge1xuICAgIGxldCBhbmdsZSA9IChzbGljZSAqIE1hdGguUEkgKiBhbHBoYSkgLyAxODA7XG4gICAgbGV0IG91dCA9IGF4aXNYLnRpbWVzKE1hdGguY29zKGFuZ2xlKSkucGx1cyhheGlzWS50aW1lcyhNYXRoLnNpbihhbmdsZSkpKTtcbiAgICBsZXQgcG9zID0gcy5wbHVzKHJheS50aW1lcyhzdGFjaykpLnBsdXMob3V0LnRpbWVzKHJhZGl1cykpO1xuICAgIHJldHVybiBuZXcgVmVydGV4Myhwb3MpO1xuICB9XG4gIGlmIChhbHBoYSA+IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlczsgaSsrKSB7XG4gICAgICBsZXQgdDAgPSBpIC8gc2xpY2VzO1xuICAgICAgbGV0IHQxID0gKGkgKyAxKSAvIHNsaWNlcztcbiAgICAgIGlmIChyRW5kID09PSByU3RhcnQpIHtcbiAgICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgICBuZXcgUG9seWdvbjMoW3N0YXJ0LCBwb2ludCgwLCB0MCwgckVuZCksIHBvaW50KDAsIHQxLCByRW5kKV0pXG4gICAgICAgICk7XG4gICAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgICAgbmV3IFBvbHlnb24zKFtcbiAgICAgICAgICAgIHBvaW50KDAsIHQxLCByRW5kKSxcbiAgICAgICAgICAgIHBvaW50KDAsIHQwLCByRW5kKSxcbiAgICAgICAgICAgIHBvaW50KDEsIHQwLCByRW5kKSxcbiAgICAgICAgICAgIHBvaW50KDEsIHQxLCByRW5kKSxcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgICBwb2x5Z29ucy5wdXNoKFxuICAgICAgICAgIG5ldyBQb2x5Z29uMyhbZW5kLCBwb2ludCgxLCB0MSwgckVuZCksIHBvaW50KDEsIHQwLCByRW5kKV0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoclN0YXJ0ID4gMCkge1xuICAgICAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgICAgICBuZXcgUG9seWdvbjMoW3N0YXJ0LCBwb2ludCgwLCB0MCwgclN0YXJ0KSwgcG9pbnQoMCwgdDEsIHJTdGFydCldKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgICAgIG5ldyBQb2x5Z29uMyhbXG4gICAgICAgICAgICAgIHBvaW50KDAsIHQwLCByU3RhcnQpLFxuICAgICAgICAgICAgICBwb2ludCgxLCB0MCwgckVuZCksXG4gICAgICAgICAgICAgIHBvaW50KDAsIHQxLCByU3RhcnQpLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyRW5kID4gMCkge1xuICAgICAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgICAgICBuZXcgUG9seWdvbjMoW2VuZCwgcG9pbnQoMSwgdDEsIHJFbmQpLCBwb2ludCgxLCB0MCwgckVuZCldKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgICAgIG5ldyBQb2x5Z29uMyhbXG4gICAgICAgICAgICAgIHBvaW50KDEsIHQwLCByRW5kKSxcbiAgICAgICAgICAgICAgcG9pbnQoMSwgdDEsIHJFbmQpLFxuICAgICAgICAgICAgICBwb2ludCgwLCB0MSwgclN0YXJ0KSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWxwaGEgPCAzNjApIHtcbiAgICAgIHBvbHlnb25zLnB1c2gobmV3IFBvbHlnb24zKFtzdGFydCwgZW5kLCBwb2ludCgwLCAwLCByU3RhcnQpXSkpO1xuICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgbmV3IFBvbHlnb24zKFtwb2ludCgwLCAwLCByU3RhcnQpLCBlbmQsIHBvaW50KDEsIDAsIHJFbmQpXSlcbiAgICAgICk7XG4gICAgICBwb2x5Z29ucy5wdXNoKG5ldyBQb2x5Z29uMyhbc3RhcnQsIHBvaW50KDAsIDEsIHJTdGFydCksIGVuZF0pKTtcbiAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgIG5ldyBQb2x5Z29uMyhbcG9pbnQoMCwgMSwgclN0YXJ0KSwgcG9pbnQoMSwgMSwgckVuZCksIGVuZF0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgcmVzdWx0ID0gZnJvbVBvbHlnb25zKHBvbHlnb25zKTtcbiAgcmVzdWx0LnByb3BlcnRpZXMuY3lsaW5kZXIgPSBuZXcgUHJvcGVydGllcygpO1xuICByZXN1bHQucHJvcGVydGllcy5jeWxpbmRlci5zdGFydCA9IG5ldyBDb25uZWN0b3IocywgYXhpc1oubmVnYXRlZCgpLCBheGlzWCk7XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLmN5bGluZGVyLmVuZCA9IG5ldyBDb25uZWN0b3IoZSwgYXhpc1osIGF4aXNYKTtcbiAgbGV0IGN5bENlbnRlciA9IHMucGx1cyhyYXkudGltZXMoMC41KSk7XG4gIGxldCBmcHRWZWMgPSBheGlzWC5yb3RhdGUocywgYXhpc1osIC1hbHBoYSAvIDIpLnRpbWVzKChyU3RhcnQgKyByRW5kKSAvIDIpO1xuICBsZXQgZnB0VmVjOTAgPSBmcHRWZWMuY3Jvc3MoYXhpc1opO1xuICAvLyBub3RlIHRoaXMgb25lIGlzIE5PVCBhIGZhY2Ugbm9ybWFsIGZvciBhIGNvbmUuIC0gSXQncyBob3Jpem9udGFsIGZyb20gY3lsIHBlcnNwZWN0aXZlXG4gIHJlc3VsdC5wcm9wZXJ0aWVzLmN5bGluZGVyLmZhY2Vwb2ludEggPSBuZXcgQ29ubmVjdG9yKFxuICAgIGN5bENlbnRlci5wbHVzKGZwdFZlYyksXG4gICAgZnB0VmVjLFxuICAgIGF4aXNaXG4gICk7XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLmN5bGluZGVyLmZhY2Vwb2ludEg5MCA9IG5ldyBDb25uZWN0b3IoXG4gICAgY3lsQ2VudGVyLnBsdXMoZnB0VmVjOTApLFxuICAgIGZwdFZlYzkwLFxuICAgIGF4aXNaXG4gICk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiogQ29uc3RydWN0IGEgY3lsaW5kZXIgd2l0aCByb3VuZGVkIGVuZHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLnN0YXJ0PVswLC0xLDBdXSAtIHN0YXJ0IHBvaW50IG9mIGN5bGluZGVyXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLmVuZD1bMCwxLDBdXSAtIGVuZCBwb2ludCBvZiBjeWxpbmRlclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0xXSAtIHJhZGl1cyBvZiByb3VuZGVkIGVuZHMsIG11c3QgYmUgc2NhbGFyXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLm5vcm1hbF0gLSB2ZWN0b3IgZGV0ZXJtaW5pbmcgdGhlIHN0YXJ0aW5nIGFuZ2xlIGZvciB0ZXNzZWxhdGlvbi4gU2hvdWxkIGJlIG5vbi1wYXJhbGxlbCB0byBzdGFydC5taW51cyhlbmQpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1kZWZhdWx0UmVzb2x1dGlvbjNEXSAtIG51bWJlciBvZiBwb2x5Z29ucyBwZXIgMzYwIGRlZ3JlZSByZXZvbHV0aW9uXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgM0Qgc29saWRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGN5bGluZGVyID0gQ1NHLnJvdW5kZWRDeWxpbmRlcih7XG4gKiAgIHN0YXJ0OiBbMCwgLTEwLCAwXSxcbiAqICAgZW5kOiBbMCwgMTAsIDBdLFxuICogICByYWRpdXM6IDIsXG4gKiAgIHJlc29sdXRpb246IDE2XG4gKiB9KTtcbiAqL1xuY29uc3Qgcm91bmRlZEN5bGluZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgbGV0IHAxID0gcGFyc2VPcHRpb25BczNEVmVjdG9yKG9wdGlvbnMsICdzdGFydCcsIFswLCAtMSwgMF0pO1xuICBsZXQgcDIgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ2VuZCcsIFswLCAxLCAwXSk7XG4gIGxldCByYWRpdXMgPSBwYXJzZU9wdGlvbkFzRmxvYXQob3B0aW9ucywgJ3JhZGl1cycsIDEpO1xuICBsZXQgZGlyZWN0aW9uID0gcDIubWludXMocDEpO1xuICBsZXQgZGVmYXVsdG5vcm1hbDtcbiAgaWYgKE1hdGguYWJzKGRpcmVjdGlvbi54KSA+IE1hdGguYWJzKGRpcmVjdGlvbi55KSkge1xuICAgIGRlZmF1bHRub3JtYWwgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZhdWx0bm9ybWFsID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gIH1cbiAgbGV0IG5vcm1hbCA9IHBhcnNlT3B0aW9uQXMzRFZlY3RvcihvcHRpb25zLCAnbm9ybWFsJywgZGVmYXVsdG5vcm1hbCk7XG4gIGxldCByZXNvbHV0aW9uID0gcGFyc2VPcHRpb25Bc0ludChvcHRpb25zLCAncmVzb2x1dGlvbicsIGRlZmF1bHRSZXNvbHV0aW9uM0QpO1xuICBpZiAocmVzb2x1dGlvbiA8IDQpIHJlc29sdXRpb24gPSA0O1xuICBsZXQgcG9seWdvbnMgPSBbXTtcbiAgbGV0IHFyZXNvbHV0aW9uID0gTWF0aC5mbG9vcigwLjI1ICogcmVzb2x1dGlvbik7XG4gIGxldCBsZW5ndGggPSBkaXJlY3Rpb24ubGVuZ3RoKCk7XG4gIGlmIChsZW5ndGggPCBFUFMpIHtcbiAgICByZXR1cm4gc3BoZXJlKHtcbiAgICAgIGNlbnRlcjogcDEsXG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgfSk7XG4gIH1cbiAgbGV0IHp2ZWN0b3IgPSBkaXJlY3Rpb24udW5pdCgpLnRpbWVzKHJhZGl1cyk7XG4gIGxldCB4dmVjdG9yID0genZlY3Rvci5jcm9zcyhub3JtYWwpLnVuaXQoKS50aW1lcyhyYWRpdXMpO1xuICBsZXQgeXZlY3RvciA9IHh2ZWN0b3IuY3Jvc3MoenZlY3RvcikudW5pdCgpLnRpbWVzKHJhZGl1cyk7XG4gIGxldCBwcmV2Y3lsaW5kZXJwb2ludDtcbiAgZm9yIChsZXQgc2xpY2UxID0gMDsgc2xpY2UxIDw9IHJlc29sdXRpb247IHNsaWNlMSsrKSB7XG4gICAgbGV0IGFuZ2xlID0gKE1hdGguUEkgKiAyLjAgKiBzbGljZTEpIC8gcmVzb2x1dGlvbjtcbiAgICBsZXQgY3lsaW5kZXJwb2ludCA9IHh2ZWN0b3JcbiAgICAgIC50aW1lcyhNYXRoLmNvcyhhbmdsZSkpXG4gICAgICAucGx1cyh5dmVjdG9yLnRpbWVzKE1hdGguc2luKGFuZ2xlKSkpO1xuICAgIGlmIChzbGljZTEgPiAwKSB7XG4gICAgICAvLyBjeWxpbmRlciB2ZXJ0aWNlczpcbiAgICAgIGxldCB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgdmVydGljZXMucHVzaChuZXcgVmVydGV4MyhwMS5wbHVzKGN5bGluZGVycG9pbnQpKSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgzKHAxLnBsdXMocHJldmN5bGluZGVycG9pbnQpKSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgzKHAyLnBsdXMocHJldmN5bGluZGVycG9pbnQpKSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZXJ0ZXgzKHAyLnBsdXMoY3lsaW5kZXJwb2ludCkpKTtcbiAgICAgIHBvbHlnb25zLnB1c2gobmV3IFBvbHlnb24zKHZlcnRpY2VzKSk7XG4gICAgICBsZXQgcHJldmNvc3BpdGNoLCBwcmV2c2lucGl0Y2g7XG4gICAgICBmb3IgKGxldCBzbGljZTIgPSAwOyBzbGljZTIgPD0gcXJlc29sdXRpb247IHNsaWNlMisrKSB7XG4gICAgICAgIGxldCBwaXRjaCA9ICgwLjUgKiBNYXRoLlBJICogc2xpY2UyKSAvIHFyZXNvbHV0aW9uO1xuICAgICAgICAvLyBsZXQgcGl0Y2ggPSBNYXRoLmFzaW4oc2xpY2UyL3FyZXNvbHV0aW9uKTtcbiAgICAgICAgbGV0IGNvc3BpdGNoID0gTWF0aC5jb3MocGl0Y2gpO1xuICAgICAgICBsZXQgc2lucGl0Y2ggPSBNYXRoLnNpbihwaXRjaCk7XG4gICAgICAgIGlmIChzbGljZTIgPiAwKSB7XG4gICAgICAgICAgdmVydGljZXMgPSBbXTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgIHAxLnBsdXMoXG4gICAgICAgICAgICAgICAgcHJldmN5bGluZGVycG9pbnRcbiAgICAgICAgICAgICAgICAgIC50aW1lcyhwcmV2Y29zcGl0Y2gpXG4gICAgICAgICAgICAgICAgICAubWludXMoenZlY3Rvci50aW1lcyhwcmV2c2lucGl0Y2gpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgIHAxLnBsdXMoXG4gICAgICAgICAgICAgICAgY3lsaW5kZXJwb2ludFxuICAgICAgICAgICAgICAgICAgLnRpbWVzKHByZXZjb3NwaXRjaClcbiAgICAgICAgICAgICAgICAgIC5taW51cyh6dmVjdG9yLnRpbWVzKHByZXZzaW5waXRjaCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzbGljZTIgPCBxcmVzb2x1dGlvbikge1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgICAgcDEucGx1cyhcbiAgICAgICAgICAgICAgICAgIGN5bGluZGVycG9pbnQudGltZXMoY29zcGl0Y2gpLm1pbnVzKHp2ZWN0b3IudGltZXMoc2lucGl0Y2gpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBWZXJ0ZXgzKFxuICAgICAgICAgICAgICBwMS5wbHVzKFxuICAgICAgICAgICAgICAgIHByZXZjeWxpbmRlcnBvaW50LnRpbWVzKGNvc3BpdGNoKS5taW51cyh6dmVjdG9yLnRpbWVzKHNpbnBpdGNoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcG9seWdvbnMucHVzaChuZXcgUG9seWdvbjModmVydGljZXMpKTtcbiAgICAgICAgICB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgVmVydGV4MyhcbiAgICAgICAgICAgICAgcDIucGx1cyhcbiAgICAgICAgICAgICAgICBwcmV2Y3lsaW5kZXJwb2ludFxuICAgICAgICAgICAgICAgICAgLnRpbWVzKHByZXZjb3NwaXRjaClcbiAgICAgICAgICAgICAgICAgIC5wbHVzKHp2ZWN0b3IudGltZXMocHJldnNpbnBpdGNoKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBWZXJ0ZXgzKFxuICAgICAgICAgICAgICBwMi5wbHVzKFxuICAgICAgICAgICAgICAgIGN5bGluZGVycG9pbnRcbiAgICAgICAgICAgICAgICAgIC50aW1lcyhwcmV2Y29zcGl0Y2gpXG4gICAgICAgICAgICAgICAgICAucGx1cyh6dmVjdG9yLnRpbWVzKHByZXZzaW5waXRjaCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzbGljZTIgPCBxcmVzb2x1dGlvbikge1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgICAgcDIucGx1cyhcbiAgICAgICAgICAgICAgICAgIGN5bGluZGVycG9pbnQudGltZXMoY29zcGl0Y2gpLnBsdXMoenZlY3Rvci50aW1lcyhzaW5waXRjaCkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFZlcnRleDMoXG4gICAgICAgICAgICAgIHAyLnBsdXMoXG4gICAgICAgICAgICAgICAgcHJldmN5bGluZGVycG9pbnQudGltZXMoY29zcGl0Y2gpLnBsdXMoenZlY3Rvci50aW1lcyhzaW5waXRjaCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIHZlcnRpY2VzLnJldmVyc2UoKTtcbiAgICAgICAgICBwb2x5Z29ucy5wdXNoKG5ldyBQb2x5Z29uMyh2ZXJ0aWNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZjb3NwaXRjaCA9IGNvc3BpdGNoO1xuICAgICAgICBwcmV2c2lucGl0Y2ggPSBzaW5waXRjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldmN5bGluZGVycG9pbnQgPSBjeWxpbmRlcnBvaW50O1xuICB9XG4gIGxldCByZXN1bHQgPSBmcm9tUG9seWdvbnMocG9seWdvbnMpO1xuICBsZXQgcmF5ID0genZlY3Rvci51bml0KCk7XG4gIGxldCBheGlzWCA9IHh2ZWN0b3IudW5pdCgpO1xuICByZXN1bHQucHJvcGVydGllcy5yb3VuZGVkQ3lsaW5kZXIgPSBuZXcgUHJvcGVydGllcygpO1xuICByZXN1bHQucHJvcGVydGllcy5yb3VuZGVkQ3lsaW5kZXIuc3RhcnQgPSBuZXcgQ29ubmVjdG9yKFxuICAgIHAxLFxuICAgIHJheS5uZWdhdGVkKCksXG4gICAgYXhpc1hcbiAgKTtcbiAgcmVzdWx0LnByb3BlcnRpZXMucm91bmRlZEN5bGluZGVyLmVuZCA9IG5ldyBDb25uZWN0b3IocDIsIHJheSwgYXhpc1gpO1xuICByZXN1bHQucHJvcGVydGllcy5yb3VuZGVkQ3lsaW5kZXIuZmFjZXBvaW50ID0gcDEucGx1cyh4dmVjdG9yKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKiBDb25zdHJ1Y3QgYW4gZWxsaXB0aWMgY3lsaW5kZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLnN0YXJ0PVswLC0xLDBdXSAtIHN0YXJ0IHBvaW50IG9mIGN5bGluZGVyXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLmVuZD1bMCwxLDBdXSAtIGVuZCBwb2ludCBvZiBjeWxpbmRlclxuICogQHBhcmFtIHtWZWN0b3IyRH0gW29wdGlvbnMucmFkaXVzPVsxLDFdXSAtIHJhZGl1cyBvZiByb3VuZGVkIGVuZHMsIG11c3QgYmUgdHdvIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcGFyYW0ge1ZlY3RvcjJEfSBbb3B0aW9ucy5yYWRpdXNTdGFydD1bMSwxXV0gLSBPUFRJT05BTCByYWRpdXMgb2Ygcm91bmRlZCBzdGFydCwgbXVzdCBiZSB0d28gZGltZW5zaW9uYWwgYXJyYXlcbiAqIEBwYXJhbSB7VmVjdG9yMkR9IFtvcHRpb25zLnJhZGl1c0VuZD1bMSwxXV0gLSBPUFRJT05BTCByYWRpdXMgb2Ygcm91bmRlZCBlbmQsIG11c3QgYmUgdHdvIGRpbWVuc2lvbmFsIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1kZWZhdWx0UmVzb2x1dGlvbjJEXSAtIG51bWJlciBvZiBwb2x5Z29ucyBwZXIgMzYwIGRlZ3JlZSByZXZvbHV0aW9uXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgM0Qgc29saWRcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIGxldCBjeWxpbmRlciA9IENTRy5jeWxpbmRlckVsbGlwdGljKHtcbiAqICAgICAgIHN0YXJ0OiBbMCwgLTEwLCAwXSxcbiAqICAgICAgIGVuZDogWzAsIDEwLCAwXSxcbiAqICAgICAgIHJhZGl1c1N0YXJ0OiBbMTAsNV0sXG4gKiAgICAgICByYWRpdXNFbmQ6IFs4LDNdLFxuICogICAgICAgcmVzb2x1dGlvbjogMTZcbiAqICAgICB9KTtcbiAqL1xuXG5jb25zdCBjeWxpbmRlckVsbGlwdGljID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgbGV0IHMgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ3N0YXJ0JywgWzAsIC0xLCAwXSk7XG4gIGxldCBlID0gcGFyc2VPcHRpb25BczNEVmVjdG9yKG9wdGlvbnMsICdlbmQnLCBbMCwgMSwgMF0pO1xuICBsZXQgciA9IHBhcnNlT3B0aW9uQXMyRFZlY3RvcihvcHRpb25zLCAncmFkaXVzJywgWzEsIDFdKTtcbiAgbGV0IHJFbmQgPSBwYXJzZU9wdGlvbkFzMkRWZWN0b3Iob3B0aW9ucywgJ3JhZGl1c0VuZCcsIHIpO1xuICBsZXQgclN0YXJ0ID0gcGFyc2VPcHRpb25BczJEVmVjdG9yKG9wdGlvbnMsICdyYWRpdXNTdGFydCcsIHIpO1xuXG4gIGlmIChyRW5kLl94IDwgMCB8fCByU3RhcnQuX3ggPCAwIHx8IHJFbmQuX3kgPCAwIHx8IHJTdGFydC5feSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhZGl1cyBzaG91bGQgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gIH1cbiAgaWYgKFxuICAgIChyRW5kLl94ID09PSAwIHx8IHJFbmQuX3kgPT09IDApICYmXG4gICAgKHJTdGFydC5feCA9PT0gMCB8fCByU3RhcnQuX3kgPT09IDApXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignRWl0aGVyIHJhZGl1c1N0YXJ0IG9yIHJhZGl1c0VuZCBzaG91bGQgYmUgcG9zaXRpdmUnKTtcbiAgfVxuXG4gIGxldCBzbGljZXMgPSBwYXJzZU9wdGlvbkFzSW50KG9wdGlvbnMsICdyZXNvbHV0aW9uJywgZGVmYXVsdFJlc29sdXRpb24yRCk7IC8vIEZJWE1FIGlzIHRoaXMgY29ycmVjdD9cbiAgbGV0IHJheSA9IGUubWludXMocyk7XG4gIGxldCBheGlzWiA9IHJheS51bml0KCk7IC8vLCBpc1kgPSAoTWF0aC5hYnMoYXhpc1oueSkgPiAwLjUpO1xuICBsZXQgYXhpc1ggPSBheGlzWi5yYW5kb21Ob25QYXJhbGxlbFZlY3RvcigpLnVuaXQoKTtcblxuICAvLyAgbGV0IGF4aXNYID0gbmV3IFZlY3RvcjMoaXNZLCAhaXNZLCAwKS5jcm9zcyhheGlzWikudW5pdCgpO1xuICBsZXQgYXhpc1kgPSBheGlzWC5jcm9zcyhheGlzWikudW5pdCgpO1xuICBsZXQgc3RhcnQgPSBuZXcgVmVydGV4MyhzKTtcbiAgbGV0IGVuZCA9IG5ldyBWZXJ0ZXgzKGUpO1xuICBsZXQgcG9seWdvbnMgPSBbXTtcblxuICBmdW5jdGlvbiBwb2ludChzdGFjaywgc2xpY2UsIHJhZGl1cykge1xuICAgIGxldCBhbmdsZSA9IHNsaWNlICogTWF0aC5QSSAqIDI7XG4gICAgbGV0IG91dCA9IGF4aXNYXG4gICAgICAudGltZXMocmFkaXVzLl94ICogTWF0aC5jb3MoYW5nbGUpKVxuICAgICAgLnBsdXMoYXhpc1kudGltZXMocmFkaXVzLl95ICogTWF0aC5zaW4oYW5nbGUpKSk7XG4gICAgbGV0IHBvcyA9IHMucGx1cyhyYXkudGltZXMoc3RhY2spKS5wbHVzKG91dCk7XG4gICAgcmV0dXJuIG5ldyBWZXJ0ZXgzKHBvcyk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZXM7IGkrKykge1xuICAgIGxldCB0MCA9IGkgLyBzbGljZXM7XG4gICAgbGV0IHQxID0gKGkgKyAxKSAvIHNsaWNlcztcblxuICAgIGlmIChyRW5kLl94ID09PSByU3RhcnQuX3ggJiYgckVuZC5feSA9PT0gclN0YXJ0Ll95KSB7XG4gICAgICBwb2x5Z29ucy5wdXNoKFxuICAgICAgICBuZXcgUG9seWdvbjMoW3N0YXJ0LCBwb2ludCgwLCB0MCwgckVuZCksIHBvaW50KDAsIHQxLCByRW5kKV0pXG4gICAgICApO1xuICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgbmV3IFBvbHlnb24zKFtcbiAgICAgICAgICBwb2ludCgwLCB0MSwgckVuZCksXG4gICAgICAgICAgcG9pbnQoMCwgdDAsIHJFbmQpLFxuICAgICAgICAgIHBvaW50KDEsIHQwLCByRW5kKSxcbiAgICAgICAgICBwb2ludCgxLCB0MSwgckVuZCksXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgbmV3IFBvbHlnb24zKFtlbmQsIHBvaW50KDEsIHQxLCByRW5kKSwgcG9pbnQoMSwgdDAsIHJFbmQpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyU3RhcnQuX3ggPiAwKSB7XG4gICAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgICAgbmV3IFBvbHlnb24zKFtzdGFydCwgcG9pbnQoMCwgdDAsIHJTdGFydCksIHBvaW50KDAsIHQxLCByU3RhcnQpXSlcbiAgICAgICAgKTtcbiAgICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgICBuZXcgUG9seWdvbjMoW1xuICAgICAgICAgICAgcG9pbnQoMCwgdDAsIHJTdGFydCksXG4gICAgICAgICAgICBwb2ludCgxLCB0MCwgckVuZCksXG4gICAgICAgICAgICBwb2ludCgwLCB0MSwgclN0YXJ0KSxcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJFbmQuX3ggPiAwKSB7XG4gICAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgICAgbmV3IFBvbHlnb24zKFtlbmQsIHBvaW50KDEsIHQxLCByRW5kKSwgcG9pbnQoMSwgdDAsIHJFbmQpXSlcbiAgICAgICAgKTtcbiAgICAgICAgcG9seWdvbnMucHVzaChcbiAgICAgICAgICBuZXcgUG9seWdvbjMoW1xuICAgICAgICAgICAgcG9pbnQoMSwgdDAsIHJFbmQpLFxuICAgICAgICAgICAgcG9pbnQoMSwgdDEsIHJFbmQpLFxuICAgICAgICAgICAgcG9pbnQoMCwgdDEsIHJTdGFydCksXG4gICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGZyb21Qb2x5Z29ucyhwb2x5Z29ucyk7XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLmN5bGluZGVyID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgcmVzdWx0LnByb3BlcnRpZXMuY3lsaW5kZXIuc3RhcnQgPSBuZXcgQ29ubmVjdG9yKHMsIGF4aXNaLm5lZ2F0ZWQoKSwgYXhpc1gpO1xuICByZXN1bHQucHJvcGVydGllcy5jeWxpbmRlci5lbmQgPSBuZXcgQ29ubmVjdG9yKGUsIGF4aXNaLCBheGlzWCk7XG4gIHJlc3VsdC5wcm9wZXJ0aWVzLmN5bGluZGVyLmZhY2Vwb2ludCA9IHMucGx1cyhheGlzWC50aW1lcyhyU3RhcnQpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKiBDb25zdHJ1Y3QgYW4gYXhpcy1hbGlnbmVkIHNvbGlkIHJvdW5kZWQgY3Vib2lkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICogQHBhcmFtIHtWZWN0b3IzfSBbb3B0aW9ucy5jZW50ZXI9WzAsMCwwXV0gLSBjZW50ZXIgb2Ygcm91bmRlZCBjdWJlXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IFtvcHRpb25zLnJhZGl1cz1bMSwxLDFdXSAtIHJhZGl1cyBvZiByb3VuZGVkIGN1YmUsIHNpbmdsZSBzY2FsYXIgaXMgcG9zc2libGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yb3VuZHJhZGl1cz0wLjJdIC0gcmFkaXVzIG9mIHJvdW5kZWQgZWRnZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPWRlZmF1bHRSZXNvbHV0aW9uM0RdIC0gbnVtYmVyIG9mIHBvbHlnb25zIHBlciAzNjAgZGVncmVlIHJldm9sdXRpb25cbiAqIEByZXR1cm5zIHtDU0d9IG5ldyAzRCBzb2xpZFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgY3ViZSA9IENTRy5yb3VuZGVkQ3ViZSh7XG4gKiAgIGNlbnRlcjogWzIsIDAsIDJdLFxuICogICByYWRpdXM6IDE1LFxuICogICByb3VuZHJhZGl1czogMixcbiAqICAgcmVzb2x1dGlvbjogMzYsXG4gKiB9KTtcbiAqL1xuY29uc3Qgcm91bmRlZEN1YmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBsZXQgbWluUlIgPSAxZS0yOyAvLyBtaW5yb3VuZHJhZGl1cyAxZS0zIGdpdmVzIHJvdW5kaW5nIGVycm9ycyBhbHJlYWR5XG4gIGxldCBjZW50ZXI7XG4gIGxldCBjdWJlcmFkaXVzO1xuICBsZXQgY29ybmVyMTtcbiAgbGV0IGNvcm5lcjI7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ2Nvcm5lcjEnIGluIG9wdGlvbnMgfHwgJ2Nvcm5lcjInIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoJ2NlbnRlcicgaW4gb3B0aW9ucyB8fCAncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdyb3VuZGVkQ3ViZTogc2hvdWxkIGVpdGhlciBnaXZlIGEgcmFkaXVzIGFuZCBjZW50ZXIgcGFyYW1ldGVyLCBvciBhIGNvcm5lcjEgYW5kIGNvcm5lcjIgcGFyYW1ldGVyJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29ybmVyMSA9IHBhcnNlT3B0aW9uQXMzRFZlY3RvcihvcHRpb25zLCAnY29ybmVyMScsIFswLCAwLCAwXSk7XG4gICAgY29ybmVyMiA9IHBhcnNlT3B0aW9uQXMzRFZlY3RvcihvcHRpb25zLCAnY29ybmVyMicsIFsxLCAxLCAxXSk7XG4gICAgY2VudGVyID0gY29ybmVyMS5wbHVzKGNvcm5lcjIpLnRpbWVzKDAuNSk7XG4gICAgY3ViZXJhZGl1cyA9IGNvcm5lcjIubWludXMoY29ybmVyMSkudGltZXMoMC41KTtcbiAgfSBlbHNlIHtcbiAgICBjZW50ZXIgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ2NlbnRlcicsIFswLCAwLCAwXSk7XG4gICAgY3ViZXJhZGl1cyA9IHBhcnNlT3B0aW9uQXMzRFZlY3RvcihvcHRpb25zLCAncmFkaXVzJywgWzEsIDEsIDFdKTtcbiAgfVxuICBjdWJlcmFkaXVzID0gY3ViZXJhZGl1cy5hYnMoKTsgLy8gbmVnYXRpdmUgcmFkaWkgbWFrZSBubyBzZW5zZVxuICBsZXQgcmVzb2x1dGlvbiA9IHBhcnNlT3B0aW9uQXNJbnQob3B0aW9ucywgJ3Jlc29sdXRpb24nLCBkZWZhdWx0UmVzb2x1dGlvbjNEKTtcbiAgaWYgKHJlc29sdXRpb24gPCA0KSByZXNvbHV0aW9uID0gNDtcbiAgaWYgKHJlc29sdXRpb24gJSAyID09PSAxICYmIHJlc29sdXRpb24gPCA4KSByZXNvbHV0aW9uID0gODsgLy8gYXZvaWQgdWdseVxuICBsZXQgcm91bmRyYWRpdXMgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3Iob3B0aW9ucywgJ3JvdW5kcmFkaXVzJywgW1xuICAgIDAuMixcbiAgICAwLjIsXG4gICAgMC4yLFxuICBdKTtcbiAgLy8gc2xpZ2h0IGhhY2sgZm9yIG5vdyAtIHRvdGFsIHJhZGl1cyBzdGF5cyBva1xuICByb3VuZHJhZGl1cyA9IFZlY3RvcjMuQ3JlYXRlKFxuICAgIE1hdGgubWF4KHJvdW5kcmFkaXVzLngsIG1pblJSKSxcbiAgICBNYXRoLm1heChyb3VuZHJhZGl1cy55LCBtaW5SUiksXG4gICAgTWF0aC5tYXgocm91bmRyYWRpdXMueiwgbWluUlIpXG4gICk7XG4gIGxldCBpbm5lcnJhZGl1cyA9IGN1YmVyYWRpdXMubWludXMocm91bmRyYWRpdXMpO1xuICBpZiAoaW5uZXJyYWRpdXMueCA8IDAgfHwgaW5uZXJyYWRpdXMueSA8IDAgfHwgaW5uZXJyYWRpdXMueiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdW5kcmFkaXVzIDw9IHJhZGl1cyEnKTtcbiAgfVxuICBsZXQgcmVzID0gc3BoZXJlKHsgcmFkaXVzOiAxLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uIH0pO1xuICByZXMgPSByZXMuc2NhbGUocm91bmRyYWRpdXMpO1xuICBpbm5lcnJhZGl1cy54ID4gRVBTICYmXG4gICAgKHJlcyA9IHJlcy5zdHJldGNoQXRQbGFuZShbMSwgMCwgMF0sIFswLCAwLCAwXSwgMiAqIGlubmVycmFkaXVzLngpKTtcbiAgaW5uZXJyYWRpdXMueSA+IEVQUyAmJlxuICAgIChyZXMgPSByZXMuc3RyZXRjaEF0UGxhbmUoWzAsIDEsIDBdLCBbMCwgMCwgMF0sIDIgKiBpbm5lcnJhZGl1cy55KSk7XG4gIGlubmVycmFkaXVzLnogPiBFUFMgJiZcbiAgICAocmVzID0gcmVzLnN0cmV0Y2hBdFBsYW5lKFswLCAwLCAxXSwgWzAsIDAsIDBdLCAyICogaW5uZXJyYWRpdXMueikpO1xuICByZXMgPSByZXMudHJhbnNsYXRlKFtcbiAgICAtaW5uZXJyYWRpdXMueCArIGNlbnRlci54LFxuICAgIC1pbm5lcnJhZGl1cy55ICsgY2VudGVyLnksXG4gICAgLWlubmVycmFkaXVzLnogKyBjZW50ZXIueixcbiAgXSk7XG4gIHJlcyA9IHJlcy5yZVRlc3NlbGF0ZWQoKTtcbiAgcmVzLnByb3BlcnRpZXMucm91bmRlZEN1YmUgPSBuZXcgUHJvcGVydGllcygpO1xuICByZXMucHJvcGVydGllcy5yb3VuZGVkQ3ViZS5jZW50ZXIgPSBuZXcgVmVydGV4MyhjZW50ZXIpO1xuICByZXMucHJvcGVydGllcy5yb3VuZGVkQ3ViZS5mYWNlY2VudGVycyA9IFtcbiAgICBuZXcgQ29ubmVjdG9yKFxuICAgICAgbmV3IFZlY3RvcjMoW2N1YmVyYWRpdXMueCwgMCwgMF0pLnBsdXMoY2VudGVyKSxcbiAgICAgIFsxLCAwLCAwXSxcbiAgICAgIFswLCAwLCAxXVxuICAgICksXG4gICAgbmV3IENvbm5lY3RvcihcbiAgICAgIG5ldyBWZWN0b3IzKFstY3ViZXJhZGl1cy54LCAwLCAwXSkucGx1cyhjZW50ZXIpLFxuICAgICAgWy0xLCAwLCAwXSxcbiAgICAgIFswLCAwLCAxXVxuICAgICksXG4gICAgbmV3IENvbm5lY3RvcihcbiAgICAgIG5ldyBWZWN0b3IzKFswLCBjdWJlcmFkaXVzLnksIDBdKS5wbHVzKGNlbnRlciksXG4gICAgICBbMCwgMSwgMF0sXG4gICAgICBbMCwgMCwgMV1cbiAgICApLFxuICAgIG5ldyBDb25uZWN0b3IoXG4gICAgICBuZXcgVmVjdG9yMyhbMCwgLWN1YmVyYWRpdXMueSwgMF0pLnBsdXMoY2VudGVyKSxcbiAgICAgIFswLCAtMSwgMF0sXG4gICAgICBbMCwgMCwgMV1cbiAgICApLFxuICAgIG5ldyBDb25uZWN0b3IoXG4gICAgICBuZXcgVmVjdG9yMyhbMCwgMCwgY3ViZXJhZGl1cy56XSkucGx1cyhjZW50ZXIpLFxuICAgICAgWzAsIDAsIDFdLFxuICAgICAgWzEsIDAsIDBdXG4gICAgKSxcbiAgICBuZXcgQ29ubmVjdG9yKFxuICAgICAgbmV3IFZlY3RvcjMoWzAsIDAsIC1jdWJlcmFkaXVzLnpdKS5wbHVzKGNlbnRlciksXG4gICAgICBbMCwgMCwgLTFdLFxuICAgICAgWzEsIDAsIDBdXG4gICAgKSxcbiAgXTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKiBDcmVhdGUgYSBwb2x5aGVkcm9uIHVzaW5nIE9wZW5zY2FkIHN0eWxlIGFyZ3VtZW50cy5cbiAqIERlZmluZSBmYWNlIHZlcnRpY2VzIGNsb2Nrd2lzZSBsb29raW5nIGZyb20gb3V0c2lkZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBjb25zdHJ1Y3Rpb25cbiAqIEByZXR1cm5zIHtDU0d9IG5ldyAzRCBzb2xpZFxuICovXG5jb25zdCBwb2x5aGVkcm9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgncG9pbnRzJyBpbiBvcHRpb25zICE9PSAnZmFjZXMnIGluIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2x5aGVkcm9uIG5lZWRzICdwb2ludHMnIGFuZCAnZmFjZXMnIGFycmF5c1wiKTtcbiAgfVxuICBsZXQgdmVydGljZXMgPSBwYXJzZU9wdGlvbkFzM0RWZWN0b3JMaXN0KG9wdGlvbnMsICdwb2ludHMnLCBbXG4gICAgWzEsIDEsIDBdLFxuICAgIFsxLCAtMSwgMF0sXG4gICAgWy0xLCAtMSwgMF0sXG4gICAgWy0xLCAxLCAwXSxcbiAgICBbMCwgMCwgMV0sXG4gIF0pLm1hcChmdW5jdGlvbiAocHQpIHtcbiAgICByZXR1cm4gbmV3IFZlcnRleDMocHQpO1xuICB9KTtcbiAgbGV0IGZhY2VzID0gcGFyc2VPcHRpb24ob3B0aW9ucywgJ2ZhY2VzJywgW1xuICAgIFswLCAxLCA0XSxcbiAgICBbMSwgMiwgNF0sXG4gICAgWzIsIDMsIDRdLFxuICAgIFszLCAwLCA0XSxcbiAgICBbMSwgMCwgM10sXG4gICAgWzIsIDEsIDNdLFxuICBdKTtcbiAgLy8gT3BlbnNjYWQgY29udmVudGlvbiBkZWZpbmVzIGlud2FyZCBub3JtYWxzIC0gc28gd2UgaGF2ZSB0byBpbnZlcnQgaGVyZVxuICBmYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChmYWNlKSB7XG4gICAgZmFjZS5yZXZlcnNlKCk7XG4gIH0pO1xuICBsZXQgcG9seWdvbnMgPSBmYWNlcy5tYXAoZnVuY3Rpb24gKGZhY2UpIHtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24zKFxuICAgICAgZmFjZS5tYXAoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gdmVydGljZXNbaWR4XTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG5cbiAgLy8gVE9ETzogZmFjZWNlbnRlcnMgYXMgY29ubmVjdG9ycz8gcHJvYmFibHkgb3ZlcmtpbGwuIE1heWJlIGNlbnRyb2lkXG4gIC8vIHRoZSByZS10ZXNzZWxhdGlvbiBoZXJlIGhhcHBlbnMgYmVjYXVzZSBpdCdzIHNvIGVhc3kgZm9yIGEgdXNlciB0b1xuICAvLyBjcmVhdGUgcGFyYW1ldHJpemVkIHBvbHloZWRyb25zIHRoYXQgZW5kIHVwIHdpdGggMS0yIGRpbWVuc2lvbmFsIHBvbHlnb25zLlxuICAvLyBUaGVzZSB3aWxsIGNyZWF0ZSBpbmZpbml0ZSBsb29wcyBhdCBDU0cuVHJlZSgpXG4gIHJldHVybiBmcm9tUG9seWdvbnMocG9seWdvbnMpLnJlVGVzc2VsYXRlZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGN1YmUsXG4gIHNwaGVyZSxcbiAgcm91bmRlZEN1YmUsXG4gIGN5bGluZGVyLFxuICByb3VuZGVkQ3lsaW5kZXIsXG4gIGN5bGluZGVyRWxsaXB0aWMsXG4gIHBvbHloZWRyb24sXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/api/primitives3d.js\n");

/***/ }),

/***/ "./src/api/solidFromSlices.js":
/*!************************************!*\
  !*** ./src/api/solidFromSlices.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Polygon = __webpack_require__(/*! ../core/math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst { fromPolygons } = __webpack_require__(/*! ../core/CSGFactories */ \"./src/core/CSGFactories.js\");\nconst { fnSortByIndex } = __webpack_require__(/*! ../core/utils */ \"./src/core/utils.js\");\n\n// FIXME: WHY is this for 3D polygons and not for 2D shapes ?\n/**\n * Creates solid from slices (Polygon) by generating walls\n * @param {Object} options Solid generating options\n *  - numslices {Number} Number of slices to be generated\n *  - callback(t, slice) {Function} Callback function generating slices.\n *          arguments: t = [0..1], slice = [0..numslices - 1]\n *          return: Polygon or null to skip\n *  - loop {Boolean} no flats, only walls, it's used to generate solids like a tor\n */\nconst solidFromSlices = function (polygon, options) {\n  let polygons = [];\n  let csg = null;\n  let prev = null;\n  let bottom = null;\n  let top = null;\n  let numSlices = 2;\n  let bLoop = false;\n  let fnCallback;\n  let flipped = null;\n\n  if (options) {\n    bLoop = Boolean(options['loop']);\n\n    if (options.numslices) {\n      numSlices = options.numslices;\n    }\n\n    if (options.callback) {\n      fnCallback = options.callback;\n    }\n  }\n  if (!fnCallback) {\n    let square = Polygon.createFromPoints([\n      [0, 0, 0],\n      [1, 0, 0],\n      [1, 1, 0],\n      [0, 1, 0],\n    ]);\n    fnCallback = function (t, slice) {\n      return t === 0 || t === 1 ? square.translate([0, 0, t]) : null;\n    };\n  }\n  for (let i = 0, iMax = numSlices - 1; i <= iMax; i++) {\n    csg = fnCallback.call(polygon, i / iMax, i);\n    if (csg) {\n      if (!(csg instanceof Polygon)) {\n        throw new Error(\n          'Polygon.solidFromSlices callback error: Polygon expected'\n        );\n      }\n      csg.checkIfConvex();\n\n      if (prev) {\n        // generate walls\n        if (flipped === null) {\n          // not generated yet\n          flipped = prev.plane.signedDistanceToPoint(csg.vertices[0].pos) < 0;\n        }\n        _addWalls(polygons, prev, csg, flipped);\n      } else {\n        // the first - will be a bottom\n        bottom = csg;\n      }\n      prev = csg;\n    } // callback can return null to skip that slice\n  }\n  top = csg;\n\n  if (bLoop) {\n    let bSameTopBottom =\n      bottom.vertices.length === top.vertices.length &&\n      bottom.vertices.every(function (v, index) {\n        return v.pos.equals(top.vertices[index].pos);\n      });\n    // if top and bottom are not the same -\n    // generate walls between them\n    if (!bSameTopBottom) {\n      _addWalls(polygons, top, bottom, flipped);\n    } // else - already generated\n  } else {\n    // save top and bottom\n    // TODO: flip if necessary\n    polygons.unshift(flipped ? bottom : bottom.flipped());\n    polygons.push(flipped ? top.flipped() : top);\n  }\n  return fromPolygons(polygons);\n};\n\n/**\n * @param walls Array of wall polygons\n * @param bottom Bottom polygon\n * @param top Top polygon\n */\nconst _addWalls = function (walls, bottom, top, bFlipped) {\n  let bottomPoints = bottom.vertices.slice(0); // make a copy\n  let topPoints = top.vertices.slice(0); // make a copy\n  let color = top.shared || null;\n\n  // check if bottom perimeter is closed\n  if (!bottomPoints[0].pos.equals(bottomPoints[bottomPoints.length - 1].pos)) {\n    bottomPoints.push(bottomPoints[0]);\n  }\n\n  // check if top perimeter is closed\n  if (!topPoints[0].pos.equals(topPoints[topPoints.length - 1].pos)) {\n    topPoints.push(topPoints[0]);\n  }\n  if (bFlipped) {\n    bottomPoints = bottomPoints.reverse();\n    topPoints = topPoints.reverse();\n  }\n\n  let iTopLen = topPoints.length - 1;\n  let iBotLen = bottomPoints.length - 1;\n  let iExtra = iTopLen - iBotLen; // how many extra triangles we need\n  let bMoreTops = iExtra > 0;\n  let bMoreBottoms = iExtra < 0;\n\n  let aMin = []; // indexes to start extra triangles (polygon with minimal square)\n  // init - we need exactly /iExtra/ small triangles\n  for (let i = Math.abs(iExtra); i > 0; i--) {\n    aMin.push({\n      len: Infinity,\n      index: -1,\n    });\n  }\n\n  let len;\n  if (bMoreBottoms) {\n    for (let i = 0; i < iBotLen; i++) {\n      len = bottomPoints[i].pos.distanceToSquared(bottomPoints[i + 1].pos);\n      // find the element to replace\n      for (let j = aMin.length - 1; j >= 0; j--) {\n        if (aMin[j].len > len) {\n          aMin[j].len = len;\n          aMin.index = j;\n          break;\n        }\n      } // for\n    }\n  } else if (bMoreTops) {\n    for (let i = 0; i < iTopLen; i++) {\n      len = topPoints[i].pos.distanceToSquared(topPoints[i + 1].pos);\n      // find the element to replace\n      for (let j = aMin.length - 1; j >= 0; j--) {\n        if (aMin[j].len > len) {\n          aMin[j].len = len;\n          aMin.index = j;\n          break;\n        }\n      } // for\n    }\n  } // if\n  // sort by index\n  aMin.sort(fnSortByIndex);\n  let getTriangle = function addWallsPutTriangle(\n    pointA,\n    pointB,\n    pointC,\n    color\n  ) {\n    return new Polygon([pointA, pointB, pointC], color);\n    // return bFlipped ? triangle.flipped() : triangle;\n  };\n\n  let bpoint = bottomPoints[0];\n  let tpoint = topPoints[0];\n  let secondPoint;\n  let nBotFacet;\n  let nTopFacet; // length of triangle facet side\n  for (let iB = 0, iT = 0, iMax = iTopLen + iBotLen; iB + iT < iMax; ) {\n    if (aMin.length) {\n      if (bMoreTops && iT === aMin[0].index) {\n        // one vertex is on the bottom, 2 - on the top\n        secondPoint = topPoints[++iT];\n        // console.log('<<< extra top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);\n        walls.push(getTriangle(secondPoint, tpoint, bpoint, color));\n        tpoint = secondPoint;\n        aMin.shift();\n        continue;\n      } else if (bMoreBottoms && iB === aMin[0].index) {\n        secondPoint = bottomPoints[++iB];\n        walls.push(getTriangle(tpoint, bpoint, secondPoint, color));\n        bpoint = secondPoint;\n        aMin.shift();\n        continue;\n      }\n    }\n    // choose the shortest path\n    if (iB < iBotLen) {\n      // one vertex is on the top, 2 - on the bottom\n      nBotFacet = tpoint.pos.distanceToSquared(bottomPoints[iB + 1].pos);\n    } else {\n      nBotFacet = Infinity;\n    }\n    if (iT < iTopLen) {\n      // one vertex is on the bottom, 2 - on the top\n      nTopFacet = bpoint.pos.distanceToSquared(topPoints[iT + 1].pos);\n    } else {\n      nTopFacet = Infinity;\n    }\n    if (nBotFacet <= nTopFacet) {\n      secondPoint = bottomPoints[++iB];\n      walls.push(getTriangle(tpoint, bpoint, secondPoint, color));\n      bpoint = secondPoint;\n    } else if (iT < iTopLen) {\n      // nTopFacet < Infinity\n      secondPoint = topPoints[++iT];\n      // console.log('<<< top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);\n      walls.push(getTriangle(secondPoint, tpoint, bpoint, color));\n      tpoint = secondPoint;\n    }\n  }\n  return walls;\n};\n\nmodule.exports = solidFromSlices;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3NvbGlkRnJvbVNsaWNlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9hcGkvc29saWRGcm9tU2xpY2VzLmpzP2VhMzYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUG9seWdvbiA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0aC9Qb2x5Z29uMycpO1xuY29uc3QgeyBmcm9tUG9seWdvbnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvQ1NHRmFjdG9yaWVzJyk7XG5jb25zdCB7IGZuU29ydEJ5SW5kZXggfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbHMnKTtcblxuLy8gRklYTUU6IFdIWSBpcyB0aGlzIGZvciAzRCBwb2x5Z29ucyBhbmQgbm90IGZvciAyRCBzaGFwZXMgP1xuLyoqXG4gKiBDcmVhdGVzIHNvbGlkIGZyb20gc2xpY2VzIChQb2x5Z29uKSBieSBnZW5lcmF0aW5nIHdhbGxzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTb2xpZCBnZW5lcmF0aW5nIG9wdGlvbnNcbiAqICAtIG51bXNsaWNlcyB7TnVtYmVyfSBOdW1iZXIgb2Ygc2xpY2VzIHRvIGJlIGdlbmVyYXRlZFxuICogIC0gY2FsbGJhY2sodCwgc2xpY2UpIHtGdW5jdGlvbn0gQ2FsbGJhY2sgZnVuY3Rpb24gZ2VuZXJhdGluZyBzbGljZXMuXG4gKiAgICAgICAgICBhcmd1bWVudHM6IHQgPSBbMC4uMV0sIHNsaWNlID0gWzAuLm51bXNsaWNlcyAtIDFdXG4gKiAgICAgICAgICByZXR1cm46IFBvbHlnb24gb3IgbnVsbCB0byBza2lwXG4gKiAgLSBsb29wIHtCb29sZWFufSBubyBmbGF0cywgb25seSB3YWxscywgaXQncyB1c2VkIHRvIGdlbmVyYXRlIHNvbGlkcyBsaWtlIGEgdG9yXG4gKi9cbmNvbnN0IHNvbGlkRnJvbVNsaWNlcyA9IGZ1bmN0aW9uIChwb2x5Z29uLCBvcHRpb25zKSB7XG4gIGxldCBwb2x5Z29ucyA9IFtdO1xuICBsZXQgY3NnID0gbnVsbDtcbiAgbGV0IHByZXYgPSBudWxsO1xuICBsZXQgYm90dG9tID0gbnVsbDtcbiAgbGV0IHRvcCA9IG51bGw7XG4gIGxldCBudW1TbGljZXMgPSAyO1xuICBsZXQgYkxvb3AgPSBmYWxzZTtcbiAgbGV0IGZuQ2FsbGJhY2s7XG4gIGxldCBmbGlwcGVkID0gbnVsbDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGJMb29wID0gQm9vbGVhbihvcHRpb25zWydsb29wJ10pO1xuXG4gICAgaWYgKG9wdGlvbnMubnVtc2xpY2VzKSB7XG4gICAgICBudW1TbGljZXMgPSBvcHRpb25zLm51bXNsaWNlcztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgZm5DYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgfVxuICB9XG4gIGlmICghZm5DYWxsYmFjaykge1xuICAgIGxldCBzcXVhcmUgPSBQb2x5Z29uLmNyZWF0ZUZyb21Qb2ludHMoW1xuICAgICAgWzAsIDAsIDBdLFxuICAgICAgWzEsIDAsIDBdLFxuICAgICAgWzEsIDEsIDBdLFxuICAgICAgWzAsIDEsIDBdLFxuICAgIF0pO1xuICAgIGZuQ2FsbGJhY2sgPSBmdW5jdGlvbiAodCwgc2xpY2UpIHtcbiAgICAgIHJldHVybiB0ID09PSAwIHx8IHQgPT09IDEgPyBzcXVhcmUudHJhbnNsYXRlKFswLCAwLCB0XSkgOiBudWxsO1xuICAgIH07XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBudW1TbGljZXMgLSAxOyBpIDw9IGlNYXg7IGkrKykge1xuICAgIGNzZyA9IGZuQ2FsbGJhY2suY2FsbChwb2x5Z29uLCBpIC8gaU1heCwgaSk7XG4gICAgaWYgKGNzZykge1xuICAgICAgaWYgKCEoY3NnIGluc3RhbmNlb2YgUG9seWdvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdQb2x5Z29uLnNvbGlkRnJvbVNsaWNlcyBjYWxsYmFjayBlcnJvcjogUG9seWdvbiBleHBlY3RlZCdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNzZy5jaGVja0lmQ29udmV4KCk7XG5cbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIC8vIGdlbmVyYXRlIHdhbGxzXG4gICAgICAgIGlmIChmbGlwcGVkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gbm90IGdlbmVyYXRlZCB5ZXRcbiAgICAgICAgICBmbGlwcGVkID0gcHJldi5wbGFuZS5zaWduZWREaXN0YW5jZVRvUG9pbnQoY3NnLnZlcnRpY2VzWzBdLnBvcykgPCAwO1xuICAgICAgICB9XG4gICAgICAgIF9hZGRXYWxscyhwb2x5Z29ucywgcHJldiwgY3NnLCBmbGlwcGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCAtIHdpbGwgYmUgYSBib3R0b21cbiAgICAgICAgYm90dG9tID0gY3NnO1xuICAgICAgfVxuICAgICAgcHJldiA9IGNzZztcbiAgICB9IC8vIGNhbGxiYWNrIGNhbiByZXR1cm4gbnVsbCB0byBza2lwIHRoYXQgc2xpY2VcbiAgfVxuICB0b3AgPSBjc2c7XG5cbiAgaWYgKGJMb29wKSB7XG4gICAgbGV0IGJTYW1lVG9wQm90dG9tID1cbiAgICAgIGJvdHRvbS52ZXJ0aWNlcy5sZW5ndGggPT09IHRvcC52ZXJ0aWNlcy5sZW5ndGggJiZcbiAgICAgIGJvdHRvbS52ZXJ0aWNlcy5ldmVyeShmdW5jdGlvbiAodiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHYucG9zLmVxdWFscyh0b3AudmVydGljZXNbaW5kZXhdLnBvcyk7XG4gICAgICB9KTtcbiAgICAvLyBpZiB0b3AgYW5kIGJvdHRvbSBhcmUgbm90IHRoZSBzYW1lIC1cbiAgICAvLyBnZW5lcmF0ZSB3YWxscyBiZXR3ZWVuIHRoZW1cbiAgICBpZiAoIWJTYW1lVG9wQm90dG9tKSB7XG4gICAgICBfYWRkV2FsbHMocG9seWdvbnMsIHRvcCwgYm90dG9tLCBmbGlwcGVkKTtcbiAgICB9IC8vIGVsc2UgLSBhbHJlYWR5IGdlbmVyYXRlZFxuICB9IGVsc2Uge1xuICAgIC8vIHNhdmUgdG9wIGFuZCBib3R0b21cbiAgICAvLyBUT0RPOiBmbGlwIGlmIG5lY2Vzc2FyeVxuICAgIHBvbHlnb25zLnVuc2hpZnQoZmxpcHBlZCA/IGJvdHRvbSA6IGJvdHRvbS5mbGlwcGVkKCkpO1xuICAgIHBvbHlnb25zLnB1c2goZmxpcHBlZCA/IHRvcC5mbGlwcGVkKCkgOiB0b3ApO1xuICB9XG4gIHJldHVybiBmcm9tUG9seWdvbnMocG9seWdvbnMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gd2FsbHMgQXJyYXkgb2Ygd2FsbCBwb2x5Z29uc1xuICogQHBhcmFtIGJvdHRvbSBCb3R0b20gcG9seWdvblxuICogQHBhcmFtIHRvcCBUb3AgcG9seWdvblxuICovXG5jb25zdCBfYWRkV2FsbHMgPSBmdW5jdGlvbiAod2FsbHMsIGJvdHRvbSwgdG9wLCBiRmxpcHBlZCkge1xuICBsZXQgYm90dG9tUG9pbnRzID0gYm90dG9tLnZlcnRpY2VzLnNsaWNlKDApOyAvLyBtYWtlIGEgY29weVxuICBsZXQgdG9wUG9pbnRzID0gdG9wLnZlcnRpY2VzLnNsaWNlKDApOyAvLyBtYWtlIGEgY29weVxuICBsZXQgY29sb3IgPSB0b3Auc2hhcmVkIHx8IG51bGw7XG5cbiAgLy8gY2hlY2sgaWYgYm90dG9tIHBlcmltZXRlciBpcyBjbG9zZWRcbiAgaWYgKCFib3R0b21Qb2ludHNbMF0ucG9zLmVxdWFscyhib3R0b21Qb2ludHNbYm90dG9tUG9pbnRzLmxlbmd0aCAtIDFdLnBvcykpIHtcbiAgICBib3R0b21Qb2ludHMucHVzaChib3R0b21Qb2ludHNbMF0pO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdG9wIHBlcmltZXRlciBpcyBjbG9zZWRcbiAgaWYgKCF0b3BQb2ludHNbMF0ucG9zLmVxdWFscyh0b3BQb2ludHNbdG9wUG9pbnRzLmxlbmd0aCAtIDFdLnBvcykpIHtcbiAgICB0b3BQb2ludHMucHVzaCh0b3BQb2ludHNbMF0pO1xuICB9XG4gIGlmIChiRmxpcHBlZCkge1xuICAgIGJvdHRvbVBvaW50cyA9IGJvdHRvbVBvaW50cy5yZXZlcnNlKCk7XG4gICAgdG9wUG9pbnRzID0gdG9wUG9pbnRzLnJldmVyc2UoKTtcbiAgfVxuXG4gIGxldCBpVG9wTGVuID0gdG9wUG9pbnRzLmxlbmd0aCAtIDE7XG4gIGxldCBpQm90TGVuID0gYm90dG9tUG9pbnRzLmxlbmd0aCAtIDE7XG4gIGxldCBpRXh0cmEgPSBpVG9wTGVuIC0gaUJvdExlbjsgLy8gaG93IG1hbnkgZXh0cmEgdHJpYW5nbGVzIHdlIG5lZWRcbiAgbGV0IGJNb3JlVG9wcyA9IGlFeHRyYSA+IDA7XG4gIGxldCBiTW9yZUJvdHRvbXMgPSBpRXh0cmEgPCAwO1xuXG4gIGxldCBhTWluID0gW107IC8vIGluZGV4ZXMgdG8gc3RhcnQgZXh0cmEgdHJpYW5nbGVzIChwb2x5Z29uIHdpdGggbWluaW1hbCBzcXVhcmUpXG4gIC8vIGluaXQgLSB3ZSBuZWVkIGV4YWN0bHkgL2lFeHRyYS8gc21hbGwgdHJpYW5nbGVzXG4gIGZvciAobGV0IGkgPSBNYXRoLmFicyhpRXh0cmEpOyBpID4gMDsgaS0tKSB7XG4gICAgYU1pbi5wdXNoKHtcbiAgICAgIGxlbjogSW5maW5pdHksXG4gICAgICBpbmRleDogLTEsXG4gICAgfSk7XG4gIH1cblxuICBsZXQgbGVuO1xuICBpZiAoYk1vcmVCb3R0b21zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpQm90TGVuOyBpKyspIHtcbiAgICAgIGxlbiA9IGJvdHRvbVBvaW50c1tpXS5wb3MuZGlzdGFuY2VUb1NxdWFyZWQoYm90dG9tUG9pbnRzW2kgKyAxXS5wb3MpO1xuICAgICAgLy8gZmluZCB0aGUgZWxlbWVudCB0byByZXBsYWNlXG4gICAgICBmb3IgKGxldCBqID0gYU1pbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBpZiAoYU1pbltqXS5sZW4gPiBsZW4pIHtcbiAgICAgICAgICBhTWluW2pdLmxlbiA9IGxlbjtcbiAgICAgICAgICBhTWluLmluZGV4ID0gajtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICB9XG4gIH0gZWxzZSBpZiAoYk1vcmVUb3BzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpVG9wTGVuOyBpKyspIHtcbiAgICAgIGxlbiA9IHRvcFBvaW50c1tpXS5wb3MuZGlzdGFuY2VUb1NxdWFyZWQodG9wUG9pbnRzW2kgKyAxXS5wb3MpO1xuICAgICAgLy8gZmluZCB0aGUgZWxlbWVudCB0byByZXBsYWNlXG4gICAgICBmb3IgKGxldCBqID0gYU1pbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICBpZiAoYU1pbltqXS5sZW4gPiBsZW4pIHtcbiAgICAgICAgICBhTWluW2pdLmxlbiA9IGxlbjtcbiAgICAgICAgICBhTWluLmluZGV4ID0gajtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICB9XG4gIH0gLy8gaWZcbiAgLy8gc29ydCBieSBpbmRleFxuICBhTWluLnNvcnQoZm5Tb3J0QnlJbmRleCk7XG4gIGxldCBnZXRUcmlhbmdsZSA9IGZ1bmN0aW9uIGFkZFdhbGxzUHV0VHJpYW5nbGUoXG4gICAgcG9pbnRBLFxuICAgIHBvaW50QixcbiAgICBwb2ludEMsXG4gICAgY29sb3JcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKFtwb2ludEEsIHBvaW50QiwgcG9pbnRDXSwgY29sb3IpO1xuICAgIC8vIHJldHVybiBiRmxpcHBlZCA/IHRyaWFuZ2xlLmZsaXBwZWQoKSA6IHRyaWFuZ2xlO1xuICB9O1xuXG4gIGxldCBicG9pbnQgPSBib3R0b21Qb2ludHNbMF07XG4gIGxldCB0cG9pbnQgPSB0b3BQb2ludHNbMF07XG4gIGxldCBzZWNvbmRQb2ludDtcbiAgbGV0IG5Cb3RGYWNldDtcbiAgbGV0IG5Ub3BGYWNldDsgLy8gbGVuZ3RoIG9mIHRyaWFuZ2xlIGZhY2V0IHNpZGVcbiAgZm9yIChsZXQgaUIgPSAwLCBpVCA9IDAsIGlNYXggPSBpVG9wTGVuICsgaUJvdExlbjsgaUIgKyBpVCA8IGlNYXg7ICkge1xuICAgIGlmIChhTWluLmxlbmd0aCkge1xuICAgICAgaWYgKGJNb3JlVG9wcyAmJiBpVCA9PT0gYU1pblswXS5pbmRleCkge1xuICAgICAgICAvLyBvbmUgdmVydGV4IGlzIG9uIHRoZSBib3R0b20sIDIgLSBvbiB0aGUgdG9wXG4gICAgICAgIHNlY29uZFBvaW50ID0gdG9wUG9pbnRzWysraVRdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnPDw8IGV4dHJhIHRvcDogJyArIHNlY29uZFBvaW50ICsgJywgJyArIHRwb2ludCArICcsIGJvdHRvbTogJyArIGJwb2ludCk7XG4gICAgICAgIHdhbGxzLnB1c2goZ2V0VHJpYW5nbGUoc2Vjb25kUG9pbnQsIHRwb2ludCwgYnBvaW50LCBjb2xvcikpO1xuICAgICAgICB0cG9pbnQgPSBzZWNvbmRQb2ludDtcbiAgICAgICAgYU1pbi5zaGlmdCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoYk1vcmVCb3R0b21zICYmIGlCID09PSBhTWluWzBdLmluZGV4KSB7XG4gICAgICAgIHNlY29uZFBvaW50ID0gYm90dG9tUG9pbnRzWysraUJdO1xuICAgICAgICB3YWxscy5wdXNoKGdldFRyaWFuZ2xlKHRwb2ludCwgYnBvaW50LCBzZWNvbmRQb2ludCwgY29sb3IpKTtcbiAgICAgICAgYnBvaW50ID0gc2Vjb25kUG9pbnQ7XG4gICAgICAgIGFNaW4uc2hpZnQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aFxuICAgIGlmIChpQiA8IGlCb3RMZW4pIHtcbiAgICAgIC8vIG9uZSB2ZXJ0ZXggaXMgb24gdGhlIHRvcCwgMiAtIG9uIHRoZSBib3R0b21cbiAgICAgIG5Cb3RGYWNldCA9IHRwb2ludC5wb3MuZGlzdGFuY2VUb1NxdWFyZWQoYm90dG9tUG9pbnRzW2lCICsgMV0ucG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbkJvdEZhY2V0ID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChpVCA8IGlUb3BMZW4pIHtcbiAgICAgIC8vIG9uZSB2ZXJ0ZXggaXMgb24gdGhlIGJvdHRvbSwgMiAtIG9uIHRoZSB0b3BcbiAgICAgIG5Ub3BGYWNldCA9IGJwb2ludC5wb3MuZGlzdGFuY2VUb1NxdWFyZWQodG9wUG9pbnRzW2lUICsgMV0ucG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgblRvcEZhY2V0ID0gSW5maW5pdHk7XG4gICAgfVxuICAgIGlmIChuQm90RmFjZXQgPD0gblRvcEZhY2V0KSB7XG4gICAgICBzZWNvbmRQb2ludCA9IGJvdHRvbVBvaW50c1srK2lCXTtcbiAgICAgIHdhbGxzLnB1c2goZ2V0VHJpYW5nbGUodHBvaW50LCBicG9pbnQsIHNlY29uZFBvaW50LCBjb2xvcikpO1xuICAgICAgYnBvaW50ID0gc2Vjb25kUG9pbnQ7XG4gICAgfSBlbHNlIGlmIChpVCA8IGlUb3BMZW4pIHtcbiAgICAgIC8vIG5Ub3BGYWNldCA8IEluZmluaXR5XG4gICAgICBzZWNvbmRQb2ludCA9IHRvcFBvaW50c1srK2lUXTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCc8PDwgdG9wOiAnICsgc2Vjb25kUG9pbnQgKyAnLCAnICsgdHBvaW50ICsgJywgYm90dG9tOiAnICsgYnBvaW50KTtcbiAgICAgIHdhbGxzLnB1c2goZ2V0VHJpYW5nbGUoc2Vjb25kUG9pbnQsIHRwb2ludCwgYnBvaW50LCBjb2xvcikpO1xuICAgICAgdHBvaW50ID0gc2Vjb25kUG9pbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB3YWxscztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29saWRGcm9tU2xpY2VzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/solidFromSlices.js\n");

/***/ }),

/***/ "./src/api/text.js":
/*!*************************!*\
  !*** ./src/api/text.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const defaultFont = __webpack_require__(/*! ../fonts/single-line/hershey/simplex.js */ \"./src/fonts/single-line/hershey/simplex.js\");\nconst { union } = __webpack_require__(/*! ./ops-booleans */ \"./src/api/ops-booleans.js\");\n\nconst defaultsVectorParams = {\n  xOffset: 0,\n  yOffset: 0,\n  input: '?',\n  align: 'left',\n  font: defaultFont,\n  height: 14, // == old vector_xxx simplex font height\n  lineSpacing: 2.142857142857143, // == 30/14 == old vector_xxx ratio\n  letterSpacing: 1,\n  extrudeOffset: 0,\n};\n\n// vectorsXXX parameters handler\nfunction vectorParams(options, input) {\n  if (!input && typeof options === 'string') {\n    options = { input: options };\n  }\n  options = options || {};\n  let params = Object.assign({}, defaultsVectorParams, options);\n  params.input = input || params.input;\n  return params;\n}\n\n// translate text line\nfunction translateLine(options, line) {\n  const { x, y } = Object.assign({ x: 0, y: 0 }, options || {});\n  let segments = line.segments;\n  let segment = null;\n  let point = null;\n  for (let i = 0, il = segments.length; i < il; i++) {\n    segment = segments[i];\n    for (let j = 0, jl = segment.length; j < jl; j++) {\n      point = segment[j];\n      segment[j] = [point[0] + x, point[1] + y];\n    }\n  }\n  return line;\n}\n\n/** Represents a character as segments\n * @typedef {Object} VectorCharObject\n * @property {Float} width - character width\n * @property {Float} height - character height (uppercase)\n * @property {Array} segments - character segments [[[x, y], ...], ...]\n */\n\n/** Construct a {@link VectorCharObject} from a ascii character whose code is between 31 and 127,\n * if the character is not supported it is replaced by a question mark.\n * @param {Object|String} [options] - options for construction or ascii character\n * @param {Float} [options.xOffset=0] - x offset\n * @param {Float} [options.yOffset=0] - y offset\n * @param {Float} [options.height=21] - font size (uppercase height)\n * @param {Float} [options.extrudeOffset=0] - width of the extrusion that will be applied (manually) after the creation of the character\n * @param {String} [options.input='?'] - ascii character (ignored/overwrited if provided as seconds parameter)\n * @param {String} [char='?'] - ascii character\n * @returns {VectorCharObject}\n *\n * @example\n * let vectorCharObject = vectorChar()\n * or\n * let vectorCharObject = vectorChar('A')\n * or\n * let vectorCharObject = vectorChar({ xOffset: 57 }, 'C')\n * or\n * let vectorCharObject = vectorChar({ xOffset: 78, input: '!' })\n */\nfunction vectorChar(options, char) {\n  let { xOffset, yOffset, input, font, height, extrudeOffset } = vectorParams(\n    options,\n    char\n  );\n  let code = input.charCodeAt(0);\n  if (!code || !font[code]) {\n    code = 63; // 63 => ?\n  }\n  let glyph = [].concat(font[code]);\n  let ratio = (height - extrudeOffset) / font.height;\n  let extrudeYOffset = extrudeOffset / 2;\n  let width = glyph.shift() * ratio;\n  let segments = [];\n  let polyline = [];\n  for (let i = 0, il = glyph.length; i < il; i += 2) {\n    gx = ratio * glyph[i] + xOffset;\n    gy = ratio * glyph[i + 1] + yOffset + extrudeYOffset;\n    if (glyph[i] !== undefined) {\n      polyline.push([gx, gy]);\n      continue;\n    }\n    segments.push(polyline);\n    polyline = [];\n    i--;\n  }\n  if (polyline.length) {\n    segments.push(polyline);\n  }\n  return { width, height, segments };\n}\n\n/** Construct an array of character segments from a ascii string whose characters code is between 31 and 127,\n * if one character is not supported it is replaced by a question mark.\n * @param {Object|String} [options] - options for construction or ascii string\n * @param {Float} [options.xOffset=0] - x offset\n * @param {Float} [options.yOffset=0] - y offset\n * @param {Float} [options.height=21] - font size (uppercase height)\n * @param {Float} [options.lineSpacing=1.4] - line spacing expressed as a percentage of font size\n * @param {Float} [options.letterSpacing=1] - extra letter spacing expressed as a percentage of font size\n * @param {String} [options.align='left'] - multi-line text alignement: left, center or right\n * @param {Float} [options.extrudeOffset=0] - width of the extrusion that will be applied (manually) after the creation of the character\n * @param {String} [options.input='?'] - ascii string (ignored/overwrited if provided as seconds parameter)\n * @param {String} [text='?'] - ascii string\n * @returns {Array} characters segments [[[x, y], ...], ...]\n *\n * @example\n * let textSegments = vectorText()\n * or\n * let textSegments = vectorText('OpenJSCAD')\n * or\n * let textSegments = vectorText({ yOffset: -50 }, 'OpenJSCAD')\n * or\n * let textSegments = vectorText({ yOffset: -80, input: 'OpenJSCAD' })\n */\nfunction vectorText(options, text) {\n  let {\n    xOffset,\n    yOffset,\n    input,\n    font,\n    height,\n    align,\n    extrudeOffset,\n    lineSpacing,\n    letterSpacing,\n  } = vectorParams(options, text);\n  let [x, y] = [xOffset, yOffset];\n  let [i, il, char, vect, width, diff] = [];\n  let line = { width: 0, segments: [] };\n  let lines = [];\n  let output = [];\n  let maxWidth = 0;\n  let lineStart = x;\n  const pushLine = () => {\n    lines.push(line);\n    maxWidth = Math.max(maxWidth, line.width);\n    line = { width: 0, segments: [] };\n  };\n  for (i = 0, il = input.length; i < il; i++) {\n    char = input[i];\n    vect = vectorChar(\n      { xOffset: x, yOffset: y, font, height, extrudeOffset },\n      char\n    );\n    if (char === '\\n') {\n      x = lineStart;\n      y -= vect.height * lineSpacing;\n      pushLine();\n      continue;\n    }\n    width = vect.width * letterSpacing;\n    line.width += width;\n    x += width;\n    if (char !== ' ') {\n      line.segments = line.segments.concat(vect.segments);\n    }\n  }\n  if (line.segments.length) {\n    pushLine();\n  }\n  for (i = 0, il = lines.length; i < il; i++) {\n    line = lines[i];\n    if (maxWidth > line.width) {\n      diff = maxWidth - line.width;\n      if (align === 'right') {\n        line = translateLine({ x: diff }, line);\n      } else if (align === 'center') {\n        line = translateLine({ x: diff / 2 }, line);\n      }\n    }\n    output = output.concat(line.segments);\n  }\n  return output;\n}\n\n/** Construct a {@link VectorCharObject} from a ascii character whose code is between 31 and 127,\n* if the character is not supported it is replaced by a question mark.\n* @param {Float} x - x offset\n* @param {Float} y - y offset\n* @param {String} char - ascii character\n* @returns {VectorCharObject}\n* @deprecated >= v2\n\n* @example\n* let vectorCharObject = vector_char(36, 0, 'B')\n*/\nfunction vector_char(x, y, char) {\n  return vectorChar({ xOffset: x, yOffset: y }, char);\n}\n\n/** Construct an array of character segments from a ascii string whose characters code is between 31 and 127,\n * if one character is not supported it is replaced by a question mark.\n * @param {Float} x - x offset\n * @param {Float} y - y offset\n * @param {String} text - ascii string\n * @returns {Array} characters segments [[[x, y], ...], ...]\n * @deprecated >= v2\n *\n * @example\n * let textSegments = vector_text(0, -20, 'OpenJSCAD')\n */\nfunction vector_text(x, y, text) {\n  return vectorText({ xOffset: x, yOffset: y }, text);\n}\n\nmodule.exports = {\n  vector_char,\n  vector_text,\n  vectorChar,\n  vectorText,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBpL3RleHQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvYXBpL3RleHQuanM/YTBkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkZWZhdWx0Rm9udCA9IHJlcXVpcmUoJy4uL2ZvbnRzL3NpbmdsZS1saW5lL2hlcnNoZXkvc2ltcGxleC5qcycpO1xuY29uc3QgeyB1bmlvbiB9ID0gcmVxdWlyZSgnLi9vcHMtYm9vbGVhbnMnKTtcblxuY29uc3QgZGVmYXVsdHNWZWN0b3JQYXJhbXMgPSB7XG4gIHhPZmZzZXQ6IDAsXG4gIHlPZmZzZXQ6IDAsXG4gIGlucHV0OiAnPycsXG4gIGFsaWduOiAnbGVmdCcsXG4gIGZvbnQ6IGRlZmF1bHRGb250LFxuICBoZWlnaHQ6IDE0LCAvLyA9PSBvbGQgdmVjdG9yX3h4eCBzaW1wbGV4IGZvbnQgaGVpZ2h0XG4gIGxpbmVTcGFjaW5nOiAyLjE0Mjg1NzE0Mjg1NzE0MywgLy8gPT0gMzAvMTQgPT0gb2xkIHZlY3Rvcl94eHggcmF0aW9cbiAgbGV0dGVyU3BhY2luZzogMSxcbiAgZXh0cnVkZU9mZnNldDogMCxcbn07XG5cbi8vIHZlY3RvcnNYWFggcGFyYW1ldGVycyBoYW5kbGVyXG5mdW5jdGlvbiB2ZWN0b3JQYXJhbXMob3B0aW9ucywgaW5wdXQpIHtcbiAgaWYgKCFpbnB1dCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBpbnB1dDogb3B0aW9ucyB9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHNWZWN0b3JQYXJhbXMsIG9wdGlvbnMpO1xuICBwYXJhbXMuaW5wdXQgPSBpbnB1dCB8fCBwYXJhbXMuaW5wdXQ7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8vIHRyYW5zbGF0ZSB0ZXh0IGxpbmVcbmZ1bmN0aW9uIHRyYW5zbGF0ZUxpbmUob3B0aW9ucywgbGluZSkge1xuICBjb25zdCB7IHgsIHkgfSA9IE9iamVjdC5hc3NpZ24oeyB4OiAwLCB5OiAwIH0sIG9wdGlvbnMgfHwge30pO1xuICBsZXQgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBsZXQgc2VnbWVudCA9IG51bGw7XG4gIGxldCBwb2ludCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IDAsIGpsID0gc2VnbWVudC5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICBwb2ludCA9IHNlZ21lbnRbal07XG4gICAgICBzZWdtZW50W2pdID0gW3BvaW50WzBdICsgeCwgcG9pbnRbMV0gKyB5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59XG5cbi8qKiBSZXByZXNlbnRzIGEgY2hhcmFjdGVyIGFzIHNlZ21lbnRzXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWZWN0b3JDaGFyT2JqZWN0XG4gKiBAcHJvcGVydHkge0Zsb2F0fSB3aWR0aCAtIGNoYXJhY3RlciB3aWR0aFxuICogQHByb3BlcnR5IHtGbG9hdH0gaGVpZ2h0IC0gY2hhcmFjdGVyIGhlaWdodCAodXBwZXJjYXNlKVxuICogQHByb3BlcnR5IHtBcnJheX0gc2VnbWVudHMgLSBjaGFyYWN0ZXIgc2VnbWVudHMgW1tbeCwgeV0sIC4uLl0sIC4uLl1cbiAqL1xuXG4vKiogQ29uc3RydWN0IGEge0BsaW5rIFZlY3RvckNoYXJPYmplY3R9IGZyb20gYSBhc2NpaSBjaGFyYWN0ZXIgd2hvc2UgY29kZSBpcyBiZXR3ZWVuIDMxIGFuZCAxMjcsXG4gKiBpZiB0aGUgY2hhcmFjdGVyIGlzIG5vdCBzdXBwb3J0ZWQgaXQgaXMgcmVwbGFjZWQgYnkgYSBxdWVzdGlvbiBtYXJrLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBjb25zdHJ1Y3Rpb24gb3IgYXNjaWkgY2hhcmFjdGVyXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy54T2Zmc2V0PTBdIC0geCBvZmZzZXRcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLnlPZmZzZXQ9MF0gLSB5IG9mZnNldFxuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuaGVpZ2h0PTIxXSAtIGZvbnQgc2l6ZSAodXBwZXJjYXNlIGhlaWdodClcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmV4dHJ1ZGVPZmZzZXQ9MF0gLSB3aWR0aCBvZiB0aGUgZXh0cnVzaW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIChtYW51YWxseSkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBjaGFyYWN0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbnB1dD0nPyddIC0gYXNjaWkgY2hhcmFjdGVyIChpZ25vcmVkL292ZXJ3cml0ZWQgaWYgcHJvdmlkZWQgYXMgc2Vjb25kcyBwYXJhbWV0ZXIpXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NoYXI9Jz8nXSAtIGFzY2lpIGNoYXJhY3RlclxuICogQHJldHVybnMge1ZlY3RvckNoYXJPYmplY3R9XG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB2ZWN0b3JDaGFyT2JqZWN0ID0gdmVjdG9yQ2hhcigpXG4gKiBvclxuICogbGV0IHZlY3RvckNoYXJPYmplY3QgPSB2ZWN0b3JDaGFyKCdBJylcbiAqIG9yXG4gKiBsZXQgdmVjdG9yQ2hhck9iamVjdCA9IHZlY3RvckNoYXIoeyB4T2Zmc2V0OiA1NyB9LCAnQycpXG4gKiBvclxuICogbGV0IHZlY3RvckNoYXJPYmplY3QgPSB2ZWN0b3JDaGFyKHsgeE9mZnNldDogNzgsIGlucHV0OiAnIScgfSlcbiAqL1xuZnVuY3Rpb24gdmVjdG9yQ2hhcihvcHRpb25zLCBjaGFyKSB7XG4gIGxldCB7IHhPZmZzZXQsIHlPZmZzZXQsIGlucHV0LCBmb250LCBoZWlnaHQsIGV4dHJ1ZGVPZmZzZXQgfSA9IHZlY3RvclBhcmFtcyhcbiAgICBvcHRpb25zLFxuICAgIGNoYXJcbiAgKTtcbiAgbGV0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KDApO1xuICBpZiAoIWNvZGUgfHwgIWZvbnRbY29kZV0pIHtcbiAgICBjb2RlID0gNjM7IC8vIDYzID0+ID9cbiAgfVxuICBsZXQgZ2x5cGggPSBbXS5jb25jYXQoZm9udFtjb2RlXSk7XG4gIGxldCByYXRpbyA9IChoZWlnaHQgLSBleHRydWRlT2Zmc2V0KSAvIGZvbnQuaGVpZ2h0O1xuICBsZXQgZXh0cnVkZVlPZmZzZXQgPSBleHRydWRlT2Zmc2V0IC8gMjtcbiAgbGV0IHdpZHRoID0gZ2x5cGguc2hpZnQoKSAqIHJhdGlvO1xuICBsZXQgc2VnbWVudHMgPSBbXTtcbiAgbGV0IHBvbHlsaW5lID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGdseXBoLmxlbmd0aDsgaSA8IGlsOyBpICs9IDIpIHtcbiAgICBneCA9IHJhdGlvICogZ2x5cGhbaV0gKyB4T2Zmc2V0O1xuICAgIGd5ID0gcmF0aW8gKiBnbHlwaFtpICsgMV0gKyB5T2Zmc2V0ICsgZXh0cnVkZVlPZmZzZXQ7XG4gICAgaWYgKGdseXBoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBvbHlsaW5lLnB1c2goW2d4LCBneV0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZ21lbnRzLnB1c2gocG9seWxpbmUpO1xuICAgIHBvbHlsaW5lID0gW107XG4gICAgaS0tO1xuICB9XG4gIGlmIChwb2x5bGluZS5sZW5ndGgpIHtcbiAgICBzZWdtZW50cy5wdXNoKHBvbHlsaW5lKTtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBzZWdtZW50cyB9O1xufVxuXG4vKiogQ29uc3RydWN0IGFuIGFycmF5IG9mIGNoYXJhY3RlciBzZWdtZW50cyBmcm9tIGEgYXNjaWkgc3RyaW5nIHdob3NlIGNoYXJhY3RlcnMgY29kZSBpcyBiZXR3ZWVuIDMxIGFuZCAxMjcsXG4gKiBpZiBvbmUgY2hhcmFjdGVyIGlzIG5vdCBzdXBwb3J0ZWQgaXQgaXMgcmVwbGFjZWQgYnkgYSBxdWVzdGlvbiBtYXJrLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciBjb25zdHJ1Y3Rpb24gb3IgYXNjaWkgc3RyaW5nXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy54T2Zmc2V0PTBdIC0geCBvZmZzZXRcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLnlPZmZzZXQ9MF0gLSB5IG9mZnNldFxuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuaGVpZ2h0PTIxXSAtIGZvbnQgc2l6ZSAodXBwZXJjYXNlIGhlaWdodClcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmxpbmVTcGFjaW5nPTEuNF0gLSBsaW5lIHNwYWNpbmcgZXhwcmVzc2VkIGFzIGEgcGVyY2VudGFnZSBvZiBmb250IHNpemVcbiAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmxldHRlclNwYWNpbmc9MV0gLSBleHRyYSBsZXR0ZXIgc3BhY2luZyBleHByZXNzZWQgYXMgYSBwZXJjZW50YWdlIG9mIGZvbnQgc2l6ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFsaWduPSdsZWZ0J10gLSBtdWx0aS1saW5lIHRleHQgYWxpZ25lbWVudDogbGVmdCwgY2VudGVyIG9yIHJpZ2h0XG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5leHRydWRlT2Zmc2V0PTBdIC0gd2lkdGggb2YgdGhlIGV4dHJ1c2lvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCAobWFudWFsbHkpIGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgY2hhcmFjdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaW5wdXQ9Jz8nXSAtIGFzY2lpIHN0cmluZyAoaWdub3JlZC9vdmVyd3JpdGVkIGlmIHByb3ZpZGVkIGFzIHNlY29uZHMgcGFyYW1ldGVyKVxuICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0PSc/J10gLSBhc2NpaSBzdHJpbmdcbiAqIEByZXR1cm5zIHtBcnJheX0gY2hhcmFjdGVycyBzZWdtZW50cyBbW1t4LCB5XSwgLi4uXSwgLi4uXVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgdGV4dFNlZ21lbnRzID0gdmVjdG9yVGV4dCgpXG4gKiBvclxuICogbGV0IHRleHRTZWdtZW50cyA9IHZlY3RvclRleHQoJ09wZW5KU0NBRCcpXG4gKiBvclxuICogbGV0IHRleHRTZWdtZW50cyA9IHZlY3RvclRleHQoeyB5T2Zmc2V0OiAtNTAgfSwgJ09wZW5KU0NBRCcpXG4gKiBvclxuICogbGV0IHRleHRTZWdtZW50cyA9IHZlY3RvclRleHQoeyB5T2Zmc2V0OiAtODAsIGlucHV0OiAnT3BlbkpTQ0FEJyB9KVxuICovXG5mdW5jdGlvbiB2ZWN0b3JUZXh0KG9wdGlvbnMsIHRleHQpIHtcbiAgbGV0IHtcbiAgICB4T2Zmc2V0LFxuICAgIHlPZmZzZXQsXG4gICAgaW5wdXQsXG4gICAgZm9udCxcbiAgICBoZWlnaHQsXG4gICAgYWxpZ24sXG4gICAgZXh0cnVkZU9mZnNldCxcbiAgICBsaW5lU3BhY2luZyxcbiAgICBsZXR0ZXJTcGFjaW5nLFxuICB9ID0gdmVjdG9yUGFyYW1zKG9wdGlvbnMsIHRleHQpO1xuICBsZXQgW3gsIHldID0gW3hPZmZzZXQsIHlPZmZzZXRdO1xuICBsZXQgW2ksIGlsLCBjaGFyLCB2ZWN0LCB3aWR0aCwgZGlmZl0gPSBbXTtcbiAgbGV0IGxpbmUgPSB7IHdpZHRoOiAwLCBzZWdtZW50czogW10gfTtcbiAgbGV0IGxpbmVzID0gW107XG4gIGxldCBvdXRwdXQgPSBbXTtcbiAgbGV0IG1heFdpZHRoID0gMDtcbiAgbGV0IGxpbmVTdGFydCA9IHg7XG4gIGNvbnN0IHB1c2hMaW5lID0gKCkgPT4ge1xuICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgbWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgbGluZS53aWR0aCk7XG4gICAgbGluZSA9IHsgd2lkdGg6IDAsIHNlZ21lbnRzOiBbXSB9O1xuICB9O1xuICBmb3IgKGkgPSAwLCBpbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBjaGFyID0gaW5wdXRbaV07XG4gICAgdmVjdCA9IHZlY3RvckNoYXIoXG4gICAgICB7IHhPZmZzZXQ6IHgsIHlPZmZzZXQ6IHksIGZvbnQsIGhlaWdodCwgZXh0cnVkZU9mZnNldCB9LFxuICAgICAgY2hhclxuICAgICk7XG4gICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICB4ID0gbGluZVN0YXJ0O1xuICAgICAgeSAtPSB2ZWN0LmhlaWdodCAqIGxpbmVTcGFjaW5nO1xuICAgICAgcHVzaExpbmUoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB3aWR0aCA9IHZlY3Qud2lkdGggKiBsZXR0ZXJTcGFjaW5nO1xuICAgIGxpbmUud2lkdGggKz0gd2lkdGg7XG4gICAgeCArPSB3aWR0aDtcbiAgICBpZiAoY2hhciAhPT0gJyAnKSB7XG4gICAgICBsaW5lLnNlZ21lbnRzID0gbGluZS5zZWdtZW50cy5jb25jYXQodmVjdC5zZWdtZW50cyk7XG4gICAgfVxuICB9XG4gIGlmIChsaW5lLnNlZ21lbnRzLmxlbmd0aCkge1xuICAgIHB1c2hMaW5lKCk7XG4gIH1cbiAgZm9yIChpID0gMCwgaWwgPSBsaW5lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGlmIChtYXhXaWR0aCA+IGxpbmUud2lkdGgpIHtcbiAgICAgIGRpZmYgPSBtYXhXaWR0aCAtIGxpbmUud2lkdGg7XG4gICAgICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgbGluZSA9IHRyYW5zbGF0ZUxpbmUoeyB4OiBkaWZmIH0sIGxpbmUpO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbGluZSA9IHRyYW5zbGF0ZUxpbmUoeyB4OiBkaWZmIC8gMiB9LCBsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0ID0gb3V0cHV0LmNvbmNhdChsaW5lLnNlZ21lbnRzKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKiogQ29uc3RydWN0IGEge0BsaW5rIFZlY3RvckNoYXJPYmplY3R9IGZyb20gYSBhc2NpaSBjaGFyYWN0ZXIgd2hvc2UgY29kZSBpcyBiZXR3ZWVuIDMxIGFuZCAxMjcsXG4qIGlmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IHN1cHBvcnRlZCBpdCBpcyByZXBsYWNlZCBieSBhIHF1ZXN0aW9uIG1hcmsuXG4qIEBwYXJhbSB7RmxvYXR9IHggLSB4IG9mZnNldFxuKiBAcGFyYW0ge0Zsb2F0fSB5IC0geSBvZmZzZXRcbiogQHBhcmFtIHtTdHJpbmd9IGNoYXIgLSBhc2NpaSBjaGFyYWN0ZXJcbiogQHJldHVybnMge1ZlY3RvckNoYXJPYmplY3R9XG4qIEBkZXByZWNhdGVkID49IHYyXG5cbiogQGV4YW1wbGVcbiogbGV0IHZlY3RvckNoYXJPYmplY3QgPSB2ZWN0b3JfY2hhcigzNiwgMCwgJ0InKVxuKi9cbmZ1bmN0aW9uIHZlY3Rvcl9jaGFyKHgsIHksIGNoYXIpIHtcbiAgcmV0dXJuIHZlY3RvckNoYXIoeyB4T2Zmc2V0OiB4LCB5T2Zmc2V0OiB5IH0sIGNoYXIpO1xufVxuXG4vKiogQ29uc3RydWN0IGFuIGFycmF5IG9mIGNoYXJhY3RlciBzZWdtZW50cyBmcm9tIGEgYXNjaWkgc3RyaW5nIHdob3NlIGNoYXJhY3RlcnMgY29kZSBpcyBiZXR3ZWVuIDMxIGFuZCAxMjcsXG4gKiBpZiBvbmUgY2hhcmFjdGVyIGlzIG5vdCBzdXBwb3J0ZWQgaXQgaXMgcmVwbGFjZWQgYnkgYSBxdWVzdGlvbiBtYXJrLlxuICogQHBhcmFtIHtGbG9hdH0geCAtIHggb2Zmc2V0XG4gKiBAcGFyYW0ge0Zsb2F0fSB5IC0geSBvZmZzZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gYXNjaWkgc3RyaW5nXG4gKiBAcmV0dXJucyB7QXJyYXl9IGNoYXJhY3RlcnMgc2VnbWVudHMgW1tbeCwgeV0sIC4uLl0sIC4uLl1cbiAqIEBkZXByZWNhdGVkID49IHYyXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB0ZXh0U2VnbWVudHMgPSB2ZWN0b3JfdGV4dCgwLCAtMjAsICdPcGVuSlNDQUQnKVxuICovXG5mdW5jdGlvbiB2ZWN0b3JfdGV4dCh4LCB5LCB0ZXh0KSB7XG4gIHJldHVybiB2ZWN0b3JUZXh0KHsgeE9mZnNldDogeCwgeU9mZnNldDogeSB9LCB0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlY3Rvcl9jaGFyLFxuICB2ZWN0b3JfdGV4dCxcbiAgdmVjdG9yQ2hhcixcbiAgdmVjdG9yVGV4dCxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/text.js\n");

/***/ }),

/***/ "./src/core/CAG.js":
/*!*************************!*\
  !*** ./src/core/CAG.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Connector } = __webpack_require__(/*! ./connectors */ \"./src/core/connectors.js\");\nconst Vertex3D = __webpack_require__(/*! ./math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Vector2D = __webpack_require__(/*! ./math/Vector2 */ \"./src/core/math/Vector2.js\");\nconst Vector3D = __webpack_require__(/*! ./math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Polygon = __webpack_require__(/*! ./math/Polygon3 */ \"./src/core/math/Polygon3.js\");\n\nconst { fromPolygons } = __webpack_require__(/*! ./CSGFactories */ \"./src/core/CSGFactories.js\");\nconst { fromSides, fromFakeCSG } = __webpack_require__(/*! ./CAGFactories */ \"./src/core/CAGFactories.js\");\n\nconst canonicalize = __webpack_require__(/*! ./utils/canonicalize */ \"./src/core/utils/canonicalize.js\");\nconst retesselate = __webpack_require__(/*! ./utils/retesellate */ \"./src/core/utils/retesellate.js\");\nconst {\n  isCAGValid,\n  isSelfIntersecting,\n  hasPointInside,\n} = __webpack_require__(/*! ./utils/cagValidation */ \"./src/core/utils/cagValidation.js\");\nconst { area, getBounds } = __webpack_require__(/*! ./utils/cagMeasurements */ \"./src/core/utils/cagMeasurements.js\");\n\n// all of these are good candidates for elimination in this scope, since they are part of a functional api\nconst { overCutInsideCorners } = __webpack_require__(/*! ../api/ops-cnc */ \"./src/api/ops-cnc.js\");\nconst {\n  extrudeInOrthonormalBasis,\n  extrudeInPlane,\n  extrude,\n  rotateExtrude,\n} = __webpack_require__(/*! ../api/ops-extrusions */ \"./src/api/ops-extrusions.js\");\nconst cagoutlinePaths = __webpack_require__(/*! ../api/cagOutlinePaths */ \"./src/api/cagOutlinePaths.js\");\nconst center = __webpack_require__(/*! ../api/center */ \"./src/api/center.js\");\nconst {\n  expand,\n  contract,\n  expandedShellOfCAG,\n} = __webpack_require__(/*! ../api/ops-expandContract */ \"./src/api/ops-expandContract.js\");\n/**\n * Class CAG\n * Holds a solid area geometry like CSG but 2D.\n * Each area consists of a number of sides.\n * Each side is a line between 2 points.\n * @constructor\n */\nlet CAG = function () {\n  this.sides = [];\n  this.isCanonicalized = false;\n};\n\nCAG.prototype = {\n  union: function (cag) {\n    let cags;\n    if (cag instanceof Array) {\n      cags = cag;\n    } else {\n      cags = [cag];\n    }\n    let r = this._toCSGWall(-1, 1);\n    r = r.union(\n      cags.map(function (cag) {\n        return cag._toCSGWall(-1, 1).reTesselated();\n      }),\n      false,\n      false\n    );\n    return fromFakeCSG(r).canonicalized();\n  },\n\n  subtract: function (cag) {\n    let cags;\n    if (cag instanceof Array) {\n      cags = cag;\n    } else {\n      cags = [cag];\n    }\n    let r = this._toCSGWall(-1, 1);\n    cags.map(function (cag) {\n      r = r.subtractSub(cag._toCSGWall(-1, 1), false, false);\n    });\n    r = r.reTesselated();\n    r = r.canonicalized();\n    r = fromFakeCSG(r);\n    r = r.canonicalized();\n    return r;\n  },\n\n  intersect: function (cag) {\n    let cags;\n    if (cag instanceof Array) {\n      cags = cag;\n    } else {\n      cags = [cag];\n    }\n    let r = this._toCSGWall(-1, 1);\n    cags.map(function (cag) {\n      r = r.intersectSub(cag._toCSGWall(-1, 1), false, false);\n    });\n    r = r.reTesselated();\n    r = r.canonicalized();\n    r = fromFakeCSG(r);\n    r = r.canonicalized();\n    return r;\n  },\n\n  transform: function (matrix4x4) {\n    let ismirror = matrix4x4.isMirroring();\n    let newsides = this.sides.map(function (side) {\n      return side.transform(matrix4x4);\n    });\n    let result = fromSides(newsides);\n    if (ismirror) {\n      result = result.flipped();\n    }\n    return result;\n  },\n\n  flipped: function () {\n    let newsides = this.sides.map(function (side) {\n      return side.flipped();\n    });\n    newsides.reverse();\n    return fromSides(newsides);\n  },\n\n  // ALIAS !\n  center: function (axes) {\n    return center({ axes: axes }, [this]);\n  },\n\n  // ALIAS !\n  expandedShell: function (radius, resolution) {\n    return expandedShellOfCAG(this, radius, resolution);\n  },\n\n  // ALIAS !\n  expand: function (radius, resolution) {\n    return expand(this, radius, resolution);\n  },\n\n  contract: function (radius, resolution) {\n    return contract(this, radius, resolution);\n  },\n\n  // ALIAS !\n  area: function () {\n    return area(this);\n  },\n\n  // ALIAS !\n  getBounds: function () {\n    return getBounds(this);\n  },\n  // ALIAS !\n  isSelfIntersecting: function (debug) {\n    return isSelfIntersecting(this, debug);\n  },\n  // extrusion: all aliases to simple functions\n  extrudeInOrthonormalBasis: function (orthonormalbasis, depth, options) {\n    return extrudeInOrthonormalBasis(this, orthonormalbasis, depth, options);\n  },\n\n  // ALIAS !\n  extrudeInPlane: function (axis1, axis2, depth, options) {\n    return extrudeInPlane(this, axis1, axis2, depth, options);\n  },\n\n  // ALIAS !\n  extrude: function (options) {\n    return extrude(this, options);\n  },\n\n  // ALIAS !\n  rotateExtrude: function (options) {\n    // FIXME options should be optional\n    return rotateExtrude(this, options);\n  },\n\n  // ALIAS !\n  check: function () {\n    return isCAGValid(this);\n  },\n\n  // ALIAS !\n  canonicalized: function () {\n    return canonicalize(this);\n  },\n\n  // ALIAS !\n  reTesselated: function () {\n    return retesselate(this);\n  },\n\n  // ALIAS !\n  getOutlinePaths: function () {\n    return cagoutlinePaths(this);\n  },\n\n  // ALIAS !\n  overCutInsideCorners: function (cutterradius) {\n    return overCutInsideCorners(this, cutterradius);\n  },\n\n  // ALIAS !\n  hasPointInside: function (point) {\n    return hasPointInside(this, point);\n  },\n\n  // All the toXXX functions\n  toString: function () {\n    let result = 'CAG (' + this.sides.length + ' sides):\\n';\n    this.sides.map(function (side) {\n      result += '  ' + side.toString() + '\\n';\n    });\n    return result;\n  },\n\n  _toCSGWall: function (z0, z1) {\n    let polygons = this.sides.map(function (side) {\n      return side.toPolygon3D(z0, z1);\n    });\n    return fromPolygons(polygons);\n  },\n\n  _toVector3DPairs: function (m) {\n    // transform m\n    let pairs = this.sides.map(function (side) {\n      let p0 = side.vertex0.pos;\n      let p1 = side.vertex1.pos;\n      return [Vector3D.Create(p0.x, p0.y, 0), Vector3D.Create(p1.x, p1.y, 0)];\n    });\n    if (typeof m !== 'undefined') {\n      pairs = pairs.map(function (pair) {\n        return pair.map(function (v) {\n          return v.transform(m);\n        });\n      });\n    }\n    return pairs;\n  },\n\n  /*\n   * transform a cag into the polygons of a corresponding 3d plane, positioned per options\n   * Accepts a connector for plane positioning, or optionally\n   * single translation, axisVector, normalVector arguments\n   * (toConnector has precedence over single arguments if provided)\n   */\n  _toPlanePolygons: function (options) {\n    const defaults = {\n      flipped: false,\n    };\n    options = Object.assign({}, defaults, options);\n    let { flipped } = options;\n    // reference connector for transformation\n    let origin = [0, 0, 0];\n    let defaultAxis = [0, 0, 1];\n    let defaultNormal = [0, 1, 0];\n    let thisConnector = new Connector(origin, defaultAxis, defaultNormal);\n    // translated connector per options\n    let translation = options.translation || origin;\n    let axisVector = options.axisVector || defaultAxis;\n    let normalVector = options.normalVector || defaultNormal;\n    // will override above if options has toConnector\n    let toConnector =\n      options.toConnector ||\n      new Connector(translation, axisVector, normalVector);\n    // resulting transform\n    let m = thisConnector.getTransformationTo(toConnector, false, 0);\n    // create plane as a (partial non-closed) CSG in XY plane\n    let bounds = this.getBounds();\n    bounds[0] = bounds[0].minus(new Vector2D(1, 1));\n    bounds[1] = bounds[1].plus(new Vector2D(1, 1));\n    let csgshell = this._toCSGWall(-1, 1);\n    let csgplane = fromPolygons([\n      new Polygon([\n        new Vertex3D(new Vector3D(bounds[0].x, bounds[0].y, 0)),\n        new Vertex3D(new Vector3D(bounds[1].x, bounds[0].y, 0)),\n        new Vertex3D(new Vector3D(bounds[1].x, bounds[1].y, 0)),\n        new Vertex3D(new Vector3D(bounds[0].x, bounds[1].y, 0)),\n      ]),\n    ]);\n    if (flipped) {\n      csgplane = csgplane.invert();\n    }\n    // intersectSub -> prevent premature retesselate/canonicalize\n    csgplane = csgplane.intersectSub(csgshell);\n    // only keep the polygons in the z plane:\n    let polys = csgplane.polygons.filter(function (polygon) {\n      return Math.abs(polygon.plane.normal.z) > 0.99;\n    });\n    // finally, position the plane per passed transformations\n    return polys.map(function (poly) {\n      return poly.transform(m);\n    });\n  },\n\n  /*\n   * given 2 connectors, this returns all polygons of a \"wall\" between 2\n   * copies of this cag, positioned in 3d space as \"bottom\" and\n   * \"top\" plane per connectors toConnector1, and toConnector2, respectively\n   */\n  _toWallPolygons: function (options) {\n    // normals are going to be correct as long as toConn2.point - toConn1.point\n    // points into cag normal direction (check in caller)\n    // arguments: options.toConnector1, options.toConnector2, options.cag\n    //     walls go from toConnector1 to toConnector2\n    //     optionally, target cag to point to - cag needs to have same number of sides as this!\n    let origin = [0, 0, 0];\n    let defaultAxis = [0, 0, 1];\n    let defaultNormal = [0, 1, 0];\n    let thisConnector = new Connector(origin, defaultAxis, defaultNormal);\n    // arguments:\n    let toConnector1 = options.toConnector1;\n    // let toConnector2 = new Connector([0, 0, -30], defaultAxis, defaultNormal);\n    let toConnector2 = options.toConnector2;\n    if (\n      !(toConnector1 instanceof Connector && toConnector2 instanceof Connector)\n    ) {\n      throw new Error(\n        'could not parse Connector arguments toConnector1 or toConnector2'\n      );\n    }\n    if (options.cag) {\n      if (options.cag.sides.length !== this.sides.length) {\n        throw new Error('target cag needs same sides count as start cag');\n      }\n    }\n    // target cag is same as this unless specified\n    let toCag = options.cag || this;\n    let m1 = thisConnector.getTransformationTo(toConnector1, false, 0);\n    let m2 = thisConnector.getTransformationTo(toConnector2, false, 0);\n    let vps1 = this._toVector3DPairs(m1);\n    let vps2 = toCag._toVector3DPairs(m2);\n\n    let polygons = [];\n    vps1.forEach(function (vp1, i) {\n      polygons.push(\n        new Polygon([\n          new Vertex3D(vps2[i][1]),\n          new Vertex3D(vps2[i][0]),\n          new Vertex3D(vp1[0]),\n        ])\n      );\n      polygons.push(\n        new Polygon([\n          new Vertex3D(vps2[i][1]),\n          new Vertex3D(vp1[0]),\n          new Vertex3D(vp1[1]),\n        ])\n      );\n    });\n    return polygons;\n  },\n\n  /**\n   * Convert to a list of points.\n   * @return {points[]} list of points in 2D space\n   */\n  toPoints: function () {\n    let points = this.sides.map(function (side) {\n      let v0 = side.vertex0;\n      // let v1 = side.vertex1\n      return v0.pos;\n    });\n    // due to the logic of fromPoints()\n    // move the first point to the last\n    if (points.length > 0) {\n      points.push(points.shift());\n    }\n    return points;\n  },\n\n  /** Convert to compact binary form.\n   * See fromCompactBinary.\n   * @return {CompactBinary}\n   */\n  toCompactBinary: function () {\n    let cag = this.canonicalized();\n    let numsides = cag.sides.length;\n    let vertexmap = {};\n    let vertices = [];\n    let numvertices = 0;\n    let sideVertexIndices = new Uint32Array(2 * numsides);\n    let sidevertexindicesindex = 0;\n    cag.sides.map(function (side) {\n      [side.vertex0, side.vertex1].map(function (v) {\n        let vertextag = v.getTag();\n        let vertexindex;\n        if (!(vertextag in vertexmap)) {\n          vertexindex = numvertices++;\n          vertexmap[vertextag] = vertexindex;\n          vertices.push(v);\n        } else {\n          vertexindex = vertexmap[vertextag];\n        }\n        sideVertexIndices[sidevertexindicesindex++] = vertexindex;\n      });\n    });\n    let vertexData = new Float64Array(numvertices * 2);\n    let verticesArrayIndex = 0;\n    vertices.map(function (v) {\n      let pos = v.pos;\n      vertexData[verticesArrayIndex++] = pos._x;\n      vertexData[verticesArrayIndex++] = pos._y;\n    });\n    let result = {\n      class: 'CAG',\n      sideVertexIndices: sideVertexIndices,\n      vertexData: vertexData,\n    };\n    return result;\n  },\n};\n\nmodule.exports = CAG;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9DQUcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9DQUcuanM/NmNiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IENvbm5lY3RvciB9ID0gcmVxdWlyZSgnLi9jb25uZWN0b3JzJyk7XG5jb25zdCBWZXJ0ZXgzRCA9IHJlcXVpcmUoJy4vbWF0aC9WZXJ0ZXgzJyk7XG5jb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4vbWF0aC9WZWN0b3IyJyk7XG5jb25zdCBWZWN0b3IzRCA9IHJlcXVpcmUoJy4vbWF0aC9WZWN0b3IzJyk7XG5jb25zdCBQb2x5Z29uID0gcmVxdWlyZSgnLi9tYXRoL1BvbHlnb24zJyk7XG5cbmNvbnN0IHsgZnJvbVBvbHlnb25zIH0gPSByZXF1aXJlKCcuL0NTR0ZhY3RvcmllcycpO1xuY29uc3QgeyBmcm9tU2lkZXMsIGZyb21GYWtlQ1NHIH0gPSByZXF1aXJlKCcuL0NBR0ZhY3RvcmllcycpO1xuXG5jb25zdCBjYW5vbmljYWxpemUgPSByZXF1aXJlKCcuL3V0aWxzL2Nhbm9uaWNhbGl6ZScpO1xuY29uc3QgcmV0ZXNzZWxhdGUgPSByZXF1aXJlKCcuL3V0aWxzL3JldGVzZWxsYXRlJyk7XG5jb25zdCB7XG4gIGlzQ0FHVmFsaWQsXG4gIGlzU2VsZkludGVyc2VjdGluZyxcbiAgaGFzUG9pbnRJbnNpZGUsXG59ID0gcmVxdWlyZSgnLi91dGlscy9jYWdWYWxpZGF0aW9uJyk7XG5jb25zdCB7IGFyZWEsIGdldEJvdW5kcyB9ID0gcmVxdWlyZSgnLi91dGlscy9jYWdNZWFzdXJlbWVudHMnKTtcblxuLy8gYWxsIG9mIHRoZXNlIGFyZSBnb29kIGNhbmRpZGF0ZXMgZm9yIGVsaW1pbmF0aW9uIGluIHRoaXMgc2NvcGUsIHNpbmNlIHRoZXkgYXJlIHBhcnQgb2YgYSBmdW5jdGlvbmFsIGFwaVxuY29uc3QgeyBvdmVyQ3V0SW5zaWRlQ29ybmVycyB9ID0gcmVxdWlyZSgnLi4vYXBpL29wcy1jbmMnKTtcbmNvbnN0IHtcbiAgZXh0cnVkZUluT3J0aG9ub3JtYWxCYXNpcyxcbiAgZXh0cnVkZUluUGxhbmUsXG4gIGV4dHJ1ZGUsXG4gIHJvdGF0ZUV4dHJ1ZGUsXG59ID0gcmVxdWlyZSgnLi4vYXBpL29wcy1leHRydXNpb25zJyk7XG5jb25zdCBjYWdvdXRsaW5lUGF0aHMgPSByZXF1aXJlKCcuLi9hcGkvY2FnT3V0bGluZVBhdGhzJyk7XG5jb25zdCBjZW50ZXIgPSByZXF1aXJlKCcuLi9hcGkvY2VudGVyJyk7XG5jb25zdCB7XG4gIGV4cGFuZCxcbiAgY29udHJhY3QsXG4gIGV4cGFuZGVkU2hlbGxPZkNBRyxcbn0gPSByZXF1aXJlKCcuLi9hcGkvb3BzLWV4cGFuZENvbnRyYWN0Jyk7XG4vKipcbiAqIENsYXNzIENBR1xuICogSG9sZHMgYSBzb2xpZCBhcmVhIGdlb21ldHJ5IGxpa2UgQ1NHIGJ1dCAyRC5cbiAqIEVhY2ggYXJlYSBjb25zaXN0cyBvZiBhIG51bWJlciBvZiBzaWRlcy5cbiAqIEVhY2ggc2lkZSBpcyBhIGxpbmUgYmV0d2VlbiAyIHBvaW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5sZXQgQ0FHID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNpZGVzID0gW107XG4gIHRoaXMuaXNDYW5vbmljYWxpemVkID0gZmFsc2U7XG59O1xuXG5DQUcucHJvdG90eXBlID0ge1xuICB1bmlvbjogZnVuY3Rpb24gKGNhZykge1xuICAgIGxldCBjYWdzO1xuICAgIGlmIChjYWcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgY2FncyA9IGNhZztcbiAgICB9IGVsc2Uge1xuICAgICAgY2FncyA9IFtjYWddO1xuICAgIH1cbiAgICBsZXQgciA9IHRoaXMuX3RvQ1NHV2FsbCgtMSwgMSk7XG4gICAgciA9IHIudW5pb24oXG4gICAgICBjYWdzLm1hcChmdW5jdGlvbiAoY2FnKSB7XG4gICAgICAgIHJldHVybiBjYWcuX3RvQ1NHV2FsbCgtMSwgMSkucmVUZXNzZWxhdGVkKCk7XG4gICAgICB9KSxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHJldHVybiBmcm9tRmFrZUNTRyhyKS5jYW5vbmljYWxpemVkKCk7XG4gIH0sXG5cbiAgc3VidHJhY3Q6IGZ1bmN0aW9uIChjYWcpIHtcbiAgICBsZXQgY2FncztcbiAgICBpZiAoY2FnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNhZ3MgPSBjYWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhZ3MgPSBbY2FnXTtcbiAgICB9XG4gICAgbGV0IHIgPSB0aGlzLl90b0NTR1dhbGwoLTEsIDEpO1xuICAgIGNhZ3MubWFwKGZ1bmN0aW9uIChjYWcpIHtcbiAgICAgIHIgPSByLnN1YnRyYWN0U3ViKGNhZy5fdG9DU0dXYWxsKC0xLCAxKSwgZmFsc2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgICByID0gci5yZVRlc3NlbGF0ZWQoKTtcbiAgICByID0gci5jYW5vbmljYWxpemVkKCk7XG4gICAgciA9IGZyb21GYWtlQ1NHKHIpO1xuICAgIHIgPSByLmNhbm9uaWNhbGl6ZWQoKTtcbiAgICByZXR1cm4gcjtcbiAgfSxcblxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChjYWcpIHtcbiAgICBsZXQgY2FncztcbiAgICBpZiAoY2FnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNhZ3MgPSBjYWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhZ3MgPSBbY2FnXTtcbiAgICB9XG4gICAgbGV0IHIgPSB0aGlzLl90b0NTR1dhbGwoLTEsIDEpO1xuICAgIGNhZ3MubWFwKGZ1bmN0aW9uIChjYWcpIHtcbiAgICAgIHIgPSByLmludGVyc2VjdFN1YihjYWcuX3RvQ1NHV2FsbCgtMSwgMSksIGZhbHNlLCBmYWxzZSk7XG4gICAgfSk7XG4gICAgciA9IHIucmVUZXNzZWxhdGVkKCk7XG4gICAgciA9IHIuY2Fub25pY2FsaXplZCgpO1xuICAgIHIgPSBmcm9tRmFrZUNTRyhyKTtcbiAgICByID0gci5jYW5vbmljYWxpemVkKCk7XG4gICAgcmV0dXJuIHI7XG4gIH0sXG5cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4NHg0KSB7XG4gICAgbGV0IGlzbWlycm9yID0gbWF0cml4NHg0LmlzTWlycm9yaW5nKCk7XG4gICAgbGV0IG5ld3NpZGVzID0gdGhpcy5zaWRlcy5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJldHVybiBzaWRlLnRyYW5zZm9ybShtYXRyaXg0eDQpO1xuICAgIH0pO1xuICAgIGxldCByZXN1bHQgPSBmcm9tU2lkZXMobmV3c2lkZXMpO1xuICAgIGlmIChpc21pcnJvcikge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZsaXBwZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBmbGlwcGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IG5ld3NpZGVzID0gdGhpcy5zaWRlcy5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJldHVybiBzaWRlLmZsaXBwZWQoKTtcbiAgICB9KTtcbiAgICBuZXdzaWRlcy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGZyb21TaWRlcyhuZXdzaWRlcyk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBjZW50ZXI6IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgcmV0dXJuIGNlbnRlcih7IGF4ZXM6IGF4ZXMgfSwgW3RoaXNdKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGV4cGFuZGVkU2hlbGw6IGZ1bmN0aW9uIChyYWRpdXMsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gZXhwYW5kZWRTaGVsbE9mQ0FHKHRoaXMsIHJhZGl1cywgcmVzb2x1dGlvbik7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBleHBhbmQ6IGZ1bmN0aW9uIChyYWRpdXMsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gZXhwYW5kKHRoaXMsIHJhZGl1cywgcmVzb2x1dGlvbik7XG4gIH0sXG5cbiAgY29udHJhY3Q6IGZ1bmN0aW9uIChyYWRpdXMsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gY29udHJhY3QodGhpcywgcmFkaXVzLCByZXNvbHV0aW9uKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJlYSh0aGlzKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRCb3VuZHModGhpcyk7XG4gIH0sXG4gIC8vIEFMSUFTICFcbiAgaXNTZWxmSW50ZXJzZWN0aW5nOiBmdW5jdGlvbiAoZGVidWcpIHtcbiAgICByZXR1cm4gaXNTZWxmSW50ZXJzZWN0aW5nKHRoaXMsIGRlYnVnKTtcbiAgfSxcbiAgLy8gZXh0cnVzaW9uOiBhbGwgYWxpYXNlcyB0byBzaW1wbGUgZnVuY3Rpb25zXG4gIGV4dHJ1ZGVJbk9ydGhvbm9ybWFsQmFzaXM6IGZ1bmN0aW9uIChvcnRob25vcm1hbGJhc2lzLCBkZXB0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBleHRydWRlSW5PcnRob25vcm1hbEJhc2lzKHRoaXMsIG9ydGhvbm9ybWFsYmFzaXMsIGRlcHRoLCBvcHRpb25zKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGV4dHJ1ZGVJblBsYW5lOiBmdW5jdGlvbiAoYXhpczEsIGF4aXMyLCBkZXB0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBleHRydWRlSW5QbGFuZSh0aGlzLCBheGlzMSwgYXhpczIsIGRlcHRoLCBvcHRpb25zKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGV4dHJ1ZGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGV4dHJ1ZGUodGhpcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICByb3RhdGVFeHRydWRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIEZJWE1FIG9wdGlvbnMgc2hvdWxkIGJlIG9wdGlvbmFsXG4gICAgcmV0dXJuIHJvdGF0ZUV4dHJ1ZGUodGhpcywgb3B0aW9ucyk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBjaGVjazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc0NBR1ZhbGlkKHRoaXMpO1xuICB9LFxuXG4gIC8vIEFMSUFTICFcbiAgY2Fub25pY2FsaXplZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYW5vbmljYWxpemUodGhpcyk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICByZVRlc3NlbGF0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0ZXNzZWxhdGUodGhpcyk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBnZXRPdXRsaW5lUGF0aHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2Fnb3V0bGluZVBhdGhzKHRoaXMpO1xuICB9LFxuXG4gIC8vIEFMSUFTICFcbiAgb3ZlckN1dEluc2lkZUNvcm5lcnM6IGZ1bmN0aW9uIChjdXR0ZXJyYWRpdXMpIHtcbiAgICByZXR1cm4gb3ZlckN1dEluc2lkZUNvcm5lcnModGhpcywgY3V0dGVycmFkaXVzKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGhhc1BvaW50SW5zaWRlOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gaGFzUG9pbnRJbnNpZGUodGhpcywgcG9pbnQpO1xuICB9LFxuXG4gIC8vIEFsbCB0aGUgdG9YWFggZnVuY3Rpb25zXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc3VsdCA9ICdDQUcgKCcgKyB0aGlzLnNpZGVzLmxlbmd0aCArICcgc2lkZXMpOlxcbic7XG4gICAgdGhpcy5zaWRlcy5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJlc3VsdCArPSAnICAnICsgc2lkZS50b1N0cmluZygpICsgJ1xcbic7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBfdG9DU0dXYWxsOiBmdW5jdGlvbiAoejAsIHoxKSB7XG4gICAgbGV0IHBvbHlnb25zID0gdGhpcy5zaWRlcy5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJldHVybiBzaWRlLnRvUG9seWdvbjNEKHowLCB6MSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZyb21Qb2x5Z29ucyhwb2x5Z29ucyk7XG4gIH0sXG5cbiAgX3RvVmVjdG9yM0RQYWlyczogZnVuY3Rpb24gKG0pIHtcbiAgICAvLyB0cmFuc2Zvcm0gbVxuICAgIGxldCBwYWlycyA9IHRoaXMuc2lkZXMubWFwKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICBsZXQgcDAgPSBzaWRlLnZlcnRleDAucG9zO1xuICAgICAgbGV0IHAxID0gc2lkZS52ZXJ0ZXgxLnBvcztcbiAgICAgIHJldHVybiBbVmVjdG9yM0QuQ3JlYXRlKHAwLngsIHAwLnksIDApLCBWZWN0b3IzRC5DcmVhdGUocDEueCwgcDEueSwgMCldO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhaXJzID0gcGFpcnMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHJldHVybiBwYWlyLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiB2LnRyYW5zZm9ybShtKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9LFxuXG4gIC8qXG4gICAqIHRyYW5zZm9ybSBhIGNhZyBpbnRvIHRoZSBwb2x5Z29ucyBvZiBhIGNvcnJlc3BvbmRpbmcgM2QgcGxhbmUsIHBvc2l0aW9uZWQgcGVyIG9wdGlvbnNcbiAgICogQWNjZXB0cyBhIGNvbm5lY3RvciBmb3IgcGxhbmUgcG9zaXRpb25pbmcsIG9yIG9wdGlvbmFsbHlcbiAgICogc2luZ2xlIHRyYW5zbGF0aW9uLCBheGlzVmVjdG9yLCBub3JtYWxWZWN0b3IgYXJndW1lbnRzXG4gICAqICh0b0Nvbm5lY3RvciBoYXMgcHJlY2VkZW5jZSBvdmVyIHNpbmdsZSBhcmd1bWVudHMgaWYgcHJvdmlkZWQpXG4gICAqL1xuICBfdG9QbGFuZVBvbHlnb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgZmxpcHBlZDogZmFsc2UsXG4gICAgfTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIGxldCB7IGZsaXBwZWQgfSA9IG9wdGlvbnM7XG4gICAgLy8gcmVmZXJlbmNlIGNvbm5lY3RvciBmb3IgdHJhbnNmb3JtYXRpb25cbiAgICBsZXQgb3JpZ2luID0gWzAsIDAsIDBdO1xuICAgIGxldCBkZWZhdWx0QXhpcyA9IFswLCAwLCAxXTtcbiAgICBsZXQgZGVmYXVsdE5vcm1hbCA9IFswLCAxLCAwXTtcbiAgICBsZXQgdGhpc0Nvbm5lY3RvciA9IG5ldyBDb25uZWN0b3Iob3JpZ2luLCBkZWZhdWx0QXhpcywgZGVmYXVsdE5vcm1hbCk7XG4gICAgLy8gdHJhbnNsYXRlZCBjb25uZWN0b3IgcGVyIG9wdGlvbnNcbiAgICBsZXQgdHJhbnNsYXRpb24gPSBvcHRpb25zLnRyYW5zbGF0aW9uIHx8IG9yaWdpbjtcbiAgICBsZXQgYXhpc1ZlY3RvciA9IG9wdGlvbnMuYXhpc1ZlY3RvciB8fCBkZWZhdWx0QXhpcztcbiAgICBsZXQgbm9ybWFsVmVjdG9yID0gb3B0aW9ucy5ub3JtYWxWZWN0b3IgfHwgZGVmYXVsdE5vcm1hbDtcbiAgICAvLyB3aWxsIG92ZXJyaWRlIGFib3ZlIGlmIG9wdGlvbnMgaGFzIHRvQ29ubmVjdG9yXG4gICAgbGV0IHRvQ29ubmVjdG9yID1cbiAgICAgIG9wdGlvbnMudG9Db25uZWN0b3IgfHxcbiAgICAgIG5ldyBDb25uZWN0b3IodHJhbnNsYXRpb24sIGF4aXNWZWN0b3IsIG5vcm1hbFZlY3Rvcik7XG4gICAgLy8gcmVzdWx0aW5nIHRyYW5zZm9ybVxuICAgIGxldCBtID0gdGhpc0Nvbm5lY3Rvci5nZXRUcmFuc2Zvcm1hdGlvblRvKHRvQ29ubmVjdG9yLCBmYWxzZSwgMCk7XG4gICAgLy8gY3JlYXRlIHBsYW5lIGFzIGEgKHBhcnRpYWwgbm9uLWNsb3NlZCkgQ1NHIGluIFhZIHBsYW5lXG4gICAgbGV0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgYm91bmRzWzBdID0gYm91bmRzWzBdLm1pbnVzKG5ldyBWZWN0b3IyRCgxLCAxKSk7XG4gICAgYm91bmRzWzFdID0gYm91bmRzWzFdLnBsdXMobmV3IFZlY3RvcjJEKDEsIDEpKTtcbiAgICBsZXQgY3Nnc2hlbGwgPSB0aGlzLl90b0NTR1dhbGwoLTEsIDEpO1xuICAgIGxldCBjc2dwbGFuZSA9IGZyb21Qb2x5Z29ucyhbXG4gICAgICBuZXcgUG9seWdvbihbXG4gICAgICAgIG5ldyBWZXJ0ZXgzRChuZXcgVmVjdG9yM0QoYm91bmRzWzBdLngsIGJvdW5kc1swXS55LCAwKSksXG4gICAgICAgIG5ldyBWZXJ0ZXgzRChuZXcgVmVjdG9yM0QoYm91bmRzWzFdLngsIGJvdW5kc1swXS55LCAwKSksXG4gICAgICAgIG5ldyBWZXJ0ZXgzRChuZXcgVmVjdG9yM0QoYm91bmRzWzFdLngsIGJvdW5kc1sxXS55LCAwKSksXG4gICAgICAgIG5ldyBWZXJ0ZXgzRChuZXcgVmVjdG9yM0QoYm91bmRzWzBdLngsIGJvdW5kc1sxXS55LCAwKSksXG4gICAgICBdKSxcbiAgICBdKTtcbiAgICBpZiAoZmxpcHBlZCkge1xuICAgICAgY3NncGxhbmUgPSBjc2dwbGFuZS5pbnZlcnQoKTtcbiAgICB9XG4gICAgLy8gaW50ZXJzZWN0U3ViIC0+IHByZXZlbnQgcHJlbWF0dXJlIHJldGVzc2VsYXRlL2Nhbm9uaWNhbGl6ZVxuICAgIGNzZ3BsYW5lID0gY3NncGxhbmUuaW50ZXJzZWN0U3ViKGNzZ3NoZWxsKTtcbiAgICAvLyBvbmx5IGtlZXAgdGhlIHBvbHlnb25zIGluIHRoZSB6IHBsYW5lOlxuICAgIGxldCBwb2x5cyA9IGNzZ3BsYW5lLnBvbHlnb25zLmZpbHRlcihmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHBvbHlnb24ucGxhbmUubm9ybWFsLnopID4gMC45OTtcbiAgICB9KTtcbiAgICAvLyBmaW5hbGx5LCBwb3NpdGlvbiB0aGUgcGxhbmUgcGVyIHBhc3NlZCB0cmFuc2Zvcm1hdGlvbnNcbiAgICByZXR1cm4gcG9seXMubWFwKGZ1bmN0aW9uIChwb2x5KSB7XG4gICAgICByZXR1cm4gcG9seS50cmFuc2Zvcm0obSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLypcbiAgICogZ2l2ZW4gMiBjb25uZWN0b3JzLCB0aGlzIHJldHVybnMgYWxsIHBvbHlnb25zIG9mIGEgXCJ3YWxsXCIgYmV0d2VlbiAyXG4gICAqIGNvcGllcyBvZiB0aGlzIGNhZywgcG9zaXRpb25lZCBpbiAzZCBzcGFjZSBhcyBcImJvdHRvbVwiIGFuZFxuICAgKiBcInRvcFwiIHBsYW5lIHBlciBjb25uZWN0b3JzIHRvQ29ubmVjdG9yMSwgYW5kIHRvQ29ubmVjdG9yMiwgcmVzcGVjdGl2ZWx5XG4gICAqL1xuICBfdG9XYWxsUG9seWdvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gbm9ybWFscyBhcmUgZ29pbmcgdG8gYmUgY29ycmVjdCBhcyBsb25nIGFzIHRvQ29ubjIucG9pbnQgLSB0b0Nvbm4xLnBvaW50XG4gICAgLy8gcG9pbnRzIGludG8gY2FnIG5vcm1hbCBkaXJlY3Rpb24gKGNoZWNrIGluIGNhbGxlcilcbiAgICAvLyBhcmd1bWVudHM6IG9wdGlvbnMudG9Db25uZWN0b3IxLCBvcHRpb25zLnRvQ29ubmVjdG9yMiwgb3B0aW9ucy5jYWdcbiAgICAvLyAgICAgd2FsbHMgZ28gZnJvbSB0b0Nvbm5lY3RvcjEgdG8gdG9Db25uZWN0b3IyXG4gICAgLy8gICAgIG9wdGlvbmFsbHksIHRhcmdldCBjYWcgdG8gcG9pbnQgdG8gLSBjYWcgbmVlZHMgdG8gaGF2ZSBzYW1lIG51bWJlciBvZiBzaWRlcyBhcyB0aGlzIVxuICAgIGxldCBvcmlnaW4gPSBbMCwgMCwgMF07XG4gICAgbGV0IGRlZmF1bHRBeGlzID0gWzAsIDAsIDFdO1xuICAgIGxldCBkZWZhdWx0Tm9ybWFsID0gWzAsIDEsIDBdO1xuICAgIGxldCB0aGlzQ29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihvcmlnaW4sIGRlZmF1bHRBeGlzLCBkZWZhdWx0Tm9ybWFsKTtcbiAgICAvLyBhcmd1bWVudHM6XG4gICAgbGV0IHRvQ29ubmVjdG9yMSA9IG9wdGlvbnMudG9Db25uZWN0b3IxO1xuICAgIC8vIGxldCB0b0Nvbm5lY3RvcjIgPSBuZXcgQ29ubmVjdG9yKFswLCAwLCAtMzBdLCBkZWZhdWx0QXhpcywgZGVmYXVsdE5vcm1hbCk7XG4gICAgbGV0IHRvQ29ubmVjdG9yMiA9IG9wdGlvbnMudG9Db25uZWN0b3IyO1xuICAgIGlmIChcbiAgICAgICEodG9Db25uZWN0b3IxIGluc3RhbmNlb2YgQ29ubmVjdG9yICYmIHRvQ29ubmVjdG9yMiBpbnN0YW5jZW9mIENvbm5lY3RvcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2NvdWxkIG5vdCBwYXJzZSBDb25uZWN0b3IgYXJndW1lbnRzIHRvQ29ubmVjdG9yMSBvciB0b0Nvbm5lY3RvcjInXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jYWcpIHtcbiAgICAgIGlmIChvcHRpb25zLmNhZy5zaWRlcy5sZW5ndGggIT09IHRoaXMuc2lkZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGNhZyBuZWVkcyBzYW1lIHNpZGVzIGNvdW50IGFzIHN0YXJ0IGNhZycpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB0YXJnZXQgY2FnIGlzIHNhbWUgYXMgdGhpcyB1bmxlc3Mgc3BlY2lmaWVkXG4gICAgbGV0IHRvQ2FnID0gb3B0aW9ucy5jYWcgfHwgdGhpcztcbiAgICBsZXQgbTEgPSB0aGlzQ29ubmVjdG9yLmdldFRyYW5zZm9ybWF0aW9uVG8odG9Db25uZWN0b3IxLCBmYWxzZSwgMCk7XG4gICAgbGV0IG0yID0gdGhpc0Nvbm5lY3Rvci5nZXRUcmFuc2Zvcm1hdGlvblRvKHRvQ29ubmVjdG9yMiwgZmFsc2UsIDApO1xuICAgIGxldCB2cHMxID0gdGhpcy5fdG9WZWN0b3IzRFBhaXJzKG0xKTtcbiAgICBsZXQgdnBzMiA9IHRvQ2FnLl90b1ZlY3RvcjNEUGFpcnMobTIpO1xuXG4gICAgbGV0IHBvbHlnb25zID0gW107XG4gICAgdnBzMS5mb3JFYWNoKGZ1bmN0aW9uICh2cDEsIGkpIHtcbiAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgIG5ldyBQb2x5Z29uKFtcbiAgICAgICAgICBuZXcgVmVydGV4M0QodnBzMltpXVsxXSksXG4gICAgICAgICAgbmV3IFZlcnRleDNEKHZwczJbaV1bMF0pLFxuICAgICAgICAgIG5ldyBWZXJ0ZXgzRCh2cDFbMF0pLFxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICAgIHBvbHlnb25zLnB1c2goXG4gICAgICAgIG5ldyBQb2x5Z29uKFtcbiAgICAgICAgICBuZXcgVmVydGV4M0QodnBzMltpXVsxXSksXG4gICAgICAgICAgbmV3IFZlcnRleDNEKHZwMVswXSksXG4gICAgICAgICAgbmV3IFZlcnRleDNEKHZwMVsxXSksXG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBwb2x5Z29ucztcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCB0byBhIGxpc3Qgb2YgcG9pbnRzLlxuICAgKiBAcmV0dXJuIHtwb2ludHNbXX0gbGlzdCBvZiBwb2ludHMgaW4gMkQgc3BhY2VcbiAgICovXG4gIHRvUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHBvaW50cyA9IHRoaXMuc2lkZXMubWFwKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICBsZXQgdjAgPSBzaWRlLnZlcnRleDA7XG4gICAgICAvLyBsZXQgdjEgPSBzaWRlLnZlcnRleDFcbiAgICAgIHJldHVybiB2MC5wb3M7XG4gICAgfSk7XG4gICAgLy8gZHVlIHRvIHRoZSBsb2dpYyBvZiBmcm9tUG9pbnRzKClcbiAgICAvLyBtb3ZlIHRoZSBmaXJzdCBwb2ludCB0byB0aGUgbGFzdFxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnRzLnNoaWZ0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuXG4gIC8qKiBDb252ZXJ0IHRvIGNvbXBhY3QgYmluYXJ5IGZvcm0uXG4gICAqIFNlZSBmcm9tQ29tcGFjdEJpbmFyeS5cbiAgICogQHJldHVybiB7Q29tcGFjdEJpbmFyeX1cbiAgICovXG4gIHRvQ29tcGFjdEJpbmFyeTogZnVuY3Rpb24gKCkge1xuICAgIGxldCBjYWcgPSB0aGlzLmNhbm9uaWNhbGl6ZWQoKTtcbiAgICBsZXQgbnVtc2lkZXMgPSBjYWcuc2lkZXMubGVuZ3RoO1xuICAgIGxldCB2ZXJ0ZXhtYXAgPSB7fTtcbiAgICBsZXQgdmVydGljZXMgPSBbXTtcbiAgICBsZXQgbnVtdmVydGljZXMgPSAwO1xuICAgIGxldCBzaWRlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheSgyICogbnVtc2lkZXMpO1xuICAgIGxldCBzaWRldmVydGV4aW5kaWNlc2luZGV4ID0gMDtcbiAgICBjYWcuc2lkZXMubWFwKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICBbc2lkZS52ZXJ0ZXgwLCBzaWRlLnZlcnRleDFdLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICBsZXQgdmVydGV4dGFnID0gdi5nZXRUYWcoKTtcbiAgICAgICAgbGV0IHZlcnRleGluZGV4O1xuICAgICAgICBpZiAoISh2ZXJ0ZXh0YWcgaW4gdmVydGV4bWFwKSkge1xuICAgICAgICAgIHZlcnRleGluZGV4ID0gbnVtdmVydGljZXMrKztcbiAgICAgICAgICB2ZXJ0ZXhtYXBbdmVydGV4dGFnXSA9IHZlcnRleGluZGV4O1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2godik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVydGV4aW5kZXggPSB2ZXJ0ZXhtYXBbdmVydGV4dGFnXTtcbiAgICAgICAgfVxuICAgICAgICBzaWRlVmVydGV4SW5kaWNlc1tzaWRldmVydGV4aW5kaWNlc2luZGV4KytdID0gdmVydGV4aW5kZXg7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBsZXQgdmVydGV4RGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkobnVtdmVydGljZXMgKiAyKTtcbiAgICBsZXQgdmVydGljZXNBcnJheUluZGV4ID0gMDtcbiAgICB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIGxldCBwb3MgPSB2LnBvcztcbiAgICAgIHZlcnRleERhdGFbdmVydGljZXNBcnJheUluZGV4KytdID0gcG9zLl94O1xuICAgICAgdmVydGV4RGF0YVt2ZXJ0aWNlc0FycmF5SW5kZXgrK10gPSBwb3MuX3k7XG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGNsYXNzOiAnQ0FHJyxcbiAgICAgIHNpZGVWZXJ0ZXhJbmRpY2VzOiBzaWRlVmVydGV4SW5kaWNlcyxcbiAgICAgIHZlcnRleERhdGE6IHZlcnRleERhdGEsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDQUc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/CAG.js\n");

/***/ }),

/***/ "./src/core/CAGFactories.js":
/*!**********************************!*\
  !*** ./src/core/CAGFactories.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Side = __webpack_require__(/*! ./math/Side */ \"./src/core/math/Side.js\");\nconst Vector2D = __webpack_require__(/*! ./math/Vector2 */ \"./src/core/math/Vector2.js\");\nconst Vertex2 = __webpack_require__(/*! ./math/Vertex2 */ \"./src/core/math/Vertex2.js\");\nconst { areaEPS } = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\nconst { isSelfIntersecting, contains } = __webpack_require__(/*! ./utils/cagValidation */ \"./src/core/utils/cagValidation.js\");\nconst { union, difference } = __webpack_require__(/*! ../api/ops-booleans */ \"./src/api/ops-booleans.js\");\n\n/** Construct a CAG from a list of `Side` instances.\n * @param {Side[]} sides - list of sides\n * @returns {CAG} new CAG object\n */\nconst fromSides = function (sides) {\n  const CAG = __webpack_require__(/*! ./CAG */ \"./src/core/CAG.js\"); // circular dependency CAG => fromSides => CAG\n  let cag = new CAG();\n  cag.sides = sides;\n  return cag;\n};\n\n// Converts a CSG to a  The CSG must consist of polygons with only z coordinates +1 and -1\n// as constructed by _toCSGWall(-1, 1). This is so we can use the 3D union(), intersect() etc\nconst fromFakeCSG = function (csg) {\n  let sides = csg.polygons\n    .map(function (p) {\n      return Side._fromFakePolygon(p);\n    })\n    .filter(function (s) {\n      return s !== null;\n    });\n  return fromSides(sides);\n};\n\n/** Construct a CAG from a list of points (a polygon) or an nested array of points.\n * The rotation direction of the points is not relevant.\n * The points can define a convex or a concave polygon.\n * The polygon must not self intersect.\n * Hole detection follows the even/odd rule,\n * which means that the order of the paths is not important.\n * @param {points[]|Array.<points[]>} points - (nested) list of points in 2D space\n * @returns {CAG} new CAG object\n */\nconst fromPoints = function (points) {\n  if (!points) {\n    throw new Error('points parameter must be defined');\n  }\n  if (!Array.isArray(points)) {\n    throw new Error('points parameter must be an array');\n  }\n  if (points[0].x !== undefined || typeof points[0][0] === 'number') {\n    return fromPointsArray(points);\n  }\n  if (typeof points[0][0] === 'object') {\n    return fromNestedPointsArray(points);\n  }\n  throw new Error('Unsupported points list format');\n};\n\n// Do not export the two following function (code splitting for fromPoints())\nconst fromPointsArray = function (points) {\n  if (points.length < 3) {\n    throw new Error('CAG shape needs at least 3 points');\n  }\n  let sides = [];\n  let prevvertex = new Vertex2(new Vector2D(points[points.length - 1]));\n  points.map(function (point) {\n    let vertex = new Vertex2(new Vector2D(point));\n    sides.push(new Side(prevvertex, vertex));\n    prevvertex = vertex;\n  });\n  let result = fromSides(sides);\n  if (isSelfIntersecting(result)) {\n    throw new Error('Polygon is self intersecting!');\n  }\n  let area = result.area();\n  if (Math.abs(area) < areaEPS) {\n    throw new Error('Degenerate polygon!');\n  }\n  if (area < 0) {\n    result = result.flipped();\n  }\n  return result.canonicalized();\n};\n\nconst fromNestedPointsArray = function (points) {\n  if (points.length === 1) {\n    return fromPoints(points[0]);\n  }\n  // First pass: create a collection of CAG paths\n  let paths = [];\n  points.forEach((path) => {\n    paths.push(fromPointsArray(path));\n  });\n  // Second pass: make a tree of paths\n  let tree = {};\n  // for each polygon extract parents and childs polygons\n  paths.forEach((p1, i) => {\n    // check for intersection\n    paths.forEach((p2, y) => {\n      if (p1 !== p2) {\n        // create default node\n        tree[i] || (tree[i] = { parents: [], isHole: false });\n        tree[y] || (tree[y] = { parents: [], isHole: false });\n        // check if polygon2 stay in poylgon1\n        if (contains(p2, p1)) {\n          // push parent and child; odd parents number ==> hole\n          tree[i].parents.push(y);\n          tree[i].isHole = !!(tree[i].parents.length % 2);\n          tree[y].isHole = !!(tree[y].parents.length % 2);\n        }\n      }\n    });\n  });\n  // Third pass: subtract holes\n  let path = null;\n  for (key in tree) {\n    path = tree[key];\n    if (path.isHole) {\n      delete tree[key]; // remove holes for final pass\n      path.parents.forEach((parentKey) => {\n        paths[parentKey] = difference(paths[parentKey], paths[key]);\n      });\n    }\n  }\n  // Fourth and last pass: create final CAG object\n  let cag = fromSides([]);\n  for (key in tree) {\n    cag = union(cag, paths[key]);\n  }\n  return cag;\n};\n\n/** Reconstruct a CAG from an object with identical property names.\n * @param {Object} obj - anonymous object, typically from JSON\n * @returns {CAG} new CAG object\n */\nconst fromObject = function (obj) {\n  let sides = obj.sides.map(function (s) {\n    return Side.fromObject(s);\n  });\n  let cag = fromSides(sides);\n  cag.isCanonicalized = obj.isCanonicalized;\n  return cag;\n};\n\n/** Construct a CAG from a list of points (a polygon).\n * Like fromPoints() but does not check if the result is a valid polygon.\n * The points MUST rotate counter clockwise.\n * The points can define a convex or a concave polygon.\n * The polygon must not self intersect.\n * @param {points[]} points - list of points in 2D space\n * @returns {CAG} new CAG object\n */\nconst fromPointsNoCheck = function (points) {\n  let sides = [];\n  let prevpoint = new Vector2D(points[points.length - 1]);\n  let prevvertex = new Vertex2(prevpoint);\n  points.map(function (p) {\n    let point = new Vector2D(p);\n    let vertex = new Vertex2(point);\n    let side = new Side(prevvertex, vertex);\n    sides.push(side);\n    prevvertex = vertex;\n  });\n  return fromSides(sides);\n};\n\n/** Construct a CAG from a 2d-path (a closed sequence of points).\n * Like fromPoints() but does not check if the result is a valid polygon.\n * @param {path} Path2 - a Path2 path\n * @returns {CAG} new CAG object\n */\nconst fromPath2 = function (path) {\n  if (!path.isClosed()) throw new Error('The path should be closed!');\n  return fromPoints(path.getPoints());\n};\n\n/** Reconstruct a CAG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary()\n * @returns {CAG} new CAG object\n */\nconst fromCompactBinary = function (bin) {\n  if (bin['class'] !== 'CAG') throw new Error('Not a CAG');\n  let vertices = [];\n  let vertexData = bin.vertexData;\n  let numvertices = vertexData.length / 2;\n  let arrayindex = 0;\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    let x = vertexData[arrayindex++];\n    let y = vertexData[arrayindex++];\n    let pos = new Vector2D(x, y);\n    let vertex = new Vertex2(pos);\n    vertices.push(vertex);\n  }\n  let sides = [];\n  let numsides = bin.sideVertexIndices.length / 2;\n  arrayindex = 0;\n  for (let sideindex = 0; sideindex < numsides; sideindex++) {\n    let vertexindex0 = bin.sideVertexIndices[arrayindex++];\n    let vertexindex1 = bin.sideVertexIndices[arrayindex++];\n    let side = new Side(vertices[vertexindex0], vertices[vertexindex1]);\n    sides.push(side);\n  }\n  let cag = fromSides(sides);\n  cag.isCanonicalized = true;\n  return cag;\n};\n\nmodule.exports = {\n  fromSides,\n  fromObject,\n  fromPoints,\n  fromPointsNoCheck,\n  fromPath2,\n  fromFakeCSG,\n  fromCompactBinary,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9DQUdGYWN0b3JpZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9DQUdGYWN0b3JpZXMuanM/ZTRjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTaWRlID0gcmVxdWlyZSgnLi9tYXRoL1NpZGUnKTtcbmNvbnN0IFZlY3RvcjJEID0gcmVxdWlyZSgnLi9tYXRoL1ZlY3RvcjInKTtcbmNvbnN0IFZlcnRleDIgPSByZXF1aXJlKCcuL21hdGgvVmVydGV4MicpO1xuY29uc3QgeyBhcmVhRVBTIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc1NlbGZJbnRlcnNlY3RpbmcsIGNvbnRhaW5zIH0gPSByZXF1aXJlKCcuL3V0aWxzL2NhZ1ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgdW5pb24sIGRpZmZlcmVuY2UgfSA9IHJlcXVpcmUoJy4uL2FwaS9vcHMtYm9vbGVhbnMnKTtcblxuLyoqIENvbnN0cnVjdCBhIENBRyBmcm9tIGEgbGlzdCBvZiBgU2lkZWAgaW5zdGFuY2VzLlxuICogQHBhcmFtIHtTaWRlW119IHNpZGVzIC0gbGlzdCBvZiBzaWRlc1xuICogQHJldHVybnMge0NBR30gbmV3IENBRyBvYmplY3RcbiAqL1xuY29uc3QgZnJvbVNpZGVzID0gZnVuY3Rpb24gKHNpZGVzKSB7XG4gIGNvbnN0IENBRyA9IHJlcXVpcmUoJy4vQ0FHJyk7IC8vIGNpcmN1bGFyIGRlcGVuZGVuY3kgQ0FHID0+IGZyb21TaWRlcyA9PiBDQUdcbiAgbGV0IGNhZyA9IG5ldyBDQUcoKTtcbiAgY2FnLnNpZGVzID0gc2lkZXM7XG4gIHJldHVybiBjYWc7XG59O1xuXG4vLyBDb252ZXJ0cyBhIENTRyB0byBhICBUaGUgQ1NHIG11c3QgY29uc2lzdCBvZiBwb2x5Z29ucyB3aXRoIG9ubHkgeiBjb29yZGluYXRlcyArMSBhbmQgLTFcbi8vIGFzIGNvbnN0cnVjdGVkIGJ5IF90b0NTR1dhbGwoLTEsIDEpLiBUaGlzIGlzIHNvIHdlIGNhbiB1c2UgdGhlIDNEIHVuaW9uKCksIGludGVyc2VjdCgpIGV0Y1xuY29uc3QgZnJvbUZha2VDU0cgPSBmdW5jdGlvbiAoY3NnKSB7XG4gIGxldCBzaWRlcyA9IGNzZy5wb2x5Z29uc1xuICAgIC5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBTaWRlLl9mcm9tRmFrZVBvbHlnb24ocCk7XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcyAhPT0gbnVsbDtcbiAgICB9KTtcbiAgcmV0dXJuIGZyb21TaWRlcyhzaWRlcyk7XG59O1xuXG4vKiogQ29uc3RydWN0IGEgQ0FHIGZyb20gYSBsaXN0IG9mIHBvaW50cyAoYSBwb2x5Z29uKSBvciBhbiBuZXN0ZWQgYXJyYXkgb2YgcG9pbnRzLlxuICogVGhlIHJvdGF0aW9uIGRpcmVjdGlvbiBvZiB0aGUgcG9pbnRzIGlzIG5vdCByZWxldmFudC5cbiAqIFRoZSBwb2ludHMgY2FuIGRlZmluZSBhIGNvbnZleCBvciBhIGNvbmNhdmUgcG9seWdvbi5cbiAqIFRoZSBwb2x5Z29uIG11c3Qgbm90IHNlbGYgaW50ZXJzZWN0LlxuICogSG9sZSBkZXRlY3Rpb24gZm9sbG93cyB0aGUgZXZlbi9vZGQgcnVsZSxcbiAqIHdoaWNoIG1lYW5zIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBwYXRocyBpcyBub3QgaW1wb3J0YW50LlxuICogQHBhcmFtIHtwb2ludHNbXXxBcnJheS48cG9pbnRzW10+fSBwb2ludHMgLSAobmVzdGVkKSBsaXN0IG9mIHBvaW50cyBpbiAyRCBzcGFjZVxuICogQHJldHVybnMge0NBR30gbmV3IENBRyBvYmplY3RcbiAqL1xuY29uc3QgZnJvbVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgaWYgKCFwb2ludHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50cyBwYXJhbWV0ZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50cyBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG4gIGlmIChwb2ludHNbMF0ueCAhPT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBwb2ludHNbMF1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZyb21Qb2ludHNBcnJheShwb2ludHMpO1xuICB9XG4gIGlmICh0eXBlb2YgcG9pbnRzWzBdWzBdID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmcm9tTmVzdGVkUG9pbnRzQXJyYXkocG9pbnRzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBvaW50cyBsaXN0IGZvcm1hdCcpO1xufTtcblxuLy8gRG8gbm90IGV4cG9ydCB0aGUgdHdvIGZvbGxvd2luZyBmdW5jdGlvbiAoY29kZSBzcGxpdHRpbmcgZm9yIGZyb21Qb2ludHMoKSlcbmNvbnN0IGZyb21Qb2ludHNBcnJheSA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDQUcgc2hhcGUgbmVlZHMgYXQgbGVhc3QgMyBwb2ludHMnKTtcbiAgfVxuICBsZXQgc2lkZXMgPSBbXTtcbiAgbGV0IHByZXZ2ZXJ0ZXggPSBuZXcgVmVydGV4MihuZXcgVmVjdG9yMkQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSkpO1xuICBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgIGxldCB2ZXJ0ZXggPSBuZXcgVmVydGV4MihuZXcgVmVjdG9yMkQocG9pbnQpKTtcbiAgICBzaWRlcy5wdXNoKG5ldyBTaWRlKHByZXZ2ZXJ0ZXgsIHZlcnRleCkpO1xuICAgIHByZXZ2ZXJ0ZXggPSB2ZXJ0ZXg7XG4gIH0pO1xuICBsZXQgcmVzdWx0ID0gZnJvbVNpZGVzKHNpZGVzKTtcbiAgaWYgKGlzU2VsZkludGVyc2VjdGluZyhyZXN1bHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb2x5Z29uIGlzIHNlbGYgaW50ZXJzZWN0aW5nIScpO1xuICB9XG4gIGxldCBhcmVhID0gcmVzdWx0LmFyZWEoKTtcbiAgaWYgKE1hdGguYWJzKGFyZWEpIDwgYXJlYUVQUykge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVnZW5lcmF0ZSBwb2x5Z29uIScpO1xuICB9XG4gIGlmIChhcmVhIDwgMCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5mbGlwcGVkKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5jYW5vbmljYWxpemVkKCk7XG59O1xuXG5jb25zdCBmcm9tTmVzdGVkUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZyb21Qb2ludHMocG9pbnRzWzBdKTtcbiAgfVxuICAvLyBGaXJzdCBwYXNzOiBjcmVhdGUgYSBjb2xsZWN0aW9uIG9mIENBRyBwYXRoc1xuICBsZXQgcGF0aHMgPSBbXTtcbiAgcG9pbnRzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICBwYXRocy5wdXNoKGZyb21Qb2ludHNBcnJheShwYXRoKSk7XG4gIH0pO1xuICAvLyBTZWNvbmQgcGFzczogbWFrZSBhIHRyZWUgb2YgcGF0aHNcbiAgbGV0IHRyZWUgPSB7fTtcbiAgLy8gZm9yIGVhY2ggcG9seWdvbiBleHRyYWN0IHBhcmVudHMgYW5kIGNoaWxkcyBwb2x5Z29uc1xuICBwYXRocy5mb3JFYWNoKChwMSwgaSkgPT4ge1xuICAgIC8vIGNoZWNrIGZvciBpbnRlcnNlY3Rpb25cbiAgICBwYXRocy5mb3JFYWNoKChwMiwgeSkgPT4ge1xuICAgICAgaWYgKHAxICE9PSBwMikge1xuICAgICAgICAvLyBjcmVhdGUgZGVmYXVsdCBub2RlXG4gICAgICAgIHRyZWVbaV0gfHwgKHRyZWVbaV0gPSB7IHBhcmVudHM6IFtdLCBpc0hvbGU6IGZhbHNlIH0pO1xuICAgICAgICB0cmVlW3ldIHx8ICh0cmVlW3ldID0geyBwYXJlbnRzOiBbXSwgaXNIb2xlOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgcG9seWdvbjIgc3RheSBpbiBwb3lsZ29uMVxuICAgICAgICBpZiAoY29udGFpbnMocDIsIHAxKSkge1xuICAgICAgICAgIC8vIHB1c2ggcGFyZW50IGFuZCBjaGlsZDsgb2RkIHBhcmVudHMgbnVtYmVyID09PiBob2xlXG4gICAgICAgICAgdHJlZVtpXS5wYXJlbnRzLnB1c2goeSk7XG4gICAgICAgICAgdHJlZVtpXS5pc0hvbGUgPSAhISh0cmVlW2ldLnBhcmVudHMubGVuZ3RoICUgMik7XG4gICAgICAgICAgdHJlZVt5XS5pc0hvbGUgPSAhISh0cmVlW3ldLnBhcmVudHMubGVuZ3RoICUgMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIC8vIFRoaXJkIHBhc3M6IHN1YnRyYWN0IGhvbGVzXG4gIGxldCBwYXRoID0gbnVsbDtcbiAgZm9yIChrZXkgaW4gdHJlZSkge1xuICAgIHBhdGggPSB0cmVlW2tleV07XG4gICAgaWYgKHBhdGguaXNIb2xlKSB7XG4gICAgICBkZWxldGUgdHJlZVtrZXldOyAvLyByZW1vdmUgaG9sZXMgZm9yIGZpbmFsIHBhc3NcbiAgICAgIHBhdGgucGFyZW50cy5mb3JFYWNoKChwYXJlbnRLZXkpID0+IHtcbiAgICAgICAgcGF0aHNbcGFyZW50S2V5XSA9IGRpZmZlcmVuY2UocGF0aHNbcGFyZW50S2V5XSwgcGF0aHNba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gRm91cnRoIGFuZCBsYXN0IHBhc3M6IGNyZWF0ZSBmaW5hbCBDQUcgb2JqZWN0XG4gIGxldCBjYWcgPSBmcm9tU2lkZXMoW10pO1xuICBmb3IgKGtleSBpbiB0cmVlKSB7XG4gICAgY2FnID0gdW5pb24oY2FnLCBwYXRoc1trZXldKTtcbiAgfVxuICByZXR1cm4gY2FnO1xufTtcblxuLyoqIFJlY29uc3RydWN0IGEgQ0FHIGZyb20gYW4gb2JqZWN0IHdpdGggaWRlbnRpY2FsIHByb3BlcnR5IG5hbWVzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIGFub255bW91cyBvYmplY3QsIHR5cGljYWxseSBmcm9tIEpTT05cbiAqIEByZXR1cm5zIHtDQUd9IG5ldyBDQUcgb2JqZWN0XG4gKi9cbmNvbnN0IGZyb21PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGxldCBzaWRlcyA9IG9iai5zaWRlcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gU2lkZS5mcm9tT2JqZWN0KHMpO1xuICB9KTtcbiAgbGV0IGNhZyA9IGZyb21TaWRlcyhzaWRlcyk7XG4gIGNhZy5pc0Nhbm9uaWNhbGl6ZWQgPSBvYmouaXNDYW5vbmljYWxpemVkO1xuICByZXR1cm4gY2FnO1xufTtcblxuLyoqIENvbnN0cnVjdCBhIENBRyBmcm9tIGEgbGlzdCBvZiBwb2ludHMgKGEgcG9seWdvbikuXG4gKiBMaWtlIGZyb21Qb2ludHMoKSBidXQgZG9lcyBub3QgY2hlY2sgaWYgdGhlIHJlc3VsdCBpcyBhIHZhbGlkIHBvbHlnb24uXG4gKiBUaGUgcG9pbnRzIE1VU1Qgcm90YXRlIGNvdW50ZXIgY2xvY2t3aXNlLlxuICogVGhlIHBvaW50cyBjYW4gZGVmaW5lIGEgY29udmV4IG9yIGEgY29uY2F2ZSBwb2x5Z29uLlxuICogVGhlIHBvbHlnb24gbXVzdCBub3Qgc2VsZiBpbnRlcnNlY3QuXG4gKiBAcGFyYW0ge3BvaW50c1tdfSBwb2ludHMgLSBsaXN0IG9mIHBvaW50cyBpbiAyRCBzcGFjZVxuICogQHJldHVybnMge0NBR30gbmV3IENBRyBvYmplY3RcbiAqL1xuY29uc3QgZnJvbVBvaW50c05vQ2hlY2sgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gIGxldCBzaWRlcyA9IFtdO1xuICBsZXQgcHJldnBvaW50ID0gbmV3IFZlY3RvcjJEKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICBsZXQgcHJldnZlcnRleCA9IG5ldyBWZXJ0ZXgyKHByZXZwb2ludCk7XG4gIHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICBsZXQgcG9pbnQgPSBuZXcgVmVjdG9yMkQocCk7XG4gICAgbGV0IHZlcnRleCA9IG5ldyBWZXJ0ZXgyKHBvaW50KTtcbiAgICBsZXQgc2lkZSA9IG5ldyBTaWRlKHByZXZ2ZXJ0ZXgsIHZlcnRleCk7XG4gICAgc2lkZXMucHVzaChzaWRlKTtcbiAgICBwcmV2dmVydGV4ID0gdmVydGV4O1xuICB9KTtcbiAgcmV0dXJuIGZyb21TaWRlcyhzaWRlcyk7XG59O1xuXG4vKiogQ29uc3RydWN0IGEgQ0FHIGZyb20gYSAyZC1wYXRoIChhIGNsb3NlZCBzZXF1ZW5jZSBvZiBwb2ludHMpLlxuICogTGlrZSBmcm9tUG9pbnRzKCkgYnV0IGRvZXMgbm90IGNoZWNrIGlmIHRoZSByZXN1bHQgaXMgYSB2YWxpZCBwb2x5Z29uLlxuICogQHBhcmFtIHtwYXRofSBQYXRoMiAtIGEgUGF0aDIgcGF0aFxuICogQHJldHVybnMge0NBR30gbmV3IENBRyBvYmplY3RcbiAqL1xuY29uc3QgZnJvbVBhdGgyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKCFwYXRoLmlzQ2xvc2VkKCkpIHRocm93IG5ldyBFcnJvcignVGhlIHBhdGggc2hvdWxkIGJlIGNsb3NlZCEnKTtcbiAgcmV0dXJuIGZyb21Qb2ludHMocGF0aC5nZXRQb2ludHMoKSk7XG59O1xuXG4vKiogUmVjb25zdHJ1Y3QgYSBDQUcgZnJvbSB0aGUgb3V0cHV0IG9mIHRvQ29tcGFjdEJpbmFyeSgpLlxuICogQHBhcmFtIHtDb21wYWN0QmluYXJ5fSBiaW4gLSBzZWUgdG9Db21wYWN0QmluYXJ5KClcbiAqIEByZXR1cm5zIHtDQUd9IG5ldyBDQUcgb2JqZWN0XG4gKi9cbmNvbnN0IGZyb21Db21wYWN0QmluYXJ5ID0gZnVuY3Rpb24gKGJpbikge1xuICBpZiAoYmluWydjbGFzcyddICE9PSAnQ0FHJykgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBDQUcnKTtcbiAgbGV0IHZlcnRpY2VzID0gW107XG4gIGxldCB2ZXJ0ZXhEYXRhID0gYmluLnZlcnRleERhdGE7XG4gIGxldCBudW12ZXJ0aWNlcyA9IHZlcnRleERhdGEubGVuZ3RoIC8gMjtcbiAgbGV0IGFycmF5aW5kZXggPSAwO1xuICBmb3IgKGxldCB2ZXJ0ZXhpbmRleCA9IDA7IHZlcnRleGluZGV4IDwgbnVtdmVydGljZXM7IHZlcnRleGluZGV4KyspIHtcbiAgICBsZXQgeCA9IHZlcnRleERhdGFbYXJyYXlpbmRleCsrXTtcbiAgICBsZXQgeSA9IHZlcnRleERhdGFbYXJyYXlpbmRleCsrXTtcbiAgICBsZXQgcG9zID0gbmV3IFZlY3RvcjJEKHgsIHkpO1xuICAgIGxldCB2ZXJ0ZXggPSBuZXcgVmVydGV4Mihwb3MpO1xuICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgfVxuICBsZXQgc2lkZXMgPSBbXTtcbiAgbGV0IG51bXNpZGVzID0gYmluLnNpZGVWZXJ0ZXhJbmRpY2VzLmxlbmd0aCAvIDI7XG4gIGFycmF5aW5kZXggPSAwO1xuICBmb3IgKGxldCBzaWRlaW5kZXggPSAwOyBzaWRlaW5kZXggPCBudW1zaWRlczsgc2lkZWluZGV4KyspIHtcbiAgICBsZXQgdmVydGV4aW5kZXgwID0gYmluLnNpZGVWZXJ0ZXhJbmRpY2VzW2FycmF5aW5kZXgrK107XG4gICAgbGV0IHZlcnRleGluZGV4MSA9IGJpbi5zaWRlVmVydGV4SW5kaWNlc1thcnJheWluZGV4KytdO1xuICAgIGxldCBzaWRlID0gbmV3IFNpZGUodmVydGljZXNbdmVydGV4aW5kZXgwXSwgdmVydGljZXNbdmVydGV4aW5kZXgxXSk7XG4gICAgc2lkZXMucHVzaChzaWRlKTtcbiAgfVxuICBsZXQgY2FnID0gZnJvbVNpZGVzKHNpZGVzKTtcbiAgY2FnLmlzQ2Fub25pY2FsaXplZCA9IHRydWU7XG4gIHJldHVybiBjYWc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnJvbVNpZGVzLFxuICBmcm9tT2JqZWN0LFxuICBmcm9tUG9pbnRzLFxuICBmcm9tUG9pbnRzTm9DaGVjayxcbiAgZnJvbVBhdGgyLFxuICBmcm9tRmFrZUNTRyxcbiAgZnJvbUNvbXBhY3RCaW5hcnksXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/CAGFactories.js\n");

/***/ }),

/***/ "./src/core/CSG.js":
/*!*************************!*\
  !*** ./src/core/CSG.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Tree = __webpack_require__(/*! ./trees */ \"./src/core/trees.js\");\nconst Polygon = __webpack_require__(/*! ./math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst Plane = __webpack_require__(/*! ./math/Plane */ \"./src/core/math/Plane.js\");\nconst OrthoNormalBasis = __webpack_require__(/*! ./math/OrthoNormalBasis */ \"./src/core/math/OrthoNormalBasis.js\");\n\nconst CAG = __webpack_require__(/*! ./CAG */ \"./src/core/CAG.js\"); // FIXME: for some weird reason if CAG is imported AFTER frompolygons, a lot of things break???\n\nconst Properties = __webpack_require__(/*! ./Properties */ \"./src/core/Properties.js\");\nconst { fromPolygons } = __webpack_require__(/*! ./CSGFactories */ \"./src/core/CSGFactories.js\"); // FIXME: circular dependency !\n\nconst fixTJunctions = __webpack_require__(/*! ./utils/fixTJunctions */ \"./src/core/utils/fixTJunctions.js\");\nconst canonicalize = __webpack_require__(/*! ./utils/canonicalize */ \"./src/core/utils/canonicalize.js\");\nconst retesselate = __webpack_require__(/*! ./utils/retesellate */ \"./src/core/utils/retesellate.js\");\nconst { bounds } = __webpack_require__(/*! ./utils/csgMeasurements */ \"./src/core/utils/csgMeasurements.js\");\nconst { projectToOrthoNormalBasis } = __webpack_require__(/*! ./utils/csgProjections */ \"./src/core/utils/csgProjections.js\");\n\nconst {\n  lieFlat,\n  getTransformationToFlatLying,\n  getTransformationAndInverseTransformationToFlatLying,\n} = __webpack_require__(/*! ../api/ops-cnc */ \"./src/api/ops-cnc.js\");\nconst { sectionCut, cutByPlane } = __webpack_require__(/*! ../api/ops-cuts */ \"./src/api/ops-cuts.js\");\nconst center = __webpack_require__(/*! ../api/center */ \"./src/api/center.js\");\nconst {\n  expand,\n  contract,\n  expandedShellOfCCSG,\n} = __webpack_require__(/*! ../api/ops-expandContract */ \"./src/api/ops-expandContract.js\");\n\n/** Class CSG\n * Holds a binary space partition tree representing a 3D solid. Two solids can\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\n * @constructor\n */\nlet CSG = function () {\n  this.polygons = [];\n  this.properties = new Properties();\n  this.isCanonicalized = true;\n  this.isRetesselated = true;\n};\n\nCSG.prototype = {\n  /**\n   * Return a new CSG solid representing the space in either this solid or\n   * in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.union(B)\n   * @example\n   * +-------+            +-------+\n   * |       |            |       |\n   * |   A   |            |       |\n   * |    +--+----+   =   |       +----+\n   * +----+--+    |       +----+       |\n   *      |   B   |            |       |\n   *      |       |            |       |\n   *      +-------+            +-------+\n   */\n  union: function (csg) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg.slice(0);\n      csgs.push(this);\n    } else {\n      csgs = [this, csg];\n    }\n\n    let i;\n    // combine csg pairs in a way that forms a balanced binary tree pattern\n    for (i = 1; i < csgs.length; i += 2) {\n      csgs.push(csgs[i - 1].unionSub(csgs[i]));\n    }\n    return csgs[i - 1].reTesselated().canonicalized();\n  },\n\n  unionSub: function (csg, retesselate, canonicalize) {\n    if (!this.mayOverlap(csg)) {\n      return this.unionForNonIntersecting(csg);\n    } else {\n      let a = new Tree(this.polygons);\n      let b = new Tree(csg.polygons);\n      a.clipTo(b, false);\n\n      // b.clipTo(a, true); // ERROR: this doesn't work\n      b.clipTo(a);\n      b.invert();\n      b.clipTo(a);\n      b.invert();\n\n      let newpolygons = a.allPolygons().concat(b.allPolygons());\n      let result = fromPolygons(newpolygons);\n      result.properties = this.properties._merge(csg.properties);\n      if (retesselate) result = result.reTesselated();\n      if (canonicalize) result = result.canonicalized();\n      return result;\n    }\n  },\n\n  // Like union, but when we know that the two solids are not intersecting\n  // Do not use if you are not completely sure that the solids do not intersect!\n  unionForNonIntersecting: function (csg) {\n    let newpolygons = this.polygons.concat(csg.polygons);\n    let result = fromPolygons(newpolygons);\n    result.properties = this.properties._merge(csg.properties);\n    result.isCanonicalized = this.isCanonicalized && csg.isCanonicalized;\n    result.isRetesselated = this.isRetesselated && csg.isRetesselated;\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid representing space in this solid but\n   * not in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.subtract(B)\n   * @example\n   * +-------+            +-------+\n   * |       |            |       |\n   * |   A   |            |       |\n   * |    +--+----+   =   |    +--+\n   * +----+--+    |       +----+\n   *      |   B   |\n   *      |       |\n   *      +-------+\n   */\n  subtract: function (csg) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg;\n    } else {\n      csgs = [csg];\n    }\n    let result = this;\n    for (let i = 0; i < csgs.length; i++) {\n      let islast = i === csgs.length - 1;\n      result = result.subtractSub(csgs[i], islast, islast);\n    }\n    return result;\n  },\n\n  subtractSub: function (csg, retesselate, canonicalize) {\n    let a = new Tree(this.polygons);\n    let b = new Tree(csg.polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a, true);\n    a.addPolygons(b.allPolygons());\n    a.invert();\n    let result = fromPolygons(a.allPolygons());\n    result.properties = this.properties._merge(csg.properties);\n    if (retesselate) result = result.reTesselated();\n    if (canonicalize) result = result.canonicalized();\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid representing space in both this solid and\n   * in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.intersect(B)\n   * @example\n   * +-------+\n   * |       |\n   * |   A   |\n   * |    +--+----+   =   +--+\n   * +----+--+    |       +--+\n   *      |   B   |\n   *      |       |\n   *      +-------+\n   */\n  intersect: function (csg) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg;\n    } else {\n      csgs = [csg];\n    }\n    let result = this;\n    for (let i = 0; i < csgs.length; i++) {\n      let islast = i === csgs.length - 1;\n      result = result.intersectSub(csgs[i], islast, islast);\n    }\n    return result;\n  },\n\n  intersectSub: function (csg, retesselate, canonicalize) {\n    let a = new Tree(this.polygons);\n    let b = new Tree(csg.polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.addPolygons(b.allPolygons());\n    a.invert();\n    let result = fromPolygons(a.allPolygons());\n    result.properties = this.properties._merge(csg.properties);\n    if (retesselate) result = result.reTesselated();\n    if (canonicalize) result = result.canonicalized();\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid with solid and empty space switched.\n   * This solid is not modified.\n   * @returns {CSG} new CSG object\n   * @example\n   * let B = A.invert()\n   */\n  invert: function () {\n    let flippedpolygons = this.polygons.map(function (p) {\n      return p.flipped();\n    });\n    return fromPolygons(flippedpolygons);\n    // TODO: flip properties?\n  },\n\n  // Affine transformation of CSG object. Returns a new CSG object\n  transform1: function (matrix4x4) {\n    let newpolygons = this.polygons.map(function (p) {\n      return p.transform(matrix4x4);\n    });\n    let result = fromPolygons(newpolygons);\n    result.properties = this.properties._transform(matrix4x4);\n    result.isRetesselated = this.isRetesselated;\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid that is transformed using the given Matrix.\n   * Several matrix transformations can be combined before transforming this solid.\n   * @param {CSG.Matrix4x4} matrix4x4 - matrix to be applied\n   * @returns {CSG} new CSG object\n   * @example\n   * var m = new CSG.Matrix4x4()\n   * m = m.multiply(CSG.Matrix4x4.rotationX(40))\n   * m = m.multiply(CSG.Matrix4x4.translation([-.5, 0, 0]))\n   * let B = A.transform(m)\n   */\n  transform: function (matrix4x4) {\n    let ismirror = matrix4x4.isMirroring();\n    let transformedvertices = {};\n    let transformedplanes = {};\n    let newpolygons = this.polygons.map(function (p) {\n      let newplane;\n      let plane = p.plane;\n      let planetag = plane.getTag();\n      if (planetag in transformedplanes) {\n        newplane = transformedplanes[planetag];\n      } else {\n        newplane = plane.transform(matrix4x4);\n        transformedplanes[planetag] = newplane;\n      }\n      let newvertices = p.vertices.map(function (v) {\n        let newvertex;\n        let vertextag = v.getTag();\n        if (vertextag in transformedvertices) {\n          newvertex = transformedvertices[vertextag];\n        } else {\n          newvertex = v.transform(matrix4x4);\n          transformedvertices[vertextag] = newvertex;\n        }\n        return newvertex;\n      });\n      if (ismirror) newvertices.reverse();\n      return new Polygon(newvertices, p.shared, newplane);\n    });\n    let result = fromPolygons(newpolygons);\n    result.properties = this.properties._transform(matrix4x4);\n    result.isRetesselated = this.isRetesselated;\n    result.isCanonicalized = this.isCanonicalized;\n    return result;\n  },\n\n  // ALIAS !\n  center: function (axes) {\n    return center({ axes: axes }, [this]);\n  },\n\n  // ALIAS !\n  expand: function (radius, resolution) {\n    return expand(this, radius, resolution);\n  },\n\n  // ALIAS !\n  contract: function (radius, resolution) {\n    return contract(this, radius, resolution);\n  },\n\n  // ALIAS !\n  expandedShell: function (radius, resolution, unionWithThis) {\n    return expandedShellOfCCSG(this, radius, resolution, unionWithThis);\n  },\n\n  // cut the solid at a plane, and stretch the cross-section found along plane normal\n  // note: only used in roundedCube() internally\n  stretchAtPlane: function (normal, point, length) {\n    let plane = Plane.fromNormalAndPoint(normal, point);\n    let onb = new OrthoNormalBasis(plane);\n    let crosssect = this.sectionCut(onb);\n    let midpiece = crosssect.extrudeInOrthonormalBasis(onb, length);\n    let piece1 = this.cutByPlane(plane);\n    let piece2 = this.cutByPlane(plane.flipped());\n    let result = piece1.union([\n      midpiece,\n      piece2.translate(plane.normal.times(length)),\n    ]);\n    return result;\n  },\n\n  // ALIAS !\n  canonicalized: function () {\n    return canonicalize(this);\n  },\n\n  // ALIAS !\n  reTesselated: function () {\n    return retesselate(this);\n  },\n\n  // ALIAS !\n  fixTJunctions: function () {\n    return fixTJunctions(fromPolygons, this);\n  },\n\n  // ALIAS !\n  getBounds: function () {\n    return bounds(this);\n  },\n\n  /** returns true if there is a possibility that the two solids overlap\n   * returns false if we can be sure that they do not overlap\n   * NOTE: this is critical as it is used in UNIONs\n   * @param  {CSG} csg\n   */\n  mayOverlap: function (csg) {\n    if (this.polygons.length === 0 || csg.polygons.length === 0) {\n      return false;\n    } else {\n      let mybounds = bounds(this);\n      let otherbounds = bounds(csg);\n      if (mybounds[1].x < otherbounds[0].x) return false;\n      if (mybounds[0].x > otherbounds[1].x) return false;\n      if (mybounds[1].y < otherbounds[0].y) return false;\n      if (mybounds[0].y > otherbounds[1].y) return false;\n      if (mybounds[1].z < otherbounds[0].z) return false;\n      if (mybounds[0].z > otherbounds[1].z) return false;\n      return true;\n    }\n  },\n\n  // ALIAS !\n  cutByPlane: function (plane) {\n    return cutByPlane(this, plane);\n  },\n\n  /**\n   * Connect a solid to another solid, such that two Connectors become connected\n   * @param  {Connector} myConnector a Connector of this solid\n   * @param  {Connector} otherConnector a Connector to which myConnector should be connected\n   * @param  {Boolean} mirror false: the 'axis' vectors of the connectors should point in the same direction\n   * true: the 'axis' vectors of the connectors should point in opposite direction\n   * @param  {Float} normalrotation degrees of rotation between the 'normal' vectors of the two\n   * connectors\n   * @returns {CSG} this csg, tranformed accordingly\n   */\n  connectTo: function (myConnector, otherConnector, mirror, normalrotation) {\n    let matrix = myConnector.getTransformationTo(\n      otherConnector,\n      mirror,\n      normalrotation\n    );\n    return this.transform(matrix);\n  },\n\n  /**\n   * set the .shared property of all polygons\n   * @param  {Object} shared\n   * @returns {CSG} Returns a new CSG solid, the original is unmodified!\n   */\n  setShared: function (shared) {\n    let polygons = this.polygons.map(function (p) {\n      return new Polygon(p.vertices, shared, p.plane);\n    });\n    let result = fromPolygons(polygons);\n    result.properties = this.properties; // keep original properties\n    result.isRetesselated = this.isRetesselated;\n    result.isCanonicalized = this.isCanonicalized;\n    return result;\n  },\n\n  /** sets the color of this csg: non mutating, returns a new CSG\n   * @param  {Object} args\n   * @returns {CSG} a copy of this CSG, with the given color\n   */\n  setColor: function (args) {\n    let newshared = Polygon.Shared.fromColor.apply(this, arguments);\n    return this.setShared(newshared);\n  },\n\n  // ALIAS !\n  getTransformationAndInverseTransformationToFlatLying: function () {\n    return getTransformationAndInverseTransformationToFlatLying(this);\n  },\n\n  // ALIAS !\n  getTransformationToFlatLying: function () {\n    return getTransformationToFlatLying(this);\n  },\n\n  // ALIAS !\n  lieFlat: function () {\n    return lieFlat(this);\n  },\n\n  // project the 3D CSG onto a plane\n  // This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the\n  // plane represented by the orthonormal basis\n  projectToOrthoNormalBasis: function (orthobasis) {\n    // FIXME:  DEPENDS ON CAG !!\n    return projectToOrthoNormalBasis(this, orthobasis);\n  },\n\n  // FIXME: not finding any uses within our code ?\n  sectionCut: function (orthobasis) {\n    return sectionCut(this, orthobasis);\n  },\n\n  /**\n   * Returns an array of values for the requested features of this solid.\n   * Supported Features: 'volume', 'area'\n   * @param {String[]} features - list of features to calculate\n   * @returns {Float[]} values\n   * @example\n   * let volume = A.getFeatures('volume')\n   * let values = A.getFeatures('area','volume')\n   */\n  getFeatures: function (features) {\n    if (!(features instanceof Array)) {\n      features = [features];\n    }\n    let result = this.toTriangles()\n      .map(function (triPoly) {\n        return triPoly.getTetraFeatures(features);\n      })\n      .reduce(function (pv, v) {\n        return v.map(function (feat, i) {\n          return feat + (pv === 0 ? 0 : pv[i]);\n        });\n      }, 0);\n    return result.length === 1 ? result[0] : result;\n  },\n  /** @return {Polygon[]} The list of polygons. */\n  toPolygons: function () {\n    return this.polygons;\n  },\n\n  toString: function () {\n    let result = 'CSG solid:\\n';\n    this.polygons.map(function (p) {\n      result += p.toString();\n    });\n    return result;\n  },\n\n  /** returns a compact binary representation of this csg\n   * usually used to transfer CSG objects to/from webworkes\n   * NOTE: very interesting compact format, with a lot of reusable ideas\n   * @returns {Object} compact binary representation of a CSG\n   */\n  toCompactBinary: function () {\n    let csg = this.canonicalized();\n    let numpolygons = csg.polygons.length;\n    let numpolygonvertices = 0;\n\n    let numvertices = 0;\n    let vertexmap = {};\n    let vertices = [];\n\n    let numplanes = 0;\n    let planemap = {};\n    let planes = [];\n\n    let shareds = [];\n    let sharedmap = {};\n    let numshared = 0;\n    // for (let i = 0, iMax = csg.polygons.length; i < iMax; i++) {\n    //  let p = csg.polygons[i];\n    //  for (let j = 0, jMax = p.length; j < jMax; j++) {\n    //      ++numpolygonvertices;\n    //      let vertextag = p[j].getTag();\n    //      if(!(vertextag in vertexmap)) {\n    //          vertexmap[vertextag] = numvertices++;\n    //          vertices.push(p[j]);\n    //      }\n    //  }\n    csg.polygons.map(function (polygon) {\n      // FIXME: why use map if we do not return anything ?\n      // either for... or forEach\n      polygon.vertices.map(function (vertex) {\n        ++numpolygonvertices;\n        let vertextag = vertex.getTag();\n        if (!(vertextag in vertexmap)) {\n          vertexmap[vertextag] = numvertices++;\n          vertices.push(vertex);\n        }\n      });\n\n      let planetag = polygon.plane.getTag();\n      if (!(planetag in planemap)) {\n        planemap[planetag] = numplanes++;\n        planes.push(polygon.plane);\n      }\n      let sharedtag = polygon.shared.getTag();\n      if (!(sharedtag in sharedmap)) {\n        sharedmap[sharedtag] = numshared++;\n        shareds.push(polygon.shared);\n      }\n    });\n\n    let numVerticesPerPolygon = new Uint32Array(numpolygons);\n    let polygonSharedIndexes = new Uint32Array(numpolygons);\n    let polygonVertices = new Uint32Array(numpolygonvertices);\n    let polygonPlaneIndexes = new Uint32Array(numpolygons);\n    let vertexData = new Float64Array(numvertices * 3);\n    let planeData = new Float64Array(numplanes * 4);\n    let polygonVerticesIndex = 0;\n\n    // FIXME: doublecheck : why does it go through the whole polygons again?\n    // can we optimise that ? (perhap due to needing size to init buffers above)\n    for (let polygonindex = 0; polygonindex < numpolygons; ++polygonindex) {\n      let polygon = csg.polygons[polygonindex];\n      numVerticesPerPolygon[polygonindex] = polygon.vertices.length;\n      polygon.vertices.map(function (vertex) {\n        let vertextag = vertex.getTag();\n        let vertexindex = vertexmap[vertextag];\n        polygonVertices[polygonVerticesIndex++] = vertexindex;\n      });\n      let planetag = polygon.plane.getTag();\n      let planeindex = planemap[planetag];\n      polygonPlaneIndexes[polygonindex] = planeindex;\n      let sharedtag = polygon.shared.getTag();\n      let sharedindex = sharedmap[sharedtag];\n      polygonSharedIndexes[polygonindex] = sharedindex;\n    }\n    let verticesArrayIndex = 0;\n    vertices.map(function (vertex) {\n      const pos = vertex.pos;\n      vertexData[verticesArrayIndex++] = pos._x;\n      vertexData[verticesArrayIndex++] = pos._y;\n      vertexData[verticesArrayIndex++] = pos._z;\n    });\n    let planesArrayIndex = 0;\n    planes.map(function (plane) {\n      const normal = plane.normal;\n      planeData[planesArrayIndex++] = normal._x;\n      planeData[planesArrayIndex++] = normal._y;\n      planeData[planesArrayIndex++] = normal._z;\n      planeData[planesArrayIndex++] = plane.w;\n    });\n\n    let result = {\n      class: 'CSG',\n      numPolygons: numpolygons,\n      numVerticesPerPolygon: numVerticesPerPolygon,\n      polygonPlaneIndexes: polygonPlaneIndexes,\n      polygonSharedIndexes: polygonSharedIndexes,\n      polygonVertices: polygonVertices,\n      vertexData: vertexData,\n      planeData: planeData,\n      shared: shareds,\n    };\n    return result;\n  },\n\n  /** returns the triangles of this csg\n   * @returns {Polygons} triangulated polygons\n   */\n  toTriangles: function () {\n    let polygons = [];\n    this.polygons.forEach(function (poly) {\n      let firstVertex = poly.vertices[0];\n      for (let i = poly.vertices.length - 3; i >= 0; i--) {\n        polygons.push(\n          new Polygon(\n            [firstVertex, poly.vertices[i + 1], poly.vertices[i + 2]],\n            poly.shared,\n            poly.plane\n          )\n        );\n      }\n    });\n    return polygons;\n  },\n};\n\nmodule.exports = CSG;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9DU0cuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9DU0cuanM/YzY2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBUcmVlID0gcmVxdWlyZSgnLi90cmVlcycpO1xuY29uc3QgUG9seWdvbiA9IHJlcXVpcmUoJy4vbWF0aC9Qb2x5Z29uMycpO1xuY29uc3QgUGxhbmUgPSByZXF1aXJlKCcuL21hdGgvUGxhbmUnKTtcbmNvbnN0IE9ydGhvTm9ybWFsQmFzaXMgPSByZXF1aXJlKCcuL21hdGgvT3J0aG9Ob3JtYWxCYXNpcycpO1xuXG5jb25zdCBDQUcgPSByZXF1aXJlKCcuL0NBRycpOyAvLyBGSVhNRTogZm9yIHNvbWUgd2VpcmQgcmVhc29uIGlmIENBRyBpcyBpbXBvcnRlZCBBRlRFUiBmcm9tcG9seWdvbnMsIGEgbG90IG9mIHRoaW5ncyBicmVhaz8/P1xuXG5jb25zdCBQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9Qcm9wZXJ0aWVzJyk7XG5jb25zdCB7IGZyb21Qb2x5Z29ucyB9ID0gcmVxdWlyZSgnLi9DU0dGYWN0b3JpZXMnKTsgLy8gRklYTUU6IGNpcmN1bGFyIGRlcGVuZGVuY3kgIVxuXG5jb25zdCBmaXhUSnVuY3Rpb25zID0gcmVxdWlyZSgnLi91dGlscy9maXhUSnVuY3Rpb25zJyk7XG5jb25zdCBjYW5vbmljYWxpemUgPSByZXF1aXJlKCcuL3V0aWxzL2Nhbm9uaWNhbGl6ZScpO1xuY29uc3QgcmV0ZXNzZWxhdGUgPSByZXF1aXJlKCcuL3V0aWxzL3JldGVzZWxsYXRlJyk7XG5jb25zdCB7IGJvdW5kcyB9ID0gcmVxdWlyZSgnLi91dGlscy9jc2dNZWFzdXJlbWVudHMnKTtcbmNvbnN0IHsgcHJvamVjdFRvT3J0aG9Ob3JtYWxCYXNpcyB9ID0gcmVxdWlyZSgnLi91dGlscy9jc2dQcm9qZWN0aW9ucycpO1xuXG5jb25zdCB7XG4gIGxpZUZsYXQsXG4gIGdldFRyYW5zZm9ybWF0aW9uVG9GbGF0THlpbmcsXG4gIGdldFRyYW5zZm9ybWF0aW9uQW5kSW52ZXJzZVRyYW5zZm9ybWF0aW9uVG9GbGF0THlpbmcsXG59ID0gcmVxdWlyZSgnLi4vYXBpL29wcy1jbmMnKTtcbmNvbnN0IHsgc2VjdGlvbkN1dCwgY3V0QnlQbGFuZSB9ID0gcmVxdWlyZSgnLi4vYXBpL29wcy1jdXRzJyk7XG5jb25zdCBjZW50ZXIgPSByZXF1aXJlKCcuLi9hcGkvY2VudGVyJyk7XG5jb25zdCB7XG4gIGV4cGFuZCxcbiAgY29udHJhY3QsXG4gIGV4cGFuZGVkU2hlbGxPZkNDU0csXG59ID0gcmVxdWlyZSgnLi4vYXBpL29wcy1leHBhbmRDb250cmFjdCcpO1xuXG4vKiogQ2xhc3MgQ1NHXG4gKiBIb2xkcyBhIGJpbmFyeSBzcGFjZSBwYXJ0aXRpb24gdHJlZSByZXByZXNlbnRpbmcgYSAzRCBzb2xpZC4gVHdvIHNvbGlkcyBjYW5cbiAqIGJlIGNvbWJpbmVkIHVzaW5nIHRoZSBgdW5pb24oKWAsIGBzdWJ0cmFjdCgpYCwgYW5kIGBpbnRlcnNlY3QoKWAgbWV0aG9kcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5sZXQgQ1NHID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbHlnb25zID0gW107XG4gIHRoaXMucHJvcGVydGllcyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gIHRoaXMuaXNDYW5vbmljYWxpemVkID0gdHJ1ZTtcbiAgdGhpcy5pc1JldGVzc2VsYXRlZCA9IHRydWU7XG59O1xuXG5DU0cucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IENTRyBzb2xpZCByZXByZXNlbnRpbmcgdGhlIHNwYWNlIGluIGVpdGhlciB0aGlzIHNvbGlkIG9yXG4gICAqIGluIHRoZSBnaXZlbiBzb2xpZHMuIE5laXRoZXIgdGhpcyBzb2xpZCBub3IgdGhlIGdpdmVuIHNvbGlkcyBhcmUgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7Q1NHW119IGNzZyAtIGxpc3Qgb2YgQ1NHIG9iamVjdHNcbiAgICogQHJldHVybnMge0NTR30gbmV3IENTRyBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICogbGV0IEMgPSBBLnVuaW9uKEIpXG4gICAqIEBleGFtcGxlXG4gICAqICstLS0tLS0tKyAgICAgICAgICAgICstLS0tLS0tK1xuICAgKiB8ICAgICAgIHwgICAgICAgICAgICB8ICAgICAgIHxcbiAgICogfCAgIEEgICB8ICAgICAgICAgICAgfCAgICAgICB8XG4gICAqIHwgICAgKy0tKy0tLS0rICAgPSAgIHwgICAgICAgKy0tLS0rXG4gICAqICstLS0tKy0tKyAgICB8ICAgICAgICstLS0tKyAgICAgICB8XG4gICAqICAgICAgfCAgIEIgICB8ICAgICAgICAgICAgfCAgICAgICB8XG4gICAqICAgICAgfCAgICAgICB8ICAgICAgICAgICAgfCAgICAgICB8XG4gICAqICAgICAgKy0tLS0tLS0rICAgICAgICAgICAgKy0tLS0tLS0rXG4gICAqL1xuICB1bmlvbjogZnVuY3Rpb24gKGNzZykge1xuICAgIGxldCBjc2dzO1xuICAgIGlmIChjc2cgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgY3NncyA9IGNzZy5zbGljZSgwKTtcbiAgICAgIGNzZ3MucHVzaCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NncyA9IFt0aGlzLCBjc2ddO1xuICAgIH1cblxuICAgIGxldCBpO1xuICAgIC8vIGNvbWJpbmUgY3NnIHBhaXJzIGluIGEgd2F5IHRoYXQgZm9ybXMgYSBiYWxhbmNlZCBiaW5hcnkgdHJlZSBwYXR0ZXJuXG4gICAgZm9yIChpID0gMTsgaSA8IGNzZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNzZ3MucHVzaChjc2dzW2kgLSAxXS51bmlvblN1Yihjc2dzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBjc2dzW2kgLSAxXS5yZVRlc3NlbGF0ZWQoKS5jYW5vbmljYWxpemVkKCk7XG4gIH0sXG5cbiAgdW5pb25TdWI6IGZ1bmN0aW9uIChjc2csIHJldGVzc2VsYXRlLCBjYW5vbmljYWxpemUpIHtcbiAgICBpZiAoIXRoaXMubWF5T3ZlcmxhcChjc2cpKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmlvbkZvck5vbkludGVyc2VjdGluZyhjc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYSA9IG5ldyBUcmVlKHRoaXMucG9seWdvbnMpO1xuICAgICAgbGV0IGIgPSBuZXcgVHJlZShjc2cucG9seWdvbnMpO1xuICAgICAgYS5jbGlwVG8oYiwgZmFsc2UpO1xuXG4gICAgICAvLyBiLmNsaXBUbyhhLCB0cnVlKTsgLy8gRVJST1I6IHRoaXMgZG9lc24ndCB3b3JrXG4gICAgICBiLmNsaXBUbyhhKTtcbiAgICAgIGIuaW52ZXJ0KCk7XG4gICAgICBiLmNsaXBUbyhhKTtcbiAgICAgIGIuaW52ZXJ0KCk7XG5cbiAgICAgIGxldCBuZXdwb2x5Z29ucyA9IGEuYWxsUG9seWdvbnMoKS5jb25jYXQoYi5hbGxQb2x5Z29ucygpKTtcbiAgICAgIGxldCByZXN1bHQgPSBmcm9tUG9seWdvbnMobmV3cG9seWdvbnMpO1xuICAgICAgcmVzdWx0LnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXMuX21lcmdlKGNzZy5wcm9wZXJ0aWVzKTtcbiAgICAgIGlmIChyZXRlc3NlbGF0ZSkgcmVzdWx0ID0gcmVzdWx0LnJlVGVzc2VsYXRlZCgpO1xuICAgICAgaWYgKGNhbm9uaWNhbGl6ZSkgcmVzdWx0ID0gcmVzdWx0LmNhbm9uaWNhbGl6ZWQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LFxuXG4gIC8vIExpa2UgdW5pb24sIGJ1dCB3aGVuIHdlIGtub3cgdGhhdCB0aGUgdHdvIHNvbGlkcyBhcmUgbm90IGludGVyc2VjdGluZ1xuICAvLyBEbyBub3QgdXNlIGlmIHlvdSBhcmUgbm90IGNvbXBsZXRlbHkgc3VyZSB0aGF0IHRoZSBzb2xpZHMgZG8gbm90IGludGVyc2VjdCFcbiAgdW5pb25Gb3JOb25JbnRlcnNlY3Rpbmc6IGZ1bmN0aW9uIChjc2cpIHtcbiAgICBsZXQgbmV3cG9seWdvbnMgPSB0aGlzLnBvbHlnb25zLmNvbmNhdChjc2cucG9seWdvbnMpO1xuICAgIGxldCByZXN1bHQgPSBmcm9tUG9seWdvbnMobmV3cG9seWdvbnMpO1xuICAgIHJlc3VsdC5wcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzLl9tZXJnZShjc2cucHJvcGVydGllcyk7XG4gICAgcmVzdWx0LmlzQ2Fub25pY2FsaXplZCA9IHRoaXMuaXNDYW5vbmljYWxpemVkICYmIGNzZy5pc0Nhbm9uaWNhbGl6ZWQ7XG4gICAgcmVzdWx0LmlzUmV0ZXNzZWxhdGVkID0gdGhpcy5pc1JldGVzc2VsYXRlZCAmJiBjc2cuaXNSZXRlc3NlbGF0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IENTRyBzb2xpZCByZXByZXNlbnRpbmcgc3BhY2UgaW4gdGhpcyBzb2xpZCBidXRcbiAgICogbm90IGluIHRoZSBnaXZlbiBzb2xpZHMuIE5laXRoZXIgdGhpcyBzb2xpZCBub3IgdGhlIGdpdmVuIHNvbGlkcyBhcmUgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7Q1NHW119IGNzZyAtIGxpc3Qgb2YgQ1NHIG9iamVjdHNcbiAgICogQHJldHVybnMge0NTR30gbmV3IENTRyBvYmplY3RcbiAgICogQGV4YW1wbGVcbiAgICogbGV0IEMgPSBBLnN1YnRyYWN0KEIpXG4gICAqIEBleGFtcGxlXG4gICAqICstLS0tLS0tKyAgICAgICAgICAgICstLS0tLS0tK1xuICAgKiB8ICAgICAgIHwgICAgICAgICAgICB8ICAgICAgIHxcbiAgICogfCAgIEEgICB8ICAgICAgICAgICAgfCAgICAgICB8XG4gICAqIHwgICAgKy0tKy0tLS0rICAgPSAgIHwgICAgKy0tK1xuICAgKiArLS0tLSstLSsgICAgfCAgICAgICArLS0tLStcbiAgICogICAgICB8ICAgQiAgIHxcbiAgICogICAgICB8ICAgICAgIHxcbiAgICogICAgICArLS0tLS0tLStcbiAgICovXG4gIHN1YnRyYWN0OiBmdW5jdGlvbiAoY3NnKSB7XG4gICAgbGV0IGNzZ3M7XG4gICAgaWYgKGNzZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjc2dzID0gY3NnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc2dzID0gW2NzZ107XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3Nncy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGlzbGFzdCA9IGkgPT09IGNzZ3MubGVuZ3RoIC0gMTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJ0cmFjdFN1Yihjc2dzW2ldLCBpc2xhc3QsIGlzbGFzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgc3VidHJhY3RTdWI6IGZ1bmN0aW9uIChjc2csIHJldGVzc2VsYXRlLCBjYW5vbmljYWxpemUpIHtcbiAgICBsZXQgYSA9IG5ldyBUcmVlKHRoaXMucG9seWdvbnMpO1xuICAgIGxldCBiID0gbmV3IFRyZWUoY3NnLnBvbHlnb25zKTtcbiAgICBhLmludmVydCgpO1xuICAgIGEuY2xpcFRvKGIpO1xuICAgIGIuY2xpcFRvKGEsIHRydWUpO1xuICAgIGEuYWRkUG9seWdvbnMoYi5hbGxQb2x5Z29ucygpKTtcbiAgICBhLmludmVydCgpO1xuICAgIGxldCByZXN1bHQgPSBmcm9tUG9seWdvbnMoYS5hbGxQb2x5Z29ucygpKTtcbiAgICByZXN1bHQucHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcy5fbWVyZ2UoY3NnLnByb3BlcnRpZXMpO1xuICAgIGlmIChyZXRlc3NlbGF0ZSkgcmVzdWx0ID0gcmVzdWx0LnJlVGVzc2VsYXRlZCgpO1xuICAgIGlmIChjYW5vbmljYWxpemUpIHJlc3VsdCA9IHJlc3VsdC5jYW5vbmljYWxpemVkKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IENTRyBzb2xpZCByZXByZXNlbnRpbmcgc3BhY2UgaW4gYm90aCB0aGlzIHNvbGlkIGFuZFxuICAgKiBpbiB0aGUgZ2l2ZW4gc29saWRzLiBOZWl0aGVyIHRoaXMgc29saWQgbm9yIHRoZSBnaXZlbiBzb2xpZHMgYXJlIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge0NTR1tdfSBjc2cgLSBsaXN0IG9mIENTRyBvYmplY3RzXG4gICAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqIGxldCBDID0gQS5pbnRlcnNlY3QoQilcbiAgICogQGV4YW1wbGVcbiAgICogKy0tLS0tLS0rXG4gICAqIHwgICAgICAgfFxuICAgKiB8ICAgQSAgIHxcbiAgICogfCAgICArLS0rLS0tLSsgICA9ICAgKy0tK1xuICAgKiArLS0tLSstLSsgICAgfCAgICAgICArLS0rXG4gICAqICAgICAgfCAgIEIgICB8XG4gICAqICAgICAgfCAgICAgICB8XG4gICAqICAgICAgKy0tLS0tLS0rXG4gICAqL1xuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChjc2cpIHtcbiAgICBsZXQgY3NncztcbiAgICBpZiAoY3NnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNzZ3MgPSBjc2c7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzZ3MgPSBbY3NnXTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc2dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaXNsYXN0ID0gaSA9PT0gY3Nncy5sZW5ndGggLSAxO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmludGVyc2VjdFN1Yihjc2dzW2ldLCBpc2xhc3QsIGlzbGFzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgaW50ZXJzZWN0U3ViOiBmdW5jdGlvbiAoY3NnLCByZXRlc3NlbGF0ZSwgY2Fub25pY2FsaXplKSB7XG4gICAgbGV0IGEgPSBuZXcgVHJlZSh0aGlzLnBvbHlnb25zKTtcbiAgICBsZXQgYiA9IG5ldyBUcmVlKGNzZy5wb2x5Z29ucyk7XG4gICAgYS5pbnZlcnQoKTtcbiAgICBiLmNsaXBUbyhhKTtcbiAgICBiLmludmVydCgpO1xuICAgIGEuY2xpcFRvKGIpO1xuICAgIGIuY2xpcFRvKGEpO1xuICAgIGEuYWRkUG9seWdvbnMoYi5hbGxQb2x5Z29ucygpKTtcbiAgICBhLmludmVydCgpO1xuICAgIGxldCByZXN1bHQgPSBmcm9tUG9seWdvbnMoYS5hbGxQb2x5Z29ucygpKTtcbiAgICByZXN1bHQucHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcy5fbWVyZ2UoY3NnLnByb3BlcnRpZXMpO1xuICAgIGlmIChyZXRlc3NlbGF0ZSkgcmVzdWx0ID0gcmVzdWx0LnJlVGVzc2VsYXRlZCgpO1xuICAgIGlmIChjYW5vbmljYWxpemUpIHJlc3VsdCA9IHJlc3VsdC5jYW5vbmljYWxpemVkKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IENTRyBzb2xpZCB3aXRoIHNvbGlkIGFuZCBlbXB0eSBzcGFjZSBzd2l0Y2hlZC5cbiAgICogVGhpcyBzb2xpZCBpcyBub3QgbW9kaWZpZWQuXG4gICAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqIGxldCBCID0gQS5pbnZlcnQoKVxuICAgKi9cbiAgaW52ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGZsaXBwZWRwb2x5Z29ucyA9IHRoaXMucG9seWdvbnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcC5mbGlwcGVkKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZyb21Qb2x5Z29ucyhmbGlwcGVkcG9seWdvbnMpO1xuICAgIC8vIFRPRE86IGZsaXAgcHJvcGVydGllcz9cbiAgfSxcblxuICAvLyBBZmZpbmUgdHJhbnNmb3JtYXRpb24gb2YgQ1NHIG9iamVjdC4gUmV0dXJucyBhIG5ldyBDU0cgb2JqZWN0XG4gIHRyYW5zZm9ybTE6IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICBsZXQgbmV3cG9seWdvbnMgPSB0aGlzLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHAudHJhbnNmb3JtKG1hdHJpeDR4NCk7XG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdCA9IGZyb21Qb2x5Z29ucyhuZXdwb2x5Z29ucyk7XG4gICAgcmVzdWx0LnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXMuX3RyYW5zZm9ybShtYXRyaXg0eDQpO1xuICAgIHJlc3VsdC5pc1JldGVzc2VsYXRlZCA9IHRoaXMuaXNSZXRlc3NlbGF0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmV3IENTRyBzb2xpZCB0aGF0IGlzIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBnaXZlbiBNYXRyaXguXG4gICAqIFNldmVyYWwgbWF0cml4IHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgY29tYmluZWQgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGlzIHNvbGlkLlxuICAgKiBAcGFyYW0ge0NTRy5NYXRyaXg0eDR9IG1hdHJpeDR4NCAtIG1hdHJpeCB0byBiZSBhcHBsaWVkXG4gICAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBtID0gbmV3IENTRy5NYXRyaXg0eDQoKVxuICAgKiBtID0gbS5tdWx0aXBseShDU0cuTWF0cml4NHg0LnJvdGF0aW9uWCg0MCkpXG4gICAqIG0gPSBtLm11bHRpcGx5KENTRy5NYXRyaXg0eDQudHJhbnNsYXRpb24oWy0uNSwgMCwgMF0pKVxuICAgKiBsZXQgQiA9IEEudHJhbnNmb3JtKG0pXG4gICAqL1xuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICBsZXQgaXNtaXJyb3IgPSBtYXRyaXg0eDQuaXNNaXJyb3JpbmcoKTtcbiAgICBsZXQgdHJhbnNmb3JtZWR2ZXJ0aWNlcyA9IHt9O1xuICAgIGxldCB0cmFuc2Zvcm1lZHBsYW5lcyA9IHt9O1xuICAgIGxldCBuZXdwb2x5Z29ucyA9IHRoaXMucG9seWdvbnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICBsZXQgbmV3cGxhbmU7XG4gICAgICBsZXQgcGxhbmUgPSBwLnBsYW5lO1xuICAgICAgbGV0IHBsYW5ldGFnID0gcGxhbmUuZ2V0VGFnKCk7XG4gICAgICBpZiAocGxhbmV0YWcgaW4gdHJhbnNmb3JtZWRwbGFuZXMpIHtcbiAgICAgICAgbmV3cGxhbmUgPSB0cmFuc2Zvcm1lZHBsYW5lc1twbGFuZXRhZ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdwbGFuZSA9IHBsYW5lLnRyYW5zZm9ybShtYXRyaXg0eDQpO1xuICAgICAgICB0cmFuc2Zvcm1lZHBsYW5lc1twbGFuZXRhZ10gPSBuZXdwbGFuZTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXd2ZXJ0aWNlcyA9IHAudmVydGljZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGxldCBuZXd2ZXJ0ZXg7XG4gICAgICAgIGxldCB2ZXJ0ZXh0YWcgPSB2LmdldFRhZygpO1xuICAgICAgICBpZiAodmVydGV4dGFnIGluIHRyYW5zZm9ybWVkdmVydGljZXMpIHtcbiAgICAgICAgICBuZXd2ZXJ0ZXggPSB0cmFuc2Zvcm1lZHZlcnRpY2VzW3ZlcnRleHRhZ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3dmVydGV4ID0gdi50cmFuc2Zvcm0obWF0cml4NHg0KTtcbiAgICAgICAgICB0cmFuc2Zvcm1lZHZlcnRpY2VzW3ZlcnRleHRhZ10gPSBuZXd2ZXJ0ZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld3ZlcnRleDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzbWlycm9yKSBuZXd2ZXJ0aWNlcy5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gbmV3IFBvbHlnb24obmV3dmVydGljZXMsIHAuc2hhcmVkLCBuZXdwbGFuZSk7XG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdCA9IGZyb21Qb2x5Z29ucyhuZXdwb2x5Z29ucyk7XG4gICAgcmVzdWx0LnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXMuX3RyYW5zZm9ybShtYXRyaXg0eDQpO1xuICAgIHJlc3VsdC5pc1JldGVzc2VsYXRlZCA9IHRoaXMuaXNSZXRlc3NlbGF0ZWQ7XG4gICAgcmVzdWx0LmlzQ2Fub25pY2FsaXplZCA9IHRoaXMuaXNDYW5vbmljYWxpemVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBjZW50ZXI6IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgcmV0dXJuIGNlbnRlcih7IGF4ZXM6IGF4ZXMgfSwgW3RoaXNdKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGV4cGFuZDogZnVuY3Rpb24gKHJhZGl1cywgcmVzb2x1dGlvbikge1xuICAgIHJldHVybiBleHBhbmQodGhpcywgcmFkaXVzLCByZXNvbHV0aW9uKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGNvbnRyYWN0OiBmdW5jdGlvbiAocmFkaXVzLCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0KHRoaXMsIHJhZGl1cywgcmVzb2x1dGlvbik7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBleHBhbmRlZFNoZWxsOiBmdW5jdGlvbiAocmFkaXVzLCByZXNvbHV0aW9uLCB1bmlvbldpdGhUaGlzKSB7XG4gICAgcmV0dXJuIGV4cGFuZGVkU2hlbGxPZkNDU0codGhpcywgcmFkaXVzLCByZXNvbHV0aW9uLCB1bmlvbldpdGhUaGlzKTtcbiAgfSxcblxuICAvLyBjdXQgdGhlIHNvbGlkIGF0IGEgcGxhbmUsIGFuZCBzdHJldGNoIHRoZSBjcm9zcy1zZWN0aW9uIGZvdW5kIGFsb25nIHBsYW5lIG5vcm1hbFxuICAvLyBub3RlOiBvbmx5IHVzZWQgaW4gcm91bmRlZEN1YmUoKSBpbnRlcm5hbGx5XG4gIHN0cmV0Y2hBdFBsYW5lOiBmdW5jdGlvbiAobm9ybWFsLCBwb2ludCwgbGVuZ3RoKSB7XG4gICAgbGV0IHBsYW5lID0gUGxhbmUuZnJvbU5vcm1hbEFuZFBvaW50KG5vcm1hbCwgcG9pbnQpO1xuICAgIGxldCBvbmIgPSBuZXcgT3J0aG9Ob3JtYWxCYXNpcyhwbGFuZSk7XG4gICAgbGV0IGNyb3Nzc2VjdCA9IHRoaXMuc2VjdGlvbkN1dChvbmIpO1xuICAgIGxldCBtaWRwaWVjZSA9IGNyb3Nzc2VjdC5leHRydWRlSW5PcnRob25vcm1hbEJhc2lzKG9uYiwgbGVuZ3RoKTtcbiAgICBsZXQgcGllY2UxID0gdGhpcy5jdXRCeVBsYW5lKHBsYW5lKTtcbiAgICBsZXQgcGllY2UyID0gdGhpcy5jdXRCeVBsYW5lKHBsYW5lLmZsaXBwZWQoKSk7XG4gICAgbGV0IHJlc3VsdCA9IHBpZWNlMS51bmlvbihbXG4gICAgICBtaWRwaWVjZSxcbiAgICAgIHBpZWNlMi50cmFuc2xhdGUocGxhbmUubm9ybWFsLnRpbWVzKGxlbmd0aCkpLFxuICAgIF0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBjYW5vbmljYWxpemVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZSh0aGlzKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIHJlVGVzc2VsYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRlc3NlbGF0ZSh0aGlzKTtcbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGZpeFRKdW5jdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZml4VEp1bmN0aW9ucyhmcm9tUG9seWdvbnMsIHRoaXMpO1xuICB9LFxuXG4gIC8vIEFMSUFTICFcbiAgZ2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJvdW5kcyh0aGlzKTtcbiAgfSxcblxuICAvKiogcmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgcG9zc2liaWxpdHkgdGhhdCB0aGUgdHdvIHNvbGlkcyBvdmVybGFwXG4gICAqIHJldHVybnMgZmFsc2UgaWYgd2UgY2FuIGJlIHN1cmUgdGhhdCB0aGV5IGRvIG5vdCBvdmVybGFwXG4gICAqIE5PVEU6IHRoaXMgaXMgY3JpdGljYWwgYXMgaXQgaXMgdXNlZCBpbiBVTklPTnNcbiAgICogQHBhcmFtICB7Q1NHfSBjc2dcbiAgICovXG4gIG1heU92ZXJsYXA6IGZ1bmN0aW9uIChjc2cpIHtcbiAgICBpZiAodGhpcy5wb2x5Z29ucy5sZW5ndGggPT09IDAgfHwgY3NnLnBvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbXlib3VuZHMgPSBib3VuZHModGhpcyk7XG4gICAgICBsZXQgb3RoZXJib3VuZHMgPSBib3VuZHMoY3NnKTtcbiAgICAgIGlmIChteWJvdW5kc1sxXS54IDwgb3RoZXJib3VuZHNbMF0ueCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG15Ym91bmRzWzBdLnggPiBvdGhlcmJvdW5kc1sxXS54KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAobXlib3VuZHNbMV0ueSA8IG90aGVyYm91bmRzWzBdLnkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChteWJvdW5kc1swXS55ID4gb3RoZXJib3VuZHNbMV0ueSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKG15Ym91bmRzWzFdLnogPCBvdGhlcmJvdW5kc1swXS56KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAobXlib3VuZHNbMF0ueiA+IG90aGVyYm91bmRzWzFdLnopIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvLyBBTElBUyAhXG4gIGN1dEJ5UGxhbmU6IGZ1bmN0aW9uIChwbGFuZSkge1xuICAgIHJldHVybiBjdXRCeVBsYW5lKHRoaXMsIHBsYW5lKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29ubmVjdCBhIHNvbGlkIHRvIGFub3RoZXIgc29saWQsIHN1Y2ggdGhhdCB0d28gQ29ubmVjdG9ycyBiZWNvbWUgY29ubmVjdGVkXG4gICAqIEBwYXJhbSAge0Nvbm5lY3Rvcn0gbXlDb25uZWN0b3IgYSBDb25uZWN0b3Igb2YgdGhpcyBzb2xpZFxuICAgKiBAcGFyYW0gIHtDb25uZWN0b3J9IG90aGVyQ29ubmVjdG9yIGEgQ29ubmVjdG9yIHRvIHdoaWNoIG15Q29ubmVjdG9yIHNob3VsZCBiZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gbWlycm9yIGZhbHNlOiB0aGUgJ2F4aXMnIHZlY3RvcnMgb2YgdGhlIGNvbm5lY3RvcnMgc2hvdWxkIHBvaW50IGluIHRoZSBzYW1lIGRpcmVjdGlvblxuICAgKiB0cnVlOiB0aGUgJ2F4aXMnIHZlY3RvcnMgb2YgdGhlIGNvbm5lY3RvcnMgc2hvdWxkIHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtGbG9hdH0gbm9ybWFscm90YXRpb24gZGVncmVlcyBvZiByb3RhdGlvbiBiZXR3ZWVuIHRoZSAnbm9ybWFsJyB2ZWN0b3JzIG9mIHRoZSB0d29cbiAgICogY29ubmVjdG9yc1xuICAgKiBAcmV0dXJucyB7Q1NHfSB0aGlzIGNzZywgdHJhbmZvcm1lZCBhY2NvcmRpbmdseVxuICAgKi9cbiAgY29ubmVjdFRvOiBmdW5jdGlvbiAobXlDb25uZWN0b3IsIG90aGVyQ29ubmVjdG9yLCBtaXJyb3IsIG5vcm1hbHJvdGF0aW9uKSB7XG4gICAgbGV0IG1hdHJpeCA9IG15Q29ubmVjdG9yLmdldFRyYW5zZm9ybWF0aW9uVG8oXG4gICAgICBvdGhlckNvbm5lY3RvcixcbiAgICAgIG1pcnJvcixcbiAgICAgIG5vcm1hbHJvdGF0aW9uXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obWF0cml4KTtcbiAgfSxcblxuICAvKipcbiAgICogc2V0IHRoZSAuc2hhcmVkIHByb3BlcnR5IG9mIGFsbCBwb2x5Z29uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNoYXJlZFxuICAgKiBAcmV0dXJucyB7Q1NHfSBSZXR1cm5zIGEgbmV3IENTRyBzb2xpZCwgdGhlIG9yaWdpbmFsIGlzIHVubW9kaWZpZWQhXG4gICAqL1xuICBzZXRTaGFyZWQ6IGZ1bmN0aW9uIChzaGFyZWQpIHtcbiAgICBsZXQgcG9seWdvbnMgPSB0aGlzLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uKHAudmVydGljZXMsIHNoYXJlZCwgcC5wbGFuZSk7XG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdCA9IGZyb21Qb2x5Z29ucyhwb2x5Z29ucyk7XG4gICAgcmVzdWx0LnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7IC8vIGtlZXAgb3JpZ2luYWwgcHJvcGVydGllc1xuICAgIHJlc3VsdC5pc1JldGVzc2VsYXRlZCA9IHRoaXMuaXNSZXRlc3NlbGF0ZWQ7XG4gICAgcmVzdWx0LmlzQ2Fub25pY2FsaXplZCA9IHRoaXMuaXNDYW5vbmljYWxpemVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqIHNldHMgdGhlIGNvbG9yIG9mIHRoaXMgY3NnOiBub24gbXV0YXRpbmcsIHJldHVybnMgYSBuZXcgQ1NHXG4gICAqIEBwYXJhbSAge09iamVjdH0gYXJnc1xuICAgKiBAcmV0dXJucyB7Q1NHfSBhIGNvcHkgb2YgdGhpcyBDU0csIHdpdGggdGhlIGdpdmVuIGNvbG9yXG4gICAqL1xuICBzZXRDb2xvcjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBsZXQgbmV3c2hhcmVkID0gUG9seWdvbi5TaGFyZWQuZnJvbUNvbG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXMuc2V0U2hhcmVkKG5ld3NoYXJlZCk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBnZXRUcmFuc2Zvcm1hdGlvbkFuZEludmVyc2VUcmFuc2Zvcm1hdGlvblRvRmxhdEx5aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFRyYW5zZm9ybWF0aW9uQW5kSW52ZXJzZVRyYW5zZm9ybWF0aW9uVG9GbGF0THlpbmcodGhpcyk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBnZXRUcmFuc2Zvcm1hdGlvblRvRmxhdEx5aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFRyYW5zZm9ybWF0aW9uVG9GbGF0THlpbmcodGhpcyk7XG4gIH0sXG5cbiAgLy8gQUxJQVMgIVxuICBsaWVGbGF0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpZUZsYXQodGhpcyk7XG4gIH0sXG5cbiAgLy8gcHJvamVjdCB0aGUgM0QgQ1NHIG9udG8gYSBwbGFuZVxuICAvLyBUaGlzIHJldHVybnMgYSAyRCBDQUcgd2l0aCB0aGUgJ3NoYWRvdycgc2hhcGUgb2YgdGhlIDNEIHNvbGlkIHdoZW4gcHJvamVjdGVkIG9udG8gdGhlXG4gIC8vIHBsYW5lIHJlcHJlc2VudGVkIGJ5IHRoZSBvcnRob25vcm1hbCBiYXNpc1xuICBwcm9qZWN0VG9PcnRob05vcm1hbEJhc2lzOiBmdW5jdGlvbiAob3J0aG9iYXNpcykge1xuICAgIC8vIEZJWE1FOiAgREVQRU5EUyBPTiBDQUcgISFcbiAgICByZXR1cm4gcHJvamVjdFRvT3J0aG9Ob3JtYWxCYXNpcyh0aGlzLCBvcnRob2Jhc2lzKTtcbiAgfSxcblxuICAvLyBGSVhNRTogbm90IGZpbmRpbmcgYW55IHVzZXMgd2l0aGluIG91ciBjb2RlID9cbiAgc2VjdGlvbkN1dDogZnVuY3Rpb24gKG9ydGhvYmFzaXMpIHtcbiAgICByZXR1cm4gc2VjdGlvbkN1dCh0aGlzLCBvcnRob2Jhc2lzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMgZm9yIHRoZSByZXF1ZXN0ZWQgZmVhdHVyZXMgb2YgdGhpcyBzb2xpZC5cbiAgICogU3VwcG9ydGVkIEZlYXR1cmVzOiAndm9sdW1lJywgJ2FyZWEnXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGZlYXR1cmVzIC0gbGlzdCBvZiBmZWF0dXJlcyB0byBjYWxjdWxhdGVcbiAgICogQHJldHVybnMge0Zsb2F0W119IHZhbHVlc1xuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgdm9sdW1lID0gQS5nZXRGZWF0dXJlcygndm9sdW1lJylcbiAgICogbGV0IHZhbHVlcyA9IEEuZ2V0RmVhdHVyZXMoJ2FyZWEnLCd2b2x1bWUnKVxuICAgKi9cbiAgZ2V0RmVhdHVyZXM6IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgIGlmICghKGZlYXR1cmVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBmZWF0dXJlcyA9IFtmZWF0dXJlc107XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB0aGlzLnRvVHJpYW5nbGVzKClcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHRyaVBvbHkpIHtcbiAgICAgICAgcmV0dXJuIHRyaVBvbHkuZ2V0VGV0cmFGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICB9KVxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHYsIHYpIHtcbiAgICAgICAgcmV0dXJuIHYubWFwKGZ1bmN0aW9uIChmZWF0LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGZlYXQgKyAocHYgPT09IDAgPyAwIDogcHZbaV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDApO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICB9LFxuICAvKiogQHJldHVybiB7UG9seWdvbltdfSBUaGUgbGlzdCBvZiBwb2x5Z29ucy4gKi9cbiAgdG9Qb2x5Z29uczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBvbHlnb25zO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc3VsdCA9ICdDU0cgc29saWQ6XFxuJztcbiAgICB0aGlzLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmVzdWx0ICs9IHAudG9TdHJpbmcoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKiByZXR1cm5zIGEgY29tcGFjdCBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjc2dcbiAgICogdXN1YWxseSB1c2VkIHRvIHRyYW5zZmVyIENTRyBvYmplY3RzIHRvL2Zyb20gd2Vid29ya2VzXG4gICAqIE5PVEU6IHZlcnkgaW50ZXJlc3RpbmcgY29tcGFjdCBmb3JtYXQsIHdpdGggYSBsb3Qgb2YgcmV1c2FibGUgaWRlYXNcbiAgICogQHJldHVybnMge09iamVjdH0gY29tcGFjdCBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgYSBDU0dcbiAgICovXG4gIHRvQ29tcGFjdEJpbmFyeTogZnVuY3Rpb24gKCkge1xuICAgIGxldCBjc2cgPSB0aGlzLmNhbm9uaWNhbGl6ZWQoKTtcbiAgICBsZXQgbnVtcG9seWdvbnMgPSBjc2cucG9seWdvbnMubGVuZ3RoO1xuICAgIGxldCBudW1wb2x5Z29udmVydGljZXMgPSAwO1xuXG4gICAgbGV0IG51bXZlcnRpY2VzID0gMDtcbiAgICBsZXQgdmVydGV4bWFwID0ge307XG4gICAgbGV0IHZlcnRpY2VzID0gW107XG5cbiAgICBsZXQgbnVtcGxhbmVzID0gMDtcbiAgICBsZXQgcGxhbmVtYXAgPSB7fTtcbiAgICBsZXQgcGxhbmVzID0gW107XG5cbiAgICBsZXQgc2hhcmVkcyA9IFtdO1xuICAgIGxldCBzaGFyZWRtYXAgPSB7fTtcbiAgICBsZXQgbnVtc2hhcmVkID0gMDtcbiAgICAvLyBmb3IgKGxldCBpID0gMCwgaU1heCA9IGNzZy5wb2x5Z29ucy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAvLyAgbGV0IHAgPSBjc2cucG9seWdvbnNbaV07XG4gICAgLy8gIGZvciAobGV0IGogPSAwLCBqTWF4ID0gcC5sZW5ndGg7IGogPCBqTWF4OyBqKyspIHtcbiAgICAvLyAgICAgICsrbnVtcG9seWdvbnZlcnRpY2VzO1xuICAgIC8vICAgICAgbGV0IHZlcnRleHRhZyA9IHBbal0uZ2V0VGFnKCk7XG4gICAgLy8gICAgICBpZighKHZlcnRleHRhZyBpbiB2ZXJ0ZXhtYXApKSB7XG4gICAgLy8gICAgICAgICAgdmVydGV4bWFwW3ZlcnRleHRhZ10gPSBudW12ZXJ0aWNlcysrO1xuICAgIC8vICAgICAgICAgIHZlcnRpY2VzLnB1c2gocFtqXSk7XG4gICAgLy8gICAgICB9XG4gICAgLy8gIH1cbiAgICBjc2cucG9seWdvbnMubWFwKGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgICAvLyBGSVhNRTogd2h5IHVzZSBtYXAgaWYgd2UgZG8gbm90IHJldHVybiBhbnl0aGluZyA/XG4gICAgICAvLyBlaXRoZXIgZm9yLi4uIG9yIGZvckVhY2hcbiAgICAgIHBvbHlnb24udmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgKytudW1wb2x5Z29udmVydGljZXM7XG4gICAgICAgIGxldCB2ZXJ0ZXh0YWcgPSB2ZXJ0ZXguZ2V0VGFnKCk7XG4gICAgICAgIGlmICghKHZlcnRleHRhZyBpbiB2ZXJ0ZXhtYXApKSB7XG4gICAgICAgICAgdmVydGV4bWFwW3ZlcnRleHRhZ10gPSBudW12ZXJ0aWNlcysrO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGxldCBwbGFuZXRhZyA9IHBvbHlnb24ucGxhbmUuZ2V0VGFnKCk7XG4gICAgICBpZiAoIShwbGFuZXRhZyBpbiBwbGFuZW1hcCkpIHtcbiAgICAgICAgcGxhbmVtYXBbcGxhbmV0YWddID0gbnVtcGxhbmVzKys7XG4gICAgICAgIHBsYW5lcy5wdXNoKHBvbHlnb24ucGxhbmUpO1xuICAgICAgfVxuICAgICAgbGV0IHNoYXJlZHRhZyA9IHBvbHlnb24uc2hhcmVkLmdldFRhZygpO1xuICAgICAgaWYgKCEoc2hhcmVkdGFnIGluIHNoYXJlZG1hcCkpIHtcbiAgICAgICAgc2hhcmVkbWFwW3NoYXJlZHRhZ10gPSBudW1zaGFyZWQrKztcbiAgICAgICAgc2hhcmVkcy5wdXNoKHBvbHlnb24uc2hhcmVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCBudW1WZXJ0aWNlc1BlclBvbHlnb24gPSBuZXcgVWludDMyQXJyYXkobnVtcG9seWdvbnMpO1xuICAgIGxldCBwb2x5Z29uU2hhcmVkSW5kZXhlcyA9IG5ldyBVaW50MzJBcnJheShudW1wb2x5Z29ucyk7XG4gICAgbGV0IHBvbHlnb25WZXJ0aWNlcyA9IG5ldyBVaW50MzJBcnJheShudW1wb2x5Z29udmVydGljZXMpO1xuICAgIGxldCBwb2x5Z29uUGxhbmVJbmRleGVzID0gbmV3IFVpbnQzMkFycmF5KG51bXBvbHlnb25zKTtcbiAgICBsZXQgdmVydGV4RGF0YSA9IG5ldyBGbG9hdDY0QXJyYXkobnVtdmVydGljZXMgKiAzKTtcbiAgICBsZXQgcGxhbmVEYXRhID0gbmV3IEZsb2F0NjRBcnJheShudW1wbGFuZXMgKiA0KTtcbiAgICBsZXQgcG9seWdvblZlcnRpY2VzSW5kZXggPSAwO1xuXG4gICAgLy8gRklYTUU6IGRvdWJsZWNoZWNrIDogd2h5IGRvZXMgaXQgZ28gdGhyb3VnaCB0aGUgd2hvbGUgcG9seWdvbnMgYWdhaW4/XG4gICAgLy8gY2FuIHdlIG9wdGltaXNlIHRoYXQgPyAocGVyaGFwIGR1ZSB0byBuZWVkaW5nIHNpemUgdG8gaW5pdCBidWZmZXJzIGFib3ZlKVxuICAgIGZvciAobGV0IHBvbHlnb25pbmRleCA9IDA7IHBvbHlnb25pbmRleCA8IG51bXBvbHlnb25zOyArK3BvbHlnb25pbmRleCkge1xuICAgICAgbGV0IHBvbHlnb24gPSBjc2cucG9seWdvbnNbcG9seWdvbmluZGV4XTtcbiAgICAgIG51bVZlcnRpY2VzUGVyUG9seWdvbltwb2x5Z29uaW5kZXhdID0gcG9seWdvbi52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICBwb2x5Z29uLnZlcnRpY2VzLm1hcChmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICAgIGxldCB2ZXJ0ZXh0YWcgPSB2ZXJ0ZXguZ2V0VGFnKCk7XG4gICAgICAgIGxldCB2ZXJ0ZXhpbmRleCA9IHZlcnRleG1hcFt2ZXJ0ZXh0YWddO1xuICAgICAgICBwb2x5Z29uVmVydGljZXNbcG9seWdvblZlcnRpY2VzSW5kZXgrK10gPSB2ZXJ0ZXhpbmRleDtcbiAgICAgIH0pO1xuICAgICAgbGV0IHBsYW5ldGFnID0gcG9seWdvbi5wbGFuZS5nZXRUYWcoKTtcbiAgICAgIGxldCBwbGFuZWluZGV4ID0gcGxhbmVtYXBbcGxhbmV0YWddO1xuICAgICAgcG9seWdvblBsYW5lSW5kZXhlc1twb2x5Z29uaW5kZXhdID0gcGxhbmVpbmRleDtcbiAgICAgIGxldCBzaGFyZWR0YWcgPSBwb2x5Z29uLnNoYXJlZC5nZXRUYWcoKTtcbiAgICAgIGxldCBzaGFyZWRpbmRleCA9IHNoYXJlZG1hcFtzaGFyZWR0YWddO1xuICAgICAgcG9seWdvblNoYXJlZEluZGV4ZXNbcG9seWdvbmluZGV4XSA9IHNoYXJlZGluZGV4O1xuICAgIH1cbiAgICBsZXQgdmVydGljZXNBcnJheUluZGV4ID0gMDtcbiAgICB2ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHZlcnRleCkge1xuICAgICAgY29uc3QgcG9zID0gdmVydGV4LnBvcztcbiAgICAgIHZlcnRleERhdGFbdmVydGljZXNBcnJheUluZGV4KytdID0gcG9zLl94O1xuICAgICAgdmVydGV4RGF0YVt2ZXJ0aWNlc0FycmF5SW5kZXgrK10gPSBwb3MuX3k7XG4gICAgICB2ZXJ0ZXhEYXRhW3ZlcnRpY2VzQXJyYXlJbmRleCsrXSA9IHBvcy5fejtcbiAgICB9KTtcbiAgICBsZXQgcGxhbmVzQXJyYXlJbmRleCA9IDA7XG4gICAgcGxhbmVzLm1hcChmdW5jdGlvbiAocGxhbmUpIHtcbiAgICAgIGNvbnN0IG5vcm1hbCA9IHBsYW5lLm5vcm1hbDtcbiAgICAgIHBsYW5lRGF0YVtwbGFuZXNBcnJheUluZGV4KytdID0gbm9ybWFsLl94O1xuICAgICAgcGxhbmVEYXRhW3BsYW5lc0FycmF5SW5kZXgrK10gPSBub3JtYWwuX3k7XG4gICAgICBwbGFuZURhdGFbcGxhbmVzQXJyYXlJbmRleCsrXSA9IG5vcm1hbC5fejtcbiAgICAgIHBsYW5lRGF0YVtwbGFuZXNBcnJheUluZGV4KytdID0gcGxhbmUudztcbiAgICB9KTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBjbGFzczogJ0NTRycsXG4gICAgICBudW1Qb2x5Z29uczogbnVtcG9seWdvbnMsXG4gICAgICBudW1WZXJ0aWNlc1BlclBvbHlnb246IG51bVZlcnRpY2VzUGVyUG9seWdvbixcbiAgICAgIHBvbHlnb25QbGFuZUluZGV4ZXM6IHBvbHlnb25QbGFuZUluZGV4ZXMsXG4gICAgICBwb2x5Z29uU2hhcmVkSW5kZXhlczogcG9seWdvblNoYXJlZEluZGV4ZXMsXG4gICAgICBwb2x5Z29uVmVydGljZXM6IHBvbHlnb25WZXJ0aWNlcyxcbiAgICAgIHZlcnRleERhdGE6IHZlcnRleERhdGEsXG4gICAgICBwbGFuZURhdGE6IHBsYW5lRGF0YSxcbiAgICAgIHNoYXJlZDogc2hhcmVkcyxcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqIHJldHVybnMgdGhlIHRyaWFuZ2xlcyBvZiB0aGlzIGNzZ1xuICAgKiBAcmV0dXJucyB7UG9seWdvbnN9IHRyaWFuZ3VsYXRlZCBwb2x5Z29uc1xuICAgKi9cbiAgdG9UcmlhbmdsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcG9seWdvbnMgPSBbXTtcbiAgICB0aGlzLnBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24gKHBvbHkpIHtcbiAgICAgIGxldCBmaXJzdFZlcnRleCA9IHBvbHkudmVydGljZXNbMF07XG4gICAgICBmb3IgKGxldCBpID0gcG9seS52ZXJ0aWNlcy5sZW5ndGggLSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBwb2x5Z29ucy5wdXNoKFxuICAgICAgICAgIG5ldyBQb2x5Z29uKFxuICAgICAgICAgICAgW2ZpcnN0VmVydGV4LCBwb2x5LnZlcnRpY2VzW2kgKyAxXSwgcG9seS52ZXJ0aWNlc1tpICsgMl1dLFxuICAgICAgICAgICAgcG9seS5zaGFyZWQsXG4gICAgICAgICAgICBwb2x5LnBsYW5lXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwb2x5Z29ucztcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NHO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/CSG.js\n");

/***/ }),

/***/ "./src/core/CSGFactories.js":
/*!**********************************!*\
  !*** ./src/core/CSGFactories.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ./math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Vertex = __webpack_require__(/*! ./math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Plane = __webpack_require__(/*! ./math/Plane */ \"./src/core/math/Plane.js\");\nconst Polygon2D = __webpack_require__(/*! ./math/Polygon2 */ \"./src/core/math/Polygon2.js\");\nconst Polygon3D = __webpack_require__(/*! ./math/Polygon3 */ \"./src/core/math/Polygon3.js\");\n\n/** Construct a CSG solid from a list of `Polygon` instances.\n * @param {Polygon[]} polygons - list of polygons\n * @returns {CSG} new CSG object\n */\nconst fromPolygons = function (polygons) {\n  const CSG = __webpack_require__(/*! ./CSG */ \"./src/core/CSG.js\");\n  let csg = new CSG();\n  csg.polygons = polygons;\n  csg.isCanonicalized = false;\n  csg.isRetesselated = false;\n  return csg;\n};\n\n/** Construct a CSG solid from a list of pre-generated slices.\n * See Polygon.prototype.solidFromSlices() for details.\n * @param {Object} options - options passed to solidFromSlices()\n * @returns {CSG} new CSG object\n */\nfunction fromSlices(options) {\n  return Polygon2D.createFromPoints([\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [0, 1, 0],\n  ]).solidFromSlices(options);\n}\n\n/** Reconstruct a CSG solid from an object with identical property names.\n * @param {Object} obj - anonymous object, typically from JSON\n * @returns {CSG} new CSG object\n */\nfunction fromObject(obj) {\n  let polygons = obj.polygons.map(function (p) {\n    return Polygon3D.fromObject(p);\n  });\n  let csg = fromPolygons(polygons);\n  csg.isCanonicalized = obj.isCanonicalized;\n  csg.isRetesselated = obj.isRetesselated;\n  return csg;\n}\n\n/** Reconstruct a CSG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary().\n * @returns {CSG} new CSG object\n */\nfunction fromCompactBinary(bin) {\n  if (bin['class'] !== 'CSG') throw new Error('Not a CSG');\n  let planes = [];\n  let planeData = bin.planeData;\n  let numplanes = planeData.length / 4;\n  let arrayindex = 0;\n  let x, y, z, w, normal, plane;\n  for (let planeindex = 0; planeindex < numplanes; planeindex++) {\n    x = planeData[arrayindex++];\n    y = planeData[arrayindex++];\n    z = planeData[arrayindex++];\n    w = planeData[arrayindex++];\n    normal = Vector3D.Create(x, y, z);\n    plane = new Plane(normal, w);\n    planes.push(plane);\n  }\n\n  let vertices = [];\n  const vertexData = bin.vertexData;\n  const numvertices = vertexData.length / 3;\n  let pos;\n  let vertex;\n  arrayindex = 0;\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    x = vertexData[arrayindex++];\n    y = vertexData[arrayindex++];\n    z = vertexData[arrayindex++];\n    pos = Vector3D.Create(x, y, z);\n    vertex = new Vertex(pos);\n    vertices.push(vertex);\n  }\n\n  let shareds = bin.shared.map(function (shared) {\n    return Polygon3D.Shared.fromObject(shared);\n  });\n\n  let polygons = [];\n  let numpolygons = bin.numPolygons;\n  let numVerticesPerPolygon = bin.numVerticesPerPolygon;\n  let polygonVertices = bin.polygonVertices;\n  let polygonPlaneIndexes = bin.polygonPlaneIndexes;\n  let polygonSharedIndexes = bin.polygonSharedIndexes;\n  let numpolygonvertices;\n  let polygonvertices;\n  let shared;\n  let polygon; // already defined plane,\n  arrayindex = 0;\n  for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {\n    numpolygonvertices = numVerticesPerPolygon[polygonindex];\n    polygonvertices = [];\n    for (let i = 0; i < numpolygonvertices; i++) {\n      polygonvertices.push(vertices[polygonVertices[arrayindex++]]);\n    }\n    plane = planes[polygonPlaneIndexes[polygonindex]];\n    shared = shareds[polygonSharedIndexes[polygonindex]];\n    polygon = new Polygon3D(polygonvertices, shared, plane);\n    polygons.push(polygon);\n  }\n  let csg = fromPolygons(polygons);\n  csg.isCanonicalized = true;\n  csg.isRetesselated = true;\n  return csg;\n}\n\nmodule.exports = {\n  fromPolygons,\n  fromSlices,\n  fromObject,\n  fromCompactBinary,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9DU0dGYWN0b3JpZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9DU0dGYWN0b3JpZXMuanM/NGIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IzRCA9IHJlcXVpcmUoJy4vbWF0aC9WZWN0b3IzJyk7XG5jb25zdCBWZXJ0ZXggPSByZXF1aXJlKCcuL21hdGgvVmVydGV4MycpO1xuY29uc3QgUGxhbmUgPSByZXF1aXJlKCcuL21hdGgvUGxhbmUnKTtcbmNvbnN0IFBvbHlnb24yRCA9IHJlcXVpcmUoJy4vbWF0aC9Qb2x5Z29uMicpO1xuY29uc3QgUG9seWdvbjNEID0gcmVxdWlyZSgnLi9tYXRoL1BvbHlnb24zJyk7XG5cbi8qKiBDb25zdHJ1Y3QgYSBDU0cgc29saWQgZnJvbSBhIGxpc3Qgb2YgYFBvbHlnb25gIGluc3RhbmNlcy5cbiAqIEBwYXJhbSB7UG9seWdvbltdfSBwb2x5Z29ucyAtIGxpc3Qgb2YgcG9seWdvbnNcbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0XG4gKi9cbmNvbnN0IGZyb21Qb2x5Z29ucyA9IGZ1bmN0aW9uIChwb2x5Z29ucykge1xuICBjb25zdCBDU0cgPSByZXF1aXJlKCcuL0NTRycpO1xuICBsZXQgY3NnID0gbmV3IENTRygpO1xuICBjc2cucG9seWdvbnMgPSBwb2x5Z29ucztcbiAgY3NnLmlzQ2Fub25pY2FsaXplZCA9IGZhbHNlO1xuICBjc2cuaXNSZXRlc3NlbGF0ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGNzZztcbn07XG5cbi8qKiBDb25zdHJ1Y3QgYSBDU0cgc29saWQgZnJvbSBhIGxpc3Qgb2YgcHJlLWdlbmVyYXRlZCBzbGljZXMuXG4gKiBTZWUgUG9seWdvbi5wcm90b3R5cGUuc29saWRGcm9tU2xpY2VzKCkgZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgcGFzc2VkIHRvIHNvbGlkRnJvbVNsaWNlcygpXG4gKiBAcmV0dXJucyB7Q1NHfSBuZXcgQ1NHIG9iamVjdFxuICovXG5mdW5jdGlvbiBmcm9tU2xpY2VzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBvbHlnb24yRC5jcmVhdGVGcm9tUG9pbnRzKFtcbiAgICBbMCwgMCwgMF0sXG4gICAgWzEsIDAsIDBdLFxuICAgIFsxLCAxLCAwXSxcbiAgICBbMCwgMSwgMF0sXG4gIF0pLnNvbGlkRnJvbVNsaWNlcyhvcHRpb25zKTtcbn1cblxuLyoqIFJlY29uc3RydWN0IGEgQ1NHIHNvbGlkIGZyb20gYW4gb2JqZWN0IHdpdGggaWRlbnRpY2FsIHByb3BlcnR5IG5hbWVzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIGFub255bW91cyBvYmplY3QsIHR5cGljYWxseSBmcm9tIEpTT05cbiAqIEByZXR1cm5zIHtDU0d9IG5ldyBDU0cgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZyb21PYmplY3Qob2JqKSB7XG4gIGxldCBwb2x5Z29ucyA9IG9iai5wb2x5Z29ucy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gUG9seWdvbjNELmZyb21PYmplY3QocCk7XG4gIH0pO1xuICBsZXQgY3NnID0gZnJvbVBvbHlnb25zKHBvbHlnb25zKTtcbiAgY3NnLmlzQ2Fub25pY2FsaXplZCA9IG9iai5pc0Nhbm9uaWNhbGl6ZWQ7XG4gIGNzZy5pc1JldGVzc2VsYXRlZCA9IG9iai5pc1JldGVzc2VsYXRlZDtcbiAgcmV0dXJuIGNzZztcbn1cblxuLyoqIFJlY29uc3RydWN0IGEgQ1NHIGZyb20gdGhlIG91dHB1dCBvZiB0b0NvbXBhY3RCaW5hcnkoKS5cbiAqIEBwYXJhbSB7Q29tcGFjdEJpbmFyeX0gYmluIC0gc2VlIHRvQ29tcGFjdEJpbmFyeSgpLlxuICogQHJldHVybnMge0NTR30gbmV3IENTRyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZnJvbUNvbXBhY3RCaW5hcnkoYmluKSB7XG4gIGlmIChiaW5bJ2NsYXNzJ10gIT09ICdDU0cnKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIENTRycpO1xuICBsZXQgcGxhbmVzID0gW107XG4gIGxldCBwbGFuZURhdGEgPSBiaW4ucGxhbmVEYXRhO1xuICBsZXQgbnVtcGxhbmVzID0gcGxhbmVEYXRhLmxlbmd0aCAvIDQ7XG4gIGxldCBhcnJheWluZGV4ID0gMDtcbiAgbGV0IHgsIHksIHosIHcsIG5vcm1hbCwgcGxhbmU7XG4gIGZvciAobGV0IHBsYW5laW5kZXggPSAwOyBwbGFuZWluZGV4IDwgbnVtcGxhbmVzOyBwbGFuZWluZGV4KyspIHtcbiAgICB4ID0gcGxhbmVEYXRhW2FycmF5aW5kZXgrK107XG4gICAgeSA9IHBsYW5lRGF0YVthcnJheWluZGV4KytdO1xuICAgIHogPSBwbGFuZURhdGFbYXJyYXlpbmRleCsrXTtcbiAgICB3ID0gcGxhbmVEYXRhW2FycmF5aW5kZXgrK107XG4gICAgbm9ybWFsID0gVmVjdG9yM0QuQ3JlYXRlKHgsIHksIHopO1xuICAgIHBsYW5lID0gbmV3IFBsYW5lKG5vcm1hbCwgdyk7XG4gICAgcGxhbmVzLnB1c2gocGxhbmUpO1xuICB9XG5cbiAgbGV0IHZlcnRpY2VzID0gW107XG4gIGNvbnN0IHZlcnRleERhdGEgPSBiaW4udmVydGV4RGF0YTtcbiAgY29uc3QgbnVtdmVydGljZXMgPSB2ZXJ0ZXhEYXRhLmxlbmd0aCAvIDM7XG4gIGxldCBwb3M7XG4gIGxldCB2ZXJ0ZXg7XG4gIGFycmF5aW5kZXggPSAwO1xuICBmb3IgKGxldCB2ZXJ0ZXhpbmRleCA9IDA7IHZlcnRleGluZGV4IDwgbnVtdmVydGljZXM7IHZlcnRleGluZGV4KyspIHtcbiAgICB4ID0gdmVydGV4RGF0YVthcnJheWluZGV4KytdO1xuICAgIHkgPSB2ZXJ0ZXhEYXRhW2FycmF5aW5kZXgrK107XG4gICAgeiA9IHZlcnRleERhdGFbYXJyYXlpbmRleCsrXTtcbiAgICBwb3MgPSBWZWN0b3IzRC5DcmVhdGUoeCwgeSwgeik7XG4gICAgdmVydGV4ID0gbmV3IFZlcnRleChwb3MpO1xuICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgfVxuXG4gIGxldCBzaGFyZWRzID0gYmluLnNoYXJlZC5tYXAoZnVuY3Rpb24gKHNoYXJlZCkge1xuICAgIHJldHVybiBQb2x5Z29uM0QuU2hhcmVkLmZyb21PYmplY3Qoc2hhcmVkKTtcbiAgfSk7XG5cbiAgbGV0IHBvbHlnb25zID0gW107XG4gIGxldCBudW1wb2x5Z29ucyA9IGJpbi5udW1Qb2x5Z29ucztcbiAgbGV0IG51bVZlcnRpY2VzUGVyUG9seWdvbiA9IGJpbi5udW1WZXJ0aWNlc1BlclBvbHlnb247XG4gIGxldCBwb2x5Z29uVmVydGljZXMgPSBiaW4ucG9seWdvblZlcnRpY2VzO1xuICBsZXQgcG9seWdvblBsYW5lSW5kZXhlcyA9IGJpbi5wb2x5Z29uUGxhbmVJbmRleGVzO1xuICBsZXQgcG9seWdvblNoYXJlZEluZGV4ZXMgPSBiaW4ucG9seWdvblNoYXJlZEluZGV4ZXM7XG4gIGxldCBudW1wb2x5Z29udmVydGljZXM7XG4gIGxldCBwb2x5Z29udmVydGljZXM7XG4gIGxldCBzaGFyZWQ7XG4gIGxldCBwb2x5Z29uOyAvLyBhbHJlYWR5IGRlZmluZWQgcGxhbmUsXG4gIGFycmF5aW5kZXggPSAwO1xuICBmb3IgKGxldCBwb2x5Z29uaW5kZXggPSAwOyBwb2x5Z29uaW5kZXggPCBudW1wb2x5Z29uczsgcG9seWdvbmluZGV4KyspIHtcbiAgICBudW1wb2x5Z29udmVydGljZXMgPSBudW1WZXJ0aWNlc1BlclBvbHlnb25bcG9seWdvbmluZGV4XTtcbiAgICBwb2x5Z29udmVydGljZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXBvbHlnb252ZXJ0aWNlczsgaSsrKSB7XG4gICAgICBwb2x5Z29udmVydGljZXMucHVzaCh2ZXJ0aWNlc1twb2x5Z29uVmVydGljZXNbYXJyYXlpbmRleCsrXV0pO1xuICAgIH1cbiAgICBwbGFuZSA9IHBsYW5lc1twb2x5Z29uUGxhbmVJbmRleGVzW3BvbHlnb25pbmRleF1dO1xuICAgIHNoYXJlZCA9IHNoYXJlZHNbcG9seWdvblNoYXJlZEluZGV4ZXNbcG9seWdvbmluZGV4XV07XG4gICAgcG9seWdvbiA9IG5ldyBQb2x5Z29uM0QocG9seWdvbnZlcnRpY2VzLCBzaGFyZWQsIHBsYW5lKTtcbiAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICB9XG4gIGxldCBjc2cgPSBmcm9tUG9seWdvbnMocG9seWdvbnMpO1xuICBjc2cuaXNDYW5vbmljYWxpemVkID0gdHJ1ZTtcbiAgY3NnLmlzUmV0ZXNzZWxhdGVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNzZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZyb21Qb2x5Z29ucyxcbiAgZnJvbVNsaWNlcyxcbiAgZnJvbU9iamVjdCxcbiAgZnJvbUNvbXBhY3RCaW5hcnksXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/CSGFactories.js\n");

/***/ }),

/***/ "./src/core/FuzzyFactory.js":
/*!**********************************!*\
  !*** ./src/core/FuzzyFactory.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// //////////////////////////////\n// ## class fuzzyFactory\n// This class acts as a factory for objects. We can search for an object with approximately\n// the desired properties (say a rectangle with width 2 and height 1)\n// The lookupOrCreate() method looks for an existing object (for example it may find an existing rectangle\n// with width 2.0001 and height 0.999. If no object is found, the user supplied callback is\n// called, which should generate a new object. The new object is inserted into the database\n// so it can be found by future lookupOrCreate() calls.\n// Constructor:\n//   numdimensions: the number of parameters for each object\n//     for example for a 2D rectangle this would be 2\n//   tolerance: The maximum difference for each parameter allowed to be considered a match\nconst FuzzyFactory = function (numdimensions, tolerance) {\n  this.lookuptable = {};\n  this.multiplier = 1.0 / tolerance;\n};\n\nFuzzyFactory.prototype = {\n  // let obj = f.lookupOrCreate([el1, el2, el3], function(elements) {/* create the new object */});\n  // Performs a fuzzy lookup of the object with the specified elements.\n  // If found, returns the existing object\n  // If not found, calls the supplied callback function which should create a new object with\n  // the specified properties. This object is inserted in the lookup database.\n  lookupOrCreate: function (els, creatorCallback) {\n    let hash = '';\n    let multiplier = this.multiplier;\n    els.forEach(function (el) {\n      let valueQuantized = Math.round(el * multiplier);\n      hash += valueQuantized + '/';\n    });\n    if (hash in this.lookuptable) {\n      return this.lookuptable[hash];\n    } else {\n      let object = creatorCallback(els);\n      let hashparts = els.map(function (el) {\n        let q0 = Math.floor(el * multiplier);\n        let q1 = q0 + 1;\n        return ['' + q0 + '/', '' + q1 + '/'];\n      });\n      let numelements = els.length;\n      let numhashes = 1 << numelements;\n      for (let hashmask = 0; hashmask < numhashes; ++hashmask) {\n        let hashmaskShifted = hashmask;\n        hash = '';\n        hashparts.forEach(function (hashpart) {\n          hash += hashpart[hashmaskShifted & 1];\n          hashmaskShifted >>= 1;\n        });\n        this.lookuptable[hash] = object;\n      }\n      return object;\n    }\n  },\n};\n\nmodule.exports = FuzzyFactory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9GdXp6eUZhY3RvcnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9GdXp6eUZhY3RvcnkuanM/NzNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vICMjIGNsYXNzIGZ1enp5RmFjdG9yeVxuLy8gVGhpcyBjbGFzcyBhY3RzIGFzIGEgZmFjdG9yeSBmb3Igb2JqZWN0cy4gV2UgY2FuIHNlYXJjaCBmb3IgYW4gb2JqZWN0IHdpdGggYXBwcm94aW1hdGVseVxuLy8gdGhlIGRlc2lyZWQgcHJvcGVydGllcyAoc2F5IGEgcmVjdGFuZ2xlIHdpdGggd2lkdGggMiBhbmQgaGVpZ2h0IDEpXG4vLyBUaGUgbG9va3VwT3JDcmVhdGUoKSBtZXRob2QgbG9va3MgZm9yIGFuIGV4aXN0aW5nIG9iamVjdCAoZm9yIGV4YW1wbGUgaXQgbWF5IGZpbmQgYW4gZXhpc3RpbmcgcmVjdGFuZ2xlXG4vLyB3aXRoIHdpZHRoIDIuMDAwMSBhbmQgaGVpZ2h0IDAuOTk5LiBJZiBubyBvYmplY3QgaXMgZm91bmQsIHRoZSB1c2VyIHN1cHBsaWVkIGNhbGxiYWNrIGlzXG4vLyBjYWxsZWQsIHdoaWNoIHNob3VsZCBnZW5lcmF0ZSBhIG5ldyBvYmplY3QuIFRoZSBuZXcgb2JqZWN0IGlzIGluc2VydGVkIGludG8gdGhlIGRhdGFiYXNlXG4vLyBzbyBpdCBjYW4gYmUgZm91bmQgYnkgZnV0dXJlIGxvb2t1cE9yQ3JlYXRlKCkgY2FsbHMuXG4vLyBDb25zdHJ1Y3Rvcjpcbi8vICAgbnVtZGltZW5zaW9uczogdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGZvciBlYWNoIG9iamVjdFxuLy8gICAgIGZvciBleGFtcGxlIGZvciBhIDJEIHJlY3RhbmdsZSB0aGlzIHdvdWxkIGJlIDJcbi8vICAgdG9sZXJhbmNlOiBUaGUgbWF4aW11bSBkaWZmZXJlbmNlIGZvciBlYWNoIHBhcmFtZXRlciBhbGxvd2VkIHRvIGJlIGNvbnNpZGVyZWQgYSBtYXRjaFxuY29uc3QgRnV6enlGYWN0b3J5ID0gZnVuY3Rpb24gKG51bWRpbWVuc2lvbnMsIHRvbGVyYW5jZSkge1xuICB0aGlzLmxvb2t1cHRhYmxlID0ge307XG4gIHRoaXMubXVsdGlwbGllciA9IDEuMCAvIHRvbGVyYW5jZTtcbn07XG5cbkZ1enp5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gIC8vIGxldCBvYmogPSBmLmxvb2t1cE9yQ3JlYXRlKFtlbDEsIGVsMiwgZWwzXSwgZnVuY3Rpb24oZWxlbWVudHMpIHsvKiBjcmVhdGUgdGhlIG5ldyBvYmplY3QgKi99KTtcbiAgLy8gUGVyZm9ybXMgYSBmdXp6eSBsb29rdXAgb2YgdGhlIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgZWxlbWVudHMuXG4gIC8vIElmIGZvdW5kLCByZXR1cm5zIHRoZSBleGlzdGluZyBvYmplY3RcbiAgLy8gSWYgbm90IGZvdW5kLCBjYWxscyB0aGUgc3VwcGxpZWQgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aFxuICAvLyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuIFRoaXMgb2JqZWN0IGlzIGluc2VydGVkIGluIHRoZSBsb29rdXAgZGF0YWJhc2UuXG4gIGxvb2t1cE9yQ3JlYXRlOiBmdW5jdGlvbiAoZWxzLCBjcmVhdG9yQ2FsbGJhY2spIHtcbiAgICBsZXQgaGFzaCA9ICcnO1xuICAgIGxldCBtdWx0aXBsaWVyID0gdGhpcy5tdWx0aXBsaWVyO1xuICAgIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgbGV0IHZhbHVlUXVhbnRpemVkID0gTWF0aC5yb3VuZChlbCAqIG11bHRpcGxpZXIpO1xuICAgICAgaGFzaCArPSB2YWx1ZVF1YW50aXplZCArICcvJztcbiAgICB9KTtcbiAgICBpZiAoaGFzaCBpbiB0aGlzLmxvb2t1cHRhYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29rdXB0YWJsZVtoYXNoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG9iamVjdCA9IGNyZWF0b3JDYWxsYmFjayhlbHMpO1xuICAgICAgbGV0IGhhc2hwYXJ0cyA9IGVscy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGxldCBxMCA9IE1hdGguZmxvb3IoZWwgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgbGV0IHExID0gcTAgKyAxO1xuICAgICAgICByZXR1cm4gWycnICsgcTAgKyAnLycsICcnICsgcTEgKyAnLyddO1xuICAgICAgfSk7XG4gICAgICBsZXQgbnVtZWxlbWVudHMgPSBlbHMubGVuZ3RoO1xuICAgICAgbGV0IG51bWhhc2hlcyA9IDEgPDwgbnVtZWxlbWVudHM7XG4gICAgICBmb3IgKGxldCBoYXNobWFzayA9IDA7IGhhc2htYXNrIDwgbnVtaGFzaGVzOyArK2hhc2htYXNrKSB7XG4gICAgICAgIGxldCBoYXNobWFza1NoaWZ0ZWQgPSBoYXNobWFzaztcbiAgICAgICAgaGFzaCA9ICcnO1xuICAgICAgICBoYXNocGFydHMuZm9yRWFjaChmdW5jdGlvbiAoaGFzaHBhcnQpIHtcbiAgICAgICAgICBoYXNoICs9IGhhc2hwYXJ0W2hhc2htYXNrU2hpZnRlZCAmIDFdO1xuICAgICAgICAgIGhhc2htYXNrU2hpZnRlZCA+Pj0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubG9va3VwdGFibGVbaGFzaF0gPSBvYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnV6enlGYWN0b3J5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/FuzzyFactory.js\n");

/***/ }),

/***/ "./src/core/FuzzyFactory2d.js":
/*!************************************!*\
  !*** ./src/core/FuzzyFactory2d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const FuzzyFactory = __webpack_require__(/*! ./FuzzyFactory */ \"./src/core/FuzzyFactory.js\");\nconst { EPS } = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\nconst Side = __webpack_require__(/*! ./math/Side */ \"./src/core/math/Side.js\");\n\nconst FuzzyCAGFactory = function () {\n  this.vertexfactory = new FuzzyFactory(2, EPS);\n};\n\nFuzzyCAGFactory.prototype = {\n  getVertex: function (sourcevertex) {\n    let elements = [sourcevertex.pos._x, sourcevertex.pos._y];\n    let result = this.vertexfactory.lookupOrCreate(elements, function (els) {\n      return sourcevertex;\n    });\n    return result;\n  },\n\n  getSide: function (sourceside) {\n    let vertex0 = this.getVertex(sourceside.vertex0);\n    let vertex1 = this.getVertex(sourceside.vertex1);\n    return new Side(vertex0, vertex1);\n  },\n};\n\nmodule.exports = FuzzyCAGFactory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9GdXp6eUZhY3RvcnkyZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL0Z1enp5RmFjdG9yeTJkLmpzP2JlNWYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRnV6enlGYWN0b3J5ID0gcmVxdWlyZSgnLi9GdXp6eUZhY3RvcnknKTtcbmNvbnN0IHsgRVBTIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgU2lkZSA9IHJlcXVpcmUoJy4vbWF0aC9TaWRlJyk7XG5cbmNvbnN0IEZ1enp5Q0FHRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy52ZXJ0ZXhmYWN0b3J5ID0gbmV3IEZ1enp5RmFjdG9yeSgyLCBFUFMpO1xufTtcblxuRnV6enlDQUdGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgZ2V0VmVydGV4OiBmdW5jdGlvbiAoc291cmNldmVydGV4KSB7XG4gICAgbGV0IGVsZW1lbnRzID0gW3NvdXJjZXZlcnRleC5wb3MuX3gsIHNvdXJjZXZlcnRleC5wb3MuX3ldO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLnZlcnRleGZhY3RvcnkubG9va3VwT3JDcmVhdGUoZWxlbWVudHMsIGZ1bmN0aW9uIChlbHMpIHtcbiAgICAgIHJldHVybiBzb3VyY2V2ZXJ0ZXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBnZXRTaWRlOiBmdW5jdGlvbiAoc291cmNlc2lkZSkge1xuICAgIGxldCB2ZXJ0ZXgwID0gdGhpcy5nZXRWZXJ0ZXgoc291cmNlc2lkZS52ZXJ0ZXgwKTtcbiAgICBsZXQgdmVydGV4MSA9IHRoaXMuZ2V0VmVydGV4KHNvdXJjZXNpZGUudmVydGV4MSk7XG4gICAgcmV0dXJuIG5ldyBTaWRlKHZlcnRleDAsIHZlcnRleDEpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdXp6eUNBR0ZhY3Rvcnk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/FuzzyFactory2d.js\n");

/***/ }),

/***/ "./src/core/FuzzyFactory3d.js":
/*!************************************!*\
  !*** ./src/core/FuzzyFactory3d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS } = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\nconst Polygon = __webpack_require__(/*! ./math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst FuzzyFactory = __webpack_require__(/*! ./FuzzyFactory */ \"./src/core/FuzzyFactory.js\");\n\n// ////////////////////////////////////\nconst FuzzyCSGFactory = function () {\n  this.vertexfactory = new FuzzyFactory(3, EPS);\n  this.planefactory = new FuzzyFactory(4, EPS);\n  this.polygonsharedfactory = {};\n};\n\nFuzzyCSGFactory.prototype = {\n  getPolygonShared: function (sourceshared) {\n    let hash = sourceshared.getHash();\n    if (hash in this.polygonsharedfactory) {\n      return this.polygonsharedfactory[hash];\n    } else {\n      this.polygonsharedfactory[hash] = sourceshared;\n      return sourceshared;\n    }\n  },\n\n  getVertex: function (sourcevertex) {\n    let elements = [\n      sourcevertex.pos._x,\n      sourcevertex.pos._y,\n      sourcevertex.pos._z,\n    ];\n    let result = this.vertexfactory.lookupOrCreate(elements, function (els) {\n      return sourcevertex;\n    });\n    return result;\n  },\n\n  getPlane: function (sourceplane) {\n    let elements = [\n      sourceplane.normal._x,\n      sourceplane.normal._y,\n      sourceplane.normal._z,\n      sourceplane.w,\n    ];\n    let result = this.planefactory.lookupOrCreate(elements, function (els) {\n      return sourceplane;\n    });\n    return result;\n  },\n\n  getPolygon: function (sourcepolygon) {\n    let newplane = this.getPlane(sourcepolygon.plane);\n    let newshared = this.getPolygonShared(sourcepolygon.shared);\n    let _this = this;\n    let newvertices = sourcepolygon.vertices.map(function (vertex) {\n      return _this.getVertex(vertex);\n    });\n    // two vertices that were originally very close may now have become\n    // truly identical (referring to the same Vertex object).\n    // Remove duplicate vertices:\n    let newverticesDedup = [];\n    if (newvertices.length > 0) {\n      let prevvertextag = newvertices[newvertices.length - 1].getTag();\n      newvertices.forEach(function (vertex) {\n        let vertextag = vertex.getTag();\n        if (vertextag !== prevvertextag) {\n          newverticesDedup.push(vertex);\n        }\n        prevvertextag = vertextag;\n      });\n    }\n    // If it's degenerate, remove all vertices:\n    if (newverticesDedup.length < 3) {\n      newverticesDedup = [];\n    }\n    return new Polygon(newverticesDedup, newshared, newplane);\n  },\n};\n\nmodule.exports = FuzzyCSGFactory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9GdXp6eUZhY3RvcnkzZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL0Z1enp5RmFjdG9yeTNkLmpzPzE5NGUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBFUFMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBQb2x5Z29uID0gcmVxdWlyZSgnLi9tYXRoL1BvbHlnb24zJyk7XG5jb25zdCBGdXp6eUZhY3RvcnkgPSByZXF1aXJlKCcuL0Z1enp5RmFjdG9yeScpO1xuXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IEZ1enp5Q1NHRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy52ZXJ0ZXhmYWN0b3J5ID0gbmV3IEZ1enp5RmFjdG9yeSgzLCBFUFMpO1xuICB0aGlzLnBsYW5lZmFjdG9yeSA9IG5ldyBGdXp6eUZhY3RvcnkoNCwgRVBTKTtcbiAgdGhpcy5wb2x5Z29uc2hhcmVkZmFjdG9yeSA9IHt9O1xufTtcblxuRnV6enlDU0dGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgZ2V0UG9seWdvblNoYXJlZDogZnVuY3Rpb24gKHNvdXJjZXNoYXJlZCkge1xuICAgIGxldCBoYXNoID0gc291cmNlc2hhcmVkLmdldEhhc2goKTtcbiAgICBpZiAoaGFzaCBpbiB0aGlzLnBvbHlnb25zaGFyZWRmYWN0b3J5KSB7XG4gICAgICByZXR1cm4gdGhpcy5wb2x5Z29uc2hhcmVkZmFjdG9yeVtoYXNoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb2x5Z29uc2hhcmVkZmFjdG9yeVtoYXNoXSA9IHNvdXJjZXNoYXJlZDtcbiAgICAgIHJldHVybiBzb3VyY2VzaGFyZWQ7XG4gICAgfVxuICB9LFxuXG4gIGdldFZlcnRleDogZnVuY3Rpb24gKHNvdXJjZXZlcnRleCkge1xuICAgIGxldCBlbGVtZW50cyA9IFtcbiAgICAgIHNvdXJjZXZlcnRleC5wb3MuX3gsXG4gICAgICBzb3VyY2V2ZXJ0ZXgucG9zLl95LFxuICAgICAgc291cmNldmVydGV4LnBvcy5feixcbiAgICBdO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLnZlcnRleGZhY3RvcnkubG9va3VwT3JDcmVhdGUoZWxlbWVudHMsIGZ1bmN0aW9uIChlbHMpIHtcbiAgICAgIHJldHVybiBzb3VyY2V2ZXJ0ZXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBnZXRQbGFuZTogZnVuY3Rpb24gKHNvdXJjZXBsYW5lKSB7XG4gICAgbGV0IGVsZW1lbnRzID0gW1xuICAgICAgc291cmNlcGxhbmUubm9ybWFsLl94LFxuICAgICAgc291cmNlcGxhbmUubm9ybWFsLl95LFxuICAgICAgc291cmNlcGxhbmUubm9ybWFsLl96LFxuICAgICAgc291cmNlcGxhbmUudyxcbiAgICBdO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLnBsYW5lZmFjdG9yeS5sb29rdXBPckNyZWF0ZShlbGVtZW50cywgZnVuY3Rpb24gKGVscykge1xuICAgICAgcmV0dXJuIHNvdXJjZXBsYW5lO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgZ2V0UG9seWdvbjogZnVuY3Rpb24gKHNvdXJjZXBvbHlnb24pIHtcbiAgICBsZXQgbmV3cGxhbmUgPSB0aGlzLmdldFBsYW5lKHNvdXJjZXBvbHlnb24ucGxhbmUpO1xuICAgIGxldCBuZXdzaGFyZWQgPSB0aGlzLmdldFBvbHlnb25TaGFyZWQoc291cmNlcG9seWdvbi5zaGFyZWQpO1xuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IG5ld3ZlcnRpY2VzID0gc291cmNlcG9seWdvbi52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHZlcnRleCkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldFZlcnRleCh2ZXJ0ZXgpO1xuICAgIH0pO1xuICAgIC8vIHR3byB2ZXJ0aWNlcyB0aGF0IHdlcmUgb3JpZ2luYWxseSB2ZXJ5IGNsb3NlIG1heSBub3cgaGF2ZSBiZWNvbWVcbiAgICAvLyB0cnVseSBpZGVudGljYWwgKHJlZmVycmluZyB0byB0aGUgc2FtZSBWZXJ0ZXggb2JqZWN0KS5cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIHZlcnRpY2VzOlxuICAgIGxldCBuZXd2ZXJ0aWNlc0RlZHVwID0gW107XG4gICAgaWYgKG5ld3ZlcnRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBwcmV2dmVydGV4dGFnID0gbmV3dmVydGljZXNbbmV3dmVydGljZXMubGVuZ3RoIC0gMV0uZ2V0VGFnKCk7XG4gICAgICBuZXd2ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgbGV0IHZlcnRleHRhZyA9IHZlcnRleC5nZXRUYWcoKTtcbiAgICAgICAgaWYgKHZlcnRleHRhZyAhPT0gcHJldnZlcnRleHRhZykge1xuICAgICAgICAgIG5ld3ZlcnRpY2VzRGVkdXAucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZ2ZXJ0ZXh0YWcgPSB2ZXJ0ZXh0YWc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgaXQncyBkZWdlbmVyYXRlLCByZW1vdmUgYWxsIHZlcnRpY2VzOlxuICAgIGlmIChuZXd2ZXJ0aWNlc0RlZHVwLmxlbmd0aCA8IDMpIHtcbiAgICAgIG5ld3ZlcnRpY2VzRGVkdXAgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKG5ld3ZlcnRpY2VzRGVkdXAsIG5ld3NoYXJlZCwgbmV3cGxhbmUpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdXp6eUNTR0ZhY3Rvcnk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/FuzzyFactory3d.js\n");

/***/ }),

/***/ "./src/core/Properties.js":
/*!********************************!*\
  !*** ./src/core/Properties.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// ////////////////////////////////////\n// # Class Properties\n// This class is used to store properties of a solid\n// A property can for example be a Vertex, a Plane or a Line3D\n// Whenever an affine transform is applied to the CSG solid, all its properties are\n// transformed as well.\n// The properties can be stored in a complex nested structure (using arrays and objects)\nconst Properties = function () {};\n\nProperties.prototype = {\n  _transform: function (matrix4x4) {\n    let result = new Properties();\n    Properties.transformObj(this, result, matrix4x4);\n    return result;\n  },\n  _merge: function (otherproperties) {\n    let result = new Properties();\n    Properties.cloneObj(this, result);\n    Properties.addFrom(result, otherproperties);\n    return result;\n  },\n};\n\nProperties.transformObj = function (source, result, matrix4x4) {\n  for (let propertyname in source) {\n    if (propertyname === '_transform') continue;\n    if (propertyname === '_merge') continue;\n    let propertyvalue = source[propertyname];\n    let transformed = propertyvalue;\n    if (typeof propertyvalue === 'object') {\n      if (\n        'transform' in propertyvalue &&\n        typeof propertyvalue.transform === 'function'\n      ) {\n        transformed = propertyvalue.transform(matrix4x4);\n      } else if (propertyvalue instanceof Array) {\n        transformed = [];\n        Properties.transformObj(propertyvalue, transformed, matrix4x4);\n      } else if (propertyvalue instanceof Properties) {\n        transformed = new Properties();\n        Properties.transformObj(propertyvalue, transformed, matrix4x4);\n      }\n    }\n    result[propertyname] = transformed;\n  }\n};\n\nProperties.cloneObj = function (source, result) {\n  for (let propertyname in source) {\n    if (propertyname === '_transform') continue;\n    if (propertyname === '_merge') continue;\n    let propertyvalue = source[propertyname];\n    let cloned = propertyvalue;\n    if (typeof propertyvalue === 'object') {\n      if (propertyvalue instanceof Array) {\n        cloned = [];\n        for (let i = 0; i < propertyvalue.length; i++) {\n          cloned.push(propertyvalue[i]);\n        }\n      } else if (propertyvalue instanceof Properties) {\n        cloned = new Properties();\n        Properties.cloneObj(propertyvalue, cloned);\n      }\n    }\n    result[propertyname] = cloned;\n  }\n};\n\nProperties.addFrom = function (result, otherproperties) {\n  for (let propertyname in otherproperties) {\n    if (propertyname === '_transform') continue;\n    if (propertyname === '_merge') continue;\n    if (\n      propertyname in result &&\n      typeof result[propertyname] === 'object' &&\n      result[propertyname] instanceof Properties &&\n      typeof otherproperties[propertyname] === 'object' &&\n      otherproperties[propertyname] instanceof Properties\n    ) {\n      Properties.addFrom(result[propertyname], otherproperties[propertyname]);\n    } else if (!(propertyname in result)) {\n      result[propertyname] = otherproperties[propertyname];\n    }\n  }\n};\n\nmodule.exports = Properties;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9Qcm9wZXJ0aWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvUHJvcGVydGllcy5qcz9kZjQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gIyBDbGFzcyBQcm9wZXJ0aWVzXG4vLyBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gc3RvcmUgcHJvcGVydGllcyBvZiBhIHNvbGlkXG4vLyBBIHByb3BlcnR5IGNhbiBmb3IgZXhhbXBsZSBiZSBhIFZlcnRleCwgYSBQbGFuZSBvciBhIExpbmUzRFxuLy8gV2hlbmV2ZXIgYW4gYWZmaW5lIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBDU0cgc29saWQsIGFsbCBpdHMgcHJvcGVydGllcyBhcmVcbi8vIHRyYW5zZm9ybWVkIGFzIHdlbGwuXG4vLyBUaGUgcHJvcGVydGllcyBjYW4gYmUgc3RvcmVkIGluIGEgY29tcGxleCBuZXN0ZWQgc3RydWN0dXJlICh1c2luZyBhcnJheXMgYW5kIG9iamVjdHMpXG5jb25zdCBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge307XG5cblByb3BlcnRpZXMucHJvdG90eXBlID0ge1xuICBfdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4NHg0KSB7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgUHJvcGVydGllcy50cmFuc2Zvcm1PYmoodGhpcywgcmVzdWx0LCBtYXRyaXg0eDQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIF9tZXJnZTogZnVuY3Rpb24gKG90aGVycHJvcGVydGllcykge1xuICAgIGxldCByZXN1bHQgPSBuZXcgUHJvcGVydGllcygpO1xuICAgIFByb3BlcnRpZXMuY2xvbmVPYmoodGhpcywgcmVzdWx0KTtcbiAgICBQcm9wZXJ0aWVzLmFkZEZyb20ocmVzdWx0LCBvdGhlcnByb3BlcnRpZXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG59O1xuXG5Qcm9wZXJ0aWVzLnRyYW5zZm9ybU9iaiA9IGZ1bmN0aW9uIChzb3VyY2UsIHJlc3VsdCwgbWF0cml4NHg0KSB7XG4gIGZvciAobGV0IHByb3BlcnR5bmFtZSBpbiBzb3VyY2UpIHtcbiAgICBpZiAocHJvcGVydHluYW1lID09PSAnX3RyYW5zZm9ybScpIGNvbnRpbnVlO1xuICAgIGlmIChwcm9wZXJ0eW5hbWUgPT09ICdfbWVyZ2UnKSBjb250aW51ZTtcbiAgICBsZXQgcHJvcGVydHl2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eW5hbWVdO1xuICAgIGxldCB0cmFuc2Zvcm1lZCA9IHByb3BlcnR5dmFsdWU7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eXZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKFxuICAgICAgICAndHJhbnNmb3JtJyBpbiBwcm9wZXJ0eXZhbHVlICYmXG4gICAgICAgIHR5cGVvZiBwcm9wZXJ0eXZhbHVlLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkID0gcHJvcGVydHl2YWx1ZS50cmFuc2Zvcm0obWF0cml4NHg0KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHl2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHRyYW5zZm9ybWVkID0gW107XG4gICAgICAgIFByb3BlcnRpZXMudHJhbnNmb3JtT2JqKHByb3BlcnR5dmFsdWUsIHRyYW5zZm9ybWVkLCBtYXRyaXg0eDQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eXZhbHVlIGluc3RhbmNlb2YgUHJvcGVydGllcykge1xuICAgICAgICB0cmFuc2Zvcm1lZCA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIFByb3BlcnRpZXMudHJhbnNmb3JtT2JqKHByb3BlcnR5dmFsdWUsIHRyYW5zZm9ybWVkLCBtYXRyaXg0eDQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHRbcHJvcGVydHluYW1lXSA9IHRyYW5zZm9ybWVkO1xuICB9XG59O1xuXG5Qcm9wZXJ0aWVzLmNsb25lT2JqID0gZnVuY3Rpb24gKHNvdXJjZSwgcmVzdWx0KSB7XG4gIGZvciAobGV0IHByb3BlcnR5bmFtZSBpbiBzb3VyY2UpIHtcbiAgICBpZiAocHJvcGVydHluYW1lID09PSAnX3RyYW5zZm9ybScpIGNvbnRpbnVlO1xuICAgIGlmIChwcm9wZXJ0eW5hbWUgPT09ICdfbWVyZ2UnKSBjb250aW51ZTtcbiAgICBsZXQgcHJvcGVydHl2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eW5hbWVdO1xuICAgIGxldCBjbG9uZWQgPSBwcm9wZXJ0eXZhbHVlO1xuICAgIGlmICh0eXBlb2YgcHJvcGVydHl2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wZXJ0eXZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY2xvbmVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydHl2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNsb25lZC5wdXNoKHByb3BlcnR5dmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5dmFsdWUgaW5zdGFuY2VvZiBQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNsb25lZCA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIFByb3BlcnRpZXMuY2xvbmVPYmoocHJvcGVydHl2YWx1ZSwgY2xvbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0W3Byb3BlcnR5bmFtZV0gPSBjbG9uZWQ7XG4gIH1cbn07XG5cblByb3BlcnRpZXMuYWRkRnJvbSA9IGZ1bmN0aW9uIChyZXN1bHQsIG90aGVycHJvcGVydGllcykge1xuICBmb3IgKGxldCBwcm9wZXJ0eW5hbWUgaW4gb3RoZXJwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb3BlcnR5bmFtZSA9PT0gJ190cmFuc2Zvcm0nKSBjb250aW51ZTtcbiAgICBpZiAocHJvcGVydHluYW1lID09PSAnX21lcmdlJykgY29udGludWU7XG4gICAgaWYgKFxuICAgICAgcHJvcGVydHluYW1lIGluIHJlc3VsdCAmJlxuICAgICAgdHlwZW9mIHJlc3VsdFtwcm9wZXJ0eW5hbWVdID09PSAnb2JqZWN0JyAmJlxuICAgICAgcmVzdWx0W3Byb3BlcnR5bmFtZV0gaW5zdGFuY2VvZiBQcm9wZXJ0aWVzICYmXG4gICAgICB0eXBlb2Ygb3RoZXJwcm9wZXJ0aWVzW3Byb3BlcnR5bmFtZV0gPT09ICdvYmplY3QnICYmXG4gICAgICBvdGhlcnByb3BlcnRpZXNbcHJvcGVydHluYW1lXSBpbnN0YW5jZW9mIFByb3BlcnRpZXNcbiAgICApIHtcbiAgICAgIFByb3BlcnRpZXMuYWRkRnJvbShyZXN1bHRbcHJvcGVydHluYW1lXSwgb3RoZXJwcm9wZXJ0aWVzW3Byb3BlcnR5bmFtZV0pO1xuICAgIH0gZWxzZSBpZiAoIShwcm9wZXJ0eW5hbWUgaW4gcmVzdWx0KSkge1xuICAgICAgcmVzdWx0W3Byb3BlcnR5bmFtZV0gPSBvdGhlcnByb3BlcnRpZXNbcHJvcGVydHluYW1lXTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvcGVydGllcztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/Properties.js\n");

/***/ }),

/***/ "./src/core/connectors.js":
/*!********************************!*\
  !*** ./src/core/connectors.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ./math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Line3D = __webpack_require__(/*! ./math/Line3 */ \"./src/core/math/Line3.js\");\nconst Matrix4x4 = __webpack_require__(/*! ./math/Matrix4 */ \"./src/core/math/Matrix4.js\");\nconst OrthoNormalBasis = __webpack_require__(/*! ./math/OrthoNormalBasis */ \"./src/core/math/OrthoNormalBasis.js\");\nconst Plane = __webpack_require__(/*! ./math/Plane */ \"./src/core/math/Plane.js\");\n\n// # class Connector\n// A connector allows to attach two objects at predefined positions\n// For example a servo motor and a servo horn:\n// Both can have a Connector called 'shaft'\n// The horn can be moved and rotated such that the two connectors match\n// and the horn is attached to the servo motor at the proper position.\n// Connectors are stored in the properties of a CSG solid so they are\n// ge the same transformations applied as the solid\nconst Connector = function (point, axisvector, normalvector) {\n  this.point = new Vector3D(point);\n  this.axisvector = new Vector3D(axisvector).unit();\n  this.normalvector = new Vector3D(normalvector).unit();\n};\n\nConnector.prototype = {\n  normalized: function () {\n    let axisvector = this.axisvector.unit();\n    // make the normal vector truly normal:\n    let n = this.normalvector.cross(axisvector).unit();\n    let normalvector = axisvector.cross(n);\n    return new Connector(this.point, axisvector, normalvector);\n  },\n\n  transform: function (matrix4x4) {\n    let point = this.point.multiply4x4(matrix4x4);\n    let axisvector = this.point\n      .plus(this.axisvector)\n      .multiply4x4(matrix4x4)\n      .minus(point);\n    let normalvector = this.point\n      .plus(this.normalvector)\n      .multiply4x4(matrix4x4)\n      .minus(point);\n    return new Connector(point, axisvector, normalvector);\n  },\n\n  // Get the transformation matrix to connect this Connector to another connector\n  //   other: a Connector to which this connector should be connected\n  //   mirror: false: the 'axis' vectors of the connectors should point in the same direction\n  //           true: the 'axis' vectors of the connectors should point in opposite direction\n  //   normalrotation: degrees of rotation between the 'normal' vectors of the two\n  //                   connectors\n  getTransformationTo: function (other, mirror, normalrotation) {\n    mirror = mirror ? true : false;\n    normalrotation = normalrotation ? Number(normalrotation) : 0;\n    let us = this.normalized();\n    other = other.normalized();\n    // shift to the origin:\n    let transformation = Matrix4x4.translation(this.point.negated());\n    // construct the plane crossing through the origin and the two axes:\n    let axesplane = Plane.anyPlaneFromVector3Ds(\n      new Vector3D(0, 0, 0),\n      us.axisvector,\n      other.axisvector\n    );\n    let axesbasis = new OrthoNormalBasis(axesplane);\n    let angle1 = axesbasis.to2D(us.axisvector).angle();\n    let angle2 = axesbasis.to2D(other.axisvector).angle();\n    let rotation = (180.0 * (angle2 - angle1)) / Math.PI;\n    if (mirror) rotation += 180.0;\n    transformation = transformation.multiply(axesbasis.getProjectionMatrix());\n    transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));\n    transformation = transformation.multiply(\n      axesbasis.getInverseProjectionMatrix()\n    );\n    let usAxesAligned = us.transform(transformation);\n    // Now we have done the transformation for aligning the axes.\n    // We still need to align the normals:\n    let normalsplane = Plane.fromNormalAndPoint(\n      other.axisvector,\n      new Vector3D(0, 0, 0)\n    );\n    let normalsbasis = new OrthoNormalBasis(normalsplane);\n    angle1 = normalsbasis.to2D(usAxesAligned.normalvector).angle();\n    angle2 = normalsbasis.to2D(other.normalvector).angle();\n    rotation = (180.0 * (angle2 - angle1)) / Math.PI;\n    rotation += normalrotation;\n    transformation = transformation.multiply(\n      normalsbasis.getProjectionMatrix()\n    );\n    transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));\n    transformation = transformation.multiply(\n      normalsbasis.getInverseProjectionMatrix()\n    );\n    // and translate to the destination point:\n    transformation = transformation.multiply(\n      Matrix4x4.translation(other.point)\n    );\n    // let usAligned = us.transform(transformation);\n    return transformation;\n  },\n\n  axisLine: function () {\n    return new Line3D(this.point, this.axisvector);\n  },\n\n  // creates a new Connector, with the connection point moved in the direction of the axisvector\n  extend: function (distance) {\n    let newpoint = this.point.plus(this.axisvector.unit().times(distance));\n    return new Connector(newpoint, this.axisvector, this.normalvector);\n  },\n};\n\nconst ConnectorList = function (connectors) {\n  this.connectors_ = connectors ? connectors.slice() : [];\n};\n\nConnectorList.defaultNormal = [0, 0, 1];\n\nConnectorList.fromPath2D = function (path2D, arg1, arg2) {\n  if (arguments.length === 3) {\n    return ConnectorList._fromPath2DTangents(path2D, arg1, arg2);\n  } else if (arguments.length === 2) {\n    return ConnectorList._fromPath2DExplicit(path2D, arg1);\n  } else {\n    throw new Error(\n      'call with path2D and either 2 direction vectors, or a function returning direction vectors'\n    );\n  }\n};\n\n/*\n * calculate the connector axisvectors by calculating the \"tangent\" for path2D.\n * This is undefined for start and end points, so axis for these have to be manually\n * provided.\n */\nConnectorList._fromPath2DTangents = function (path2D, start, end) {\n  // path2D\n  let axis;\n  let pathLen = path2D.points.length;\n  let result = new ConnectorList([\n    new Connector(path2D.points[0], start, ConnectorList.defaultNormal),\n  ]);\n  // middle points\n  path2D.points.slice(1, pathLen - 1).forEach(function (p2, i) {\n    axis = path2D.points[i + 2].minus(path2D.points[i]).toVector3D(0);\n    result.appendConnector(\n      new Connector(p2.toVector3D(0), axis, ConnectorList.defaultNormal)\n    );\n  }, this);\n  result.appendConnector(\n    new Connector(path2D.points[pathLen - 1], end, ConnectorList.defaultNormal)\n  );\n  result.closed = path2D.closed;\n  return result;\n};\n\n/*\n * angleIsh: either a static angle, or a function(point) returning an angle\n */\nConnectorList._fromPath2DExplicit = function (path2D, angleIsh) {\n  function getAngle(angleIsh, pt, i) {\n    if (typeof angleIsh === 'function') {\n      angleIsh = angleIsh(pt, i);\n    }\n    return angleIsh;\n  }\n  let result = new ConnectorList(\n    path2D.points.map(function (p2, i) {\n      return new Connector(\n        p2.toVector3D(0),\n        Vector3D.Create(1, 0, 0).rotateZ(getAngle(angleIsh, p2, i)),\n        ConnectorList.defaultNormal\n      );\n    }, this)\n  );\n  result.closed = path2D.closed;\n  return result;\n};\n\nConnectorList.prototype = {\n  setClosed: function (closed) {\n    this.closed = !!closed;\n  },\n  appendConnector: function (conn) {\n    this.connectors_.push(conn);\n  },\n  /*\n   * arguments: cagish: a cag or a function(connector) returning a cag\n   *            closed: whether the 3d path defined by connectors location\n   *              should be closed or stay open\n   *              Note: don't duplicate connectors in the path\n   * TODO: consider an option \"maySelfIntersect\" to close & force union all single segments\n   */\n  followWith: function (cagish) {\n    const CSG = __webpack_require__(/*! ./CSG */ \"./src/core/CSG.js\"); // FIXME , circular dependency connectors => CSG => connectors\n\n    this.verify();\n    function getCag(cagish, connector) {\n      if (typeof cagish === 'function') {\n        cagish = cagish(\n          connector.point,\n          connector.axisvector,\n          connector.normalvector\n        );\n      }\n      return cagish;\n    }\n\n    let polygons = [];\n    let currCag;\n    let prevConnector = this.connectors_[this.connectors_.length - 1];\n    let prevCag = getCag(cagish, prevConnector);\n    // add walls\n    this.connectors_.forEach(function (connector, notFirst) {\n      currCag = getCag(cagish, connector);\n      if (notFirst || this.closed) {\n        polygons.push.apply(\n          polygons,\n          prevCag._toWallPolygons({\n            toConnector1: prevConnector,\n            toConnector2: connector,\n            cag: currCag,\n          })\n        );\n      } else {\n        // it is the first, and shape not closed -> build start wall\n        polygons.push.apply(\n          polygons,\n          currCag._toPlanePolygons({ toConnector: connector, flipped: true })\n        );\n      }\n      if (notFirst === this.connectors_.length - 1 && !this.closed) {\n        // build end wall\n        polygons.push.apply(\n          polygons,\n          currCag._toPlanePolygons({ toConnector: connector })\n        );\n      }\n      prevCag = currCag;\n      prevConnector = connector;\n    }, this);\n    return CSG.fromPolygons(polygons).reTesselated().canonicalized();\n  },\n  /*\n   * general idea behind these checks: connectors need to have smooth transition from one to another\n   * TODO: add a check that 2 follow-on CAGs are not intersecting\n   */\n  verify: function () {\n    let connI;\n    let connI1;\n    for (let i = 0; i < this.connectors_.length - 1; i++) {\n      connI = this.connectors_[i];\n      connI1 = this.connectors_[i + 1];\n      if (connI1.point.minus(connI.point).dot(connI.axisvector) <= 0) {\n        throw new Error(\n          'Invalid ConnectorList. Each connectors position needs to be within a <90deg range of previous connectors axisvector'\n        );\n      }\n      if (connI.axisvector.dot(connI1.axisvector) <= 0) {\n        throw new Error(\n          'invalid ConnectorList. No neighboring connectors axisvectors may span a >=90deg angle'\n        );\n      }\n    }\n  },\n};\n\nmodule.exports = { Connector, ConnectorList };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb25uZWN0b3JzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvY29ubmVjdG9ycy5qcz85MGVkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlY3RvcjNEID0gcmVxdWlyZSgnLi9tYXRoL1ZlY3RvcjMnKTtcbmNvbnN0IExpbmUzRCA9IHJlcXVpcmUoJy4vbWF0aC9MaW5lMycpO1xuY29uc3QgTWF0cml4NHg0ID0gcmVxdWlyZSgnLi9tYXRoL01hdHJpeDQnKTtcbmNvbnN0IE9ydGhvTm9ybWFsQmFzaXMgPSByZXF1aXJlKCcuL21hdGgvT3J0aG9Ob3JtYWxCYXNpcycpO1xuY29uc3QgUGxhbmUgPSByZXF1aXJlKCcuL21hdGgvUGxhbmUnKTtcblxuLy8gIyBjbGFzcyBDb25uZWN0b3Jcbi8vIEEgY29ubmVjdG9yIGFsbG93cyB0byBhdHRhY2ggdHdvIG9iamVjdHMgYXQgcHJlZGVmaW5lZCBwb3NpdGlvbnNcbi8vIEZvciBleGFtcGxlIGEgc2Vydm8gbW90b3IgYW5kIGEgc2Vydm8gaG9ybjpcbi8vIEJvdGggY2FuIGhhdmUgYSBDb25uZWN0b3IgY2FsbGVkICdzaGFmdCdcbi8vIFRoZSBob3JuIGNhbiBiZSBtb3ZlZCBhbmQgcm90YXRlZCBzdWNoIHRoYXQgdGhlIHR3byBjb25uZWN0b3JzIG1hdGNoXG4vLyBhbmQgdGhlIGhvcm4gaXMgYXR0YWNoZWQgdG8gdGhlIHNlcnZvIG1vdG9yIGF0IHRoZSBwcm9wZXIgcG9zaXRpb24uXG4vLyBDb25uZWN0b3JzIGFyZSBzdG9yZWQgaW4gdGhlIHByb3BlcnRpZXMgb2YgYSBDU0cgc29saWQgc28gdGhleSBhcmVcbi8vIGdlIHRoZSBzYW1lIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIGFzIHRoZSBzb2xpZFxuY29uc3QgQ29ubmVjdG9yID0gZnVuY3Rpb24gKHBvaW50LCBheGlzdmVjdG9yLCBub3JtYWx2ZWN0b3IpIHtcbiAgdGhpcy5wb2ludCA9IG5ldyBWZWN0b3IzRChwb2ludCk7XG4gIHRoaXMuYXhpc3ZlY3RvciA9IG5ldyBWZWN0b3IzRChheGlzdmVjdG9yKS51bml0KCk7XG4gIHRoaXMubm9ybWFsdmVjdG9yID0gbmV3IFZlY3RvcjNEKG5vcm1hbHZlY3RvcikudW5pdCgpO1xufTtcblxuQ29ubmVjdG9yLnByb3RvdHlwZSA9IHtcbiAgbm9ybWFsaXplZDogZnVuY3Rpb24gKCkge1xuICAgIGxldCBheGlzdmVjdG9yID0gdGhpcy5heGlzdmVjdG9yLnVuaXQoKTtcbiAgICAvLyBtYWtlIHRoZSBub3JtYWwgdmVjdG9yIHRydWx5IG5vcm1hbDpcbiAgICBsZXQgbiA9IHRoaXMubm9ybWFsdmVjdG9yLmNyb3NzKGF4aXN2ZWN0b3IpLnVuaXQoKTtcbiAgICBsZXQgbm9ybWFsdmVjdG9yID0gYXhpc3ZlY3Rvci5jcm9zcyhuKTtcbiAgICByZXR1cm4gbmV3IENvbm5lY3Rvcih0aGlzLnBvaW50LCBheGlzdmVjdG9yLCBub3JtYWx2ZWN0b3IpO1xuICB9LFxuXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1hdHJpeDR4NCkge1xuICAgIGxldCBwb2ludCA9IHRoaXMucG9pbnQubXVsdGlwbHk0eDQobWF0cml4NHg0KTtcbiAgICBsZXQgYXhpc3ZlY3RvciA9IHRoaXMucG9pbnRcbiAgICAgIC5wbHVzKHRoaXMuYXhpc3ZlY3RvcilcbiAgICAgIC5tdWx0aXBseTR4NChtYXRyaXg0eDQpXG4gICAgICAubWludXMocG9pbnQpO1xuICAgIGxldCBub3JtYWx2ZWN0b3IgPSB0aGlzLnBvaW50XG4gICAgICAucGx1cyh0aGlzLm5vcm1hbHZlY3RvcilcbiAgICAgIC5tdWx0aXBseTR4NChtYXRyaXg0eDQpXG4gICAgICAubWludXMocG9pbnQpO1xuICAgIHJldHVybiBuZXcgQ29ubmVjdG9yKHBvaW50LCBheGlzdmVjdG9yLCBub3JtYWx2ZWN0b3IpO1xuICB9LFxuXG4gIC8vIEdldCB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRvIGNvbm5lY3QgdGhpcyBDb25uZWN0b3IgdG8gYW5vdGhlciBjb25uZWN0b3JcbiAgLy8gICBvdGhlcjogYSBDb25uZWN0b3IgdG8gd2hpY2ggdGhpcyBjb25uZWN0b3Igc2hvdWxkIGJlIGNvbm5lY3RlZFxuICAvLyAgIG1pcnJvcjogZmFsc2U6IHRoZSAnYXhpcycgdmVjdG9ycyBvZiB0aGUgY29ubmVjdG9ycyBzaG91bGQgcG9pbnQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXG4gIC8vICAgICAgICAgICB0cnVlOiB0aGUgJ2F4aXMnIHZlY3RvcnMgb2YgdGhlIGNvbm5lY3RvcnMgc2hvdWxkIHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvblxuICAvLyAgIG5vcm1hbHJvdGF0aW9uOiBkZWdyZWVzIG9mIHJvdGF0aW9uIGJldHdlZW4gdGhlICdub3JtYWwnIHZlY3RvcnMgb2YgdGhlIHR3b1xuICAvLyAgICAgICAgICAgICAgICAgICBjb25uZWN0b3JzXG4gIGdldFRyYW5zZm9ybWF0aW9uVG86IGZ1bmN0aW9uIChvdGhlciwgbWlycm9yLCBub3JtYWxyb3RhdGlvbikge1xuICAgIG1pcnJvciA9IG1pcnJvciA/IHRydWUgOiBmYWxzZTtcbiAgICBub3JtYWxyb3RhdGlvbiA9IG5vcm1hbHJvdGF0aW9uID8gTnVtYmVyKG5vcm1hbHJvdGF0aW9uKSA6IDA7XG4gICAgbGV0IHVzID0gdGhpcy5ub3JtYWxpemVkKCk7XG4gICAgb3RoZXIgPSBvdGhlci5ub3JtYWxpemVkKCk7XG4gICAgLy8gc2hpZnQgdG8gdGhlIG9yaWdpbjpcbiAgICBsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXRyaXg0eDQudHJhbnNsYXRpb24odGhpcy5wb2ludC5uZWdhdGVkKCkpO1xuICAgIC8vIGNvbnN0cnVjdCB0aGUgcGxhbmUgY3Jvc3NpbmcgdGhyb3VnaCB0aGUgb3JpZ2luIGFuZCB0aGUgdHdvIGF4ZXM6XG4gICAgbGV0IGF4ZXNwbGFuZSA9IFBsYW5lLmFueVBsYW5lRnJvbVZlY3RvcjNEcyhcbiAgICAgIG5ldyBWZWN0b3IzRCgwLCAwLCAwKSxcbiAgICAgIHVzLmF4aXN2ZWN0b3IsXG4gICAgICBvdGhlci5heGlzdmVjdG9yXG4gICAgKTtcbiAgICBsZXQgYXhlc2Jhc2lzID0gbmV3IE9ydGhvTm9ybWFsQmFzaXMoYXhlc3BsYW5lKTtcbiAgICBsZXQgYW5nbGUxID0gYXhlc2Jhc2lzLnRvMkQodXMuYXhpc3ZlY3RvcikuYW5nbGUoKTtcbiAgICBsZXQgYW5nbGUyID0gYXhlc2Jhc2lzLnRvMkQob3RoZXIuYXhpc3ZlY3RvcikuYW5nbGUoKTtcbiAgICBsZXQgcm90YXRpb24gPSAoMTgwLjAgKiAoYW5nbGUyIC0gYW5nbGUxKSkgLyBNYXRoLlBJO1xuICAgIGlmIChtaXJyb3IpIHJvdGF0aW9uICs9IDE4MC4wO1xuICAgIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24ubXVsdGlwbHkoYXhlc2Jhc2lzLmdldFByb2plY3Rpb25NYXRyaXgoKSk7XG4gICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbi5tdWx0aXBseShNYXRyaXg0eDQucm90YXRpb25aKHJvdGF0aW9uKSk7XG4gICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbi5tdWx0aXBseShcbiAgICAgIGF4ZXNiYXNpcy5nZXRJbnZlcnNlUHJvamVjdGlvbk1hdHJpeCgpXG4gICAgKTtcbiAgICBsZXQgdXNBeGVzQWxpZ25lZCA9IHVzLnRyYW5zZm9ybSh0cmFuc2Zvcm1hdGlvbik7XG4gICAgLy8gTm93IHdlIGhhdmUgZG9uZSB0aGUgdHJhbnNmb3JtYXRpb24gZm9yIGFsaWduaW5nIHRoZSBheGVzLlxuICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gYWxpZ24gdGhlIG5vcm1hbHM6XG4gICAgbGV0IG5vcm1hbHNwbGFuZSA9IFBsYW5lLmZyb21Ob3JtYWxBbmRQb2ludChcbiAgICAgIG90aGVyLmF4aXN2ZWN0b3IsXG4gICAgICBuZXcgVmVjdG9yM0QoMCwgMCwgMClcbiAgICApO1xuICAgIGxldCBub3JtYWxzYmFzaXMgPSBuZXcgT3J0aG9Ob3JtYWxCYXNpcyhub3JtYWxzcGxhbmUpO1xuICAgIGFuZ2xlMSA9IG5vcm1hbHNiYXNpcy50bzJEKHVzQXhlc0FsaWduZWQubm9ybWFsdmVjdG9yKS5hbmdsZSgpO1xuICAgIGFuZ2xlMiA9IG5vcm1hbHNiYXNpcy50bzJEKG90aGVyLm5vcm1hbHZlY3RvcikuYW5nbGUoKTtcbiAgICByb3RhdGlvbiA9ICgxODAuMCAqIChhbmdsZTIgLSBhbmdsZTEpKSAvIE1hdGguUEk7XG4gICAgcm90YXRpb24gKz0gbm9ybWFscm90YXRpb247XG4gICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbi5tdWx0aXBseShcbiAgICAgIG5vcm1hbHNiYXNpcy5nZXRQcm9qZWN0aW9uTWF0cml4KClcbiAgICApO1xuICAgIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24ubXVsdGlwbHkoTWF0cml4NHg0LnJvdGF0aW9uWihyb3RhdGlvbikpO1xuICAgIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24ubXVsdGlwbHkoXG4gICAgICBub3JtYWxzYmFzaXMuZ2V0SW52ZXJzZVByb2plY3Rpb25NYXRyaXgoKVxuICAgICk7XG4gICAgLy8gYW5kIHRyYW5zbGF0ZSB0byB0aGUgZGVzdGluYXRpb24gcG9pbnQ6XG4gICAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbi5tdWx0aXBseShcbiAgICAgIE1hdHJpeDR4NC50cmFuc2xhdGlvbihvdGhlci5wb2ludClcbiAgICApO1xuICAgIC8vIGxldCB1c0FsaWduZWQgPSB1cy50cmFuc2Zvcm0odHJhbnNmb3JtYXRpb24pO1xuICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbjtcbiAgfSxcblxuICBheGlzTGluZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTGluZTNEKHRoaXMucG9pbnQsIHRoaXMuYXhpc3ZlY3Rvcik7XG4gIH0sXG5cbiAgLy8gY3JlYXRlcyBhIG5ldyBDb25uZWN0b3IsIHdpdGggdGhlIGNvbm5lY3Rpb24gcG9pbnQgbW92ZWQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgYXhpc3ZlY3RvclxuICBleHRlbmQ6IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgIGxldCBuZXdwb2ludCA9IHRoaXMucG9pbnQucGx1cyh0aGlzLmF4aXN2ZWN0b3IudW5pdCgpLnRpbWVzKGRpc3RhbmNlKSk7XG4gICAgcmV0dXJuIG5ldyBDb25uZWN0b3IobmV3cG9pbnQsIHRoaXMuYXhpc3ZlY3RvciwgdGhpcy5ub3JtYWx2ZWN0b3IpO1xuICB9LFxufTtcblxuY29uc3QgQ29ubmVjdG9yTGlzdCA9IGZ1bmN0aW9uIChjb25uZWN0b3JzKSB7XG4gIHRoaXMuY29ubmVjdG9yc18gPSBjb25uZWN0b3JzID8gY29ubmVjdG9ycy5zbGljZSgpIDogW107XG59O1xuXG5Db25uZWN0b3JMaXN0LmRlZmF1bHROb3JtYWwgPSBbMCwgMCwgMV07XG5cbkNvbm5lY3Rvckxpc3QuZnJvbVBhdGgyRCA9IGZ1bmN0aW9uIChwYXRoMkQsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gQ29ubmVjdG9yTGlzdC5fZnJvbVBhdGgyRFRhbmdlbnRzKHBhdGgyRCwgYXJnMSwgYXJnMik7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBDb25uZWN0b3JMaXN0Ll9mcm9tUGF0aDJERXhwbGljaXQocGF0aDJELCBhcmcxKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnY2FsbCB3aXRoIHBhdGgyRCBhbmQgZWl0aGVyIDIgZGlyZWN0aW9uIHZlY3RvcnMsIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGRpcmVjdGlvbiB2ZWN0b3JzJ1xuICAgICk7XG4gIH1cbn07XG5cbi8qXG4gKiBjYWxjdWxhdGUgdGhlIGNvbm5lY3RvciBheGlzdmVjdG9ycyBieSBjYWxjdWxhdGluZyB0aGUgXCJ0YW5nZW50XCIgZm9yIHBhdGgyRC5cbiAqIFRoaXMgaXMgdW5kZWZpbmVkIGZvciBzdGFydCBhbmQgZW5kIHBvaW50cywgc28gYXhpcyBmb3IgdGhlc2UgaGF2ZSB0byBiZSBtYW51YWxseVxuICogcHJvdmlkZWQuXG4gKi9cbkNvbm5lY3Rvckxpc3QuX2Zyb21QYXRoMkRUYW5nZW50cyA9IGZ1bmN0aW9uIChwYXRoMkQsIHN0YXJ0LCBlbmQpIHtcbiAgLy8gcGF0aDJEXG4gIGxldCBheGlzO1xuICBsZXQgcGF0aExlbiA9IHBhdGgyRC5wb2ludHMubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gbmV3IENvbm5lY3Rvckxpc3QoW1xuICAgIG5ldyBDb25uZWN0b3IocGF0aDJELnBvaW50c1swXSwgc3RhcnQsIENvbm5lY3Rvckxpc3QuZGVmYXVsdE5vcm1hbCksXG4gIF0pO1xuICAvLyBtaWRkbGUgcG9pbnRzXG4gIHBhdGgyRC5wb2ludHMuc2xpY2UoMSwgcGF0aExlbiAtIDEpLmZvckVhY2goZnVuY3Rpb24gKHAyLCBpKSB7XG4gICAgYXhpcyA9IHBhdGgyRC5wb2ludHNbaSArIDJdLm1pbnVzKHBhdGgyRC5wb2ludHNbaV0pLnRvVmVjdG9yM0QoMCk7XG4gICAgcmVzdWx0LmFwcGVuZENvbm5lY3RvcihcbiAgICAgIG5ldyBDb25uZWN0b3IocDIudG9WZWN0b3IzRCgwKSwgYXhpcywgQ29ubmVjdG9yTGlzdC5kZWZhdWx0Tm9ybWFsKVxuICAgICk7XG4gIH0sIHRoaXMpO1xuICByZXN1bHQuYXBwZW5kQ29ubmVjdG9yKFxuICAgIG5ldyBDb25uZWN0b3IocGF0aDJELnBvaW50c1twYXRoTGVuIC0gMV0sIGVuZCwgQ29ubmVjdG9yTGlzdC5kZWZhdWx0Tm9ybWFsKVxuICApO1xuICByZXN1bHQuY2xvc2VkID0gcGF0aDJELmNsb3NlZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qXG4gKiBhbmdsZUlzaDogZWl0aGVyIGEgc3RhdGljIGFuZ2xlLCBvciBhIGZ1bmN0aW9uKHBvaW50KSByZXR1cm5pbmcgYW4gYW5nbGVcbiAqL1xuQ29ubmVjdG9yTGlzdC5fZnJvbVBhdGgyREV4cGxpY2l0ID0gZnVuY3Rpb24gKHBhdGgyRCwgYW5nbGVJc2gpIHtcbiAgZnVuY3Rpb24gZ2V0QW5nbGUoYW5nbGVJc2gsIHB0LCBpKSB7XG4gICAgaWYgKHR5cGVvZiBhbmdsZUlzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYW5nbGVJc2ggPSBhbmdsZUlzaChwdCwgaSk7XG4gICAgfVxuICAgIHJldHVybiBhbmdsZUlzaDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gbmV3IENvbm5lY3Rvckxpc3QoXG4gICAgcGF0aDJELnBvaW50cy5tYXAoZnVuY3Rpb24gKHAyLCBpKSB7XG4gICAgICByZXR1cm4gbmV3IENvbm5lY3RvcihcbiAgICAgICAgcDIudG9WZWN0b3IzRCgwKSxcbiAgICAgICAgVmVjdG9yM0QuQ3JlYXRlKDEsIDAsIDApLnJvdGF0ZVooZ2V0QW5nbGUoYW5nbGVJc2gsIHAyLCBpKSksXG4gICAgICAgIENvbm5lY3Rvckxpc3QuZGVmYXVsdE5vcm1hbFxuICAgICAgKTtcbiAgICB9LCB0aGlzKVxuICApO1xuICByZXN1bHQuY2xvc2VkID0gcGF0aDJELmNsb3NlZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkNvbm5lY3Rvckxpc3QucHJvdG90eXBlID0ge1xuICBzZXRDbG9zZWQ6IGZ1bmN0aW9uIChjbG9zZWQpIHtcbiAgICB0aGlzLmNsb3NlZCA9ICEhY2xvc2VkO1xuICB9LFxuICBhcHBlbmRDb25uZWN0b3I6IGZ1bmN0aW9uIChjb25uKSB7XG4gICAgdGhpcy5jb25uZWN0b3JzXy5wdXNoKGNvbm4pO1xuICB9LFxuICAvKlxuICAgKiBhcmd1bWVudHM6IGNhZ2lzaDogYSBjYWcgb3IgYSBmdW5jdGlvbihjb25uZWN0b3IpIHJldHVybmluZyBhIGNhZ1xuICAgKiAgICAgICAgICAgIGNsb3NlZDogd2hldGhlciB0aGUgM2QgcGF0aCBkZWZpbmVkIGJ5IGNvbm5lY3RvcnMgbG9jYXRpb25cbiAgICogICAgICAgICAgICAgIHNob3VsZCBiZSBjbG9zZWQgb3Igc3RheSBvcGVuXG4gICAqICAgICAgICAgICAgICBOb3RlOiBkb24ndCBkdXBsaWNhdGUgY29ubmVjdG9ycyBpbiB0aGUgcGF0aFxuICAgKiBUT0RPOiBjb25zaWRlciBhbiBvcHRpb24gXCJtYXlTZWxmSW50ZXJzZWN0XCIgdG8gY2xvc2UgJiBmb3JjZSB1bmlvbiBhbGwgc2luZ2xlIHNlZ21lbnRzXG4gICAqL1xuICBmb2xsb3dXaXRoOiBmdW5jdGlvbiAoY2FnaXNoKSB7XG4gICAgY29uc3QgQ1NHID0gcmVxdWlyZSgnLi9DU0cnKTsgLy8gRklYTUUgLCBjaXJjdWxhciBkZXBlbmRlbmN5IGNvbm5lY3RvcnMgPT4gQ1NHID0+IGNvbm5lY3RvcnNcblxuICAgIHRoaXMudmVyaWZ5KCk7XG4gICAgZnVuY3Rpb24gZ2V0Q2FnKGNhZ2lzaCwgY29ubmVjdG9yKSB7XG4gICAgICBpZiAodHlwZW9mIGNhZ2lzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWdpc2ggPSBjYWdpc2goXG4gICAgICAgICAgY29ubmVjdG9yLnBvaW50LFxuICAgICAgICAgIGNvbm5lY3Rvci5heGlzdmVjdG9yLFxuICAgICAgICAgIGNvbm5lY3Rvci5ub3JtYWx2ZWN0b3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWdpc2g7XG4gICAgfVxuXG4gICAgbGV0IHBvbHlnb25zID0gW107XG4gICAgbGV0IGN1cnJDYWc7XG4gICAgbGV0IHByZXZDb25uZWN0b3IgPSB0aGlzLmNvbm5lY3RvcnNfW3RoaXMuY29ubmVjdG9yc18ubGVuZ3RoIC0gMV07XG4gICAgbGV0IHByZXZDYWcgPSBnZXRDYWcoY2FnaXNoLCBwcmV2Q29ubmVjdG9yKTtcbiAgICAvLyBhZGQgd2FsbHNcbiAgICB0aGlzLmNvbm5lY3RvcnNfLmZvckVhY2goZnVuY3Rpb24gKGNvbm5lY3Rvciwgbm90Rmlyc3QpIHtcbiAgICAgIGN1cnJDYWcgPSBnZXRDYWcoY2FnaXNoLCBjb25uZWN0b3IpO1xuICAgICAgaWYgKG5vdEZpcnN0IHx8IHRoaXMuY2xvc2VkKSB7XG4gICAgICAgIHBvbHlnb25zLnB1c2guYXBwbHkoXG4gICAgICAgICAgcG9seWdvbnMsXG4gICAgICAgICAgcHJldkNhZy5fdG9XYWxsUG9seWdvbnMoe1xuICAgICAgICAgICAgdG9Db25uZWN0b3IxOiBwcmV2Q29ubmVjdG9yLFxuICAgICAgICAgICAgdG9Db25uZWN0b3IyOiBjb25uZWN0b3IsXG4gICAgICAgICAgICBjYWc6IGN1cnJDYWcsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0IGlzIHRoZSBmaXJzdCwgYW5kIHNoYXBlIG5vdCBjbG9zZWQgLT4gYnVpbGQgc3RhcnQgd2FsbFxuICAgICAgICBwb2x5Z29ucy5wdXNoLmFwcGx5KFxuICAgICAgICAgIHBvbHlnb25zLFxuICAgICAgICAgIGN1cnJDYWcuX3RvUGxhbmVQb2x5Z29ucyh7IHRvQ29ubmVjdG9yOiBjb25uZWN0b3IsIGZsaXBwZWQ6IHRydWUgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChub3RGaXJzdCA9PT0gdGhpcy5jb25uZWN0b3JzXy5sZW5ndGggLSAxICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAvLyBidWlsZCBlbmQgd2FsbFxuICAgICAgICBwb2x5Z29ucy5wdXNoLmFwcGx5KFxuICAgICAgICAgIHBvbHlnb25zLFxuICAgICAgICAgIGN1cnJDYWcuX3RvUGxhbmVQb2x5Z29ucyh7IHRvQ29ubmVjdG9yOiBjb25uZWN0b3IgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByZXZDYWcgPSBjdXJyQ2FnO1xuICAgICAgcHJldkNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gQ1NHLmZyb21Qb2x5Z29ucyhwb2x5Z29ucykucmVUZXNzZWxhdGVkKCkuY2Fub25pY2FsaXplZCgpO1xuICB9LFxuICAvKlxuICAgKiBnZW5lcmFsIGlkZWEgYmVoaW5kIHRoZXNlIGNoZWNrczogY29ubmVjdG9ycyBuZWVkIHRvIGhhdmUgc21vb3RoIHRyYW5zaXRpb24gZnJvbSBvbmUgdG8gYW5vdGhlclxuICAgKiBUT0RPOiBhZGQgYSBjaGVjayB0aGF0IDIgZm9sbG93LW9uIENBR3MgYXJlIG5vdCBpbnRlcnNlY3RpbmdcbiAgICovXG4gIHZlcmlmeTogZnVuY3Rpb24gKCkge1xuICAgIGxldCBjb25uSTtcbiAgICBsZXQgY29ubkkxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25uZWN0b3JzXy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGNvbm5JID0gdGhpcy5jb25uZWN0b3JzX1tpXTtcbiAgICAgIGNvbm5JMSA9IHRoaXMuY29ubmVjdG9yc19baSArIDFdO1xuICAgICAgaWYgKGNvbm5JMS5wb2ludC5taW51cyhjb25uSS5wb2ludCkuZG90KGNvbm5JLmF4aXN2ZWN0b3IpIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIENvbm5lY3Rvckxpc3QuIEVhY2ggY29ubmVjdG9ycyBwb3NpdGlvbiBuZWVkcyB0byBiZSB3aXRoaW4gYSA8OTBkZWcgcmFuZ2Ugb2YgcHJldmlvdXMgY29ubmVjdG9ycyBheGlzdmVjdG9yJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbm5JLmF4aXN2ZWN0b3IuZG90KGNvbm5JMS5heGlzdmVjdG9yKSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnaW52YWxpZCBDb25uZWN0b3JMaXN0LiBObyBuZWlnaGJvcmluZyBjb25uZWN0b3JzIGF4aXN2ZWN0b3JzIG1heSBzcGFuIGEgPj05MGRlZyBhbmdsZSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgQ29ubmVjdG9yLCBDb25uZWN0b3JMaXN0IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/connectors.js\n");

/***/ }),

/***/ "./src/core/constants.js":
/*!*******************************!*\
  !*** ./src/core/constants.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const _CSGDEBUG = false;\n\n/** Number of polygons per 360 degree revolution for 2D objects.\n * @default\n */\nconst defaultResolution2D = 32; // FIXME this seems excessive\n/** Number of polygons per 360 degree revolution for 3D objects.\n * @default\n */\nconst defaultResolution3D = 12;\n\n/** Epsilon used during determination of near zero distances.\n * @default\n */\nconst EPS = 1e-5;\n\n/** Epsilon used during determination of near zero areas.\n * @default\n */\nconst angleEPS = 0.1;\n\n/** Epsilon used during determination of near zero areas.\n *  This is the minimal area of a minimal polygon.\n * @default\n */\nconst areaEPS = 0.5 * EPS * EPS * Math.sin(angleEPS);\n\nconst all = 0;\nconst top = 1;\nconst bottom = 2;\nconst left = 3;\nconst right = 4;\nconst front = 5;\nconst back = 6;\n// Tag factory: we can request a unique tag through CSG.getTag()\nlet staticTag = 1;\nconst getTag = () => staticTag++;\n\nmodule.exports = {\n  _CSGDEBUG,\n  defaultResolution2D,\n  defaultResolution3D,\n  EPS,\n  angleEPS,\n  areaEPS,\n  all,\n  top,\n  bottom,\n  left,\n  right,\n  front,\n  back,\n  staticTag,\n  getTag,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb25zdGFudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9jb25zdGFudHMuanM/NjExOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBfQ1NHREVCVUcgPSBmYWxzZTtcblxuLyoqIE51bWJlciBvZiBwb2x5Z29ucyBwZXIgMzYwIGRlZ3JlZSByZXZvbHV0aW9uIGZvciAyRCBvYmplY3RzLlxuICogQGRlZmF1bHRcbiAqL1xuY29uc3QgZGVmYXVsdFJlc29sdXRpb24yRCA9IDMyOyAvLyBGSVhNRSB0aGlzIHNlZW1zIGV4Y2Vzc2l2ZVxuLyoqIE51bWJlciBvZiBwb2x5Z29ucyBwZXIgMzYwIGRlZ3JlZSByZXZvbHV0aW9uIGZvciAzRCBvYmplY3RzLlxuICogQGRlZmF1bHRcbiAqL1xuY29uc3QgZGVmYXVsdFJlc29sdXRpb24zRCA9IDEyO1xuXG4vKiogRXBzaWxvbiB1c2VkIGR1cmluZyBkZXRlcm1pbmF0aW9uIG9mIG5lYXIgemVybyBkaXN0YW5jZXMuXG4gKiBAZGVmYXVsdFxuICovXG5jb25zdCBFUFMgPSAxZS01O1xuXG4vKiogRXBzaWxvbiB1c2VkIGR1cmluZyBkZXRlcm1pbmF0aW9uIG9mIG5lYXIgemVybyBhcmVhcy5cbiAqIEBkZWZhdWx0XG4gKi9cbmNvbnN0IGFuZ2xlRVBTID0gMC4xO1xuXG4vKiogRXBzaWxvbiB1c2VkIGR1cmluZyBkZXRlcm1pbmF0aW9uIG9mIG5lYXIgemVybyBhcmVhcy5cbiAqICBUaGlzIGlzIHRoZSBtaW5pbWFsIGFyZWEgb2YgYSBtaW5pbWFsIHBvbHlnb24uXG4gKiBAZGVmYXVsdFxuICovXG5jb25zdCBhcmVhRVBTID0gMC41ICogRVBTICogRVBTICogTWF0aC5zaW4oYW5nbGVFUFMpO1xuXG5jb25zdCBhbGwgPSAwO1xuY29uc3QgdG9wID0gMTtcbmNvbnN0IGJvdHRvbSA9IDI7XG5jb25zdCBsZWZ0ID0gMztcbmNvbnN0IHJpZ2h0ID0gNDtcbmNvbnN0IGZyb250ID0gNTtcbmNvbnN0IGJhY2sgPSA2O1xuLy8gVGFnIGZhY3Rvcnk6IHdlIGNhbiByZXF1ZXN0IGEgdW5pcXVlIHRhZyB0aHJvdWdoIENTRy5nZXRUYWcoKVxubGV0IHN0YXRpY1RhZyA9IDE7XG5jb25zdCBnZXRUYWcgPSAoKSA9PiBzdGF0aWNUYWcrKztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIF9DU0dERUJVRyxcbiAgZGVmYXVsdFJlc29sdXRpb24yRCxcbiAgZGVmYXVsdFJlc29sdXRpb24zRCxcbiAgRVBTLFxuICBhbmdsZUVQUyxcbiAgYXJlYUVQUyxcbiAgYWxsLFxuICB0b3AsXG4gIGJvdHRvbSxcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIGZyb250LFxuICBiYWNrLFxuICBzdGF0aWNUYWcsXG4gIGdldFRhZyxcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/constants.js\n");

/***/ }),

/***/ "./src/core/math/Line2.js":
/*!********************************!*\
  !*** ./src/core/math/Line2.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\nconst { solve2Linear } = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n\n/**  class Line2D\n * Represents a directional line in 2D space\n * A line is parametrized by its normal vector (perpendicular to the line, rotated 90 degrees counter clockwise)\n * and w. The line passes through the point <normal>.times(w).\n * Equation: p is on line if normal.dot(p)==w\n * @param {Vector2D} normal normal must be a unit vector!\n * @returns {Line2D}\n */\nconst Line2D = function (normal, w) {\n  normal = new Vector2D(normal);\n  w = parseFloat(w);\n  let l = normal.length();\n  // normalize:\n  w *= l;\n  normal = normal.times(1.0 / l);\n  this.normal = normal;\n  this.w = w;\n};\n\nLine2D.fromPoints = function (p1, p2) {\n  p1 = new Vector2D(p1);\n  p2 = new Vector2D(p2);\n  let direction = p2.minus(p1);\n  let normal = direction.normal().negated().unit();\n  let w = p1.dot(normal);\n  return new Line2D(normal, w);\n};\n\nLine2D.prototype = {\n  // same line but opposite direction:\n  reverse: function () {\n    return new Line2D(this.normal.negated(), -this.w);\n  },\n\n  equals: function (l) {\n    return l.normal.equals(this.normal) && l.w === this.w;\n  },\n\n  origin: function () {\n    return this.normal.times(this.w);\n  },\n\n  direction: function () {\n    return this.normal.normal();\n  },\n\n  xAtY: function (y) {\n    // (py == y) && (normal * p == w)\n    // -> px = (w - normal._y * y) / normal.x\n    let x = (this.w - this.normal._y * y) / this.normal.x;\n    return x;\n  },\n\n  absDistanceToPoint: function (point) {\n    point = new Vector2D(point);\n    let pointProjected = point.dot(this.normal);\n    let distance = Math.abs(pointProjected - this.w);\n    return distance;\n  },\n  /* FIXME: has error - origin is not defined, the method is never used\n     closestPoint: function(point) {\n         point = new Vector2D(point);\n         let vector = point.dot(this.direction());\n         return origin.plus(vector);\n     },\n     */\n\n  // intersection between two lines, returns point as Vector2D\n  intersectWithLine: function (line2d) {\n    let point = solve2Linear(\n      this.normal.x,\n      this.normal.y,\n      line2d.normal.x,\n      line2d.normal.y,\n      this.w,\n      line2d.w\n    );\n    point = new Vector2D(point); // make  vector2d\n    return point;\n  },\n\n  transform: function (matrix4x4) {\n    let origin = new Vector2D(0, 0);\n    let pointOnPlane = this.normal.times(this.w);\n    let neworigin = origin.multiply4x4(matrix4x4);\n    let neworiginPlusNormal = this.normal.multiply4x4(matrix4x4);\n    let newnormal = neworiginPlusNormal.minus(neworigin);\n    let newpointOnPlane = pointOnPlane.multiply4x4(matrix4x4);\n    let neww = newnormal.dot(newpointOnPlane);\n    return new Line2D(newnormal, neww);\n  },\n};\n\nmodule.exports = Line2D;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL0xpbmUyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvbWF0aC9MaW5lMi5qcz80ZjI5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlY3RvcjJEID0gcmVxdWlyZSgnLi9WZWN0b3IyJyk7XG5jb25zdCB7IHNvbHZlMkxpbmVhciB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqICBjbGFzcyBMaW5lMkRcbiAqIFJlcHJlc2VudHMgYSBkaXJlY3Rpb25hbCBsaW5lIGluIDJEIHNwYWNlXG4gKiBBIGxpbmUgaXMgcGFyYW1ldHJpemVkIGJ5IGl0cyBub3JtYWwgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lLCByb3RhdGVkIDkwIGRlZ3JlZXMgY291bnRlciBjbG9ja3dpc2UpXG4gKiBhbmQgdy4gVGhlIGxpbmUgcGFzc2VzIHRocm91Z2ggdGhlIHBvaW50IDxub3JtYWw+LnRpbWVzKHcpLlxuICogRXF1YXRpb246IHAgaXMgb24gbGluZSBpZiBub3JtYWwuZG90KHApPT13XG4gKiBAcGFyYW0ge1ZlY3RvcjJEfSBub3JtYWwgbm9ybWFsIG11c3QgYmUgYSB1bml0IHZlY3RvciFcbiAqIEByZXR1cm5zIHtMaW5lMkR9XG4gKi9cbmNvbnN0IExpbmUyRCA9IGZ1bmN0aW9uIChub3JtYWwsIHcpIHtcbiAgbm9ybWFsID0gbmV3IFZlY3RvcjJEKG5vcm1hbCk7XG4gIHcgPSBwYXJzZUZsb2F0KHcpO1xuICBsZXQgbCA9IG5vcm1hbC5sZW5ndGgoKTtcbiAgLy8gbm9ybWFsaXplOlxuICB3ICo9IGw7XG4gIG5vcm1hbCA9IG5vcm1hbC50aW1lcygxLjAgLyBsKTtcbiAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gIHRoaXMudyA9IHc7XG59O1xuXG5MaW5lMkQuZnJvbVBvaW50cyA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgcDEgPSBuZXcgVmVjdG9yMkQocDEpO1xuICBwMiA9IG5ldyBWZWN0b3IyRChwMik7XG4gIGxldCBkaXJlY3Rpb24gPSBwMi5taW51cyhwMSk7XG4gIGxldCBub3JtYWwgPSBkaXJlY3Rpb24ubm9ybWFsKCkubmVnYXRlZCgpLnVuaXQoKTtcbiAgbGV0IHcgPSBwMS5kb3Qobm9ybWFsKTtcbiAgcmV0dXJuIG5ldyBMaW5lMkQobm9ybWFsLCB3KTtcbn07XG5cbkxpbmUyRC5wcm90b3R5cGUgPSB7XG4gIC8vIHNhbWUgbGluZSBidXQgb3Bwb3NpdGUgZGlyZWN0aW9uOlxuICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lMkQodGhpcy5ub3JtYWwubmVnYXRlZCgpLCAtdGhpcy53KTtcbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uIChsKSB7XG4gICAgcmV0dXJuIGwubm9ybWFsLmVxdWFscyh0aGlzLm5vcm1hbCkgJiYgbC53ID09PSB0aGlzLnc7XG4gIH0sXG5cbiAgb3JpZ2luOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLnRpbWVzKHRoaXMudyk7XG4gIH0sXG5cbiAgZGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsLm5vcm1hbCgpO1xuICB9LFxuXG4gIHhBdFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgLy8gKHB5ID09IHkpICYmIChub3JtYWwgKiBwID09IHcpXG4gICAgLy8gLT4gcHggPSAodyAtIG5vcm1hbC5feSAqIHkpIC8gbm9ybWFsLnhcbiAgICBsZXQgeCA9ICh0aGlzLncgLSB0aGlzLm5vcm1hbC5feSAqIHkpIC8gdGhpcy5ub3JtYWwueDtcbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBhYnNEaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHBvaW50ID0gbmV3IFZlY3RvcjJEKHBvaW50KTtcbiAgICBsZXQgcG9pbnRQcm9qZWN0ZWQgPSBwb2ludC5kb3QodGhpcy5ub3JtYWwpO1xuICAgIGxldCBkaXN0YW5jZSA9IE1hdGguYWJzKHBvaW50UHJvamVjdGVkIC0gdGhpcy53KTtcbiAgICByZXR1cm4gZGlzdGFuY2U7XG4gIH0sXG4gIC8qIEZJWE1FOiBoYXMgZXJyb3IgLSBvcmlnaW4gaXMgbm90IGRlZmluZWQsIHRoZSBtZXRob2QgaXMgbmV2ZXIgdXNlZFxuICAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICBwb2ludCA9IG5ldyBWZWN0b3IyRChwb2ludCk7XG4gICAgICAgICBsZXQgdmVjdG9yID0gcG9pbnQuZG90KHRoaXMuZGlyZWN0aW9uKCkpO1xuICAgICAgICAgcmV0dXJuIG9yaWdpbi5wbHVzKHZlY3Rvcik7XG4gICAgIH0sXG4gICAgICovXG5cbiAgLy8gaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLCByZXR1cm5zIHBvaW50IGFzIFZlY3RvcjJEXG4gIGludGVyc2VjdFdpdGhMaW5lOiBmdW5jdGlvbiAobGluZTJkKSB7XG4gICAgbGV0IHBvaW50ID0gc29sdmUyTGluZWFyKFxuICAgICAgdGhpcy5ub3JtYWwueCxcbiAgICAgIHRoaXMubm9ybWFsLnksXG4gICAgICBsaW5lMmQubm9ybWFsLngsXG4gICAgICBsaW5lMmQubm9ybWFsLnksXG4gICAgICB0aGlzLncsXG4gICAgICBsaW5lMmQud1xuICAgICk7XG4gICAgcG9pbnQgPSBuZXcgVmVjdG9yMkQocG9pbnQpOyAvLyBtYWtlICB2ZWN0b3IyZFxuICAgIHJldHVybiBwb2ludDtcbiAgfSxcblxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICBsZXQgb3JpZ2luID0gbmV3IFZlY3RvcjJEKDAsIDApO1xuICAgIGxldCBwb2ludE9uUGxhbmUgPSB0aGlzLm5vcm1hbC50aW1lcyh0aGlzLncpO1xuICAgIGxldCBuZXdvcmlnaW4gPSBvcmlnaW4ubXVsdGlwbHk0eDQobWF0cml4NHg0KTtcbiAgICBsZXQgbmV3b3JpZ2luUGx1c05vcm1hbCA9IHRoaXMubm9ybWFsLm11bHRpcGx5NHg0KG1hdHJpeDR4NCk7XG4gICAgbGV0IG5ld25vcm1hbCA9IG5ld29yaWdpblBsdXNOb3JtYWwubWludXMobmV3b3JpZ2luKTtcbiAgICBsZXQgbmV3cG9pbnRPblBsYW5lID0gcG9pbnRPblBsYW5lLm11bHRpcGx5NHg0KG1hdHJpeDR4NCk7XG4gICAgbGV0IG5ld3cgPSBuZXdub3JtYWwuZG90KG5ld3BvaW50T25QbGFuZSk7XG4gICAgcmV0dXJuIG5ldyBMaW5lMkQobmV3bm9ybWFsLCBuZXd3KTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZTJEO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/Line2.js\n");

/***/ }),

/***/ "./src/core/math/Line3.js":
/*!********************************!*\
  !*** ./src/core/math/Line3.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ./Vector3 */ \"./src/core/math/Vector3.js\");\nconst { EPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst { solve2Linear } = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n\n// # class Line3D\n// Represents a line in 3D space\n// direction must be a unit vector\n// point is a random point on the line\nconst Line3D = function (point, direction) {\n  point = new Vector3D(point);\n  direction = new Vector3D(direction);\n  this.point = point;\n  this.direction = direction.unit();\n};\n\nLine3D.fromPoints = function (p1, p2) {\n  p1 = new Vector3D(p1);\n  p2 = new Vector3D(p2);\n  let direction = p2.minus(p1);\n  return new Line3D(p1, direction);\n};\n\nLine3D.fromPlanes = function (p1, p2) {\n  let direction = p1.normal.cross(p2.normal);\n  let l = direction.length();\n  if (l < EPS) {\n    throw new Error('Parallel planes');\n  }\n  direction = direction.times(1.0 / l);\n\n  let mabsx = Math.abs(direction.x);\n  let mabsy = Math.abs(direction.y);\n  let mabsz = Math.abs(direction.z);\n  let origin;\n  if (mabsx >= mabsy && mabsx >= mabsz) {\n    // direction vector is mostly pointing towards x\n    // find a point p for which x is zero:\n    let r = solve2Linear(\n      p1.normal.y,\n      p1.normal.z,\n      p2.normal.y,\n      p2.normal.z,\n      p1.w,\n      p2.w\n    );\n    origin = new Vector3D(0, r[0], r[1]);\n  } else if (mabsy >= mabsx && mabsy >= mabsz) {\n    // find a point p for which y is zero:\n    let r = solve2Linear(\n      p1.normal.x,\n      p1.normal.z,\n      p2.normal.x,\n      p2.normal.z,\n      p1.w,\n      p2.w\n    );\n    origin = new Vector3D(r[0], 0, r[1]);\n  } else {\n    // find a point p for which z is zero:\n    let r = solve2Linear(\n      p1.normal.x,\n      p1.normal.y,\n      p2.normal.x,\n      p2.normal.y,\n      p1.w,\n      p2.w\n    );\n    origin = new Vector3D(r[0], r[1], 0);\n  }\n  return new Line3D(origin, direction);\n};\n\nLine3D.prototype = {\n  intersectWithPlane: function (plane) {\n    // plane: plane.normal * p = plane.w\n    // line: p=line.point + labda * line.direction\n    let labda =\n      (plane.w - plane.normal.dot(this.point)) /\n      plane.normal.dot(this.direction);\n    let point = this.point.plus(this.direction.times(labda));\n    return point;\n  },\n\n  clone: function (line) {\n    return new Line3D(this.point.clone(), this.direction.clone());\n  },\n\n  reverse: function () {\n    return new Line3D(this.point.clone(), this.direction.negated());\n  },\n\n  transform: function (matrix4x4) {\n    let newpoint = this.point.multiply4x4(matrix4x4);\n    let pointPlusDirection = this.point.plus(this.direction);\n    let newPointPlusDirection = pointPlusDirection.multiply4x4(matrix4x4);\n    let newdirection = newPointPlusDirection.minus(newpoint);\n    return new Line3D(newpoint, newdirection);\n  },\n\n  closestPointOnLine: function (point) {\n    point = new Vector3D(point);\n    let t =\n      point.minus(this.point).dot(this.direction) /\n      this.direction.dot(this.direction);\n    let closestpoint = this.point.plus(this.direction.times(t));\n    return closestpoint;\n  },\n\n  distanceToPoint: function (point) {\n    point = new Vector3D(point);\n    let closestpoint = this.closestPointOnLine(point);\n    let distancevector = point.minus(closestpoint);\n    let distance = distancevector.length();\n    return distance;\n  },\n\n  equals: function (line3d) {\n    if (!this.direction.equals(line3d.direction)) return false;\n    let distance = this.distanceToPoint(line3d.point);\n    if (distance > EPS) return false;\n    return true;\n  },\n};\n\nmodule.exports = Line3D;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL0xpbmUzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvbWF0aC9MaW5lMy5qcz85ZjNmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlY3RvcjNEID0gcmVxdWlyZSgnLi9WZWN0b3IzJyk7XG5jb25zdCB7IEVQUyB9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5jb25zdCB7IHNvbHZlMkxpbmVhciB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLy8gIyBjbGFzcyBMaW5lM0Rcbi8vIFJlcHJlc2VudHMgYSBsaW5lIGluIDNEIHNwYWNlXG4vLyBkaXJlY3Rpb24gbXVzdCBiZSBhIHVuaXQgdmVjdG9yXG4vLyBwb2ludCBpcyBhIHJhbmRvbSBwb2ludCBvbiB0aGUgbGluZVxuY29uc3QgTGluZTNEID0gZnVuY3Rpb24gKHBvaW50LCBkaXJlY3Rpb24pIHtcbiAgcG9pbnQgPSBuZXcgVmVjdG9yM0QocG9pbnQpO1xuICBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yM0QoZGlyZWN0aW9uKTtcbiAgdGhpcy5wb2ludCA9IHBvaW50O1xuICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbi51bml0KCk7XG59O1xuXG5MaW5lM0QuZnJvbVBvaW50cyA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgcDEgPSBuZXcgVmVjdG9yM0QocDEpO1xuICBwMiA9IG5ldyBWZWN0b3IzRChwMik7XG4gIGxldCBkaXJlY3Rpb24gPSBwMi5taW51cyhwMSk7XG4gIHJldHVybiBuZXcgTGluZTNEKHAxLCBkaXJlY3Rpb24pO1xufTtcblxuTGluZTNELmZyb21QbGFuZXMgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gIGxldCBkaXJlY3Rpb24gPSBwMS5ub3JtYWwuY3Jvc3MocDIubm9ybWFsKTtcbiAgbGV0IGwgPSBkaXJlY3Rpb24ubGVuZ3RoKCk7XG4gIGlmIChsIDwgRVBTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbGxlbCBwbGFuZXMnKTtcbiAgfVxuICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24udGltZXMoMS4wIC8gbCk7XG5cbiAgbGV0IG1hYnN4ID0gTWF0aC5hYnMoZGlyZWN0aW9uLngpO1xuICBsZXQgbWFic3kgPSBNYXRoLmFicyhkaXJlY3Rpb24ueSk7XG4gIGxldCBtYWJzeiA9IE1hdGguYWJzKGRpcmVjdGlvbi56KTtcbiAgbGV0IG9yaWdpbjtcbiAgaWYgKG1hYnN4ID49IG1hYnN5ICYmIG1hYnN4ID49IG1hYnN6KSB7XG4gICAgLy8gZGlyZWN0aW9uIHZlY3RvciBpcyBtb3N0bHkgcG9pbnRpbmcgdG93YXJkcyB4XG4gICAgLy8gZmluZCBhIHBvaW50IHAgZm9yIHdoaWNoIHggaXMgemVybzpcbiAgICBsZXQgciA9IHNvbHZlMkxpbmVhcihcbiAgICAgIHAxLm5vcm1hbC55LFxuICAgICAgcDEubm9ybWFsLnosXG4gICAgICBwMi5ub3JtYWwueSxcbiAgICAgIHAyLm5vcm1hbC56LFxuICAgICAgcDEudyxcbiAgICAgIHAyLndcbiAgICApO1xuICAgIG9yaWdpbiA9IG5ldyBWZWN0b3IzRCgwLCByWzBdLCByWzFdKTtcbiAgfSBlbHNlIGlmIChtYWJzeSA+PSBtYWJzeCAmJiBtYWJzeSA+PSBtYWJzeikge1xuICAgIC8vIGZpbmQgYSBwb2ludCBwIGZvciB3aGljaCB5IGlzIHplcm86XG4gICAgbGV0IHIgPSBzb2x2ZTJMaW5lYXIoXG4gICAgICBwMS5ub3JtYWwueCxcbiAgICAgIHAxLm5vcm1hbC56LFxuICAgICAgcDIubm9ybWFsLngsXG4gICAgICBwMi5ub3JtYWwueixcbiAgICAgIHAxLncsXG4gICAgICBwMi53XG4gICAgKTtcbiAgICBvcmlnaW4gPSBuZXcgVmVjdG9yM0QoclswXSwgMCwgclsxXSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZmluZCBhIHBvaW50IHAgZm9yIHdoaWNoIHogaXMgemVybzpcbiAgICBsZXQgciA9IHNvbHZlMkxpbmVhcihcbiAgICAgIHAxLm5vcm1hbC54LFxuICAgICAgcDEubm9ybWFsLnksXG4gICAgICBwMi5ub3JtYWwueCxcbiAgICAgIHAyLm5vcm1hbC55LFxuICAgICAgcDEudyxcbiAgICAgIHAyLndcbiAgICApO1xuICAgIG9yaWdpbiA9IG5ldyBWZWN0b3IzRChyWzBdLCByWzFdLCAwKTtcbiAgfVxuICByZXR1cm4gbmV3IExpbmUzRChvcmlnaW4sIGRpcmVjdGlvbik7XG59O1xuXG5MaW5lM0QucHJvdG90eXBlID0ge1xuICBpbnRlcnNlY3RXaXRoUGxhbmU6IGZ1bmN0aW9uIChwbGFuZSkge1xuICAgIC8vIHBsYW5lOiBwbGFuZS5ub3JtYWwgKiBwID0gcGxhbmUud1xuICAgIC8vIGxpbmU6IHA9bGluZS5wb2ludCArIGxhYmRhICogbGluZS5kaXJlY3Rpb25cbiAgICBsZXQgbGFiZGEgPVxuICAgICAgKHBsYW5lLncgLSBwbGFuZS5ub3JtYWwuZG90KHRoaXMucG9pbnQpKSAvXG4gICAgICBwbGFuZS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKTtcbiAgICBsZXQgcG9pbnQgPSB0aGlzLnBvaW50LnBsdXModGhpcy5kaXJlY3Rpb24udGltZXMobGFiZGEpKTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lM0QodGhpcy5wb2ludC5jbG9uZSgpLCB0aGlzLmRpcmVjdGlvbi5jbG9uZSgpKTtcbiAgfSxcblxuICByZXZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lM0QodGhpcy5wb2ludC5jbG9uZSgpLCB0aGlzLmRpcmVjdGlvbi5uZWdhdGVkKCkpO1xuICB9LFxuXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKG1hdHJpeDR4NCkge1xuICAgIGxldCBuZXdwb2ludCA9IHRoaXMucG9pbnQubXVsdGlwbHk0eDQobWF0cml4NHg0KTtcbiAgICBsZXQgcG9pbnRQbHVzRGlyZWN0aW9uID0gdGhpcy5wb2ludC5wbHVzKHRoaXMuZGlyZWN0aW9uKTtcbiAgICBsZXQgbmV3UG9pbnRQbHVzRGlyZWN0aW9uID0gcG9pbnRQbHVzRGlyZWN0aW9uLm11bHRpcGx5NHg0KG1hdHJpeDR4NCk7XG4gICAgbGV0IG5ld2RpcmVjdGlvbiA9IG5ld1BvaW50UGx1c0RpcmVjdGlvbi5taW51cyhuZXdwb2ludCk7XG4gICAgcmV0dXJuIG5ldyBMaW5lM0QobmV3cG9pbnQsIG5ld2RpcmVjdGlvbik7XG4gIH0sXG5cbiAgY2xvc2VzdFBvaW50T25MaW5lOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBwb2ludCA9IG5ldyBWZWN0b3IzRChwb2ludCk7XG4gICAgbGV0IHQgPVxuICAgICAgcG9pbnQubWludXModGhpcy5wb2ludCkuZG90KHRoaXMuZGlyZWN0aW9uKSAvXG4gICAgICB0aGlzLmRpcmVjdGlvbi5kb3QodGhpcy5kaXJlY3Rpb24pO1xuICAgIGxldCBjbG9zZXN0cG9pbnQgPSB0aGlzLnBvaW50LnBsdXModGhpcy5kaXJlY3Rpb24udGltZXModCkpO1xuICAgIHJldHVybiBjbG9zZXN0cG9pbnQ7XG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBwb2ludCA9IG5ldyBWZWN0b3IzRChwb2ludCk7XG4gICAgbGV0IGNsb3Nlc3Rwb2ludCA9IHRoaXMuY2xvc2VzdFBvaW50T25MaW5lKHBvaW50KTtcbiAgICBsZXQgZGlzdGFuY2V2ZWN0b3IgPSBwb2ludC5taW51cyhjbG9zZXN0cG9pbnQpO1xuICAgIGxldCBkaXN0YW5jZSA9IGRpc3RhbmNldmVjdG9yLmxlbmd0aCgpO1xuICAgIHJldHVybiBkaXN0YW5jZTtcbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uIChsaW5lM2QpIHtcbiAgICBpZiAoIXRoaXMuZGlyZWN0aW9uLmVxdWFscyhsaW5lM2QuZGlyZWN0aW9uKSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KGxpbmUzZC5wb2ludCk7XG4gICAgaWYgKGRpc3RhbmNlID4gRVBTKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmUzRDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/Line3.js\n");

/***/ }),

/***/ "./src/core/math/Matrix4.js":
/*!**********************************!*\
  !*** ./src/core/math/Matrix4.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ./Vector3 */ \"./src/core/math/Vector3.js\");\nconst Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\nconst OrthoNormalBasis = __webpack_require__(/*! ./OrthoNormalBasis */ \"./src/core/math/OrthoNormalBasis.js\");\nconst Plane = __webpack_require__(/*! ./Plane */ \"./src/core/math/Plane.js\");\n\n// # class Matrix4x4:\n// Represents a 4x4 matrix. Elements are specified in row order\nconst Matrix4x4 = function (elements) {\n  if (arguments.length >= 1) {\n    this.elements = elements;\n  } else {\n    // if no arguments passed: create unity matrix\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  }\n};\n\nMatrix4x4.prototype = {\n  plus: function (m) {\n    var r = [];\n    for (var i = 0; i < 16; i++) {\n      r[i] = this.elements[i] + m.elements[i];\n    }\n    return new Matrix4x4(r);\n  },\n\n  minus: function (m) {\n    var r = [];\n    for (var i = 0; i < 16; i++) {\n      r[i] = this.elements[i] - m.elements[i];\n    }\n    return new Matrix4x4(r);\n  },\n\n  // right multiply by another 4x4 matrix:\n  multiply: function (m) {\n    // cache elements in local variables, for speedup:\n    var this0 = this.elements[0];\n    var this1 = this.elements[1];\n    var this2 = this.elements[2];\n    var this3 = this.elements[3];\n    var this4 = this.elements[4];\n    var this5 = this.elements[5];\n    var this6 = this.elements[6];\n    var this7 = this.elements[7];\n    var this8 = this.elements[8];\n    var this9 = this.elements[9];\n    var this10 = this.elements[10];\n    var this11 = this.elements[11];\n    var this12 = this.elements[12];\n    var this13 = this.elements[13];\n    var this14 = this.elements[14];\n    var this15 = this.elements[15];\n    var m0 = m.elements[0];\n    var m1 = m.elements[1];\n    var m2 = m.elements[2];\n    var m3 = m.elements[3];\n    var m4 = m.elements[4];\n    var m5 = m.elements[5];\n    var m6 = m.elements[6];\n    var m7 = m.elements[7];\n    var m8 = m.elements[8];\n    var m9 = m.elements[9];\n    var m10 = m.elements[10];\n    var m11 = m.elements[11];\n    var m12 = m.elements[12];\n    var m13 = m.elements[13];\n    var m14 = m.elements[14];\n    var m15 = m.elements[15];\n\n    var result = [];\n    result[0] = this0 * m0 + this1 * m4 + this2 * m8 + this3 * m12;\n    result[1] = this0 * m1 + this1 * m5 + this2 * m9 + this3 * m13;\n    result[2] = this0 * m2 + this1 * m6 + this2 * m10 + this3 * m14;\n    result[3] = this0 * m3 + this1 * m7 + this2 * m11 + this3 * m15;\n    result[4] = this4 * m0 + this5 * m4 + this6 * m8 + this7 * m12;\n    result[5] = this4 * m1 + this5 * m5 + this6 * m9 + this7 * m13;\n    result[6] = this4 * m2 + this5 * m6 + this6 * m10 + this7 * m14;\n    result[7] = this4 * m3 + this5 * m7 + this6 * m11 + this7 * m15;\n    result[8] = this8 * m0 + this9 * m4 + this10 * m8 + this11 * m12;\n    result[9] = this8 * m1 + this9 * m5 + this10 * m9 + this11 * m13;\n    result[10] = this8 * m2 + this9 * m6 + this10 * m10 + this11 * m14;\n    result[11] = this8 * m3 + this9 * m7 + this10 * m11 + this11 * m15;\n    result[12] = this12 * m0 + this13 * m4 + this14 * m8 + this15 * m12;\n    result[13] = this12 * m1 + this13 * m5 + this14 * m9 + this15 * m13;\n    result[14] = this12 * m2 + this13 * m6 + this14 * m10 + this15 * m14;\n    result[15] = this12 * m3 + this13 * m7 + this14 * m11 + this15 * m15;\n    return new Matrix4x4(result);\n  },\n\n  clone: function () {\n    var elements = this.elements.map(function (p) {\n      return p;\n    });\n    return new Matrix4x4(elements);\n  },\n\n  // Right multiply the matrix by a Vector3D (interpreted as 3 row, 1 column)\n  // (result = M*v)\n  // Fourth element is taken as 1\n  rightMultiply1x3Vector: function (v) {\n    var v0 = v._x;\n    var v1 = v._y;\n    var v2 = v._z;\n    var v3 = 1;\n    var x =\n      v0 * this.elements[0] +\n      v1 * this.elements[1] +\n      v2 * this.elements[2] +\n      v3 * this.elements[3];\n    var y =\n      v0 * this.elements[4] +\n      v1 * this.elements[5] +\n      v2 * this.elements[6] +\n      v3 * this.elements[7];\n    var z =\n      v0 * this.elements[8] +\n      v1 * this.elements[9] +\n      v2 * this.elements[10] +\n      v3 * this.elements[11];\n    var w =\n      v0 * this.elements[12] +\n      v1 * this.elements[13] +\n      v2 * this.elements[14] +\n      v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector3D(x, y, z);\n  },\n\n  // Multiply a Vector3D (interpreted as 3 column, 1 row) by this matrix\n  // (result = v*M)\n  // Fourth element is taken as 1\n  leftMultiply1x3Vector: function (v) {\n    var v0 = v._x;\n    var v1 = v._y;\n    var v2 = v._z;\n    var v3 = 1;\n    var x =\n      v0 * this.elements[0] +\n      v1 * this.elements[4] +\n      v2 * this.elements[8] +\n      v3 * this.elements[12];\n    var y =\n      v0 * this.elements[1] +\n      v1 * this.elements[5] +\n      v2 * this.elements[9] +\n      v3 * this.elements[13];\n    var z =\n      v0 * this.elements[2] +\n      v1 * this.elements[6] +\n      v2 * this.elements[10] +\n      v3 * this.elements[14];\n    var w =\n      v0 * this.elements[3] +\n      v1 * this.elements[7] +\n      v2 * this.elements[11] +\n      v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector3D(x, y, z);\n  },\n\n  // Right multiply the matrix by a Vector2D (interpreted as 2 row, 1 column)\n  // (result = M*v)\n  // Fourth element is taken as 1\n  rightMultiply1x2Vector: function (v) {\n    var v0 = v.x;\n    var v1 = v.y;\n    var v2 = 0;\n    var v3 = 1;\n    var x =\n      v0 * this.elements[0] +\n      v1 * this.elements[1] +\n      v2 * this.elements[2] +\n      v3 * this.elements[3];\n    var y =\n      v0 * this.elements[4] +\n      v1 * this.elements[5] +\n      v2 * this.elements[6] +\n      v3 * this.elements[7];\n    var z =\n      v0 * this.elements[8] +\n      v1 * this.elements[9] +\n      v2 * this.elements[10] +\n      v3 * this.elements[11];\n    var w =\n      v0 * this.elements[12] +\n      v1 * this.elements[13] +\n      v2 * this.elements[14] +\n      v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector2D(x, y);\n  },\n\n  // Multiply a Vector2D (interpreted as 2 column, 1 row) by this matrix\n  // (result = v*M)\n  // Fourth element is taken as 1\n  leftMultiply1x2Vector: function (v) {\n    var v0 = v.x;\n    var v1 = v.y;\n    var v2 = 0;\n    var v3 = 1;\n    var x =\n      v0 * this.elements[0] +\n      v1 * this.elements[4] +\n      v2 * this.elements[8] +\n      v3 * this.elements[12];\n    var y =\n      v0 * this.elements[1] +\n      v1 * this.elements[5] +\n      v2 * this.elements[9] +\n      v3 * this.elements[13];\n    var z =\n      v0 * this.elements[2] +\n      v1 * this.elements[6] +\n      v2 * this.elements[10] +\n      v3 * this.elements[14];\n    var w =\n      v0 * this.elements[3] +\n      v1 * this.elements[7] +\n      v2 * this.elements[11] +\n      v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector2D(x, y);\n  },\n\n  // determine whether this matrix is a mirroring transformation\n  isMirroring: function () {\n    var u = new Vector3D(this.elements[0], this.elements[4], this.elements[8]);\n    var v = new Vector3D(this.elements[1], this.elements[5], this.elements[9]);\n    var w = new Vector3D(this.elements[2], this.elements[6], this.elements[10]);\n\n    // for a true orthogonal, non-mirrored base, u.cross(v) == w\n    // If they have an opposite direction then we are mirroring\n    var mirrorvalue = u.cross(v).dot(w);\n    var ismirror = mirrorvalue < 0;\n    return ismirror;\n  },\n};\n\n// return the unity matrix\nMatrix4x4.unity = function () {\n  return new Matrix4x4();\n};\n\n// Create a rotation matrix for rotating around the x axis\nMatrix4x4.rotationX = function (degrees) {\n  var radians = degrees * Math.PI * (1.0 / 180.0);\n  var cos = Math.cos(radians);\n  var sin = Math.sin(radians);\n  var els = [1, 0, 0, 0, 0, cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1];\n  return new Matrix4x4(els);\n};\n\n// Create a rotation matrix for rotating around the y axis\nMatrix4x4.rotationY = function (degrees) {\n  var radians = degrees * Math.PI * (1.0 / 180.0);\n  var cos = Math.cos(radians);\n  var sin = Math.sin(radians);\n  var els = [cos, 0, -sin, 0, 0, 1, 0, 0, sin, 0, cos, 0, 0, 0, 0, 1];\n  return new Matrix4x4(els);\n};\n\n// Create a rotation matrix for rotating around the z axis\nMatrix4x4.rotationZ = function (degrees) {\n  var radians = degrees * Math.PI * (1.0 / 180.0);\n  var cos = Math.cos(radians);\n  var sin = Math.sin(radians);\n  var els = [cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  return new Matrix4x4(els);\n};\n\n// Matrix for rotation about arbitrary point and axis\nMatrix4x4.rotation = function (rotationCenter, rotationAxis, degrees) {\n  rotationCenter = new Vector3D(rotationCenter);\n  rotationAxis = new Vector3D(rotationAxis);\n  var rotationPlane = Plane.fromNormalAndPoint(rotationAxis, rotationCenter);\n  var orthobasis = new OrthoNormalBasis(rotationPlane);\n  var transformation = Matrix4x4.translation(rotationCenter.negated());\n  transformation = transformation.multiply(orthobasis.getProjectionMatrix());\n  transformation = transformation.multiply(Matrix4x4.rotationZ(degrees));\n  transformation = transformation.multiply(\n    orthobasis.getInverseProjectionMatrix()\n  );\n  transformation = transformation.multiply(\n    Matrix4x4.translation(rotationCenter)\n  );\n  return transformation;\n};\n\n// Create an affine matrix for translation:\nMatrix4x4.translation = function (v) {\n  // parse as Vector3D, so we can pass an array or a Vector3D\n  var vec = new Vector3D(v);\n  var els = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, vec.x, vec.y, vec.z, 1];\n  return new Matrix4x4(els);\n};\n\n// Create an affine matrix for mirroring into an arbitrary plane:\nMatrix4x4.mirroring = function (plane) {\n  var nx = plane.normal.x;\n  var ny = plane.normal.y;\n  var nz = plane.normal.z;\n  var w = plane.w;\n  var els = [\n    1.0 - 2.0 * nx * nx,\n    -2.0 * ny * nx,\n    -2.0 * nz * nx,\n    0,\n    -2.0 * nx * ny,\n    1.0 - 2.0 * ny * ny,\n    -2.0 * nz * ny,\n    0,\n    -2.0 * nx * nz,\n    -2.0 * ny * nz,\n    1.0 - 2.0 * nz * nz,\n    0,\n    2.0 * nx * w,\n    2.0 * ny * w,\n    2.0 * nz * w,\n    1,\n  ];\n  return new Matrix4x4(els);\n};\n\n// Create an affine matrix for scaling:\nMatrix4x4.scaling = function (v) {\n  // parse as Vector3D, so we can pass an array or a Vector3D\n  var vec = new Vector3D(v);\n  var els = [vec.x, 0, 0, 0, 0, vec.y, 0, 0, 0, 0, vec.z, 0, 0, 0, 0, 1];\n  return new Matrix4x4(els);\n};\n\nmodule.exports = Matrix4x4;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL01hdHJpeDQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9tYXRoL01hdHJpeDQuanM/YTg4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IzRCA9IHJlcXVpcmUoJy4vVmVjdG9yMycpO1xuY29uc3QgVmVjdG9yMkQgPSByZXF1aXJlKCcuL1ZlY3RvcjInKTtcbmNvbnN0IE9ydGhvTm9ybWFsQmFzaXMgPSByZXF1aXJlKCcuL09ydGhvTm9ybWFsQmFzaXMnKTtcbmNvbnN0IFBsYW5lID0gcmVxdWlyZSgnLi9QbGFuZScpO1xuXG4vLyAjIGNsYXNzIE1hdHJpeDR4NDpcbi8vIFJlcHJlc2VudHMgYSA0eDQgbWF0cml4LiBFbGVtZW50cyBhcmUgc3BlY2lmaWVkIGluIHJvdyBvcmRlclxuY29uc3QgTWF0cml4NHg0ID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDEpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgbm8gYXJndW1lbnRzIHBhc3NlZDogY3JlYXRlIHVuaXR5IG1hdHJpeFxuICAgIHRoaXMuZWxlbWVudHMgPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG4gIH1cbn07XG5cbk1hdHJpeDR4NC5wcm90b3R5cGUgPSB7XG4gIHBsdXM6IGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIHIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHJbaV0gPSB0aGlzLmVsZW1lbnRzW2ldICsgbS5lbGVtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0eDQocik7XG4gIH0sXG5cbiAgbWludXM6IGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIHIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIHJbaV0gPSB0aGlzLmVsZW1lbnRzW2ldIC0gbS5lbGVtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0eDQocik7XG4gIH0sXG5cbiAgLy8gcmlnaHQgbXVsdGlwbHkgYnkgYW5vdGhlciA0eDQgbWF0cml4OlxuICBtdWx0aXBseTogZnVuY3Rpb24gKG0pIHtcbiAgICAvLyBjYWNoZSBlbGVtZW50cyBpbiBsb2NhbCB2YXJpYWJsZXMsIGZvciBzcGVlZHVwOlxuICAgIHZhciB0aGlzMCA9IHRoaXMuZWxlbWVudHNbMF07XG4gICAgdmFyIHRoaXMxID0gdGhpcy5lbGVtZW50c1sxXTtcbiAgICB2YXIgdGhpczIgPSB0aGlzLmVsZW1lbnRzWzJdO1xuICAgIHZhciB0aGlzMyA9IHRoaXMuZWxlbWVudHNbM107XG4gICAgdmFyIHRoaXM0ID0gdGhpcy5lbGVtZW50c1s0XTtcbiAgICB2YXIgdGhpczUgPSB0aGlzLmVsZW1lbnRzWzVdO1xuICAgIHZhciB0aGlzNiA9IHRoaXMuZWxlbWVudHNbNl07XG4gICAgdmFyIHRoaXM3ID0gdGhpcy5lbGVtZW50c1s3XTtcbiAgICB2YXIgdGhpczggPSB0aGlzLmVsZW1lbnRzWzhdO1xuICAgIHZhciB0aGlzOSA9IHRoaXMuZWxlbWVudHNbOV07XG4gICAgdmFyIHRoaXMxMCA9IHRoaXMuZWxlbWVudHNbMTBdO1xuICAgIHZhciB0aGlzMTEgPSB0aGlzLmVsZW1lbnRzWzExXTtcbiAgICB2YXIgdGhpczEyID0gdGhpcy5lbGVtZW50c1sxMl07XG4gICAgdmFyIHRoaXMxMyA9IHRoaXMuZWxlbWVudHNbMTNdO1xuICAgIHZhciB0aGlzMTQgPSB0aGlzLmVsZW1lbnRzWzE0XTtcbiAgICB2YXIgdGhpczE1ID0gdGhpcy5lbGVtZW50c1sxNV07XG4gICAgdmFyIG0wID0gbS5lbGVtZW50c1swXTtcbiAgICB2YXIgbTEgPSBtLmVsZW1lbnRzWzFdO1xuICAgIHZhciBtMiA9IG0uZWxlbWVudHNbMl07XG4gICAgdmFyIG0zID0gbS5lbGVtZW50c1szXTtcbiAgICB2YXIgbTQgPSBtLmVsZW1lbnRzWzRdO1xuICAgIHZhciBtNSA9IG0uZWxlbWVudHNbNV07XG4gICAgdmFyIG02ID0gbS5lbGVtZW50c1s2XTtcbiAgICB2YXIgbTcgPSBtLmVsZW1lbnRzWzddO1xuICAgIHZhciBtOCA9IG0uZWxlbWVudHNbOF07XG4gICAgdmFyIG05ID0gbS5lbGVtZW50c1s5XTtcbiAgICB2YXIgbTEwID0gbS5lbGVtZW50c1sxMF07XG4gICAgdmFyIG0xMSA9IG0uZWxlbWVudHNbMTFdO1xuICAgIHZhciBtMTIgPSBtLmVsZW1lbnRzWzEyXTtcbiAgICB2YXIgbTEzID0gbS5lbGVtZW50c1sxM107XG4gICAgdmFyIG0xNCA9IG0uZWxlbWVudHNbMTRdO1xuICAgIHZhciBtMTUgPSBtLmVsZW1lbnRzWzE1XTtcblxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHRbMF0gPSB0aGlzMCAqIG0wICsgdGhpczEgKiBtNCArIHRoaXMyICogbTggKyB0aGlzMyAqIG0xMjtcbiAgICByZXN1bHRbMV0gPSB0aGlzMCAqIG0xICsgdGhpczEgKiBtNSArIHRoaXMyICogbTkgKyB0aGlzMyAqIG0xMztcbiAgICByZXN1bHRbMl0gPSB0aGlzMCAqIG0yICsgdGhpczEgKiBtNiArIHRoaXMyICogbTEwICsgdGhpczMgKiBtMTQ7XG4gICAgcmVzdWx0WzNdID0gdGhpczAgKiBtMyArIHRoaXMxICogbTcgKyB0aGlzMiAqIG0xMSArIHRoaXMzICogbTE1O1xuICAgIHJlc3VsdFs0XSA9IHRoaXM0ICogbTAgKyB0aGlzNSAqIG00ICsgdGhpczYgKiBtOCArIHRoaXM3ICogbTEyO1xuICAgIHJlc3VsdFs1XSA9IHRoaXM0ICogbTEgKyB0aGlzNSAqIG01ICsgdGhpczYgKiBtOSArIHRoaXM3ICogbTEzO1xuICAgIHJlc3VsdFs2XSA9IHRoaXM0ICogbTIgKyB0aGlzNSAqIG02ICsgdGhpczYgKiBtMTAgKyB0aGlzNyAqIG0xNDtcbiAgICByZXN1bHRbN10gPSB0aGlzNCAqIG0zICsgdGhpczUgKiBtNyArIHRoaXM2ICogbTExICsgdGhpczcgKiBtMTU7XG4gICAgcmVzdWx0WzhdID0gdGhpczggKiBtMCArIHRoaXM5ICogbTQgKyB0aGlzMTAgKiBtOCArIHRoaXMxMSAqIG0xMjtcbiAgICByZXN1bHRbOV0gPSB0aGlzOCAqIG0xICsgdGhpczkgKiBtNSArIHRoaXMxMCAqIG05ICsgdGhpczExICogbTEzO1xuICAgIHJlc3VsdFsxMF0gPSB0aGlzOCAqIG0yICsgdGhpczkgKiBtNiArIHRoaXMxMCAqIG0xMCArIHRoaXMxMSAqIG0xNDtcbiAgICByZXN1bHRbMTFdID0gdGhpczggKiBtMyArIHRoaXM5ICogbTcgKyB0aGlzMTAgKiBtMTEgKyB0aGlzMTEgKiBtMTU7XG4gICAgcmVzdWx0WzEyXSA9IHRoaXMxMiAqIG0wICsgdGhpczEzICogbTQgKyB0aGlzMTQgKiBtOCArIHRoaXMxNSAqIG0xMjtcbiAgICByZXN1bHRbMTNdID0gdGhpczEyICogbTEgKyB0aGlzMTMgKiBtNSArIHRoaXMxNCAqIG05ICsgdGhpczE1ICogbTEzO1xuICAgIHJlc3VsdFsxNF0gPSB0aGlzMTIgKiBtMiArIHRoaXMxMyAqIG02ICsgdGhpczE0ICogbTEwICsgdGhpczE1ICogbTE0O1xuICAgIHJlc3VsdFsxNV0gPSB0aGlzMTIgKiBtMyArIHRoaXMxMyAqIG03ICsgdGhpczE0ICogbTExICsgdGhpczE1ICogbTE1O1xuICAgIHJldHVybiBuZXcgTWF0cml4NHg0KHJlc3VsdCk7XG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0eDQoZWxlbWVudHMpO1xuICB9LFxuXG4gIC8vIFJpZ2h0IG11bHRpcGx5IHRoZSBtYXRyaXggYnkgYSBWZWN0b3IzRCAoaW50ZXJwcmV0ZWQgYXMgMyByb3csIDEgY29sdW1uKVxuICAvLyAocmVzdWx0ID0gTSp2KVxuICAvLyBGb3VydGggZWxlbWVudCBpcyB0YWtlbiBhcyAxXG4gIHJpZ2h0TXVsdGlwbHkxeDNWZWN0b3I6IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHYwID0gdi5feDtcbiAgICB2YXIgdjEgPSB2Ll95O1xuICAgIHZhciB2MiA9IHYuX3o7XG4gICAgdmFyIHYzID0gMTtcbiAgICB2YXIgeCA9XG4gICAgICB2MCAqIHRoaXMuZWxlbWVudHNbMF0gK1xuICAgICAgdjEgKiB0aGlzLmVsZW1lbnRzWzFdICtcbiAgICAgIHYyICogdGhpcy5lbGVtZW50c1syXSArXG4gICAgICB2MyAqIHRoaXMuZWxlbWVudHNbM107XG4gICAgdmFyIHkgPVxuICAgICAgdjAgKiB0aGlzLmVsZW1lbnRzWzRdICtcbiAgICAgIHYxICogdGhpcy5lbGVtZW50c1s1XSArXG4gICAgICB2MiAqIHRoaXMuZWxlbWVudHNbNl0gK1xuICAgICAgdjMgKiB0aGlzLmVsZW1lbnRzWzddO1xuICAgIHZhciB6ID1cbiAgICAgIHYwICogdGhpcy5lbGVtZW50c1s4XSArXG4gICAgICB2MSAqIHRoaXMuZWxlbWVudHNbOV0gK1xuICAgICAgdjIgKiB0aGlzLmVsZW1lbnRzWzEwXSArXG4gICAgICB2MyAqIHRoaXMuZWxlbWVudHNbMTFdO1xuICAgIHZhciB3ID1cbiAgICAgIHYwICogdGhpcy5lbGVtZW50c1sxMl0gK1xuICAgICAgdjEgKiB0aGlzLmVsZW1lbnRzWzEzXSArXG4gICAgICB2MiAqIHRoaXMuZWxlbWVudHNbMTRdICtcbiAgICAgIHYzICogdGhpcy5lbGVtZW50c1sxNV07XG4gICAgLy8gc2NhbGUgc3VjaCB0aGF0IGZvdXJ0aCBlbGVtZW50IGJlY29tZXMgMTpcbiAgICBpZiAodyAhPT0gMSkge1xuICAgICAgdmFyIGludncgPSAxLjAgLyB3O1xuICAgICAgeCAqPSBpbnZ3O1xuICAgICAgeSAqPSBpbnZ3O1xuICAgICAgeiAqPSBpbnZ3O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZlY3RvcjNEKHgsIHksIHopO1xuICB9LFxuXG4gIC8vIE11bHRpcGx5IGEgVmVjdG9yM0QgKGludGVycHJldGVkIGFzIDMgY29sdW1uLCAxIHJvdykgYnkgdGhpcyBtYXRyaXhcbiAgLy8gKHJlc3VsdCA9IHYqTSlcbiAgLy8gRm91cnRoIGVsZW1lbnQgaXMgdGFrZW4gYXMgMVxuICBsZWZ0TXVsdGlwbHkxeDNWZWN0b3I6IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHYwID0gdi5feDtcbiAgICB2YXIgdjEgPSB2Ll95O1xuICAgIHZhciB2MiA9IHYuX3o7XG4gICAgdmFyIHYzID0gMTtcbiAgICB2YXIgeCA9XG4gICAgICB2MCAqIHRoaXMuZWxlbWVudHNbMF0gK1xuICAgICAgdjEgKiB0aGlzLmVsZW1lbnRzWzRdICtcbiAgICAgIHYyICogdGhpcy5lbGVtZW50c1s4XSArXG4gICAgICB2MyAqIHRoaXMuZWxlbWVudHNbMTJdO1xuICAgIHZhciB5ID1cbiAgICAgIHYwICogdGhpcy5lbGVtZW50c1sxXSArXG4gICAgICB2MSAqIHRoaXMuZWxlbWVudHNbNV0gK1xuICAgICAgdjIgKiB0aGlzLmVsZW1lbnRzWzldICtcbiAgICAgIHYzICogdGhpcy5lbGVtZW50c1sxM107XG4gICAgdmFyIHogPVxuICAgICAgdjAgKiB0aGlzLmVsZW1lbnRzWzJdICtcbiAgICAgIHYxICogdGhpcy5lbGVtZW50c1s2XSArXG4gICAgICB2MiAqIHRoaXMuZWxlbWVudHNbMTBdICtcbiAgICAgIHYzICogdGhpcy5lbGVtZW50c1sxNF07XG4gICAgdmFyIHcgPVxuICAgICAgdjAgKiB0aGlzLmVsZW1lbnRzWzNdICtcbiAgICAgIHYxICogdGhpcy5lbGVtZW50c1s3XSArXG4gICAgICB2MiAqIHRoaXMuZWxlbWVudHNbMTFdICtcbiAgICAgIHYzICogdGhpcy5lbGVtZW50c1sxNV07XG4gICAgLy8gc2NhbGUgc3VjaCB0aGF0IGZvdXJ0aCBlbGVtZW50IGJlY29tZXMgMTpcbiAgICBpZiAodyAhPT0gMSkge1xuICAgICAgdmFyIGludncgPSAxLjAgLyB3O1xuICAgICAgeCAqPSBpbnZ3O1xuICAgICAgeSAqPSBpbnZ3O1xuICAgICAgeiAqPSBpbnZ3O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZlY3RvcjNEKHgsIHksIHopO1xuICB9LFxuXG4gIC8vIFJpZ2h0IG11bHRpcGx5IHRoZSBtYXRyaXggYnkgYSBWZWN0b3IyRCAoaW50ZXJwcmV0ZWQgYXMgMiByb3csIDEgY29sdW1uKVxuICAvLyAocmVzdWx0ID0gTSp2KVxuICAvLyBGb3VydGggZWxlbWVudCBpcyB0YWtlbiBhcyAxXG4gIHJpZ2h0TXVsdGlwbHkxeDJWZWN0b3I6IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHYwID0gdi54O1xuICAgIHZhciB2MSA9IHYueTtcbiAgICB2YXIgdjIgPSAwO1xuICAgIHZhciB2MyA9IDE7XG4gICAgdmFyIHggPVxuICAgICAgdjAgKiB0aGlzLmVsZW1lbnRzWzBdICtcbiAgICAgIHYxICogdGhpcy5lbGVtZW50c1sxXSArXG4gICAgICB2MiAqIHRoaXMuZWxlbWVudHNbMl0gK1xuICAgICAgdjMgKiB0aGlzLmVsZW1lbnRzWzNdO1xuICAgIHZhciB5ID1cbiAgICAgIHYwICogdGhpcy5lbGVtZW50c1s0XSArXG4gICAgICB2MSAqIHRoaXMuZWxlbWVudHNbNV0gK1xuICAgICAgdjIgKiB0aGlzLmVsZW1lbnRzWzZdICtcbiAgICAgIHYzICogdGhpcy5lbGVtZW50c1s3XTtcbiAgICB2YXIgeiA9XG4gICAgICB2MCAqIHRoaXMuZWxlbWVudHNbOF0gK1xuICAgICAgdjEgKiB0aGlzLmVsZW1lbnRzWzldICtcbiAgICAgIHYyICogdGhpcy5lbGVtZW50c1sxMF0gK1xuICAgICAgdjMgKiB0aGlzLmVsZW1lbnRzWzExXTtcbiAgICB2YXIgdyA9XG4gICAgICB2MCAqIHRoaXMuZWxlbWVudHNbMTJdICtcbiAgICAgIHYxICogdGhpcy5lbGVtZW50c1sxM10gK1xuICAgICAgdjIgKiB0aGlzLmVsZW1lbnRzWzE0XSArXG4gICAgICB2MyAqIHRoaXMuZWxlbWVudHNbMTVdO1xuICAgIC8vIHNjYWxlIHN1Y2ggdGhhdCBmb3VydGggZWxlbWVudCBiZWNvbWVzIDE6XG4gICAgaWYgKHcgIT09IDEpIHtcbiAgICAgIHZhciBpbnZ3ID0gMS4wIC8gdztcbiAgICAgIHggKj0gaW52dztcbiAgICAgIHkgKj0gaW52dztcbiAgICAgIHogKj0gaW52dztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyRCh4LCB5KTtcbiAgfSxcblxuICAvLyBNdWx0aXBseSBhIFZlY3RvcjJEIChpbnRlcnByZXRlZCBhcyAyIGNvbHVtbiwgMSByb3cpIGJ5IHRoaXMgbWF0cml4XG4gIC8vIChyZXN1bHQgPSB2Kk0pXG4gIC8vIEZvdXJ0aCBlbGVtZW50IGlzIHRha2VuIGFzIDFcbiAgbGVmdE11bHRpcGx5MXgyVmVjdG9yOiBmdW5jdGlvbiAodikge1xuICAgIHZhciB2MCA9IHYueDtcbiAgICB2YXIgdjEgPSB2Lnk7XG4gICAgdmFyIHYyID0gMDtcbiAgICB2YXIgdjMgPSAxO1xuICAgIHZhciB4ID1cbiAgICAgIHYwICogdGhpcy5lbGVtZW50c1swXSArXG4gICAgICB2MSAqIHRoaXMuZWxlbWVudHNbNF0gK1xuICAgICAgdjIgKiB0aGlzLmVsZW1lbnRzWzhdICtcbiAgICAgIHYzICogdGhpcy5lbGVtZW50c1sxMl07XG4gICAgdmFyIHkgPVxuICAgICAgdjAgKiB0aGlzLmVsZW1lbnRzWzFdICtcbiAgICAgIHYxICogdGhpcy5lbGVtZW50c1s1XSArXG4gICAgICB2MiAqIHRoaXMuZWxlbWVudHNbOV0gK1xuICAgICAgdjMgKiB0aGlzLmVsZW1lbnRzWzEzXTtcbiAgICB2YXIgeiA9XG4gICAgICB2MCAqIHRoaXMuZWxlbWVudHNbMl0gK1xuICAgICAgdjEgKiB0aGlzLmVsZW1lbnRzWzZdICtcbiAgICAgIHYyICogdGhpcy5lbGVtZW50c1sxMF0gK1xuICAgICAgdjMgKiB0aGlzLmVsZW1lbnRzWzE0XTtcbiAgICB2YXIgdyA9XG4gICAgICB2MCAqIHRoaXMuZWxlbWVudHNbM10gK1xuICAgICAgdjEgKiB0aGlzLmVsZW1lbnRzWzddICtcbiAgICAgIHYyICogdGhpcy5lbGVtZW50c1sxMV0gK1xuICAgICAgdjMgKiB0aGlzLmVsZW1lbnRzWzE1XTtcbiAgICAvLyBzY2FsZSBzdWNoIHRoYXQgZm91cnRoIGVsZW1lbnQgYmVjb21lcyAxOlxuICAgIGlmICh3ICE9PSAxKSB7XG4gICAgICB2YXIgaW52dyA9IDEuMCAvIHc7XG4gICAgICB4ICo9IGludnc7XG4gICAgICB5ICo9IGludnc7XG4gICAgICB6ICo9IGludnc7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVmVjdG9yMkQoeCwgeSk7XG4gIH0sXG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBtYXRyaXggaXMgYSBtaXJyb3JpbmcgdHJhbnNmb3JtYXRpb25cbiAgaXNNaXJyb3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdSA9IG5ldyBWZWN0b3IzRCh0aGlzLmVsZW1lbnRzWzBdLCB0aGlzLmVsZW1lbnRzWzRdLCB0aGlzLmVsZW1lbnRzWzhdKTtcbiAgICB2YXIgdiA9IG5ldyBWZWN0b3IzRCh0aGlzLmVsZW1lbnRzWzFdLCB0aGlzLmVsZW1lbnRzWzVdLCB0aGlzLmVsZW1lbnRzWzldKTtcbiAgICB2YXIgdyA9IG5ldyBWZWN0b3IzRCh0aGlzLmVsZW1lbnRzWzJdLCB0aGlzLmVsZW1lbnRzWzZdLCB0aGlzLmVsZW1lbnRzWzEwXSk7XG5cbiAgICAvLyBmb3IgYSB0cnVlIG9ydGhvZ29uYWwsIG5vbi1taXJyb3JlZCBiYXNlLCB1LmNyb3NzKHYpID09IHdcbiAgICAvLyBJZiB0aGV5IGhhdmUgYW4gb3Bwb3NpdGUgZGlyZWN0aW9uIHRoZW4gd2UgYXJlIG1pcnJvcmluZ1xuICAgIHZhciBtaXJyb3J2YWx1ZSA9IHUuY3Jvc3ModikuZG90KHcpO1xuICAgIHZhciBpc21pcnJvciA9IG1pcnJvcnZhbHVlIDwgMDtcbiAgICByZXR1cm4gaXNtaXJyb3I7XG4gIH0sXG59O1xuXG4vLyByZXR1cm4gdGhlIHVuaXR5IG1hdHJpeFxuTWF0cml4NHg0LnVuaXR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1hdHJpeDR4NCgpO1xufTtcblxuLy8gQ3JlYXRlIGEgcm90YXRpb24gbWF0cml4IGZvciByb3RhdGluZyBhcm91bmQgdGhlIHggYXhpc1xuTWF0cml4NHg0LnJvdGF0aW9uWCA9IGZ1bmN0aW9uIChkZWdyZWVzKSB7XG4gIHZhciByYWRpYW5zID0gZGVncmVlcyAqIE1hdGguUEkgKiAoMS4wIC8gMTgwLjApO1xuICB2YXIgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcbiAgdmFyIGVscyA9IFsxLCAwLCAwLCAwLCAwLCBjb3MsIHNpbiwgMCwgMCwgLXNpbiwgY29zLCAwLCAwLCAwLCAwLCAxXTtcbiAgcmV0dXJuIG5ldyBNYXRyaXg0eDQoZWxzKTtcbn07XG5cbi8vIENyZWF0ZSBhIHJvdGF0aW9uIG1hdHJpeCBmb3Igcm90YXRpbmcgYXJvdW5kIHRoZSB5IGF4aXNcbk1hdHJpeDR4NC5yb3RhdGlvblkgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICB2YXIgcmFkaWFucyA9IGRlZ3JlZXMgKiBNYXRoLlBJICogKDEuMCAvIDE4MC4wKTtcbiAgdmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gIHZhciBlbHMgPSBbY29zLCAwLCAtc2luLCAwLCAwLCAxLCAwLCAwLCBzaW4sIDAsIGNvcywgMCwgMCwgMCwgMCwgMV07XG4gIHJldHVybiBuZXcgTWF0cml4NHg0KGVscyk7XG59O1xuXG4vLyBDcmVhdGUgYSByb3RhdGlvbiBtYXRyaXggZm9yIHJvdGF0aW5nIGFyb3VuZCB0aGUgeiBheGlzXG5NYXRyaXg0eDQucm90YXRpb25aID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcbiAgdmFyIHJhZGlhbnMgPSBkZWdyZWVzICogTWF0aC5QSSAqICgxLjAgLyAxODAuMCk7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xuICB2YXIgZWxzID0gW2Nvcywgc2luLCAwLCAwLCAtc2luLCBjb3MsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuICByZXR1cm4gbmV3IE1hdHJpeDR4NChlbHMpO1xufTtcblxuLy8gTWF0cml4IGZvciByb3RhdGlvbiBhYm91dCBhcmJpdHJhcnkgcG9pbnQgYW5kIGF4aXNcbk1hdHJpeDR4NC5yb3RhdGlvbiA9IGZ1bmN0aW9uIChyb3RhdGlvbkNlbnRlciwgcm90YXRpb25BeGlzLCBkZWdyZWVzKSB7XG4gIHJvdGF0aW9uQ2VudGVyID0gbmV3IFZlY3RvcjNEKHJvdGF0aW9uQ2VudGVyKTtcbiAgcm90YXRpb25BeGlzID0gbmV3IFZlY3RvcjNEKHJvdGF0aW9uQXhpcyk7XG4gIHZhciByb3RhdGlvblBsYW5lID0gUGxhbmUuZnJvbU5vcm1hbEFuZFBvaW50KHJvdGF0aW9uQXhpcywgcm90YXRpb25DZW50ZXIpO1xuICB2YXIgb3J0aG9iYXNpcyA9IG5ldyBPcnRob05vcm1hbEJhc2lzKHJvdGF0aW9uUGxhbmUpO1xuICB2YXIgdHJhbnNmb3JtYXRpb24gPSBNYXRyaXg0eDQudHJhbnNsYXRpb24ocm90YXRpb25DZW50ZXIubmVnYXRlZCgpKTtcbiAgdHJhbnNmb3JtYXRpb24gPSB0cmFuc2Zvcm1hdGlvbi5tdWx0aXBseShvcnRob2Jhc2lzLmdldFByb2plY3Rpb25NYXRyaXgoKSk7XG4gIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24ubXVsdGlwbHkoTWF0cml4NHg0LnJvdGF0aW9uWihkZWdyZWVzKSk7XG4gIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24ubXVsdGlwbHkoXG4gICAgb3J0aG9iYXNpcy5nZXRJbnZlcnNlUHJvamVjdGlvbk1hdHJpeCgpXG4gICk7XG4gIHRyYW5zZm9ybWF0aW9uID0gdHJhbnNmb3JtYXRpb24ubXVsdGlwbHkoXG4gICAgTWF0cml4NHg0LnRyYW5zbGF0aW9uKHJvdGF0aW9uQ2VudGVyKVxuICApO1xuICByZXR1cm4gdHJhbnNmb3JtYXRpb247XG59O1xuXG4vLyBDcmVhdGUgYW4gYWZmaW5lIG1hdHJpeCBmb3IgdHJhbnNsYXRpb246XG5NYXRyaXg0eDQudHJhbnNsYXRpb24gPSBmdW5jdGlvbiAodikge1xuICAvLyBwYXJzZSBhcyBWZWN0b3IzRCwgc28gd2UgY2FuIHBhc3MgYW4gYXJyYXkgb3IgYSBWZWN0b3IzRFxuICB2YXIgdmVjID0gbmV3IFZlY3RvcjNEKHYpO1xuICB2YXIgZWxzID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIHZlYy54LCB2ZWMueSwgdmVjLnosIDFdO1xuICByZXR1cm4gbmV3IE1hdHJpeDR4NChlbHMpO1xufTtcblxuLy8gQ3JlYXRlIGFuIGFmZmluZSBtYXRyaXggZm9yIG1pcnJvcmluZyBpbnRvIGFuIGFyYml0cmFyeSBwbGFuZTpcbk1hdHJpeDR4NC5taXJyb3JpbmcgPSBmdW5jdGlvbiAocGxhbmUpIHtcbiAgdmFyIG54ID0gcGxhbmUubm9ybWFsLng7XG4gIHZhciBueSA9IHBsYW5lLm5vcm1hbC55O1xuICB2YXIgbnogPSBwbGFuZS5ub3JtYWwuejtcbiAgdmFyIHcgPSBwbGFuZS53O1xuICB2YXIgZWxzID0gW1xuICAgIDEuMCAtIDIuMCAqIG54ICogbngsXG4gICAgLTIuMCAqIG55ICogbngsXG4gICAgLTIuMCAqIG56ICogbngsXG4gICAgMCxcbiAgICAtMi4wICogbnggKiBueSxcbiAgICAxLjAgLSAyLjAgKiBueSAqIG55LFxuICAgIC0yLjAgKiBueiAqIG55LFxuICAgIDAsXG4gICAgLTIuMCAqIG54ICogbnosXG4gICAgLTIuMCAqIG55ICogbnosXG4gICAgMS4wIC0gMi4wICogbnogKiBueixcbiAgICAwLFxuICAgIDIuMCAqIG54ICogdyxcbiAgICAyLjAgKiBueSAqIHcsXG4gICAgMi4wICogbnogKiB3LFxuICAgIDEsXG4gIF07XG4gIHJldHVybiBuZXcgTWF0cml4NHg0KGVscyk7XG59O1xuXG4vLyBDcmVhdGUgYW4gYWZmaW5lIG1hdHJpeCBmb3Igc2NhbGluZzpcbk1hdHJpeDR4NC5zY2FsaW5nID0gZnVuY3Rpb24gKHYpIHtcbiAgLy8gcGFyc2UgYXMgVmVjdG9yM0QsIHNvIHdlIGNhbiBwYXNzIGFuIGFycmF5IG9yIGEgVmVjdG9yM0RcbiAgdmFyIHZlYyA9IG5ldyBWZWN0b3IzRCh2KTtcbiAgdmFyIGVscyA9IFt2ZWMueCwgMCwgMCwgMCwgMCwgdmVjLnksIDAsIDAsIDAsIDAsIHZlYy56LCAwLCAwLCAwLCAwLCAxXTtcbiAgcmV0dXJuIG5ldyBNYXRyaXg0eDQoZWxzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4NHg0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/math/Matrix4.js\n");

/***/ }),

/***/ "./src/core/math/OrthoNormalBasis.js":
/*!*******************************************!*\
  !*** ./src/core/math/OrthoNormalBasis.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\nconst Vector3D = __webpack_require__(/*! ./Vector3 */ \"./src/core/math/Vector3.js\");\nconst Line2D = __webpack_require__(/*! ./Line2 */ \"./src/core/math/Line2.js\");\nconst Line3D = __webpack_require__(/*! ./Line3 */ \"./src/core/math/Line3.js\");\nconst Plane = __webpack_require__(/*! ./Plane */ \"./src/core/math/Plane.js\");\n\n/** class OrthoNormalBasis\n * Reprojects points on a 3D plane onto a 2D plane\n * or from a 2D plane back onto the 3D plane\n * @param  {Plane} plane\n * @param  {Vector3D|Vector2D} rightvector\n */\nconst OrthoNormalBasis = function (plane, rightvector) {\n  if (arguments.length < 2) {\n    // choose an arbitrary right hand vector, making sure it is somewhat orthogonal to the plane normal:\n    rightvector = plane.normal.randomNonParallelVector();\n  } else {\n    rightvector = new Vector3D(rightvector);\n  }\n  this.v = plane.normal.cross(rightvector).unit();\n  this.u = this.v.cross(plane.normal);\n  this.plane = plane;\n  this.planeorigin = plane.normal.times(plane.w);\n};\n\n// Get an orthonormal basis for the standard XYZ planes.\n// Parameters: the names of two 3D axes. The 2d x axis will map to the first given 3D axis, the 2d y\n// axis will map to the second.\n// Prepend the axis with a \"-\" to invert the direction of this axis.\n// For example: OrthoNormalBasis.GetCartesian(\"-Y\",\"Z\")\n//   will return an orthonormal basis where the 2d X axis maps to the 3D inverted Y axis, and\n//   the 2d Y axis maps to the 3D Z axis.\nOrthoNormalBasis.GetCartesian = function (xaxisid, yaxisid) {\n  let axisid = xaxisid + '/' + yaxisid;\n  let planenormal, rightvector;\n  if (axisid === 'X/Y') {\n    planenormal = [0, 0, 1];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Y/-X') {\n    planenormal = [0, 0, 1];\n    rightvector = [0, 1, 0];\n  } else if (axisid === '-X/-Y') {\n    planenormal = [0, 0, 1];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Y/X') {\n    planenormal = [0, 0, 1];\n    rightvector = [0, -1, 0];\n  } else if (axisid === '-X/Y') {\n    planenormal = [0, 0, -1];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Y/-X') {\n    planenormal = [0, 0, -1];\n    rightvector = [0, -1, 0];\n  } else if (axisid === 'X/-Y') {\n    planenormal = [0, 0, -1];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Y/X') {\n    planenormal = [0, 0, -1];\n    rightvector = [0, 1, 0];\n  } else if (axisid === 'X/Z') {\n    planenormal = [0, -1, 0];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Z/-X') {\n    planenormal = [0, -1, 0];\n    rightvector = [0, 0, 1];\n  } else if (axisid === '-X/-Z') {\n    planenormal = [0, -1, 0];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Z/X') {\n    planenormal = [0, -1, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === '-X/Z') {\n    planenormal = [0, 1, 0];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Z/-X') {\n    planenormal = [0, 1, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === 'X/-Z') {\n    planenormal = [0, 1, 0];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Z/X') {\n    planenormal = [0, 1, 0];\n    rightvector = [0, 0, 1];\n  } else if (axisid === 'Y/Z') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, 1, 0];\n  } else if (axisid === 'Z/-Y') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, 0, 1];\n  } else if (axisid === '-Y/-Z') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, -1, 0];\n  } else if (axisid === '-Z/Y') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === '-Y/Z') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, -1, 0];\n  } else if (axisid === '-Z/-Y') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === 'Y/-Z') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, 1, 0];\n  } else if (axisid === 'Z/Y') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, 0, 1];\n  } else {\n    throw new Error(\n      'OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.'\n    );\n  }\n  return new OrthoNormalBasis(\n    new Plane(new Vector3D(planenormal), 0),\n    new Vector3D(rightvector)\n  );\n};\n\n/*\n// test code for OrthoNormalBasis.GetCartesian()\nOrthoNormalBasis.GetCartesian_Test=function() {\n  let axisnames=[\"X\",\"Y\",\"Z\",\"-X\",\"-Y\",\"-Z\"];\n  let axisvectors=[[1,0,0], [0,1,0], [0,0,1], [-1,0,0], [0,-1,0], [0,0,-1]];\n  for(let axis1=0; axis1 < 3; axis1++) {\n    for(let axis1inverted=0; axis1inverted < 2; axis1inverted++) {\n      let axis1name=axisnames[axis1+3*axis1inverted];\n      let axis1vector=axisvectors[axis1+3*axis1inverted];\n      for(let axis2=0; axis2 < 3; axis2++) {\n        if(axis2 != axis1) {\n          for(let axis2inverted=0; axis2inverted < 2; axis2inverted++) {\n            let axis2name=axisnames[axis2+3*axis2inverted];\n            let axis2vector=axisvectors[axis2+3*axis2inverted];\n            let orthobasis=OrthoNormalBasis.GetCartesian(axis1name, axis2name);\n            let test1=orthobasis.to3D(new Vector2D([1,0]));\n            let test2=orthobasis.to3D(new Vector2D([0,1]));\n            let expected1=new Vector3D(axis1vector);\n            let expected2=new Vector3D(axis2vector);\n            let d1=test1.distanceTo(expected1);\n            let d2=test2.distanceTo(expected2);\n            if( (d1 > 0.01) || (d2 > 0.01) ) {\n              throw new Error(\"Wrong!\");\n  }}}}}}\n  throw new Error(\"OK\");\n};\n*/\n\n// The z=0 plane, with the 3D x and y vectors mapped to the 2D x and y vector\nOrthoNormalBasis.Z0Plane = function () {\n  let plane = new Plane(new Vector3D([0, 0, 1]), 0);\n  return new OrthoNormalBasis(plane, new Vector3D([1, 0, 0]));\n};\n\nOrthoNormalBasis.prototype = {\n  getProjectionMatrix: function () {\n    const Matrix4x4 = __webpack_require__(/*! ./Matrix4 */ \"./src/core/math/Matrix4.js\"); // FIXME: circular dependencies Matrix=>OrthoNormalBasis => Matrix\n    return new Matrix4x4([\n      this.u.x,\n      this.v.x,\n      this.plane.normal.x,\n      0,\n      this.u.y,\n      this.v.y,\n      this.plane.normal.y,\n      0,\n      this.u.z,\n      this.v.z,\n      this.plane.normal.z,\n      0,\n      0,\n      0,\n      -this.plane.w,\n      1,\n    ]);\n  },\n\n  getInverseProjectionMatrix: function () {\n    const Matrix4x4 = __webpack_require__(/*! ./Matrix4 */ \"./src/core/math/Matrix4.js\"); // FIXME: circular dependencies Matrix=>OrthoNormalBasis => Matrix\n    let p = this.plane.normal.times(this.plane.w);\n    return new Matrix4x4([\n      this.u.x,\n      this.u.y,\n      this.u.z,\n      0,\n      this.v.x,\n      this.v.y,\n      this.v.z,\n      0,\n      this.plane.normal.x,\n      this.plane.normal.y,\n      this.plane.normal.z,\n      0,\n      p.x,\n      p.y,\n      p.z,\n      1,\n    ]);\n  },\n\n  to2D: function (vec3) {\n    return new Vector2D(vec3.dot(this.u), vec3.dot(this.v));\n  },\n\n  to3D: function (vec2) {\n    return this.planeorigin\n      .plus(this.u.times(vec2.x))\n      .plus(this.v.times(vec2.y));\n  },\n\n  line3Dto2D: function (line3d) {\n    let a = line3d.point;\n    let b = line3d.direction.plus(a);\n    let a2d = this.to2D(a);\n    let b2d = this.to2D(b);\n    return Line2D.fromPoints(a2d, b2d);\n  },\n\n  line2Dto3D: function (line2d) {\n    let a = line2d.origin();\n    let b = line2d.direction().plus(a);\n    let a3d = this.to3D(a);\n    let b3d = this.to3D(b);\n    return Line3D.fromPoints(a3d, b3d);\n  },\n\n  transform: function (matrix4x4) {\n    // todo: this may not work properly in case of mirroring\n    let newplane = this.plane.transform(matrix4x4);\n    let rightpointTransformed = this.u.transform(matrix4x4);\n    let originTransformed = new Vector3D(0, 0, 0).transform(matrix4x4);\n    let newrighthandvector = rightpointTransformed.minus(originTransformed);\n    let newbasis = new OrthoNormalBasis(newplane, newrighthandvector);\n    return newbasis;\n  },\n};\n\nmodule.exports = OrthoNormalBasis;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL09ydGhvTm9ybWFsQmFzaXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9tYXRoL09ydGhvTm9ybWFsQmFzaXMuanM/MDNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4vVmVjdG9yMicpO1xuY29uc3QgVmVjdG9yM0QgPSByZXF1aXJlKCcuL1ZlY3RvcjMnKTtcbmNvbnN0IExpbmUyRCA9IHJlcXVpcmUoJy4vTGluZTInKTtcbmNvbnN0IExpbmUzRCA9IHJlcXVpcmUoJy4vTGluZTMnKTtcbmNvbnN0IFBsYW5lID0gcmVxdWlyZSgnLi9QbGFuZScpO1xuXG4vKiogY2xhc3MgT3J0aG9Ob3JtYWxCYXNpc1xuICogUmVwcm9qZWN0cyBwb2ludHMgb24gYSAzRCBwbGFuZSBvbnRvIGEgMkQgcGxhbmVcbiAqIG9yIGZyb20gYSAyRCBwbGFuZSBiYWNrIG9udG8gdGhlIDNEIHBsYW5lXG4gKiBAcGFyYW0gIHtQbGFuZX0gcGxhbmVcbiAqIEBwYXJhbSAge1ZlY3RvcjNEfFZlY3RvcjJEfSByaWdodHZlY3RvclxuICovXG5jb25zdCBPcnRob05vcm1hbEJhc2lzID0gZnVuY3Rpb24gKHBsYW5lLCByaWdodHZlY3Rvcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAvLyBjaG9vc2UgYW4gYXJiaXRyYXJ5IHJpZ2h0IGhhbmQgdmVjdG9yLCBtYWtpbmcgc3VyZSBpdCBpcyBzb21ld2hhdCBvcnRob2dvbmFsIHRvIHRoZSBwbGFuZSBub3JtYWw6XG4gICAgcmlnaHR2ZWN0b3IgPSBwbGFuZS5ub3JtYWwucmFuZG9tTm9uUGFyYWxsZWxWZWN0b3IoKTtcbiAgfSBlbHNlIHtcbiAgICByaWdodHZlY3RvciA9IG5ldyBWZWN0b3IzRChyaWdodHZlY3Rvcik7XG4gIH1cbiAgdGhpcy52ID0gcGxhbmUubm9ybWFsLmNyb3NzKHJpZ2h0dmVjdG9yKS51bml0KCk7XG4gIHRoaXMudSA9IHRoaXMudi5jcm9zcyhwbGFuZS5ub3JtYWwpO1xuICB0aGlzLnBsYW5lID0gcGxhbmU7XG4gIHRoaXMucGxhbmVvcmlnaW4gPSBwbGFuZS5ub3JtYWwudGltZXMocGxhbmUudyk7XG59O1xuXG4vLyBHZXQgYW4gb3J0aG9ub3JtYWwgYmFzaXMgZm9yIHRoZSBzdGFuZGFyZCBYWVogcGxhbmVzLlxuLy8gUGFyYW1ldGVyczogdGhlIG5hbWVzIG9mIHR3byAzRCBheGVzLiBUaGUgMmQgeCBheGlzIHdpbGwgbWFwIHRvIHRoZSBmaXJzdCBnaXZlbiAzRCBheGlzLCB0aGUgMmQgeVxuLy8gYXhpcyB3aWxsIG1hcCB0byB0aGUgc2Vjb25kLlxuLy8gUHJlcGVuZCB0aGUgYXhpcyB3aXRoIGEgXCItXCIgdG8gaW52ZXJ0IHRoZSBkaXJlY3Rpb24gb2YgdGhpcyBheGlzLlxuLy8gRm9yIGV4YW1wbGU6IE9ydGhvTm9ybWFsQmFzaXMuR2V0Q2FydGVzaWFuKFwiLVlcIixcIlpcIilcbi8vICAgd2lsbCByZXR1cm4gYW4gb3J0aG9ub3JtYWwgYmFzaXMgd2hlcmUgdGhlIDJkIFggYXhpcyBtYXBzIHRvIHRoZSAzRCBpbnZlcnRlZCBZIGF4aXMsIGFuZFxuLy8gICB0aGUgMmQgWSBheGlzIG1hcHMgdG8gdGhlIDNEIFogYXhpcy5cbk9ydGhvTm9ybWFsQmFzaXMuR2V0Q2FydGVzaWFuID0gZnVuY3Rpb24gKHhheGlzaWQsIHlheGlzaWQpIHtcbiAgbGV0IGF4aXNpZCA9IHhheGlzaWQgKyAnLycgKyB5YXhpc2lkO1xuICBsZXQgcGxhbmVub3JtYWwsIHJpZ2h0dmVjdG9yO1xuICBpZiAoYXhpc2lkID09PSAnWC9ZJykge1xuICAgIHBsYW5lbm9ybWFsID0gWzAsIDAsIDFdO1xuICAgIHJpZ2h0dmVjdG9yID0gWzEsIDAsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJ1kvLVgnKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMCwgMCwgMV07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgMSwgMF07XG4gIH0gZWxzZSBpZiAoYXhpc2lkID09PSAnLVgvLVknKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMCwgMCwgMV07XG4gICAgcmlnaHR2ZWN0b3IgPSBbLTEsIDAsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJy1ZL1gnKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMCwgMCwgMV07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgLTEsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJy1YL1knKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMCwgMCwgLTFdO1xuICAgIHJpZ2h0dmVjdG9yID0gWy0xLCAwLCAwXTtcbiAgfSBlbHNlIGlmIChheGlzaWQgPT09ICctWS8tWCcpIHtcbiAgICBwbGFuZW5vcm1hbCA9IFswLCAwLCAtMV07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgLTEsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJ1gvLVknKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMCwgMCwgLTFdO1xuICAgIHJpZ2h0dmVjdG9yID0gWzEsIDAsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJ1kvWCcpIHtcbiAgICBwbGFuZW5vcm1hbCA9IFswLCAwLCAtMV07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgMSwgMF07XG4gIH0gZWxzZSBpZiAoYXhpc2lkID09PSAnWC9aJykge1xuICAgIHBsYW5lbm9ybWFsID0gWzAsIC0xLCAwXTtcbiAgICByaWdodHZlY3RvciA9IFsxLCAwLCAwXTtcbiAgfSBlbHNlIGlmIChheGlzaWQgPT09ICdaLy1YJykge1xuICAgIHBsYW5lbm9ybWFsID0gWzAsIC0xLCAwXTtcbiAgICByaWdodHZlY3RvciA9IFswLCAwLCAxXTtcbiAgfSBlbHNlIGlmIChheGlzaWQgPT09ICctWC8tWicpIHtcbiAgICBwbGFuZW5vcm1hbCA9IFswLCAtMSwgMF07XG4gICAgcmlnaHR2ZWN0b3IgPSBbLTEsIDAsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJy1aL1gnKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMCwgLTEsIDBdO1xuICAgIHJpZ2h0dmVjdG9yID0gWzAsIDAsIC0xXTtcbiAgfSBlbHNlIGlmIChheGlzaWQgPT09ICctWC9aJykge1xuICAgIHBsYW5lbm9ybWFsID0gWzAsIDEsIDBdO1xuICAgIHJpZ2h0dmVjdG9yID0gWy0xLCAwLCAwXTtcbiAgfSBlbHNlIGlmIChheGlzaWQgPT09ICctWi8tWCcpIHtcbiAgICBwbGFuZW5vcm1hbCA9IFswLCAxLCAwXTtcbiAgICByaWdodHZlY3RvciA9IFswLCAwLCAtMV07XG4gIH0gZWxzZSBpZiAoYXhpc2lkID09PSAnWC8tWicpIHtcbiAgICBwbGFuZW5vcm1hbCA9IFswLCAxLCAwXTtcbiAgICByaWdodHZlY3RvciA9IFsxLCAwLCAwXTtcbiAgfSBlbHNlIGlmIChheGlzaWQgPT09ICdaL1gnKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMCwgMSwgMF07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgMCwgMV07XG4gIH0gZWxzZSBpZiAoYXhpc2lkID09PSAnWS9aJykge1xuICAgIHBsYW5lbm9ybWFsID0gWzEsIDAsIDBdO1xuICAgIHJpZ2h0dmVjdG9yID0gWzAsIDEsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJ1ovLVknKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMSwgMCwgMF07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgMCwgMV07XG4gIH0gZWxzZSBpZiAoYXhpc2lkID09PSAnLVkvLVonKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMSwgMCwgMF07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgLTEsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJy1aL1knKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbMSwgMCwgMF07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgMCwgLTFdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJy1ZL1onKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbLTEsIDAsIDBdO1xuICAgIHJpZ2h0dmVjdG9yID0gWzAsIC0xLCAwXTtcbiAgfSBlbHNlIGlmIChheGlzaWQgPT09ICctWi8tWScpIHtcbiAgICBwbGFuZW5vcm1hbCA9IFstMSwgMCwgMF07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgMCwgLTFdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJ1kvLVonKSB7XG4gICAgcGxhbmVub3JtYWwgPSBbLTEsIDAsIDBdO1xuICAgIHJpZ2h0dmVjdG9yID0gWzAsIDEsIDBdO1xuICB9IGVsc2UgaWYgKGF4aXNpZCA9PT0gJ1ovWScpIHtcbiAgICBwbGFuZW5vcm1hbCA9IFstMSwgMCwgMF07XG4gICAgcmlnaHR2ZWN0b3IgPSBbMCwgMCwgMV07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ09ydGhvTm9ybWFsQmFzaXMuR2V0Q2FydGVzaWFuOiBpbnZhbGlkIGNvbWJpbmF0aW9uIG9mIGF4aXMgaWRlbnRpZmllcnMuIFNob3VsZCBwYXNzIHR3byBzdHJpbmcgYXJndW1lbnRzIGZyb20gW1gsWSxaLC1YLC1ZLC1aXSwgYmVpbmcgdHdvIGRpZmZlcmVudCBheGVzLidcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXcgT3J0aG9Ob3JtYWxCYXNpcyhcbiAgICBuZXcgUGxhbmUobmV3IFZlY3RvcjNEKHBsYW5lbm9ybWFsKSwgMCksXG4gICAgbmV3IFZlY3RvcjNEKHJpZ2h0dmVjdG9yKVxuICApO1xufTtcblxuLypcbi8vIHRlc3QgY29kZSBmb3IgT3J0aG9Ob3JtYWxCYXNpcy5HZXRDYXJ0ZXNpYW4oKVxuT3J0aG9Ob3JtYWxCYXNpcy5HZXRDYXJ0ZXNpYW5fVGVzdD1mdW5jdGlvbigpIHtcbiAgbGV0IGF4aXNuYW1lcz1bXCJYXCIsXCJZXCIsXCJaXCIsXCItWFwiLFwiLVlcIixcIi1aXCJdO1xuICBsZXQgYXhpc3ZlY3RvcnM9W1sxLDAsMF0sIFswLDEsMF0sIFswLDAsMV0sIFstMSwwLDBdLCBbMCwtMSwwXSwgWzAsMCwtMV1dO1xuICBmb3IobGV0IGF4aXMxPTA7IGF4aXMxIDwgMzsgYXhpczErKykge1xuICAgIGZvcihsZXQgYXhpczFpbnZlcnRlZD0wOyBheGlzMWludmVydGVkIDwgMjsgYXhpczFpbnZlcnRlZCsrKSB7XG4gICAgICBsZXQgYXhpczFuYW1lPWF4aXNuYW1lc1theGlzMSszKmF4aXMxaW52ZXJ0ZWRdO1xuICAgICAgbGV0IGF4aXMxdmVjdG9yPWF4aXN2ZWN0b3JzW2F4aXMxKzMqYXhpczFpbnZlcnRlZF07XG4gICAgICBmb3IobGV0IGF4aXMyPTA7IGF4aXMyIDwgMzsgYXhpczIrKykge1xuICAgICAgICBpZihheGlzMiAhPSBheGlzMSkge1xuICAgICAgICAgIGZvcihsZXQgYXhpczJpbnZlcnRlZD0wOyBheGlzMmludmVydGVkIDwgMjsgYXhpczJpbnZlcnRlZCsrKSB7XG4gICAgICAgICAgICBsZXQgYXhpczJuYW1lPWF4aXNuYW1lc1theGlzMiszKmF4aXMyaW52ZXJ0ZWRdO1xuICAgICAgICAgICAgbGV0IGF4aXMydmVjdG9yPWF4aXN2ZWN0b3JzW2F4aXMyKzMqYXhpczJpbnZlcnRlZF07XG4gICAgICAgICAgICBsZXQgb3J0aG9iYXNpcz1PcnRob05vcm1hbEJhc2lzLkdldENhcnRlc2lhbihheGlzMW5hbWUsIGF4aXMybmFtZSk7XG4gICAgICAgICAgICBsZXQgdGVzdDE9b3J0aG9iYXNpcy50bzNEKG5ldyBWZWN0b3IyRChbMSwwXSkpO1xuICAgICAgICAgICAgbGV0IHRlc3QyPW9ydGhvYmFzaXMudG8zRChuZXcgVmVjdG9yMkQoWzAsMV0pKTtcbiAgICAgICAgICAgIGxldCBleHBlY3RlZDE9bmV3IFZlY3RvcjNEKGF4aXMxdmVjdG9yKTtcbiAgICAgICAgICAgIGxldCBleHBlY3RlZDI9bmV3IFZlY3RvcjNEKGF4aXMydmVjdG9yKTtcbiAgICAgICAgICAgIGxldCBkMT10ZXN0MS5kaXN0YW5jZVRvKGV4cGVjdGVkMSk7XG4gICAgICAgICAgICBsZXQgZDI9dGVzdDIuZGlzdGFuY2VUbyhleHBlY3RlZDIpO1xuICAgICAgICAgICAgaWYoIChkMSA+IDAuMDEpIHx8IChkMiA+IDAuMDEpICkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyFcIik7XG4gIH19fX19fVxuICB0aHJvdyBuZXcgRXJyb3IoXCJPS1wiKTtcbn07XG4qL1xuXG4vLyBUaGUgej0wIHBsYW5lLCB3aXRoIHRoZSAzRCB4IGFuZCB5IHZlY3RvcnMgbWFwcGVkIHRvIHRoZSAyRCB4IGFuZCB5IHZlY3RvclxuT3J0aG9Ob3JtYWxCYXNpcy5aMFBsYW5lID0gZnVuY3Rpb24gKCkge1xuICBsZXQgcGxhbmUgPSBuZXcgUGxhbmUobmV3IFZlY3RvcjNEKFswLCAwLCAxXSksIDApO1xuICByZXR1cm4gbmV3IE9ydGhvTm9ybWFsQmFzaXMocGxhbmUsIG5ldyBWZWN0b3IzRChbMSwgMCwgMF0pKTtcbn07XG5cbk9ydGhvTm9ybWFsQmFzaXMucHJvdG90eXBlID0ge1xuICBnZXRQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgTWF0cml4NHg0ID0gcmVxdWlyZSgnLi9NYXRyaXg0Jyk7IC8vIEZJWE1FOiBjaXJjdWxhciBkZXBlbmRlbmNpZXMgTWF0cml4PT5PcnRob05vcm1hbEJhc2lzID0+IE1hdHJpeFxuICAgIHJldHVybiBuZXcgTWF0cml4NHg0KFtcbiAgICAgIHRoaXMudS54LFxuICAgICAgdGhpcy52LngsXG4gICAgICB0aGlzLnBsYW5lLm5vcm1hbC54LFxuICAgICAgMCxcbiAgICAgIHRoaXMudS55LFxuICAgICAgdGhpcy52LnksXG4gICAgICB0aGlzLnBsYW5lLm5vcm1hbC55LFxuICAgICAgMCxcbiAgICAgIHRoaXMudS56LFxuICAgICAgdGhpcy52LnosXG4gICAgICB0aGlzLnBsYW5lLm5vcm1hbC56LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLXRoaXMucGxhbmUudyxcbiAgICAgIDEsXG4gICAgXSk7XG4gIH0sXG5cbiAgZ2V0SW52ZXJzZVByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBNYXRyaXg0eDQgPSByZXF1aXJlKCcuL01hdHJpeDQnKTsgLy8gRklYTUU6IGNpcmN1bGFyIGRlcGVuZGVuY2llcyBNYXRyaXg9Pk9ydGhvTm9ybWFsQmFzaXMgPT4gTWF0cml4XG4gICAgbGV0IHAgPSB0aGlzLnBsYW5lLm5vcm1hbC50aW1lcyh0aGlzLnBsYW5lLncpO1xuICAgIHJldHVybiBuZXcgTWF0cml4NHg0KFtcbiAgICAgIHRoaXMudS54LFxuICAgICAgdGhpcy51LnksXG4gICAgICB0aGlzLnUueixcbiAgICAgIDAsXG4gICAgICB0aGlzLnYueCxcbiAgICAgIHRoaXMudi55LFxuICAgICAgdGhpcy52LnosXG4gICAgICAwLFxuICAgICAgdGhpcy5wbGFuZS5ub3JtYWwueCxcbiAgICAgIHRoaXMucGxhbmUubm9ybWFsLnksXG4gICAgICB0aGlzLnBsYW5lLm5vcm1hbC56LFxuICAgICAgMCxcbiAgICAgIHAueCxcbiAgICAgIHAueSxcbiAgICAgIHAueixcbiAgICAgIDEsXG4gICAgXSk7XG4gIH0sXG5cbiAgdG8yRDogZnVuY3Rpb24gKHZlYzMpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjJEKHZlYzMuZG90KHRoaXMudSksIHZlYzMuZG90KHRoaXMudikpO1xuICB9LFxuXG4gIHRvM0Q6IGZ1bmN0aW9uICh2ZWMyKSB7XG4gICAgcmV0dXJuIHRoaXMucGxhbmVvcmlnaW5cbiAgICAgIC5wbHVzKHRoaXMudS50aW1lcyh2ZWMyLngpKVxuICAgICAgLnBsdXModGhpcy52LnRpbWVzKHZlYzIueSkpO1xuICB9LFxuXG4gIGxpbmUzRHRvMkQ6IGZ1bmN0aW9uIChsaW5lM2QpIHtcbiAgICBsZXQgYSA9IGxpbmUzZC5wb2ludDtcbiAgICBsZXQgYiA9IGxpbmUzZC5kaXJlY3Rpb24ucGx1cyhhKTtcbiAgICBsZXQgYTJkID0gdGhpcy50bzJEKGEpO1xuICAgIGxldCBiMmQgPSB0aGlzLnRvMkQoYik7XG4gICAgcmV0dXJuIExpbmUyRC5mcm9tUG9pbnRzKGEyZCwgYjJkKTtcbiAgfSxcblxuICBsaW5lMkR0bzNEOiBmdW5jdGlvbiAobGluZTJkKSB7XG4gICAgbGV0IGEgPSBsaW5lMmQub3JpZ2luKCk7XG4gICAgbGV0IGIgPSBsaW5lMmQuZGlyZWN0aW9uKCkucGx1cyhhKTtcbiAgICBsZXQgYTNkID0gdGhpcy50bzNEKGEpO1xuICAgIGxldCBiM2QgPSB0aGlzLnRvM0QoYik7XG4gICAgcmV0dXJuIExpbmUzRC5mcm9tUG9pbnRzKGEzZCwgYjNkKTtcbiAgfSxcblxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICAvLyB0b2RvOiB0aGlzIG1heSBub3Qgd29yayBwcm9wZXJseSBpbiBjYXNlIG9mIG1pcnJvcmluZ1xuICAgIGxldCBuZXdwbGFuZSA9IHRoaXMucGxhbmUudHJhbnNmb3JtKG1hdHJpeDR4NCk7XG4gICAgbGV0IHJpZ2h0cG9pbnRUcmFuc2Zvcm1lZCA9IHRoaXMudS50cmFuc2Zvcm0obWF0cml4NHg0KTtcbiAgICBsZXQgb3JpZ2luVHJhbnNmb3JtZWQgPSBuZXcgVmVjdG9yM0QoMCwgMCwgMCkudHJhbnNmb3JtKG1hdHJpeDR4NCk7XG4gICAgbGV0IG5ld3JpZ2h0aGFuZHZlY3RvciA9IHJpZ2h0cG9pbnRUcmFuc2Zvcm1lZC5taW51cyhvcmlnaW5UcmFuc2Zvcm1lZCk7XG4gICAgbGV0IG5ld2Jhc2lzID0gbmV3IE9ydGhvTm9ybWFsQmFzaXMobmV3cGxhbmUsIG5ld3JpZ2h0aGFuZHZlY3Rvcik7XG4gICAgcmV0dXJuIG5ld2Jhc2lzO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcnRob05vcm1hbEJhc2lzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/math/OrthoNormalBasis.js\n");

/***/ }),

/***/ "./src/core/math/Path2.js":
/*!********************************!*\
  !*** ./src/core/math/Path2.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\nconst { EPS, angleEPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst {\n  parseOptionAs2DVector,\n  parseOptionAsFloat,\n  parseOptionAsInt,\n  parseOptionAsBool,\n} = __webpack_require__(/*! ../../api/optionParsers */ \"./src/api/optionParsers.js\");\nconst { defaultResolution2D } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst Vertex = __webpack_require__(/*! ./Vertex2 */ \"./src/core/math/Vertex2.js\");\nconst Side = __webpack_require__(/*! ./Side */ \"./src/core/math/Side.js\");\n\n/** Class Path2D\n * Represents a series of points, connected by infinitely thin lines.\n * A path can be open or closed, i.e. additional line between first and last points.\n * The difference between Path2D and CAG is that a path is a 'thin' line, whereas a CAG is an enclosed area.\n * @constructor\n * @param {Vector2D[]} [points=[]] - list of points\n * @param {boolean} [closed=false] - closer of path\n *\n * @example\n * new CSG.Path2D()\n * new CSG.Path2D([[10,10], [-10,10], [-10,-10], [10,-10]], true) // closed\n */\nconst Path2D = function (points, closed) {\n  closed = !!closed;\n  points = points || [];\n  // re-parse the points into Vector2D\n  // and remove any duplicate points\n  let prevpoint = null;\n  if (closed && points.length > 0) {\n    prevpoint = new Vector2D(points[points.length - 1]);\n  }\n  let newpoints = [];\n  points.map(function (point) {\n    point = new Vector2D(point);\n    let skip = false;\n    if (prevpoint !== null) {\n      let distance = point.distanceTo(prevpoint);\n      skip = distance < EPS;\n    }\n    if (!skip) newpoints.push(point);\n    prevpoint = point;\n  });\n  this.points = newpoints;\n  this.closed = closed;\n};\n\n/** Construct an arc.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of circle\n * @param {Number} [options.radius=1] - radius of circle\n * @param {Number} [options.startangle=0] - starting angle of the arc, in degrees\n * @param {Number} [options.endangle=360] - ending angle of the arc, in degrees\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @param {Boolean} [options.maketangent=false] - adds line segments at both ends of the arc to ensure that the gradients at the edges are tangent\n * @returns {Path2D} new Path2D object (not closed)\n *\n * @example\n * let path = CSG.Path2D.arc({\n *   center: [5, 5],\n *   radius: 10,\n *   startangle: 90,\n *   endangle: 180,\n *   resolution: 36,\n *   maketangent: true\n * });\n */\nPath2D.arc = function (options) {\n  let center = parseOptionAs2DVector(options, 'center', 0);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let startangle = parseOptionAsFloat(options, 'startangle', 0);\n  let endangle = parseOptionAsFloat(options, 'endangle', 360);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n  let maketangent = parseOptionAsBool(options, 'maketangent', false);\n  // no need to make multiple turns:\n  while (endangle - startangle >= 720) {\n    endangle -= 360;\n  }\n  while (endangle - startangle <= -720) {\n    endangle += 360;\n  }\n  let points = [];\n  let point;\n  let absangledif = Math.abs(endangle - startangle);\n  if (absangledif < angleEPS) {\n    point = Vector2D.fromAngle((startangle / 180.0) * Math.PI).times(radius);\n    points.push(point.plus(center));\n  } else {\n    let numsteps = Math.floor((resolution * absangledif) / 360) + 1;\n    let edgestepsize = (numsteps * 0.5) / absangledif; // step size for half a degree\n    if (edgestepsize > 0.25) edgestepsize = 0.25;\n    let numstepsMod = maketangent ? numsteps + 2 : numsteps;\n    for (let i = 0; i <= numstepsMod; i++) {\n      let step = i;\n      if (maketangent) {\n        step =\n          ((i - 1) * (numsteps - 2 * edgestepsize)) / numsteps + edgestepsize;\n        if (step < 0) step = 0;\n        if (step > numsteps) step = numsteps;\n      }\n      let angle = startangle + (step * (endangle - startangle)) / numsteps;\n      point = Vector2D.fromAngle((angle / 180.0) * Math.PI).times(radius);\n      points.push(point.plus(center));\n    }\n  }\n  return new Path2D(points, false);\n};\n\nPath2D.prototype = {\n  concat: function (otherpath) {\n    if (this.closed || otherpath.closed) {\n      throw new Error('Paths must not be closed');\n    }\n    let newpoints = this.points.concat(otherpath.points);\n    return new Path2D(newpoints);\n  },\n\n  /**\n   * Get the points that make up the path.\n   * note that this is current internal list of points, not an immutable copy.\n   * @returns {Vector2[]} array of points the make up the path\n   */\n  getPoints: function () {\n    return this.points;\n  },\n\n  /**\n   * Append an point to the end of the path.\n   * @param {Vector2D} point - point to append\n   * @returns {Path2D} new Path2D object (not closed)\n   */\n  appendPoint: function (point) {\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    point = new Vector2D(point); // cast to Vector2D\n    let newpoints = this.points.concat([point]);\n    return new Path2D(newpoints);\n  },\n\n  /**\n   * Append a list of points to the end of the path.\n   * @param {Vector2D[]} points - points to append\n   * @returns {Path2D} new Path2D object (not closed)\n   */\n  appendPoints: function (points) {\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    let newpoints = this.points;\n    points.forEach(function (point) {\n      newpoints.push(new Vector2D(point)); // cast to Vector2D\n    });\n    return new Path2D(newpoints);\n  },\n\n  close: function () {\n    return new Path2D(this.points, true);\n  },\n\n  /**\n   * Determine if the path is a closed or not.\n   * @returns {Boolean} true when the path is closed, otherwise false\n   */\n  isClosed: function () {\n    return this.closed;\n  },\n\n  /**\n   * Determine the overall clockwise or anti-clockwise turn of a path.\n   * See: http://mathworld.wolfram.com/PolygonArea.html\n   * @returns {String} One of ['clockwise', 'counter-clockwise', 'straight'].\n   */\n  getTurn: function () {\n    const points = this.points;\n    let twice_area = 0;\n    let last = points.length - 1;\n    for (let current = 0; current < points.length; last = current++) {\n      twice_area +=\n        points[last].x * points[current].y - points[last].y * points[current].x;\n    }\n    if (twice_area > 0) {\n      return 'clockwise';\n    } else if (twice_area < 0) {\n      return 'counter-clockwise';\n    } else {\n      return 'straight';\n    }\n  },\n\n  // Extrude the path by following it with a rectangle (upright, perpendicular to the path direction)\n  // Returns a CSG solid\n  //   width: width of the extrusion, in the z=0 plane\n  //   height: height of the extrusion in the z direction\n  //   resolution: number of segments per 360 degrees for the curve in a corner\n  rectangularExtrude: function (width, height, resolution) {\n    let cag = this.expandToCAG(width / 2, resolution);\n    let result = cag.extrude({\n      offset: [0, 0, height],\n    });\n    return result;\n  },\n\n  // Expand the path to a CAG\n  // This traces the path with a circle with radius pathradius\n  expandToCAG: function (pathradius, resolution) {\n    const CAG = __webpack_require__(/*! ../CAG */ \"./src/core/CAG.js\"); // FIXME: cyclic dependencies CAG => PATH2 => CAG\n    let sides = [];\n    let numpoints = this.points.length;\n    let startindex = 0;\n    if (this.closed && numpoints > 2) startindex = -1;\n    let prevvertex;\n    for (let i = startindex; i < numpoints; i++) {\n      let pointindex = i;\n      if (pointindex < 0) pointindex = numpoints - 1;\n      let point = this.points[pointindex];\n      let vertex = new Vertex(point);\n      if (i > startindex) {\n        let side = new Side(prevvertex, vertex);\n        sides.push(side);\n      }\n      prevvertex = vertex;\n    }\n    let shellcag = CAG.fromSides(sides);\n    let expanded = shellcag.expandedShell(pathradius, resolution);\n    return expanded;\n  },\n\n  innerToCAG: function () {\n    const CAG = __webpack_require__(/*! ../CAG */ \"./src/core/CAG.js\"); // FIXME: cyclic dependencies CAG => PATH2 => CAG\n    if (!this.closed) throw new Error('The path should be closed!');\n    return CAG.fromPoints(this.points);\n  },\n\n  transform: function (matrix4x4) {\n    let newpoints = this.points.map(function (point) {\n      return point.multiply4x4(matrix4x4);\n    });\n    return new Path2D(newpoints, this.closed);\n  },\n\n  /**\n   * Append a Bezier curve to the end of the path, using the control points to transition the curve through start and end points.\n   * <br>\n   * The Bzier curve starts at the last point in the path,\n   * and ends at the last given control point. Other control points are intermediate control points.\n   * <br>\n   * The first control point may be null to ensure a smooth transition occurs. In this case,\n   * the second to last control point of the path is mirrored into the control points of the Bezier curve.\n   * In other words, the trailing gradient of the path matches the new gradient of the curve.\n   * @param {Vector2D[]} controlpoints - list of control points\n   * @param {Object} [options] - options for construction\n   * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n   * @returns {Path2D} new Path2D object (not closed)\n   *\n   * @example\n   * let p5 = new CSG.Path2D([[10,-20]],false);\n   * p5 = p5.appendBezier([[10,-10],[25,-10],[25,-20]]);\n   * p5 = p5.appendBezier([[25,-30],[40,-30],[40,-20]]);\n   */\n  appendBezier: function (controlpoints, options) {\n    if (arguments.length < 2) {\n      options = {};\n    }\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    if (!(controlpoints instanceof Array)) {\n      throw new Error('appendBezier: should pass an array of control points');\n    }\n    if (controlpoints.length < 1) {\n      throw new Error('appendBezier: need at least 1 control point');\n    }\n    if (this.points.length < 1) {\n      throw new Error(\n        'appendBezier: path must already contain a point (the endpoint of the path is used as the starting point for the bezier curve)'\n      );\n    }\n    let resolution = parseOptionAsInt(\n      options,\n      'resolution',\n      defaultResolution2D\n    );\n    if (resolution < 4) resolution = 4;\n    let factorials = [];\n    let controlpointsParsed = [];\n    controlpointsParsed.push(this.points[this.points.length - 1]); // start at the previous end point\n    for (let i = 0; i < controlpoints.length; ++i) {\n      let p = controlpoints[i];\n      if (p === null) {\n        // we can pass null as the first control point. In that case a smooth gradient is ensured:\n        if (i !== 0) {\n          throw new Error(\n            'appendBezier: null can only be passed as the first control point'\n          );\n        }\n        if (controlpoints.length < 2) {\n          throw new Error(\n            'appendBezier: null can only be passed if there is at least one more control point'\n          );\n        }\n        let lastBezierControlPoint;\n        if ('lastBezierControlPoint' in this) {\n          lastBezierControlPoint = this.lastBezierControlPoint;\n        } else {\n          if (this.points.length < 2) {\n            throw new Error(\n              'appendBezier: null is passed as a control point but this requires a previous bezier curve or at least two points in the existing path'\n            );\n          }\n          lastBezierControlPoint = this.points[this.points.length - 2];\n        }\n        // mirror the last bezier control point:\n        p = this.points[this.points.length - 1]\n          .times(2)\n          .minus(lastBezierControlPoint);\n      } else {\n        p = new Vector2D(p); // cast to Vector2D\n      }\n      controlpointsParsed.push(p);\n    }\n    let bezierOrder = controlpointsParsed.length - 1;\n    let fact = 1;\n    for (let i = 0; i <= bezierOrder; ++i) {\n      if (i > 0) fact *= i;\n      factorials.push(fact);\n    }\n    let binomials = [];\n    for (let i = 0; i <= bezierOrder; ++i) {\n      let binomial =\n        factorials[bezierOrder] / (factorials[i] * factorials[bezierOrder - i]);\n      binomials.push(binomial);\n    }\n    let getPointForT = function (t) {\n      let t_k = 1; // = pow(t,k)\n      let one_minus_t_n_minus_k = Math.pow(1 - t, bezierOrder); // = pow( 1-t, bezierOrder - k)\n      let inv_1_minus_t = t !== 1 ? 1 / (1 - t) : 1;\n      let point = new Vector2D(0, 0);\n      for (let k = 0; k <= bezierOrder; ++k) {\n        if (k === bezierOrder) one_minus_t_n_minus_k = 1;\n        let bernstein_coefficient = binomials[k] * t_k * one_minus_t_n_minus_k;\n        point = point.plus(controlpointsParsed[k].times(bernstein_coefficient));\n        t_k *= t;\n        one_minus_t_n_minus_k *= inv_1_minus_t;\n      }\n      return point;\n    };\n    let newpoints = [];\n    let newpoints_t = [];\n    let numsteps = bezierOrder + 1;\n    for (let i = 0; i < numsteps; ++i) {\n      let t = i / (numsteps - 1);\n      let point = getPointForT(t);\n      newpoints.push(point);\n      newpoints_t.push(t);\n    }\n    // subdivide each segment until the angle at each vertex becomes small enough:\n    let subdivideBase = 1;\n    let maxangle = (Math.PI * 2) / resolution; // segments may have differ no more in angle than this\n    let maxsinangle = Math.sin(maxangle);\n    while (subdivideBase < newpoints.length - 1) {\n      let dir1 = newpoints[subdivideBase]\n        .minus(newpoints[subdivideBase - 1])\n        .unit();\n      let dir2 = newpoints[subdivideBase + 1]\n        .minus(newpoints[subdivideBase])\n        .unit();\n      let sinangle = dir1.cross(dir2); // this is the sine of the angle\n      if (Math.abs(sinangle) > maxsinangle) {\n        // angle is too big, we need to subdivide\n        let t0 = newpoints_t[subdivideBase - 1];\n        let t1 = newpoints_t[subdivideBase + 1];\n        let t0_new = t0 + ((t1 - t0) * 1) / 3;\n        let t1_new = t0 + ((t1 - t0) * 2) / 3;\n        let point0_new = getPointForT(t0_new);\n        let point1_new = getPointForT(t1_new);\n        // remove the point at subdivideBase and replace with 2 new points:\n        newpoints.splice(subdivideBase, 1, point0_new, point1_new);\n        newpoints_t.splice(subdivideBase, 1, t0_new, t1_new);\n        // re - evaluate the angles, starting at the previous junction since it has changed:\n        subdivideBase--;\n        if (subdivideBase < 1) subdivideBase = 1;\n      } else {\n        ++subdivideBase;\n      }\n    }\n    // append to the previous points, but skip the first new point because it is identical to the last point:\n    newpoints = this.points.concat(newpoints.slice(1));\n    let result = new Path2D(newpoints);\n    result.lastBezierControlPoint =\n      controlpointsParsed[controlpointsParsed.length - 2];\n    return result;\n  },\n\n  /**\n   * Append an arc to the end of the path.\n   * This implementation follows the SVG arc specs. For the details see\n   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n   * @param {Vector2D} endpoint - end point of arc\n   * @param {Object} [options] - options for construction\n   * @param {Number} [options.radius=0] - radius of arc (X and Y), see also xradius and yradius\n   * @param {Number} [options.xradius=0] - X radius of arc, see also radius\n   * @param {Number} [options.yradius=0] - Y radius of arc, see also radius\n   * @param {Number} [options.xaxisrotation=0] -  rotation (in degrees) of the X axis of the arc with respect to the X axis of the coordinate system\n   * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n   * @param {Boolean} [options.clockwise=false] - draw an arc clockwise with respect to the center point\n   * @param {Boolean} [options.large=false] - draw an arc longer than 180 degrees\n   * @returns {Path2D} new Path2D object (not closed)\n   *\n   * @example\n   * let p1 = new CSG.Path2D([[27.5,-22.96875]],false);\n   * p1 = p1.appendPoint([27.5,-3.28125]);\n   * p1 = p1.appendArc([12.5,-22.96875],{xradius: 15,yradius: -19.6875,xaxisrotation: 0,clockwise: false,large: false});\n   * p1 = p1.close();\n   */\n  appendArc: function (endpoint, options) {\n    let decimals = 100000;\n    if (arguments.length < 2) {\n      options = {};\n    }\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    if (this.points.length < 1) {\n      throw new Error(\n        'appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)'\n      );\n    }\n    let resolution = parseOptionAsInt(\n      options,\n      'resolution',\n      defaultResolution2D\n    );\n    if (resolution < 4) resolution = 4;\n    let xradius, yradius;\n    if ('xradius' in options || 'yradius' in options) {\n      if ('radius' in options) {\n        throw new Error(\n          'Should either give an xradius and yradius parameter, or a radius parameter'\n        );\n      }\n      xradius = parseOptionAsFloat(options, 'xradius', 0);\n      yradius = parseOptionAsFloat(options, 'yradius', 0);\n    } else {\n      xradius = parseOptionAsFloat(options, 'radius', 0);\n      yradius = xradius;\n    }\n    let xaxisrotation = parseOptionAsFloat(options, 'xaxisrotation', 0);\n    let clockwise = parseOptionAsBool(options, 'clockwise', false);\n    let largearc = parseOptionAsBool(options, 'large', false);\n    let startpoint = this.points[this.points.length - 1];\n    endpoint = new Vector2D(endpoint);\n    // round to precision in order to have determinate calculations\n    xradius = Math.round(xradius * decimals) / decimals;\n    yradius = Math.round(yradius * decimals) / decimals;\n    endpoint = new Vector2D(\n      Math.round(endpoint.x * decimals) / decimals,\n      Math.round(endpoint.y * decimals) / decimals\n    );\n\n    let sweepFlag = !clockwise;\n    let newpoints = [];\n    if (xradius === 0 || yradius === 0) {\n      // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes:\n      // If rx = 0 or ry = 0, then treat this as a straight line from (x1, y1) to (x2, y2) and stop\n      newpoints.push(endpoint);\n    } else {\n      xradius = Math.abs(xradius);\n      yradius = Math.abs(yradius);\n\n      // see http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes :\n      let phi = (xaxisrotation * Math.PI) / 180.0;\n      let cosphi = Math.cos(phi);\n      let sinphi = Math.sin(phi);\n      let minushalfdistance = startpoint.minus(endpoint).times(0.5);\n      // F.6.5.1:\n      // round to precision in order to have determinate calculations\n      let x =\n        Math.round(\n          (cosphi * minushalfdistance.x + sinphi * minushalfdistance.y) *\n            decimals\n        ) / decimals;\n      let y =\n        Math.round(\n          (-sinphi * minushalfdistance.x + cosphi * minushalfdistance.y) *\n            decimals\n        ) / decimals;\n      let startTranslated = new Vector2D(x, y);\n      // F.6.6.2:\n      let biglambda =\n        (startTranslated.x * startTranslated.x) / (xradius * xradius) +\n        (startTranslated.y * startTranslated.y) / (yradius * yradius);\n      if (biglambda > 1.0) {\n        // F.6.6.3:\n        let sqrtbiglambda = Math.sqrt(biglambda);\n        xradius *= sqrtbiglambda;\n        yradius *= sqrtbiglambda;\n        // round to precision in order to have determinate calculations\n        xradius = Math.round(xradius * decimals) / decimals;\n        yradius = Math.round(yradius * decimals) / decimals;\n      }\n      // F.6.5.2:\n      let multiplier1 = Math.sqrt(\n        (xradius * xradius * yradius * yradius -\n          xradius * xradius * startTranslated.y * startTranslated.y -\n          yradius * yradius * startTranslated.x * startTranslated.x) /\n          (xradius * xradius * startTranslated.y * startTranslated.y +\n            yradius * yradius * startTranslated.x * startTranslated.x)\n      );\n      if (sweepFlag === largearc) multiplier1 = -multiplier1;\n      let centerTranslated = new Vector2D(\n        (xradius * startTranslated.y) / yradius,\n        (-yradius * startTranslated.x) / xradius\n      ).times(multiplier1);\n      // F.6.5.3:\n      let center = new Vector2D(\n        cosphi * centerTranslated.x - sinphi * centerTranslated.y,\n        sinphi * centerTranslated.x + cosphi * centerTranslated.y\n      ).plus(startpoint.plus(endpoint).times(0.5));\n      // F.6.5.5:\n      let vec1 = new Vector2D(\n        (startTranslated.x - centerTranslated.x) / xradius,\n        (startTranslated.y - centerTranslated.y) / yradius\n      );\n      let vec2 = new Vector2D(\n        (-startTranslated.x - centerTranslated.x) / xradius,\n        (-startTranslated.y - centerTranslated.y) / yradius\n      );\n      let theta1 = vec1.angleRadians();\n      let theta2 = vec2.angleRadians();\n      let deltatheta = theta2 - theta1;\n      deltatheta = deltatheta % (2 * Math.PI);\n      if (!sweepFlag && deltatheta > 0) {\n        deltatheta -= 2 * Math.PI;\n      } else if (sweepFlag && deltatheta < 0) {\n        deltatheta += 2 * Math.PI;\n      }\n\n      // Ok, we have the center point and angle range (from theta1, deltatheta radians) so we can create the ellipse\n      let numsteps =\n        Math.ceil((Math.abs(deltatheta) / (2 * Math.PI)) * resolution) + 1;\n      if (numsteps < 1) numsteps = 1;\n      for (let step = 1; step <= numsteps; step++) {\n        let theta = theta1 + (step / numsteps) * deltatheta;\n        let costheta = Math.cos(theta);\n        let sintheta = Math.sin(theta);\n        // F.6.3.1:\n        let point = new Vector2D(\n          cosphi * xradius * costheta - sinphi * yradius * sintheta,\n          sinphi * xradius * costheta + cosphi * yradius * sintheta\n        ).plus(center);\n        newpoints.push(point);\n      }\n    }\n    newpoints = this.points.concat(newpoints);\n    let result = new Path2D(newpoints);\n    return result;\n  },\n};\n\nmodule.exports = Path2D;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1BhdGgyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvbWF0aC9QYXRoMi5qcz82ODFhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlY3RvcjJEID0gcmVxdWlyZSgnLi9WZWN0b3IyJyk7XG5jb25zdCB7IEVQUywgYW5nbGVFUFMgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBwYXJzZU9wdGlvbkFzMkRWZWN0b3IsXG4gIHBhcnNlT3B0aW9uQXNGbG9hdCxcbiAgcGFyc2VPcHRpb25Bc0ludCxcbiAgcGFyc2VPcHRpb25Bc0Jvb2wsXG59ID0gcmVxdWlyZSgnLi4vLi4vYXBpL29wdGlvblBhcnNlcnMnKTtcbmNvbnN0IHsgZGVmYXVsdFJlc29sdXRpb24yRCB9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5jb25zdCBWZXJ0ZXggPSByZXF1aXJlKCcuL1ZlcnRleDInKTtcbmNvbnN0IFNpZGUgPSByZXF1aXJlKCcuL1NpZGUnKTtcblxuLyoqIENsYXNzIFBhdGgyRFxuICogUmVwcmVzZW50cyBhIHNlcmllcyBvZiBwb2ludHMsIGNvbm5lY3RlZCBieSBpbmZpbml0ZWx5IHRoaW4gbGluZXMuXG4gKiBBIHBhdGggY2FuIGJlIG9wZW4gb3IgY2xvc2VkLCBpLmUuIGFkZGl0aW9uYWwgbGluZSBiZXR3ZWVuIGZpcnN0IGFuZCBsYXN0IHBvaW50cy5cbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gUGF0aDJEIGFuZCBDQUcgaXMgdGhhdCBhIHBhdGggaXMgYSAndGhpbicgbGluZSwgd2hlcmVhcyBhIENBRyBpcyBhbiBlbmNsb3NlZCBhcmVhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1ZlY3RvcjJEW119IFtwb2ludHM9W11dIC0gbGlzdCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Nsb3NlZD1mYWxzZV0gLSBjbG9zZXIgb2YgcGF0aFxuICpcbiAqIEBleGFtcGxlXG4gKiBuZXcgQ1NHLlBhdGgyRCgpXG4gKiBuZXcgQ1NHLlBhdGgyRChbWzEwLDEwXSwgWy0xMCwxMF0sIFstMTAsLTEwXSwgWzEwLC0xMF1dLCB0cnVlKSAvLyBjbG9zZWRcbiAqL1xuY29uc3QgUGF0aDJEID0gZnVuY3Rpb24gKHBvaW50cywgY2xvc2VkKSB7XG4gIGNsb3NlZCA9ICEhY2xvc2VkO1xuICBwb2ludHMgPSBwb2ludHMgfHwgW107XG4gIC8vIHJlLXBhcnNlIHRoZSBwb2ludHMgaW50byBWZWN0b3IyRFxuICAvLyBhbmQgcmVtb3ZlIGFueSBkdXBsaWNhdGUgcG9pbnRzXG4gIGxldCBwcmV2cG9pbnQgPSBudWxsO1xuICBpZiAoY2xvc2VkICYmIHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgcHJldnBvaW50ID0gbmV3IFZlY3RvcjJEKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGxldCBuZXdwb2ludHMgPSBbXTtcbiAgcG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBwb2ludCA9IG5ldyBWZWN0b3IyRChwb2ludCk7XG4gICAgbGV0IHNraXAgPSBmYWxzZTtcbiAgICBpZiAocHJldnBvaW50ICE9PSBudWxsKSB7XG4gICAgICBsZXQgZGlzdGFuY2UgPSBwb2ludC5kaXN0YW5jZVRvKHByZXZwb2ludCk7XG4gICAgICBza2lwID0gZGlzdGFuY2UgPCBFUFM7XG4gICAgfVxuICAgIGlmICghc2tpcCkgbmV3cG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIHByZXZwb2ludCA9IHBvaW50O1xuICB9KTtcbiAgdGhpcy5wb2ludHMgPSBuZXdwb2ludHM7XG4gIHRoaXMuY2xvc2VkID0gY2xvc2VkO1xufTtcblxuLyoqIENvbnN0cnVjdCBhbiBhcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gKiBAcGFyYW0ge1ZlY3RvcjJEfSBbb3B0aW9ucy5jZW50ZXI9WzAsMF1dIC0gY2VudGVyIG9mIGNpcmNsZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhZGl1cz0xXSAtIHJhZGl1cyBvZiBjaXJjbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zdGFydGFuZ2xlPTBdIC0gc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gZGVncmVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVuZGFuZ2xlPTM2MF0gLSBlbmRpbmcgYW5nbGUgb2YgdGhlIGFyYywgaW4gZGVncmVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249ZGVmYXVsdFJlc29sdXRpb24yRF0gLSBudW1iZXIgb2Ygc2lkZXMgcGVyIDM2MCByb3RhdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYWtldGFuZ2VudD1mYWxzZV0gLSBhZGRzIGxpbmUgc2VnbWVudHMgYXQgYm90aCBlbmRzIG9mIHRoZSBhcmMgdG8gZW5zdXJlIHRoYXQgdGhlIGdyYWRpZW50cyBhdCB0aGUgZWRnZXMgYXJlIHRhbmdlbnRcbiAqIEByZXR1cm5zIHtQYXRoMkR9IG5ldyBQYXRoMkQgb2JqZWN0IChub3QgY2xvc2VkKVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcGF0aCA9IENTRy5QYXRoMkQuYXJjKHtcbiAqICAgY2VudGVyOiBbNSwgNV0sXG4gKiAgIHJhZGl1czogMTAsXG4gKiAgIHN0YXJ0YW5nbGU6IDkwLFxuICogICBlbmRhbmdsZTogMTgwLFxuICogICByZXNvbHV0aW9uOiAzNixcbiAqICAgbWFrZXRhbmdlbnQ6IHRydWVcbiAqIH0pO1xuICovXG5QYXRoMkQuYXJjID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgbGV0IGNlbnRlciA9IHBhcnNlT3B0aW9uQXMyRFZlY3RvcihvcHRpb25zLCAnY2VudGVyJywgMCk7XG4gIGxldCByYWRpdXMgPSBwYXJzZU9wdGlvbkFzRmxvYXQob3B0aW9ucywgJ3JhZGl1cycsIDEpO1xuICBsZXQgc3RhcnRhbmdsZSA9IHBhcnNlT3B0aW9uQXNGbG9hdChvcHRpb25zLCAnc3RhcnRhbmdsZScsIDApO1xuICBsZXQgZW5kYW5nbGUgPSBwYXJzZU9wdGlvbkFzRmxvYXQob3B0aW9ucywgJ2VuZGFuZ2xlJywgMzYwKTtcbiAgbGV0IHJlc29sdXRpb24gPSBwYXJzZU9wdGlvbkFzSW50KG9wdGlvbnMsICdyZXNvbHV0aW9uJywgZGVmYXVsdFJlc29sdXRpb24yRCk7XG4gIGxldCBtYWtldGFuZ2VudCA9IHBhcnNlT3B0aW9uQXNCb29sKG9wdGlvbnMsICdtYWtldGFuZ2VudCcsIGZhbHNlKTtcbiAgLy8gbm8gbmVlZCB0byBtYWtlIG11bHRpcGxlIHR1cm5zOlxuICB3aGlsZSAoZW5kYW5nbGUgLSBzdGFydGFuZ2xlID49IDcyMCkge1xuICAgIGVuZGFuZ2xlIC09IDM2MDtcbiAgfVxuICB3aGlsZSAoZW5kYW5nbGUgLSBzdGFydGFuZ2xlIDw9IC03MjApIHtcbiAgICBlbmRhbmdsZSArPSAzNjA7XG4gIH1cbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgcG9pbnQ7XG4gIGxldCBhYnNhbmdsZWRpZiA9IE1hdGguYWJzKGVuZGFuZ2xlIC0gc3RhcnRhbmdsZSk7XG4gIGlmIChhYnNhbmdsZWRpZiA8IGFuZ2xlRVBTKSB7XG4gICAgcG9pbnQgPSBWZWN0b3IyRC5mcm9tQW5nbGUoKHN0YXJ0YW5nbGUgLyAxODAuMCkgKiBNYXRoLlBJKS50aW1lcyhyYWRpdXMpO1xuICAgIHBvaW50cy5wdXNoKHBvaW50LnBsdXMoY2VudGVyKSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IG51bXN0ZXBzID0gTWF0aC5mbG9vcigocmVzb2x1dGlvbiAqIGFic2FuZ2xlZGlmKSAvIDM2MCkgKyAxO1xuICAgIGxldCBlZGdlc3RlcHNpemUgPSAobnVtc3RlcHMgKiAwLjUpIC8gYWJzYW5nbGVkaWY7IC8vIHN0ZXAgc2l6ZSBmb3IgaGFsZiBhIGRlZ3JlZVxuICAgIGlmIChlZGdlc3RlcHNpemUgPiAwLjI1KSBlZGdlc3RlcHNpemUgPSAwLjI1O1xuICAgIGxldCBudW1zdGVwc01vZCA9IG1ha2V0YW5nZW50ID8gbnVtc3RlcHMgKyAyIDogbnVtc3RlcHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbnVtc3RlcHNNb2Q7IGkrKykge1xuICAgICAgbGV0IHN0ZXAgPSBpO1xuICAgICAgaWYgKG1ha2V0YW5nZW50KSB7XG4gICAgICAgIHN0ZXAgPVxuICAgICAgICAgICgoaSAtIDEpICogKG51bXN0ZXBzIC0gMiAqIGVkZ2VzdGVwc2l6ZSkpIC8gbnVtc3RlcHMgKyBlZGdlc3RlcHNpemU7XG4gICAgICAgIGlmIChzdGVwIDwgMCkgc3RlcCA9IDA7XG4gICAgICAgIGlmIChzdGVwID4gbnVtc3RlcHMpIHN0ZXAgPSBudW1zdGVwcztcbiAgICAgIH1cbiAgICAgIGxldCBhbmdsZSA9IHN0YXJ0YW5nbGUgKyAoc3RlcCAqIChlbmRhbmdsZSAtIHN0YXJ0YW5nbGUpKSAvIG51bXN0ZXBzO1xuICAgICAgcG9pbnQgPSBWZWN0b3IyRC5mcm9tQW5nbGUoKGFuZ2xlIC8gMTgwLjApICogTWF0aC5QSSkudGltZXMocmFkaXVzKTtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50LnBsdXMoY2VudGVyKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUGF0aDJEKHBvaW50cywgZmFsc2UpO1xufTtcblxuUGF0aDJELnByb3RvdHlwZSA9IHtcbiAgY29uY2F0OiBmdW5jdGlvbiAob3RoZXJwYXRoKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkIHx8IG90aGVycGF0aC5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aHMgbXVzdCBub3QgYmUgY2xvc2VkJyk7XG4gICAgfVxuICAgIGxldCBuZXdwb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQob3RoZXJwYXRoLnBvaW50cyk7XG4gICAgcmV0dXJuIG5ldyBQYXRoMkQobmV3cG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwb2ludHMgdGhhdCBtYWtlIHVwIHRoZSBwYXRoLlxuICAgKiBub3RlIHRoYXQgdGhpcyBpcyBjdXJyZW50IGludGVybmFsIGxpc3Qgb2YgcG9pbnRzLCBub3QgYW4gaW1tdXRhYmxlIGNvcHkuXG4gICAqIEByZXR1cm5zIHtWZWN0b3IyW119IGFycmF5IG9mIHBvaW50cyB0aGUgbWFrZSB1cCB0aGUgcGF0aFxuICAgKi9cbiAgZ2V0UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYW4gcG9pbnQgdG8gdGhlIGVuZCBvZiB0aGUgcGF0aC5cbiAgICogQHBhcmFtIHtWZWN0b3IyRH0gcG9pbnQgLSBwb2ludCB0byBhcHBlbmRcbiAgICogQHJldHVybnMge1BhdGgyRH0gbmV3IFBhdGgyRCBvYmplY3QgKG5vdCBjbG9zZWQpXG4gICAqL1xuICBhcHBlbmRQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBub3QgYmUgY2xvc2VkJyk7XG4gICAgfVxuICAgIHBvaW50ID0gbmV3IFZlY3RvcjJEKHBvaW50KTsgLy8gY2FzdCB0byBWZWN0b3IyRFxuICAgIGxldCBuZXdwb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQoW3BvaW50XSk7XG4gICAgcmV0dXJuIG5ldyBQYXRoMkQobmV3cG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwZW5kIGEgbGlzdCBvZiBwb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcGF0aC5cbiAgICogQHBhcmFtIHtWZWN0b3IyRFtdfSBwb2ludHMgLSBwb2ludHMgdG8gYXBwZW5kXG4gICAqIEByZXR1cm5zIHtQYXRoMkR9IG5ldyBQYXRoMkQgb2JqZWN0IChub3QgY2xvc2VkKVxuICAgKi9cbiAgYXBwZW5kUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBub3QgYmUgY2xvc2VkJyk7XG4gICAgfVxuICAgIGxldCBuZXdwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIG5ld3BvaW50cy5wdXNoKG5ldyBWZWN0b3IyRChwb2ludCkpOyAvLyBjYXN0IHRvIFZlY3RvcjJEXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQYXRoMkQobmV3cG9pbnRzKTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUGF0aDJEKHRoaXMucG9pbnRzLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBwYXRoIGlzIGEgY2xvc2VkIG9yIG5vdC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgd2hlbiB0aGUgcGF0aCBpcyBjbG9zZWQsIG90aGVyd2lzZSBmYWxzZVxuICAgKi9cbiAgaXNDbG9zZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgb3ZlcmFsbCBjbG9ja3dpc2Ugb3IgYW50aS1jbG9ja3dpc2UgdHVybiBvZiBhIHBhdGguXG4gICAqIFNlZTogaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9Qb2x5Z29uQXJlYS5odG1sXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IE9uZSBvZiBbJ2Nsb2Nrd2lzZScsICdjb3VudGVyLWNsb2Nrd2lzZScsICdzdHJhaWdodCddLlxuICAgKi9cbiAgZ2V0VHVybjogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGxldCB0d2ljZV9hcmVhID0gMDtcbiAgICBsZXQgbGFzdCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGN1cnJlbnQgPSAwOyBjdXJyZW50IDwgcG9pbnRzLmxlbmd0aDsgbGFzdCA9IGN1cnJlbnQrKykge1xuICAgICAgdHdpY2VfYXJlYSArPVxuICAgICAgICBwb2ludHNbbGFzdF0ueCAqIHBvaW50c1tjdXJyZW50XS55IC0gcG9pbnRzW2xhc3RdLnkgKiBwb2ludHNbY3VycmVudF0ueDtcbiAgICB9XG4gICAgaWYgKHR3aWNlX2FyZWEgPiAwKSB7XG4gICAgICByZXR1cm4gJ2Nsb2Nrd2lzZSc7XG4gICAgfSBlbHNlIGlmICh0d2ljZV9hcmVhIDwgMCkge1xuICAgICAgcmV0dXJuICdjb3VudGVyLWNsb2Nrd2lzZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnc3RyYWlnaHQnO1xuICAgIH1cbiAgfSxcblxuICAvLyBFeHRydWRlIHRoZSBwYXRoIGJ5IGZvbGxvd2luZyBpdCB3aXRoIGEgcmVjdGFuZ2xlICh1cHJpZ2h0LCBwZXJwZW5kaWN1bGFyIHRvIHRoZSBwYXRoIGRpcmVjdGlvbilcbiAgLy8gUmV0dXJucyBhIENTRyBzb2xpZFxuICAvLyAgIHdpZHRoOiB3aWR0aCBvZiB0aGUgZXh0cnVzaW9uLCBpbiB0aGUgej0wIHBsYW5lXG4gIC8vICAgaGVpZ2h0OiBoZWlnaHQgb2YgdGhlIGV4dHJ1c2lvbiBpbiB0aGUgeiBkaXJlY3Rpb25cbiAgLy8gICByZXNvbHV0aW9uOiBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIDM2MCBkZWdyZWVzIGZvciB0aGUgY3VydmUgaW4gYSBjb3JuZXJcbiAgcmVjdGFuZ3VsYXJFeHRydWRlOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xuICAgIGxldCBjYWcgPSB0aGlzLmV4cGFuZFRvQ0FHKHdpZHRoIC8gMiwgcmVzb2x1dGlvbik7XG4gICAgbGV0IHJlc3VsdCA9IGNhZy5leHRydWRlKHtcbiAgICAgIG9mZnNldDogWzAsIDAsIGhlaWdodF0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvLyBFeHBhbmQgdGhlIHBhdGggdG8gYSBDQUdcbiAgLy8gVGhpcyB0cmFjZXMgdGhlIHBhdGggd2l0aCBhIGNpcmNsZSB3aXRoIHJhZGl1cyBwYXRocmFkaXVzXG4gIGV4cGFuZFRvQ0FHOiBmdW5jdGlvbiAocGF0aHJhZGl1cywgcmVzb2x1dGlvbikge1xuICAgIGNvbnN0IENBRyA9IHJlcXVpcmUoJy4uL0NBRycpOyAvLyBGSVhNRTogY3ljbGljIGRlcGVuZGVuY2llcyBDQUcgPT4gUEFUSDIgPT4gQ0FHXG4gICAgbGV0IHNpZGVzID0gW107XG4gICAgbGV0IG51bXBvaW50cyA9IHRoaXMucG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgc3RhcnRpbmRleCA9IDA7XG4gICAgaWYgKHRoaXMuY2xvc2VkICYmIG51bXBvaW50cyA+IDIpIHN0YXJ0aW5kZXggPSAtMTtcbiAgICBsZXQgcHJldnZlcnRleDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRpbmRleDsgaSA8IG51bXBvaW50czsgaSsrKSB7XG4gICAgICBsZXQgcG9pbnRpbmRleCA9IGk7XG4gICAgICBpZiAocG9pbnRpbmRleCA8IDApIHBvaW50aW5kZXggPSBudW1wb2ludHMgLSAxO1xuICAgICAgbGV0IHBvaW50ID0gdGhpcy5wb2ludHNbcG9pbnRpbmRleF07XG4gICAgICBsZXQgdmVydGV4ID0gbmV3IFZlcnRleChwb2ludCk7XG4gICAgICBpZiAoaSA+IHN0YXJ0aW5kZXgpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBuZXcgU2lkZShwcmV2dmVydGV4LCB2ZXJ0ZXgpO1xuICAgICAgICBzaWRlcy5wdXNoKHNpZGUpO1xuICAgICAgfVxuICAgICAgcHJldnZlcnRleCA9IHZlcnRleDtcbiAgICB9XG4gICAgbGV0IHNoZWxsY2FnID0gQ0FHLmZyb21TaWRlcyhzaWRlcyk7XG4gICAgbGV0IGV4cGFuZGVkID0gc2hlbGxjYWcuZXhwYW5kZWRTaGVsbChwYXRocmFkaXVzLCByZXNvbHV0aW9uKTtcbiAgICByZXR1cm4gZXhwYW5kZWQ7XG4gIH0sXG5cbiAgaW5uZXJUb0NBRzogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IENBRyA9IHJlcXVpcmUoJy4uL0NBRycpOyAvLyBGSVhNRTogY3ljbGljIGRlcGVuZGVuY2llcyBDQUcgPT4gUEFUSDIgPT4gQ0FHXG4gICAgaWYgKCF0aGlzLmNsb3NlZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGF0aCBzaG91bGQgYmUgY2xvc2VkIScpO1xuICAgIHJldHVybiBDQUcuZnJvbVBvaW50cyh0aGlzLnBvaW50cyk7XG4gIH0sXG5cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiAobWF0cml4NHg0KSB7XG4gICAgbGV0IG5ld3BvaW50cyA9IHRoaXMucG9pbnRzLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiBwb2ludC5tdWx0aXBseTR4NChtYXRyaXg0eDQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUGF0aDJEKG5ld3BvaW50cywgdGhpcy5jbG9zZWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBCZXppZXIgY3VydmUgdG8gdGhlIGVuZCBvZiB0aGUgcGF0aCwgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHRvIHRyYW5zaXRpb24gdGhlIGN1cnZlIHRocm91Z2ggc3RhcnQgYW5kIGVuZCBwb2ludHMuXG4gICAqIDxicj5cbiAgICogVGhlIELDqXppZXIgY3VydmUgc3RhcnRzIGF0IHRoZSBsYXN0IHBvaW50IGluIHRoZSBwYXRoLFxuICAgKiBhbmQgZW5kcyBhdCB0aGUgbGFzdCBnaXZlbiBjb250cm9sIHBvaW50LiBPdGhlciBjb250cm9sIHBvaW50cyBhcmUgaW50ZXJtZWRpYXRlIGNvbnRyb2wgcG9pbnRzLlxuICAgKiA8YnI+XG4gICAqIFRoZSBmaXJzdCBjb250cm9sIHBvaW50IG1heSBiZSBudWxsIHRvIGVuc3VyZSBhIHNtb290aCB0cmFuc2l0aW9uIG9jY3Vycy4gSW4gdGhpcyBjYXNlLFxuICAgKiB0aGUgc2Vjb25kIHRvIGxhc3QgY29udHJvbCBwb2ludCBvZiB0aGUgcGF0aCBpcyBtaXJyb3JlZCBpbnRvIHRoZSBjb250cm9sIHBvaW50cyBvZiB0aGUgQmV6aWVyIGN1cnZlLlxuICAgKiBJbiBvdGhlciB3b3JkcywgdGhlIHRyYWlsaW5nIGdyYWRpZW50IG9mIHRoZSBwYXRoIG1hdGNoZXMgdGhlIG5ldyBncmFkaWVudCBvZiB0aGUgY3VydmUuXG4gICAqIEBwYXJhbSB7VmVjdG9yMkRbXX0gY29udHJvbHBvaW50cyAtIGxpc3Qgb2YgY29udHJvbCBwb2ludHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGNvbnN0cnVjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj1kZWZhdWx0UmVzb2x1dGlvbjJEXSAtIG51bWJlciBvZiBzaWRlcyBwZXIgMzYwIHJvdGF0aW9uXG4gICAqIEByZXR1cm5zIHtQYXRoMkR9IG5ldyBQYXRoMkQgb2JqZWN0IChub3QgY2xvc2VkKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgcDUgPSBuZXcgQ1NHLlBhdGgyRChbWzEwLC0yMF1dLGZhbHNlKTtcbiAgICogcDUgPSBwNS5hcHBlbmRCZXppZXIoW1sxMCwtMTBdLFsyNSwtMTBdLFsyNSwtMjBdXSk7XG4gICAqIHA1ID0gcDUuYXBwZW5kQmV6aWVyKFtbMjUsLTMwXSxbNDAsLTMwXSxbNDAsLTIwXV0pO1xuICAgKi9cbiAgYXBwZW5kQmV6aWVyOiBmdW5jdGlvbiAoY29udHJvbHBvaW50cywgb3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IG5vdCBiZSBjbG9zZWQnKTtcbiAgICB9XG4gICAgaWYgKCEoY29udHJvbHBvaW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBlbmRCZXppZXI6IHNob3VsZCBwYXNzIGFuIGFycmF5IG9mIGNvbnRyb2wgcG9pbnRzJyk7XG4gICAgfVxuICAgIGlmIChjb250cm9scG9pbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXBwZW5kQmV6aWVyOiBuZWVkIGF0IGxlYXN0IDEgY29udHJvbCBwb2ludCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYXBwZW5kQmV6aWVyOiBwYXRoIG11c3QgYWxyZWFkeSBjb250YWluIGEgcG9pbnQgKHRoZSBlbmRwb2ludCBvZiB0aGUgcGF0aCBpcyB1c2VkIGFzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIGJlemllciBjdXJ2ZSknXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgcmVzb2x1dGlvbiA9IHBhcnNlT3B0aW9uQXNJbnQoXG4gICAgICBvcHRpb25zLFxuICAgICAgJ3Jlc29sdXRpb24nLFxuICAgICAgZGVmYXVsdFJlc29sdXRpb24yRFxuICAgICk7XG4gICAgaWYgKHJlc29sdXRpb24gPCA0KSByZXNvbHV0aW9uID0gNDtcbiAgICBsZXQgZmFjdG9yaWFscyA9IFtdO1xuICAgIGxldCBjb250cm9scG9pbnRzUGFyc2VkID0gW107XG4gICAgY29udHJvbHBvaW50c1BhcnNlZC5wdXNoKHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdKTsgLy8gc3RhcnQgYXQgdGhlIHByZXZpb3VzIGVuZCBwb2ludFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgbGV0IHAgPSBjb250cm9scG9pbnRzW2ldO1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgY2FuIHBhc3MgbnVsbCBhcyB0aGUgZmlyc3QgY29udHJvbCBwb2ludC4gSW4gdGhhdCBjYXNlIGEgc21vb3RoIGdyYWRpZW50IGlzIGVuc3VyZWQ6XG4gICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2FwcGVuZEJlemllcjogbnVsbCBjYW4gb25seSBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ2FwcGVuZEJlemllcjogbnVsbCBjYW4gb25seSBiZSBwYXNzZWQgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG1vcmUgY29udHJvbCBwb2ludCdcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0QmV6aWVyQ29udHJvbFBvaW50O1xuICAgICAgICBpZiAoJ2xhc3RCZXppZXJDb250cm9sUG9pbnQnIGluIHRoaXMpIHtcbiAgICAgICAgICBsYXN0QmV6aWVyQ29udHJvbFBvaW50ID0gdGhpcy5sYXN0QmV6aWVyQ29udHJvbFBvaW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdhcHBlbmRCZXppZXI6IG51bGwgaXMgcGFzc2VkIGFzIGEgY29udHJvbCBwb2ludCBidXQgdGhpcyByZXF1aXJlcyBhIHByZXZpb3VzIGJlemllciBjdXJ2ZSBvciBhdCBsZWFzdCB0d28gcG9pbnRzIGluIHRoZSBleGlzdGluZyBwYXRoJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdEJlemllckNvbnRyb2xQb2ludCA9IHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1pcnJvciB0aGUgbGFzdCBiZXppZXIgY29udHJvbCBwb2ludDpcbiAgICAgICAgcCA9IHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgLnRpbWVzKDIpXG4gICAgICAgICAgLm1pbnVzKGxhc3RCZXppZXJDb250cm9sUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IG5ldyBWZWN0b3IyRChwKTsgLy8gY2FzdCB0byBWZWN0b3IyRFxuICAgICAgfVxuICAgICAgY29udHJvbHBvaW50c1BhcnNlZC5wdXNoKHApO1xuICAgIH1cbiAgICBsZXQgYmV6aWVyT3JkZXIgPSBjb250cm9scG9pbnRzUGFyc2VkLmxlbmd0aCAtIDE7XG4gICAgbGV0IGZhY3QgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGJlemllck9yZGVyOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkgZmFjdCAqPSBpO1xuICAgICAgZmFjdG9yaWFscy5wdXNoKGZhY3QpO1xuICAgIH1cbiAgICBsZXQgYmlub21pYWxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYmV6aWVyT3JkZXI7ICsraSkge1xuICAgICAgbGV0IGJpbm9taWFsID1cbiAgICAgICAgZmFjdG9yaWFsc1tiZXppZXJPcmRlcl0gLyAoZmFjdG9yaWFsc1tpXSAqIGZhY3RvcmlhbHNbYmV6aWVyT3JkZXIgLSBpXSk7XG4gICAgICBiaW5vbWlhbHMucHVzaChiaW5vbWlhbCk7XG4gICAgfVxuICAgIGxldCBnZXRQb2ludEZvclQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgbGV0IHRfayA9IDE7IC8vID0gcG93KHQsaylcbiAgICAgIGxldCBvbmVfbWludXNfdF9uX21pbnVzX2sgPSBNYXRoLnBvdygxIC0gdCwgYmV6aWVyT3JkZXIpOyAvLyA9IHBvdyggMS10LCBiZXppZXJPcmRlciAtIGspXG4gICAgICBsZXQgaW52XzFfbWludXNfdCA9IHQgIT09IDEgPyAxIC8gKDEgLSB0KSA6IDE7XG4gICAgICBsZXQgcG9pbnQgPSBuZXcgVmVjdG9yMkQoMCwgMCk7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8PSBiZXppZXJPcmRlcjsgKytrKSB7XG4gICAgICAgIGlmIChrID09PSBiZXppZXJPcmRlcikgb25lX21pbnVzX3Rfbl9taW51c19rID0gMTtcbiAgICAgICAgbGV0IGJlcm5zdGVpbl9jb2VmZmljaWVudCA9IGJpbm9taWFsc1trXSAqIHRfayAqIG9uZV9taW51c190X25fbWludXNfaztcbiAgICAgICAgcG9pbnQgPSBwb2ludC5wbHVzKGNvbnRyb2xwb2ludHNQYXJzZWRba10udGltZXMoYmVybnN0ZWluX2NvZWZmaWNpZW50KSk7XG4gICAgICAgIHRfayAqPSB0O1xuICAgICAgICBvbmVfbWludXNfdF9uX21pbnVzX2sgKj0gaW52XzFfbWludXNfdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xuICAgIGxldCBuZXdwb2ludHMgPSBbXTtcbiAgICBsZXQgbmV3cG9pbnRzX3QgPSBbXTtcbiAgICBsZXQgbnVtc3RlcHMgPSBiZXppZXJPcmRlciArIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zdGVwczsgKytpKSB7XG4gICAgICBsZXQgdCA9IGkgLyAobnVtc3RlcHMgLSAxKTtcbiAgICAgIGxldCBwb2ludCA9IGdldFBvaW50Rm9yVCh0KTtcbiAgICAgIG5ld3BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIG5ld3BvaW50c190LnB1c2godCk7XG4gICAgfVxuICAgIC8vIHN1YmRpdmlkZSBlYWNoIHNlZ21lbnQgdW50aWwgdGhlIGFuZ2xlIGF0IGVhY2ggdmVydGV4IGJlY29tZXMgc21hbGwgZW5vdWdoOlxuICAgIGxldCBzdWJkaXZpZGVCYXNlID0gMTtcbiAgICBsZXQgbWF4YW5nbGUgPSAoTWF0aC5QSSAqIDIpIC8gcmVzb2x1dGlvbjsgLy8gc2VnbWVudHMgbWF5IGhhdmUgZGlmZmVyIG5vIG1vcmUgaW4gYW5nbGUgdGhhbiB0aGlzXG4gICAgbGV0IG1heHNpbmFuZ2xlID0gTWF0aC5zaW4obWF4YW5nbGUpO1xuICAgIHdoaWxlIChzdWJkaXZpZGVCYXNlIDwgbmV3cG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGxldCBkaXIxID0gbmV3cG9pbnRzW3N1YmRpdmlkZUJhc2VdXG4gICAgICAgIC5taW51cyhuZXdwb2ludHNbc3ViZGl2aWRlQmFzZSAtIDFdKVxuICAgICAgICAudW5pdCgpO1xuICAgICAgbGV0IGRpcjIgPSBuZXdwb2ludHNbc3ViZGl2aWRlQmFzZSArIDFdXG4gICAgICAgIC5taW51cyhuZXdwb2ludHNbc3ViZGl2aWRlQmFzZV0pXG4gICAgICAgIC51bml0KCk7XG4gICAgICBsZXQgc2luYW5nbGUgPSBkaXIxLmNyb3NzKGRpcjIpOyAvLyB0aGlzIGlzIHRoZSBzaW5lIG9mIHRoZSBhbmdsZVxuICAgICAgaWYgKE1hdGguYWJzKHNpbmFuZ2xlKSA+IG1heHNpbmFuZ2xlKSB7XG4gICAgICAgIC8vIGFuZ2xlIGlzIHRvbyBiaWcsIHdlIG5lZWQgdG8gc3ViZGl2aWRlXG4gICAgICAgIGxldCB0MCA9IG5ld3BvaW50c190W3N1YmRpdmlkZUJhc2UgLSAxXTtcbiAgICAgICAgbGV0IHQxID0gbmV3cG9pbnRzX3Rbc3ViZGl2aWRlQmFzZSArIDFdO1xuICAgICAgICBsZXQgdDBfbmV3ID0gdDAgKyAoKHQxIC0gdDApICogMSkgLyAzO1xuICAgICAgICBsZXQgdDFfbmV3ID0gdDAgKyAoKHQxIC0gdDApICogMikgLyAzO1xuICAgICAgICBsZXQgcG9pbnQwX25ldyA9IGdldFBvaW50Rm9yVCh0MF9uZXcpO1xuICAgICAgICBsZXQgcG9pbnQxX25ldyA9IGdldFBvaW50Rm9yVCh0MV9uZXcpO1xuICAgICAgICAvLyByZW1vdmUgdGhlIHBvaW50IGF0IHN1YmRpdmlkZUJhc2UgYW5kIHJlcGxhY2Ugd2l0aCAyIG5ldyBwb2ludHM6XG4gICAgICAgIG5ld3BvaW50cy5zcGxpY2Uoc3ViZGl2aWRlQmFzZSwgMSwgcG9pbnQwX25ldywgcG9pbnQxX25ldyk7XG4gICAgICAgIG5ld3BvaW50c190LnNwbGljZShzdWJkaXZpZGVCYXNlLCAxLCB0MF9uZXcsIHQxX25ldyk7XG4gICAgICAgIC8vIHJlIC0gZXZhbHVhdGUgdGhlIGFuZ2xlcywgc3RhcnRpbmcgYXQgdGhlIHByZXZpb3VzIGp1bmN0aW9uIHNpbmNlIGl0IGhhcyBjaGFuZ2VkOlxuICAgICAgICBzdWJkaXZpZGVCYXNlLS07XG4gICAgICAgIGlmIChzdWJkaXZpZGVCYXNlIDwgMSkgc3ViZGl2aWRlQmFzZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3N1YmRpdmlkZUJhc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFwcGVuZCB0byB0aGUgcHJldmlvdXMgcG9pbnRzLCBidXQgc2tpcCB0aGUgZmlyc3QgbmV3IHBvaW50IGJlY2F1c2UgaXQgaXMgaWRlbnRpY2FsIHRvIHRoZSBsYXN0IHBvaW50OlxuICAgIG5ld3BvaW50cyA9IHRoaXMucG9pbnRzLmNvbmNhdChuZXdwb2ludHMuc2xpY2UoMSkpO1xuICAgIGxldCByZXN1bHQgPSBuZXcgUGF0aDJEKG5ld3BvaW50cyk7XG4gICAgcmVzdWx0Lmxhc3RCZXppZXJDb250cm9sUG9pbnQgPVxuICAgICAgY29udHJvbHBvaW50c1BhcnNlZFtjb250cm9scG9pbnRzUGFyc2VkLmxlbmd0aCAtIDJdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhbiBhcmMgdG8gdGhlIGVuZCBvZiB0aGUgcGF0aC5cbiAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBmb2xsb3dzIHRoZSBTVkcgYXJjIHNwZWNzLiBGb3IgdGhlIGRldGFpbHMgc2VlXG4gICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhRWxsaXB0aWNhbEFyY0NvbW1hbmRzXG4gICAqIEBwYXJhbSB7VmVjdG9yMkR9IGVuZHBvaW50IC0gZW5kIHBvaW50IG9mIGFyY1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgY29uc3RydWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MF0gLSByYWRpdXMgb2YgYXJjIChYIGFuZCBZKSwgc2VlIGFsc28geHJhZGl1cyBhbmQgeXJhZGl1c1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueHJhZGl1cz0wXSAtIFggcmFkaXVzIG9mIGFyYywgc2VlIGFsc28gcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy55cmFkaXVzPTBdIC0gWSByYWRpdXMgb2YgYXJjLCBzZWUgYWxzbyByYWRpdXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnhheGlzcm90YXRpb249MF0gLSAgcm90YXRpb24gKGluIGRlZ3JlZXMpIG9mIHRoZSBYIGF4aXMgb2YgdGhlIGFyYyB3aXRoIHJlc3BlY3QgdG8gdGhlIFggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249ZGVmYXVsdFJlc29sdXRpb24yRF0gLSBudW1iZXIgb2Ygc2lkZXMgcGVyIDM2MCByb3RhdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsb2Nrd2lzZT1mYWxzZV0gLSBkcmF3IGFuIGFyYyBjbG9ja3dpc2Ugd2l0aCByZXNwZWN0IHRvIHRoZSBjZW50ZXIgcG9pbnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sYXJnZT1mYWxzZV0gLSBkcmF3IGFuIGFyYyBsb25nZXIgdGhhbiAxODAgZGVncmVlc1xuICAgKiBAcmV0dXJucyB7UGF0aDJEfSBuZXcgUGF0aDJEIG9iamVjdCAobm90IGNsb3NlZClcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbGV0IHAxID0gbmV3IENTRy5QYXRoMkQoW1syNy41LC0yMi45Njg3NV1dLGZhbHNlKTtcbiAgICogcDEgPSBwMS5hcHBlbmRQb2ludChbMjcuNSwtMy4yODEyNV0pO1xuICAgKiBwMSA9IHAxLmFwcGVuZEFyYyhbMTIuNSwtMjIuOTY4NzVdLHt4cmFkaXVzOiAxNSx5cmFkaXVzOiAtMTkuNjg3NSx4YXhpc3JvdGF0aW9uOiAwLGNsb2Nrd2lzZTogZmFsc2UsbGFyZ2U6IGZhbHNlfSk7XG4gICAqIHAxID0gcDEuY2xvc2UoKTtcbiAgICovXG4gIGFwcGVuZEFyYzogZnVuY3Rpb24gKGVuZHBvaW50LCBvcHRpb25zKSB7XG4gICAgbGV0IGRlY2ltYWxzID0gMTAwMDAwO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IG5vdCBiZSBjbG9zZWQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2FwcGVuZEFyYzogcGF0aCBtdXN0IGFscmVhZHkgY29udGFpbiBhIHBvaW50ICh0aGUgZW5kcG9pbnQgb2YgdGhlIHBhdGggaXMgdXNlZCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBhcmMpJ1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHJlc29sdXRpb24gPSBwYXJzZU9wdGlvbkFzSW50KFxuICAgICAgb3B0aW9ucyxcbiAgICAgICdyZXNvbHV0aW9uJyxcbiAgICAgIGRlZmF1bHRSZXNvbHV0aW9uMkRcbiAgICApO1xuICAgIGlmIChyZXNvbHV0aW9uIDwgNCkgcmVzb2x1dGlvbiA9IDQ7XG4gICAgbGV0IHhyYWRpdXMsIHlyYWRpdXM7XG4gICAgaWYgKCd4cmFkaXVzJyBpbiBvcHRpb25zIHx8ICd5cmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoJ3JhZGl1cycgaW4gb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1Nob3VsZCBlaXRoZXIgZ2l2ZSBhbiB4cmFkaXVzIGFuZCB5cmFkaXVzIHBhcmFtZXRlciwgb3IgYSByYWRpdXMgcGFyYW1ldGVyJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgeHJhZGl1cyA9IHBhcnNlT3B0aW9uQXNGbG9hdChvcHRpb25zLCAneHJhZGl1cycsIDApO1xuICAgICAgeXJhZGl1cyA9IHBhcnNlT3B0aW9uQXNGbG9hdChvcHRpb25zLCAneXJhZGl1cycsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4cmFkaXVzID0gcGFyc2VPcHRpb25Bc0Zsb2F0KG9wdGlvbnMsICdyYWRpdXMnLCAwKTtcbiAgICAgIHlyYWRpdXMgPSB4cmFkaXVzO1xuICAgIH1cbiAgICBsZXQgeGF4aXNyb3RhdGlvbiA9IHBhcnNlT3B0aW9uQXNGbG9hdChvcHRpb25zLCAneGF4aXNyb3RhdGlvbicsIDApO1xuICAgIGxldCBjbG9ja3dpc2UgPSBwYXJzZU9wdGlvbkFzQm9vbChvcHRpb25zLCAnY2xvY2t3aXNlJywgZmFsc2UpO1xuICAgIGxldCBsYXJnZWFyYyA9IHBhcnNlT3B0aW9uQXNCb29sKG9wdGlvbnMsICdsYXJnZScsIGZhbHNlKTtcbiAgICBsZXQgc3RhcnRwb2ludCA9IHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIGVuZHBvaW50ID0gbmV3IFZlY3RvcjJEKGVuZHBvaW50KTtcbiAgICAvLyByb3VuZCB0byBwcmVjaXNpb24gaW4gb3JkZXIgdG8gaGF2ZSBkZXRlcm1pbmF0ZSBjYWxjdWxhdGlvbnNcbiAgICB4cmFkaXVzID0gTWF0aC5yb3VuZCh4cmFkaXVzICogZGVjaW1hbHMpIC8gZGVjaW1hbHM7XG4gICAgeXJhZGl1cyA9IE1hdGgucm91bmQoeXJhZGl1cyAqIGRlY2ltYWxzKSAvIGRlY2ltYWxzO1xuICAgIGVuZHBvaW50ID0gbmV3IFZlY3RvcjJEKFxuICAgICAgTWF0aC5yb3VuZChlbmRwb2ludC54ICogZGVjaW1hbHMpIC8gZGVjaW1hbHMsXG4gICAgICBNYXRoLnJvdW5kKGVuZHBvaW50LnkgKiBkZWNpbWFscykgLyBkZWNpbWFsc1xuICAgICk7XG5cbiAgICBsZXQgc3dlZXBGbGFnID0gIWNsb2Nrd2lzZTtcbiAgICBsZXQgbmV3cG9pbnRzID0gW107XG4gICAgaWYgKHhyYWRpdXMgPT09IDAgfHwgeXJhZGl1cyA9PT0gMCkge1xuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3RlczpcbiAgICAgIC8vIElmIHJ4ID0gMCBvciByeSA9IDAsIHRoZW4gdHJlYXQgdGhpcyBhcyBhIHN0cmFpZ2h0IGxpbmUgZnJvbSAoeDEsIHkxKSB0byAoeDIsIHkyKSBhbmQgc3RvcFxuICAgICAgbmV3cG9pbnRzLnB1c2goZW5kcG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4cmFkaXVzID0gTWF0aC5hYnMoeHJhZGl1cyk7XG4gICAgICB5cmFkaXVzID0gTWF0aC5hYnMoeXJhZGl1cyk7XG5cbiAgICAgIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzIDpcbiAgICAgIGxldCBwaGkgPSAoeGF4aXNyb3RhdGlvbiAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgICBsZXQgY29zcGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICAgIGxldCBzaW5waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgbGV0IG1pbnVzaGFsZmRpc3RhbmNlID0gc3RhcnRwb2ludC5taW51cyhlbmRwb2ludCkudGltZXMoMC41KTtcbiAgICAgIC8vIEYuNi41LjE6XG4gICAgICAvLyByb3VuZCB0byBwcmVjaXNpb24gaW4gb3JkZXIgdG8gaGF2ZSBkZXRlcm1pbmF0ZSBjYWxjdWxhdGlvbnNcbiAgICAgIGxldCB4ID1cbiAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAoY29zcGhpICogbWludXNoYWxmZGlzdGFuY2UueCArIHNpbnBoaSAqIG1pbnVzaGFsZmRpc3RhbmNlLnkpICpcbiAgICAgICAgICAgIGRlY2ltYWxzXG4gICAgICAgICkgLyBkZWNpbWFscztcbiAgICAgIGxldCB5ID1cbiAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAoLXNpbnBoaSAqIG1pbnVzaGFsZmRpc3RhbmNlLnggKyBjb3NwaGkgKiBtaW51c2hhbGZkaXN0YW5jZS55KSAqXG4gICAgICAgICAgICBkZWNpbWFsc1xuICAgICAgICApIC8gZGVjaW1hbHM7XG4gICAgICBsZXQgc3RhcnRUcmFuc2xhdGVkID0gbmV3IFZlY3RvcjJEKHgsIHkpO1xuICAgICAgLy8gRi42LjYuMjpcbiAgICAgIGxldCBiaWdsYW1iZGEgPVxuICAgICAgICAoc3RhcnRUcmFuc2xhdGVkLnggKiBzdGFydFRyYW5zbGF0ZWQueCkgLyAoeHJhZGl1cyAqIHhyYWRpdXMpICtcbiAgICAgICAgKHN0YXJ0VHJhbnNsYXRlZC55ICogc3RhcnRUcmFuc2xhdGVkLnkpIC8gKHlyYWRpdXMgKiB5cmFkaXVzKTtcbiAgICAgIGlmIChiaWdsYW1iZGEgPiAxLjApIHtcbiAgICAgICAgLy8gRi42LjYuMzpcbiAgICAgICAgbGV0IHNxcnRiaWdsYW1iZGEgPSBNYXRoLnNxcnQoYmlnbGFtYmRhKTtcbiAgICAgICAgeHJhZGl1cyAqPSBzcXJ0YmlnbGFtYmRhO1xuICAgICAgICB5cmFkaXVzICo9IHNxcnRiaWdsYW1iZGE7XG4gICAgICAgIC8vIHJvdW5kIHRvIHByZWNpc2lvbiBpbiBvcmRlciB0byBoYXZlIGRldGVybWluYXRlIGNhbGN1bGF0aW9uc1xuICAgICAgICB4cmFkaXVzID0gTWF0aC5yb3VuZCh4cmFkaXVzICogZGVjaW1hbHMpIC8gZGVjaW1hbHM7XG4gICAgICAgIHlyYWRpdXMgPSBNYXRoLnJvdW5kKHlyYWRpdXMgKiBkZWNpbWFscykgLyBkZWNpbWFscztcbiAgICAgIH1cbiAgICAgIC8vIEYuNi41LjI6XG4gICAgICBsZXQgbXVsdGlwbGllcjEgPSBNYXRoLnNxcnQoXG4gICAgICAgICh4cmFkaXVzICogeHJhZGl1cyAqIHlyYWRpdXMgKiB5cmFkaXVzIC1cbiAgICAgICAgICB4cmFkaXVzICogeHJhZGl1cyAqIHN0YXJ0VHJhbnNsYXRlZC55ICogc3RhcnRUcmFuc2xhdGVkLnkgLVxuICAgICAgICAgIHlyYWRpdXMgKiB5cmFkaXVzICogc3RhcnRUcmFuc2xhdGVkLnggKiBzdGFydFRyYW5zbGF0ZWQueCkgL1xuICAgICAgICAgICh4cmFkaXVzICogeHJhZGl1cyAqIHN0YXJ0VHJhbnNsYXRlZC55ICogc3RhcnRUcmFuc2xhdGVkLnkgK1xuICAgICAgICAgICAgeXJhZGl1cyAqIHlyYWRpdXMgKiBzdGFydFRyYW5zbGF0ZWQueCAqIHN0YXJ0VHJhbnNsYXRlZC54KVxuICAgICAgKTtcbiAgICAgIGlmIChzd2VlcEZsYWcgPT09IGxhcmdlYXJjKSBtdWx0aXBsaWVyMSA9IC1tdWx0aXBsaWVyMTtcbiAgICAgIGxldCBjZW50ZXJUcmFuc2xhdGVkID0gbmV3IFZlY3RvcjJEKFxuICAgICAgICAoeHJhZGl1cyAqIHN0YXJ0VHJhbnNsYXRlZC55KSAvIHlyYWRpdXMsXG4gICAgICAgICgteXJhZGl1cyAqIHN0YXJ0VHJhbnNsYXRlZC54KSAvIHhyYWRpdXNcbiAgICAgICkudGltZXMobXVsdGlwbGllcjEpO1xuICAgICAgLy8gRi42LjUuMzpcbiAgICAgIGxldCBjZW50ZXIgPSBuZXcgVmVjdG9yMkQoXG4gICAgICAgIGNvc3BoaSAqIGNlbnRlclRyYW5zbGF0ZWQueCAtIHNpbnBoaSAqIGNlbnRlclRyYW5zbGF0ZWQueSxcbiAgICAgICAgc2lucGhpICogY2VudGVyVHJhbnNsYXRlZC54ICsgY29zcGhpICogY2VudGVyVHJhbnNsYXRlZC55XG4gICAgICApLnBsdXMoc3RhcnRwb2ludC5wbHVzKGVuZHBvaW50KS50aW1lcygwLjUpKTtcbiAgICAgIC8vIEYuNi41LjU6XG4gICAgICBsZXQgdmVjMSA9IG5ldyBWZWN0b3IyRChcbiAgICAgICAgKHN0YXJ0VHJhbnNsYXRlZC54IC0gY2VudGVyVHJhbnNsYXRlZC54KSAvIHhyYWRpdXMsXG4gICAgICAgIChzdGFydFRyYW5zbGF0ZWQueSAtIGNlbnRlclRyYW5zbGF0ZWQueSkgLyB5cmFkaXVzXG4gICAgICApO1xuICAgICAgbGV0IHZlYzIgPSBuZXcgVmVjdG9yMkQoXG4gICAgICAgICgtc3RhcnRUcmFuc2xhdGVkLnggLSBjZW50ZXJUcmFuc2xhdGVkLngpIC8geHJhZGl1cyxcbiAgICAgICAgKC1zdGFydFRyYW5zbGF0ZWQueSAtIGNlbnRlclRyYW5zbGF0ZWQueSkgLyB5cmFkaXVzXG4gICAgICApO1xuICAgICAgbGV0IHRoZXRhMSA9IHZlYzEuYW5nbGVSYWRpYW5zKCk7XG4gICAgICBsZXQgdGhldGEyID0gdmVjMi5hbmdsZVJhZGlhbnMoKTtcbiAgICAgIGxldCBkZWx0YXRoZXRhID0gdGhldGEyIC0gdGhldGExO1xuICAgICAgZGVsdGF0aGV0YSA9IGRlbHRhdGhldGEgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgaWYgKCFzd2VlcEZsYWcgJiYgZGVsdGF0aGV0YSA+IDApIHtcbiAgICAgICAgZGVsdGF0aGV0YSAtPSAyICogTWF0aC5QSTtcbiAgICAgIH0gZWxzZSBpZiAoc3dlZXBGbGFnICYmIGRlbHRhdGhldGEgPCAwKSB7XG4gICAgICAgIGRlbHRhdGhldGEgKz0gMiAqIE1hdGguUEk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9rLCB3ZSBoYXZlIHRoZSBjZW50ZXIgcG9pbnQgYW5kIGFuZ2xlIHJhbmdlIChmcm9tIHRoZXRhMSwgZGVsdGF0aGV0YSByYWRpYW5zKSBzbyB3ZSBjYW4gY3JlYXRlIHRoZSBlbGxpcHNlXG4gICAgICBsZXQgbnVtc3RlcHMgPVxuICAgICAgICBNYXRoLmNlaWwoKE1hdGguYWJzKGRlbHRhdGhldGEpIC8gKDIgKiBNYXRoLlBJKSkgKiByZXNvbHV0aW9uKSArIDE7XG4gICAgICBpZiAobnVtc3RlcHMgPCAxKSBudW1zdGVwcyA9IDE7XG4gICAgICBmb3IgKGxldCBzdGVwID0gMTsgc3RlcCA8PSBudW1zdGVwczsgc3RlcCsrKSB7XG4gICAgICAgIGxldCB0aGV0YSA9IHRoZXRhMSArIChzdGVwIC8gbnVtc3RlcHMpICogZGVsdGF0aGV0YTtcbiAgICAgICAgbGV0IGNvc3RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBsZXQgc2ludGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIC8vIEYuNi4zLjE6XG4gICAgICAgIGxldCBwb2ludCA9IG5ldyBWZWN0b3IyRChcbiAgICAgICAgICBjb3NwaGkgKiB4cmFkaXVzICogY29zdGhldGEgLSBzaW5waGkgKiB5cmFkaXVzICogc2ludGhldGEsXG4gICAgICAgICAgc2lucGhpICogeHJhZGl1cyAqIGNvc3RoZXRhICsgY29zcGhpICogeXJhZGl1cyAqIHNpbnRoZXRhXG4gICAgICAgICkucGx1cyhjZW50ZXIpO1xuICAgICAgICBuZXdwb2ludHMucHVzaChwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICAgIG5ld3BvaW50cyA9IHRoaXMucG9pbnRzLmNvbmNhdChuZXdwb2ludHMpO1xuICAgIGxldCByZXN1bHQgPSBuZXcgUGF0aDJEKG5ld3BvaW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0aDJEO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/Path2.js\n");

/***/ }),

/***/ "./src/core/math/Plane.js":
/*!********************************!*\
  !*** ./src/core/math/Plane.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ./Vector3 */ \"./src/core/math/Vector3.js\");\nconst Line3D = __webpack_require__(/*! ./Line3 */ \"./src/core/math/Line3.js\");\nconst { EPS, getTag } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\n\n// # class Plane\n// Represents a plane in 3D space.\nconst Plane = function (normal, w) {\n  this.normal = normal;\n  this.w = w;\n};\n\n// create from an untyped object with identical property names:\nPlane.fromObject = function (obj) {\n  let normal = new Vector3D(obj.normal);\n  let w = parseFloat(obj.w);\n  return new Plane(normal, w);\n};\n\nPlane.fromVector3Ds = function (a, b, c) {\n  let n = b.minus(a).cross(c.minus(a)).unit();\n  return new Plane(n, n.dot(a));\n};\n\n// like fromVector3Ds, but allow the vectors to be on one point or one line\n// in such a case a random plane through the given points is constructed\nPlane.anyPlaneFromVector3Ds = function (a, b, c) {\n  let v1 = b.minus(a);\n  let v2 = c.minus(a);\n  if (v1.length() < EPS) {\n    v1 = v2.randomNonParallelVector();\n  }\n  if (v2.length() < EPS) {\n    v2 = v1.randomNonParallelVector();\n  }\n  let normal = v1.cross(v2);\n  if (normal.length() < EPS) {\n    // this would mean that v1 == v2.negated()\n    v2 = v1.randomNonParallelVector();\n    normal = v1.cross(v2);\n  }\n  normal = normal.unit();\n  return new Plane(normal, normal.dot(a));\n};\n\nPlane.fromPoints = function (a, b, c) {\n  a = new Vector3D(a);\n  b = new Vector3D(b);\n  c = new Vector3D(c);\n  return Plane.fromVector3Ds(a, b, c);\n};\n\nPlane.fromNormalAndPoint = function (normal, point) {\n  normal = new Vector3D(normal);\n  point = new Vector3D(point);\n  normal = normal.unit();\n  let w = point.dot(normal);\n  return new Plane(normal, w);\n};\n\nPlane.prototype = {\n  flipped: function () {\n    return new Plane(this.normal.negated(), -this.w);\n  },\n\n  getTag: function () {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n\n  equals: function (n) {\n    return this.normal.equals(n.normal) && this.w === n.w;\n  },\n\n  transform: function (matrix4x4) {\n    let ismirror = matrix4x4.isMirroring();\n    // get two vectors in the plane:\n    let r = this.normal.randomNonParallelVector();\n    let u = this.normal.cross(r);\n    let v = this.normal.cross(u);\n    // get 3 points in the plane:\n    let point1 = this.normal.times(this.w);\n    let point2 = point1.plus(u);\n    let point3 = point1.plus(v);\n    // transform the points:\n    point1 = point1.multiply4x4(matrix4x4);\n    point2 = point2.multiply4x4(matrix4x4);\n    point3 = point3.multiply4x4(matrix4x4);\n    // and create a new plane from the transformed points:\n    let newplane = Plane.fromVector3Ds(point1, point2, point3);\n    if (ismirror) {\n      // the transform is mirroring\n      // We should mirror the plane:\n      newplane = newplane.flipped();\n    }\n    return newplane;\n  },\n\n  // robust splitting of a line by a plane\n  // will work even if the line is parallel to the plane\n  splitLineBetweenPoints: function (p1, p2) {\n    let direction = p2.minus(p1);\n    let labda = (this.w - this.normal.dot(p1)) / this.normal.dot(direction);\n    if (isNaN(labda)) labda = 0;\n    if (labda > 1) labda = 1;\n    if (labda < 0) labda = 0;\n    let result = p1.plus(direction.times(labda));\n    return result;\n  },\n\n  // returns Vector3D\n  intersectWithLine: function (line3d) {\n    return line3d.intersectWithPlane(this);\n  },\n\n  // intersection of two planes\n  intersectWithPlane: function (plane) {\n    return Line3D.fromPlanes(this, plane);\n  },\n\n  signedDistanceToPoint: function (point) {\n    let t = this.normal.dot(point) - this.w;\n    return t;\n  },\n\n  toString: function () {\n    return '[normal: ' + this.normal.toString() + ', w: ' + this.w + ']';\n  },\n\n  mirrorPoint: function (point3d) {\n    let distance = this.signedDistanceToPoint(point3d);\n    let mirrored = point3d.minus(this.normal.times(distance * 2.0));\n    return mirrored;\n  },\n};\n\nmodule.exports = Plane;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1BsYW5lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvbWF0aC9QbGFuZS5qcz9mNmU0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlY3RvcjNEID0gcmVxdWlyZSgnLi9WZWN0b3IzJyk7XG5jb25zdCBMaW5lM0QgPSByZXF1aXJlKCcuL0xpbmUzJyk7XG5jb25zdCB7IEVQUywgZ2V0VGFnIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxuLy8gIyBjbGFzcyBQbGFuZVxuLy8gUmVwcmVzZW50cyBhIHBsYW5lIGluIDNEIHNwYWNlLlxuY29uc3QgUGxhbmUgPSBmdW5jdGlvbiAobm9ybWFsLCB3KSB7XG4gIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICB0aGlzLncgPSB3O1xufTtcblxuLy8gY3JlYXRlIGZyb20gYW4gdW50eXBlZCBvYmplY3Qgd2l0aCBpZGVudGljYWwgcHJvcGVydHkgbmFtZXM6XG5QbGFuZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICBsZXQgbm9ybWFsID0gbmV3IFZlY3RvcjNEKG9iai5ub3JtYWwpO1xuICBsZXQgdyA9IHBhcnNlRmxvYXQob2JqLncpO1xuICByZXR1cm4gbmV3IFBsYW5lKG5vcm1hbCwgdyk7XG59O1xuXG5QbGFuZS5mcm9tVmVjdG9yM0RzID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgbGV0IG4gPSBiLm1pbnVzKGEpLmNyb3NzKGMubWludXMoYSkpLnVuaXQoKTtcbiAgcmV0dXJuIG5ldyBQbGFuZShuLCBuLmRvdChhKSk7XG59O1xuXG4vLyBsaWtlIGZyb21WZWN0b3IzRHMsIGJ1dCBhbGxvdyB0aGUgdmVjdG9ycyB0byBiZSBvbiBvbmUgcG9pbnQgb3Igb25lIGxpbmVcbi8vIGluIHN1Y2ggYSBjYXNlIGEgcmFuZG9tIHBsYW5lIHRocm91Z2ggdGhlIGdpdmVuIHBvaW50cyBpcyBjb25zdHJ1Y3RlZFxuUGxhbmUuYW55UGxhbmVGcm9tVmVjdG9yM0RzID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgbGV0IHYxID0gYi5taW51cyhhKTtcbiAgbGV0IHYyID0gYy5taW51cyhhKTtcbiAgaWYgKHYxLmxlbmd0aCgpIDwgRVBTKSB7XG4gICAgdjEgPSB2Mi5yYW5kb21Ob25QYXJhbGxlbFZlY3RvcigpO1xuICB9XG4gIGlmICh2Mi5sZW5ndGgoKSA8IEVQUykge1xuICAgIHYyID0gdjEucmFuZG9tTm9uUGFyYWxsZWxWZWN0b3IoKTtcbiAgfVxuICBsZXQgbm9ybWFsID0gdjEuY3Jvc3ModjIpO1xuICBpZiAobm9ybWFsLmxlbmd0aCgpIDwgRVBTKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBtZWFuIHRoYXQgdjEgPT0gdjIubmVnYXRlZCgpXG4gICAgdjIgPSB2MS5yYW5kb21Ob25QYXJhbGxlbFZlY3RvcigpO1xuICAgIG5vcm1hbCA9IHYxLmNyb3NzKHYyKTtcbiAgfVxuICBub3JtYWwgPSBub3JtYWwudW5pdCgpO1xuICByZXR1cm4gbmV3IFBsYW5lKG5vcm1hbCwgbm9ybWFsLmRvdChhKSk7XG59O1xuXG5QbGFuZS5mcm9tUG9pbnRzID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgYSA9IG5ldyBWZWN0b3IzRChhKTtcbiAgYiA9IG5ldyBWZWN0b3IzRChiKTtcbiAgYyA9IG5ldyBWZWN0b3IzRChjKTtcbiAgcmV0dXJuIFBsYW5lLmZyb21WZWN0b3IzRHMoYSwgYiwgYyk7XG59O1xuXG5QbGFuZS5mcm9tTm9ybWFsQW5kUG9pbnQgPSBmdW5jdGlvbiAobm9ybWFsLCBwb2ludCkge1xuICBub3JtYWwgPSBuZXcgVmVjdG9yM0Qobm9ybWFsKTtcbiAgcG9pbnQgPSBuZXcgVmVjdG9yM0QocG9pbnQpO1xuICBub3JtYWwgPSBub3JtYWwudW5pdCgpO1xuICBsZXQgdyA9IHBvaW50LmRvdChub3JtYWwpO1xuICByZXR1cm4gbmV3IFBsYW5lKG5vcm1hbCwgdyk7XG59O1xuXG5QbGFuZS5wcm90b3R5cGUgPSB7XG4gIGZsaXBwZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFBsYW5lKHRoaXMubm9ybWFsLm5lZ2F0ZWQoKSwgLXRoaXMudyk7XG4gIH0sXG5cbiAgZ2V0VGFnOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMudGFnO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBnZXRUYWcoKTtcbiAgICAgIHRoaXMudGFnID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWwuZXF1YWxzKG4ubm9ybWFsKSAmJiB0aGlzLncgPT09IG4udztcbiAgfSxcblxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICBsZXQgaXNtaXJyb3IgPSBtYXRyaXg0eDQuaXNNaXJyb3JpbmcoKTtcbiAgICAvLyBnZXQgdHdvIHZlY3RvcnMgaW4gdGhlIHBsYW5lOlxuICAgIGxldCByID0gdGhpcy5ub3JtYWwucmFuZG9tTm9uUGFyYWxsZWxWZWN0b3IoKTtcbiAgICBsZXQgdSA9IHRoaXMubm9ybWFsLmNyb3NzKHIpO1xuICAgIGxldCB2ID0gdGhpcy5ub3JtYWwuY3Jvc3ModSk7XG4gICAgLy8gZ2V0IDMgcG9pbnRzIGluIHRoZSBwbGFuZTpcbiAgICBsZXQgcG9pbnQxID0gdGhpcy5ub3JtYWwudGltZXModGhpcy53KTtcbiAgICBsZXQgcG9pbnQyID0gcG9pbnQxLnBsdXModSk7XG4gICAgbGV0IHBvaW50MyA9IHBvaW50MS5wbHVzKHYpO1xuICAgIC8vIHRyYW5zZm9ybSB0aGUgcG9pbnRzOlxuICAgIHBvaW50MSA9IHBvaW50MS5tdWx0aXBseTR4NChtYXRyaXg0eDQpO1xuICAgIHBvaW50MiA9IHBvaW50Mi5tdWx0aXBseTR4NChtYXRyaXg0eDQpO1xuICAgIHBvaW50MyA9IHBvaW50My5tdWx0aXBseTR4NChtYXRyaXg0eDQpO1xuICAgIC8vIGFuZCBjcmVhdGUgYSBuZXcgcGxhbmUgZnJvbSB0aGUgdHJhbnNmb3JtZWQgcG9pbnRzOlxuICAgIGxldCBuZXdwbGFuZSA9IFBsYW5lLmZyb21WZWN0b3IzRHMocG9pbnQxLCBwb2ludDIsIHBvaW50Myk7XG4gICAgaWYgKGlzbWlycm9yKSB7XG4gICAgICAvLyB0aGUgdHJhbnNmb3JtIGlzIG1pcnJvcmluZ1xuICAgICAgLy8gV2Ugc2hvdWxkIG1pcnJvciB0aGUgcGxhbmU6XG4gICAgICBuZXdwbGFuZSA9IG5ld3BsYW5lLmZsaXBwZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld3BsYW5lO1xuICB9LFxuXG4gIC8vIHJvYnVzdCBzcGxpdHRpbmcgb2YgYSBsaW5lIGJ5IGEgcGxhbmVcbiAgLy8gd2lsbCB3b3JrIGV2ZW4gaWYgdGhlIGxpbmUgaXMgcGFyYWxsZWwgdG8gdGhlIHBsYW5lXG4gIHNwbGl0TGluZUJldHdlZW5Qb2ludHM6IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gcDIubWludXMocDEpO1xuICAgIGxldCBsYWJkYSA9ICh0aGlzLncgLSB0aGlzLm5vcm1hbC5kb3QocDEpKSAvIHRoaXMubm9ybWFsLmRvdChkaXJlY3Rpb24pO1xuICAgIGlmIChpc05hTihsYWJkYSkpIGxhYmRhID0gMDtcbiAgICBpZiAobGFiZGEgPiAxKSBsYWJkYSA9IDE7XG4gICAgaWYgKGxhYmRhIDwgMCkgbGFiZGEgPSAwO1xuICAgIGxldCByZXN1bHQgPSBwMS5wbHVzKGRpcmVjdGlvbi50aW1lcyhsYWJkYSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLy8gcmV0dXJucyBWZWN0b3IzRFxuICBpbnRlcnNlY3RXaXRoTGluZTogZnVuY3Rpb24gKGxpbmUzZCkge1xuICAgIHJldHVybiBsaW5lM2QuaW50ZXJzZWN0V2l0aFBsYW5lKHRoaXMpO1xuICB9LFxuXG4gIC8vIGludGVyc2VjdGlvbiBvZiB0d28gcGxhbmVzXG4gIGludGVyc2VjdFdpdGhQbGFuZTogZnVuY3Rpb24gKHBsYW5lKSB7XG4gICAgcmV0dXJuIExpbmUzRC5mcm9tUGxhbmVzKHRoaXMsIHBsYW5lKTtcbiAgfSxcblxuICBzaWduZWREaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIGxldCB0ID0gdGhpcy5ub3JtYWwuZG90KHBvaW50KSAtIHRoaXMudztcbiAgICByZXR1cm4gdDtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnW25vcm1hbDogJyArIHRoaXMubm9ybWFsLnRvU3RyaW5nKCkgKyAnLCB3OiAnICsgdGhpcy53ICsgJ10nO1xuICB9LFxuXG4gIG1pcnJvclBvaW50OiBmdW5jdGlvbiAocG9pbnQzZCkge1xuICAgIGxldCBkaXN0YW5jZSA9IHRoaXMuc2lnbmVkRGlzdGFuY2VUb1BvaW50KHBvaW50M2QpO1xuICAgIGxldCBtaXJyb3JlZCA9IHBvaW50M2QubWludXModGhpcy5ub3JtYWwudGltZXMoZGlzdGFuY2UgKiAyLjApKTtcbiAgICByZXR1cm4gbWlycm9yZWQ7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/math/Plane.js\n");

/***/ }),

/***/ "./src/core/math/Polygon2.js":
/*!***********************************!*\
  !*** ./src/core/math/Polygon2.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CAG = __webpack_require__(/*! ../CAG */ \"./src/core/CAG.js\");\nconst { fromPoints } = __webpack_require__(/*! ../CAGFactories */ \"./src/core/CAGFactories.js\");\n\n/*\n2D polygons are now supported through the CAG class.\nWith many improvements (see documentation):\n  - shapes do no longer have to be convex\n  - union/intersect/subtract is supported\n  - expand / contract are supported\n\nBut we'll keep CSG.Polygon2D as a stub for backwards compatibility\n*/\nfunction Polygon2D(points) {\n  const cag = fromPoints(points);\n  this.sides = cag.sides;\n}\n\nPolygon2D.prototype = CAG.prototype;\n\nmodule.exports = Polygon2D;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1BvbHlnb24yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvbWF0aC9Qb2x5Z29uMi5qcz84NWIyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENBRyA9IHJlcXVpcmUoJy4uL0NBRycpO1xuY29uc3QgeyBmcm9tUG9pbnRzIH0gPSByZXF1aXJlKCcuLi9DQUdGYWN0b3JpZXMnKTtcblxuLypcbjJEIHBvbHlnb25zIGFyZSBub3cgc3VwcG9ydGVkIHRocm91Z2ggdGhlIENBRyBjbGFzcy5cbldpdGggbWFueSBpbXByb3ZlbWVudHMgKHNlZSBkb2N1bWVudGF0aW9uKTpcbiAgLSBzaGFwZXMgZG8gbm8gbG9uZ2VyIGhhdmUgdG8gYmUgY29udmV4XG4gIC0gdW5pb24vaW50ZXJzZWN0L3N1YnRyYWN0IGlzIHN1cHBvcnRlZFxuICAtIGV4cGFuZCAvIGNvbnRyYWN0IGFyZSBzdXBwb3J0ZWRcblxuQnV0IHdlJ2xsIGtlZXAgQ1NHLlBvbHlnb24yRCBhcyBhIHN0dWIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4qL1xuZnVuY3Rpb24gUG9seWdvbjJEKHBvaW50cykge1xuICBjb25zdCBjYWcgPSBmcm9tUG9pbnRzKHBvaW50cyk7XG4gIHRoaXMuc2lkZXMgPSBjYWcuc2lkZXM7XG59XG5cblBvbHlnb24yRC5wcm90b3R5cGUgPSBDQUcucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb24yRDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/Polygon2.js\n");

/***/ }),

/***/ "./src/core/math/Polygon3.js":
/*!***********************************!*\
  !*** ./src/core/math/Polygon3.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ./Vector3 */ \"./src/core/math/Vector3.js\");\nconst Vertex = __webpack_require__(/*! ./Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Matrix4x4 = __webpack_require__(/*! ./Matrix4 */ \"./src/core/math/Matrix4.js\");\nconst { _CSGDEBUG, EPS, getTag, areaEPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\n\n/** Class Polygon\n * Represents a convex polygon. The vertices used to initialize a polygon must\n *   be coplanar and form a convex loop. They do not have to be `Vertex`\n *   instances but they must behave similarly (duck typing can be used for\n *   customization).\n * <br>\n * Each convex polygon has a `shared` property, which is shared between all\n *   polygons that are clones of each other or were split from the same polygon.\n *   This can be used to define per-polygon properties (such as surface color).\n * <br>\n * The plane of the polygon is calculated from the vertex coordinates if not provided.\n *   The plane can alternatively be passed as the third argument to avoid calculations.\n *\n * @constructor\n * @param {Vertex[]} vertices - list of vertices\n * @param {Polygon.Shared} [shared=defaultShared] - shared property to apply\n * @param {Plane} [plane] - plane of the polygon\n *\n * @example\n * const vertices = [\n *   new CSG.Vertex(new CSG.Vector3D([0, 0, 0])),\n *   new CSG.Vertex(new CSG.Vector3D([0, 10, 0])),\n *   new CSG.Vertex(new CSG.Vector3D([0, 10, 10]))\n * ]\n * let observed = new Polygon(vertices)\n */\nlet Polygon = function (vertices, shared, plane) {\n  this.vertices = vertices;\n  if (!shared) shared = Polygon.defaultShared;\n  this.shared = shared;\n  // let numvertices = vertices.length;\n\n  if (arguments.length >= 3) {\n    this.plane = plane;\n  } else {\n    const Plane = __webpack_require__(/*! ./Plane */ \"./src/core/math/Plane.js\"); // FIXME: circular dependencies\n    this.plane = Plane.fromVector3Ds(\n      vertices[0].pos,\n      vertices[1].pos,\n      vertices[2].pos\n    );\n  }\n\n  if (_CSGDEBUG) {\n    if (!this.checkIfConvex()) {\n      throw new Error('Not convex!');\n    }\n  }\n};\n\nPolygon.prototype = {\n  /** Check whether the polygon is convex. (it should be, otherwise we will get unexpected results)\n   * @returns {boolean}\n   */\n  checkIfConvex: function () {\n    return Polygon.verticesConvex(this.vertices, this.plane.normal);\n  },\n\n  // FIXME what? why does this return this, and not a new polygon?\n  // FIXME is this used?\n  setColor: function (args) {\n    let newshared = Polygon.Shared.fromColor.apply(this, arguments);\n    this.shared = newshared;\n    return this;\n  },\n\n  getSignedVolume: function () {\n    let signedVolume = 0;\n    for (let i = 0; i < this.vertices.length - 2; i++) {\n      signedVolume += this.vertices[0].pos.dot(\n        this.vertices[i + 1].pos.cross(this.vertices[i + 2].pos)\n      );\n    }\n    signedVolume /= 6;\n    return signedVolume;\n  },\n\n  // Note: could calculate vectors only once to speed up\n  getArea: function () {\n    let polygonArea = 0;\n    for (let i = 0; i < this.vertices.length - 2; i++) {\n      polygonArea += this.vertices[i + 1].pos\n        .minus(this.vertices[0].pos)\n        .cross(this.vertices[i + 2].pos.minus(this.vertices[i + 1].pos))\n        .length();\n    }\n    polygonArea /= 2;\n    return polygonArea;\n  },\n\n  // accepts array of features to calculate\n  // returns array of results\n  getTetraFeatures: function (features) {\n    let result = [];\n    features.forEach(function (feature) {\n      if (feature === 'volume') {\n        result.push(this.getSignedVolume());\n      } else if (feature === 'area') {\n        result.push(this.getArea());\n      }\n    }, this);\n    return result;\n  },\n\n  // Extrude a polygon into the direction offsetvector\n  // Returns a CSG object\n  extrude: function (offsetvector) {\n    const { fromPolygons } = __webpack_require__(/*! ../CSGFactories */ \"./src/core/CSGFactories.js\"); // because of circular dependencies\n\n    let newpolygons = [];\n\n    let polygon1 = this;\n    let direction = polygon1.plane.normal.dot(offsetvector);\n    if (direction > 0) {\n      polygon1 = polygon1.flipped();\n    }\n    newpolygons.push(polygon1);\n    let polygon2 = polygon1.translate(offsetvector);\n    let numvertices = this.vertices.length;\n    for (let i = 0; i < numvertices; i++) {\n      let sidefacepoints = [];\n      let nexti = i < numvertices - 1 ? i + 1 : 0;\n      sidefacepoints.push(polygon1.vertices[i].pos);\n      sidefacepoints.push(polygon2.vertices[i].pos);\n      sidefacepoints.push(polygon2.vertices[nexti].pos);\n      sidefacepoints.push(polygon1.vertices[nexti].pos);\n      let sidefacepolygon = Polygon.createFromPoints(\n        sidefacepoints,\n        this.shared\n      );\n      newpolygons.push(sidefacepolygon);\n    }\n    polygon2 = polygon2.flipped();\n    newpolygons.push(polygon2);\n    return fromPolygons(newpolygons);\n  },\n\n  translate: function (offset) {\n    return this.transform(Matrix4x4.translation(offset));\n  },\n\n  // returns an array with a Vector3D (center point) and a radius\n  boundingSphere: function () {\n    if (!this.cachedBoundingSphere) {\n      let box = this.boundingBox();\n      let middle = box[0].plus(box[1]).times(0.5);\n      let radius3 = box[1].minus(middle);\n      let radius = radius3.length();\n      this.cachedBoundingSphere = [middle, radius];\n    }\n    return this.cachedBoundingSphere;\n  },\n\n  // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)\n  boundingBox: function () {\n    if (!this.cachedBoundingBox) {\n      let minpoint, maxpoint;\n      let vertices = this.vertices;\n      let numvertices = vertices.length;\n      if (numvertices === 0) {\n        minpoint = new Vector3D(0, 0, 0);\n      } else {\n        minpoint = vertices[0].pos;\n      }\n      maxpoint = minpoint;\n      for (let i = 1; i < numvertices; i++) {\n        let point = vertices[i].pos;\n        minpoint = minpoint.min(point);\n        maxpoint = maxpoint.max(point);\n      }\n      this.cachedBoundingBox = [minpoint, maxpoint];\n    }\n    return this.cachedBoundingBox;\n  },\n\n  flipped: function () {\n    let newvertices = this.vertices.map(function (v) {\n      return v.flipped();\n    });\n    newvertices.reverse();\n    let newplane = this.plane.flipped();\n    return new Polygon(newvertices, this.shared, newplane);\n  },\n\n  // Affine transformation of polygon. Returns a new Polygon\n  transform: function (matrix4x4) {\n    let newvertices = this.vertices.map(function (v) {\n      return v.transform(matrix4x4);\n    });\n    let newplane = this.plane.transform(matrix4x4);\n    if (matrix4x4.isMirroring()) {\n      // need to reverse the vertex order\n      // in order to preserve the inside/outside orientation:\n      newvertices.reverse();\n    }\n    return new Polygon(newvertices, this.shared, newplane);\n  },\n\n  toString: function () {\n    let result = 'Polygon plane: ' + this.plane.toString() + '\\n';\n    this.vertices.map(function (vertex) {\n      result += '  ' + vertex.toString() + '\\n';\n    });\n    return result;\n  },\n\n  // project the 3D polygon onto a plane\n  projectToOrthoNormalBasis: function (orthobasis) {\n    const CAG = __webpack_require__(/*! ../CAG */ \"./src/core/CAG.js\");\n    const { fromPointsNoCheck } = __webpack_require__(/*! ../CAGFactories */ \"./src/core/CAGFactories.js\"); // circular dependencies\n    let points2d = this.vertices.map(function (vertex) {\n      return orthobasis.to2D(vertex.pos);\n    });\n\n    let result = fromPointsNoCheck(points2d);\n    let area = result.area();\n    if (Math.abs(area) < areaEPS) {\n      // the polygon was perpendicular to the orthnormal plane. The resulting 2D polygon would be degenerate\n      // return an empty area instead:\n      result = new CAG();\n    } else if (area < 0) {\n      result = result.flipped();\n    }\n    return result;\n  },\n\n  // ALIAS ONLY!!\n  solidFromSlices: function (options) {\n    const solidFromSlices = __webpack_require__(/*! ../../api/solidFromSlices */ \"./src/api/solidFromSlices.js\");\n    return solidFromSlices(this, options);\n  },\n};\n\n// create from an untyped object with identical property names:\nPolygon.fromObject = function (obj) {\n  const Plane = __webpack_require__(/*! ./Plane */ \"./src/core/math/Plane.js\"); // FIXME: circular dependencies\n  let vertices = obj.vertices.map(function (v) {\n    return Vertex.fromObject(v);\n  });\n  let shared = Polygon.Shared.fromObject(obj.shared);\n  let plane = Plane.fromObject(obj.plane);\n  return new Polygon(vertices, shared, plane);\n};\n\n/** Create a polygon from the given points.\n *\n * @param {Array[]} points - list of points\n * @param {Polygon.Shared} [shared=defaultShared] - shared property to apply\n * @param {Plane} [plane] - plane of the polygon\n *\n * @example\n * const points = [\n *   [0,  0, 0],\n *   [0, 10, 0],\n *   [0, 10, 10]\n * ]\n * let observed = CSG.Polygon.createFromPoints(points)\n */\nPolygon.createFromPoints = function (points, shared, plane) {\n  // FIXME : this circular dependency does not work !\n  // const {fromPoints} = require('./polygon3Factories')\n  // return fromPoints(points, shared, plane)\n  let vertices = [];\n  points.map(function (p) {\n    let vec = new Vector3D(p);\n    let vertex = new Vertex(vec);\n    vertices.push(vertex);\n  });\n  let polygon;\n  if (arguments.length < 3) {\n    polygon = new Polygon(vertices, shared);\n  } else {\n    polygon = new Polygon(vertices, shared, plane);\n  }\n  return polygon;\n};\n\nPolygon.verticesConvex = function (vertices, planenormal) {\n  let numvertices = vertices.length;\n  if (numvertices > 2) {\n    let prevprevpos = vertices[numvertices - 2].pos;\n    let prevpos = vertices[numvertices - 1].pos;\n    for (let i = 0; i < numvertices; i++) {\n      let pos = vertices[i].pos;\n      if (!Polygon.isConvexPoint(prevprevpos, prevpos, pos, planenormal)) {\n        return false;\n      }\n      prevprevpos = prevpos;\n      prevpos = pos;\n    }\n  }\n  return true;\n};\n\n// calculate whether three points form a convex corner\n//  prevpoint, point, nextpoint: the 3 coordinates (Vector3D instances)\n//  normal: the normal vector of the plane\nPolygon.isConvexPoint = function (prevpoint, point, nextpoint, normal) {\n  let crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));\n  let crossdotnormal = crossproduct.dot(normal);\n  return crossdotnormal >= 0;\n};\n\nPolygon.isStrictlyConvexPoint = function (prevpoint, point, nextpoint, normal) {\n  let crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));\n  let crossdotnormal = crossproduct.dot(normal);\n  return crossdotnormal >= EPS;\n};\n\n/** Class Polygon.Shared\n * Holds the shared properties for each polygon (Currently only color).\n * @constructor\n * @param {Array[]} color - array containing RGBA values, or null\n *\n * @example\n *   let shared = new CSG.Polygon.Shared([0, 0, 0, 1])\n */\nPolygon.Shared = function (color) {\n  if (color !== null && color !== undefined) {\n    if (color.length !== 4) {\n      throw new Error('Expecting 4 element array');\n    }\n  }\n  this.color = color;\n};\n\nPolygon.Shared.fromObject = function (obj) {\n  return new Polygon.Shared(obj.color);\n};\n\n/** Create Polygon.Shared from color values.\n * @param {number} r - value of RED component\n * @param {number} g - value of GREEN component\n * @param {number} b - value of BLUE component\n * @param {number} [a] - value of ALPHA component\n * @param {Array[]} [color] - OR array containing RGB values (optional Alpha)\n *\n * @example\n * let s1 = Polygon.Shared.fromColor(0,0,0)\n * let s2 = Polygon.Shared.fromColor([0,0,0,1])\n */\nPolygon.Shared.fromColor = function (args) {\n  let color;\n  if (arguments.length === 1) {\n    color = arguments[0].slice(); // make deep copy\n  } else {\n    color = [];\n    for (let i = 0; i < arguments.length; i++) {\n      color.push(arguments[i]);\n    }\n  }\n  if (color.length === 3) {\n    color.push(1);\n  } else if (color.length !== 4) {\n    throw new Error(\n      'setColor expects either an array with 3 or 4 elements, or 3 or 4 parameters.'\n    );\n  }\n  return new Polygon.Shared(color);\n};\n\nPolygon.Shared.prototype = {\n  getTag: function () {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n  // get a string uniquely identifying this object\n  getHash: function () {\n    if (!this.color) return 'null';\n    return this.color.join('/');\n  },\n};\n\nPolygon.defaultShared = new Polygon.Shared(null);\n\nmodule.exports = Polygon;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1BvbHlnb24zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvbWF0aC9Qb2x5Z29uMy5qcz80MzVhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlY3RvcjNEID0gcmVxdWlyZSgnLi9WZWN0b3IzJyk7XG5jb25zdCBWZXJ0ZXggPSByZXF1aXJlKCcuL1ZlcnRleDMnKTtcbmNvbnN0IE1hdHJpeDR4NCA9IHJlcXVpcmUoJy4vTWF0cml4NCcpO1xuY29uc3QgeyBfQ1NHREVCVUcsIEVQUywgZ2V0VGFnLCBhcmVhRVBTIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxuLyoqIENsYXNzIFBvbHlnb25cbiAqIFJlcHJlc2VudHMgYSBjb252ZXggcG9seWdvbi4gVGhlIHZlcnRpY2VzIHVzZWQgdG8gaW5pdGlhbGl6ZSBhIHBvbHlnb24gbXVzdFxuICogICBiZSBjb3BsYW5hciBhbmQgZm9ybSBhIGNvbnZleCBsb29wLiBUaGV5IGRvIG5vdCBoYXZlIHRvIGJlIGBWZXJ0ZXhgXG4gKiAgIGluc3RhbmNlcyBidXQgdGhleSBtdXN0IGJlaGF2ZSBzaW1pbGFybHkgKGR1Y2sgdHlwaW5nIGNhbiBiZSB1c2VkIGZvclxuICogICBjdXN0b21pemF0aW9uKS5cbiAqIDxicj5cbiAqIEVhY2ggY29udmV4IHBvbHlnb24gaGFzIGEgYHNoYXJlZGAgcHJvcGVydHksIHdoaWNoIGlzIHNoYXJlZCBiZXR3ZWVuIGFsbFxuICogICBwb2x5Z29ucyB0aGF0IGFyZSBjbG9uZXMgb2YgZWFjaCBvdGhlciBvciB3ZXJlIHNwbGl0IGZyb20gdGhlIHNhbWUgcG9seWdvbi5cbiAqICAgVGhpcyBjYW4gYmUgdXNlZCB0byBkZWZpbmUgcGVyLXBvbHlnb24gcHJvcGVydGllcyAoc3VjaCBhcyBzdXJmYWNlIGNvbG9yKS5cbiAqIDxicj5cbiAqIFRoZSBwbGFuZSBvZiB0aGUgcG9seWdvbiBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIHZlcnRleCBjb29yZGluYXRlcyBpZiBub3QgcHJvdmlkZWQuXG4gKiAgIFRoZSBwbGFuZSBjYW4gYWx0ZXJuYXRpdmVseSBiZSBwYXNzZWQgYXMgdGhlIHRoaXJkIGFyZ3VtZW50IHRvIGF2b2lkIGNhbGN1bGF0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VmVydGV4W119IHZlcnRpY2VzIC0gbGlzdCBvZiB2ZXJ0aWNlc1xuICogQHBhcmFtIHtQb2x5Z29uLlNoYXJlZH0gW3NoYXJlZD1kZWZhdWx0U2hhcmVkXSAtIHNoYXJlZCBwcm9wZXJ0eSB0byBhcHBseVxuICogQHBhcmFtIHtQbGFuZX0gW3BsYW5lXSAtIHBsYW5lIG9mIHRoZSBwb2x5Z29uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHZlcnRpY2VzID0gW1xuICogICBuZXcgQ1NHLlZlcnRleChuZXcgQ1NHLlZlY3RvcjNEKFswLCAwLCAwXSkpLFxuICogICBuZXcgQ1NHLlZlcnRleChuZXcgQ1NHLlZlY3RvcjNEKFswLCAxMCwgMF0pKSxcbiAqICAgbmV3IENTRy5WZXJ0ZXgobmV3IENTRy5WZWN0b3IzRChbMCwgMTAsIDEwXSkpXG4gKiBdXG4gKiBsZXQgb2JzZXJ2ZWQgPSBuZXcgUG9seWdvbih2ZXJ0aWNlcylcbiAqL1xubGV0IFBvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMsIHNoYXJlZCwgcGxhbmUpIHtcbiAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICBpZiAoIXNoYXJlZCkgc2hhcmVkID0gUG9seWdvbi5kZWZhdWx0U2hhcmVkO1xuICB0aGlzLnNoYXJlZCA9IHNoYXJlZDtcbiAgLy8gbGV0IG51bXZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICB0aGlzLnBsYW5lID0gcGxhbmU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgUGxhbmUgPSByZXF1aXJlKCcuL1BsYW5lJyk7IC8vIEZJWE1FOiBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAgICB0aGlzLnBsYW5lID0gUGxhbmUuZnJvbVZlY3RvcjNEcyhcbiAgICAgIHZlcnRpY2VzWzBdLnBvcyxcbiAgICAgIHZlcnRpY2VzWzFdLnBvcyxcbiAgICAgIHZlcnRpY2VzWzJdLnBvc1xuICAgICk7XG4gIH1cblxuICBpZiAoX0NTR0RFQlVHKSB7XG4gICAgaWYgKCF0aGlzLmNoZWNrSWZDb252ZXgoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29udmV4IScpO1xuICAgIH1cbiAgfVxufTtcblxuUG9seWdvbi5wcm90b3R5cGUgPSB7XG4gIC8qKiBDaGVjayB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGNvbnZleC4gKGl0IHNob3VsZCBiZSwgb3RoZXJ3aXNlIHdlIHdpbGwgZ2V0IHVuZXhwZWN0ZWQgcmVzdWx0cylcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja0lmQ29udmV4OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBvbHlnb24udmVydGljZXNDb252ZXgodGhpcy52ZXJ0aWNlcywgdGhpcy5wbGFuZS5ub3JtYWwpO1xuICB9LFxuXG4gIC8vIEZJWE1FIHdoYXQ/IHdoeSBkb2VzIHRoaXMgcmV0dXJuIHRoaXMsIGFuZCBub3QgYSBuZXcgcG9seWdvbj9cbiAgLy8gRklYTUUgaXMgdGhpcyB1c2VkP1xuICBzZXRDb2xvcjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBsZXQgbmV3c2hhcmVkID0gUG9seWdvbi5TaGFyZWQuZnJvbUNvbG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaGFyZWQgPSBuZXdzaGFyZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZ2V0U2lnbmVkVm9sdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHNpZ25lZFZvbHVtZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgc2lnbmVkVm9sdW1lICs9IHRoaXMudmVydGljZXNbMF0ucG9zLmRvdChcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1tpICsgMV0ucG9zLmNyb3NzKHRoaXMudmVydGljZXNbaSArIDJdLnBvcylcbiAgICAgICk7XG4gICAgfVxuICAgIHNpZ25lZFZvbHVtZSAvPSA2O1xuICAgIHJldHVybiBzaWduZWRWb2x1bWU7XG4gIH0sXG5cbiAgLy8gTm90ZTogY291bGQgY2FsY3VsYXRlIHZlY3RvcnMgb25seSBvbmNlIHRvIHNwZWVkIHVwXG4gIGdldEFyZWE6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcG9seWdvbkFyZWEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgIHBvbHlnb25BcmVhICs9IHRoaXMudmVydGljZXNbaSArIDFdLnBvc1xuICAgICAgICAubWludXModGhpcy52ZXJ0aWNlc1swXS5wb3MpXG4gICAgICAgIC5jcm9zcyh0aGlzLnZlcnRpY2VzW2kgKyAyXS5wb3MubWludXModGhpcy52ZXJ0aWNlc1tpICsgMV0ucG9zKSlcbiAgICAgICAgLmxlbmd0aCgpO1xuICAgIH1cbiAgICBwb2x5Z29uQXJlYSAvPSAyO1xuICAgIHJldHVybiBwb2x5Z29uQXJlYTtcbiAgfSxcblxuICAvLyBhY2NlcHRzIGFycmF5IG9mIGZlYXR1cmVzIHRvIGNhbGN1bGF0ZVxuICAvLyByZXR1cm5zIGFycmF5IG9mIHJlc3VsdHNcbiAgZ2V0VGV0cmFGZWF0dXJlczogZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgIGlmIChmZWF0dXJlID09PSAndm9sdW1lJykge1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdldFNpZ25lZFZvbHVtZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ2FyZWEnKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2V0QXJlYSgpKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8vIEV4dHJ1ZGUgYSBwb2x5Z29uIGludG8gdGhlIGRpcmVjdGlvbiBvZmZzZXR2ZWN0b3JcbiAgLy8gUmV0dXJucyBhIENTRyBvYmplY3RcbiAgZXh0cnVkZTogZnVuY3Rpb24gKG9mZnNldHZlY3Rvcikge1xuICAgIGNvbnN0IHsgZnJvbVBvbHlnb25zIH0gPSByZXF1aXJlKCcuLi9DU0dGYWN0b3JpZXMnKTsgLy8gYmVjYXVzZSBvZiBjaXJjdWxhciBkZXBlbmRlbmNpZXNcblxuICAgIGxldCBuZXdwb2x5Z29ucyA9IFtdO1xuXG4gICAgbGV0IHBvbHlnb24xID0gdGhpcztcbiAgICBsZXQgZGlyZWN0aW9uID0gcG9seWdvbjEucGxhbmUubm9ybWFsLmRvdChvZmZzZXR2ZWN0b3IpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBwb2x5Z29uMSA9IHBvbHlnb24xLmZsaXBwZWQoKTtcbiAgICB9XG4gICAgbmV3cG9seWdvbnMucHVzaChwb2x5Z29uMSk7XG4gICAgbGV0IHBvbHlnb24yID0gcG9seWdvbjEudHJhbnNsYXRlKG9mZnNldHZlY3Rvcik7XG4gICAgbGV0IG51bXZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW12ZXJ0aWNlczsgaSsrKSB7XG4gICAgICBsZXQgc2lkZWZhY2Vwb2ludHMgPSBbXTtcbiAgICAgIGxldCBuZXh0aSA9IGkgPCBudW12ZXJ0aWNlcyAtIDEgPyBpICsgMSA6IDA7XG4gICAgICBzaWRlZmFjZXBvaW50cy5wdXNoKHBvbHlnb24xLnZlcnRpY2VzW2ldLnBvcyk7XG4gICAgICBzaWRlZmFjZXBvaW50cy5wdXNoKHBvbHlnb24yLnZlcnRpY2VzW2ldLnBvcyk7XG4gICAgICBzaWRlZmFjZXBvaW50cy5wdXNoKHBvbHlnb24yLnZlcnRpY2VzW25leHRpXS5wb3MpO1xuICAgICAgc2lkZWZhY2Vwb2ludHMucHVzaChwb2x5Z29uMS52ZXJ0aWNlc1tuZXh0aV0ucG9zKTtcbiAgICAgIGxldCBzaWRlZmFjZXBvbHlnb24gPSBQb2x5Z29uLmNyZWF0ZUZyb21Qb2ludHMoXG4gICAgICAgIHNpZGVmYWNlcG9pbnRzLFxuICAgICAgICB0aGlzLnNoYXJlZFxuICAgICAgKTtcbiAgICAgIG5ld3BvbHlnb25zLnB1c2goc2lkZWZhY2Vwb2x5Z29uKTtcbiAgICB9XG4gICAgcG9seWdvbjIgPSBwb2x5Z29uMi5mbGlwcGVkKCk7XG4gICAgbmV3cG9seWdvbnMucHVzaChwb2x5Z29uMik7XG4gICAgcmV0dXJuIGZyb21Qb2x5Z29ucyhuZXdwb2x5Z29ucyk7XG4gIH0sXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC50cmFuc2xhdGlvbihvZmZzZXQpKTtcbiAgfSxcblxuICAvLyByZXR1cm5zIGFuIGFycmF5IHdpdGggYSBWZWN0b3IzRCAoY2VudGVyIHBvaW50KSBhbmQgYSByYWRpdXNcbiAgYm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY2FjaGVkQm91bmRpbmdTcGhlcmUpIHtcbiAgICAgIGxldCBib3ggPSB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICBsZXQgbWlkZGxlID0gYm94WzBdLnBsdXMoYm94WzFdKS50aW1lcygwLjUpO1xuICAgICAgbGV0IHJhZGl1czMgPSBib3hbMV0ubWludXMobWlkZGxlKTtcbiAgICAgIGxldCByYWRpdXMgPSByYWRpdXMzLmxlbmd0aCgpO1xuICAgICAgdGhpcy5jYWNoZWRCb3VuZGluZ1NwaGVyZSA9IFttaWRkbGUsIHJhZGl1c107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlZEJvdW5kaW5nU3BoZXJlO1xuICB9LFxuXG4gIC8vIHJldHVybnMgYW4gYXJyYXkgb2YgdHdvIFZlY3RvcjNEcyAobWluaW11bSBjb29yZGluYXRlcyBhbmQgbWF4aW11bSBjb29yZGluYXRlcylcbiAgYm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY2FjaGVkQm91bmRpbmdCb3gpIHtcbiAgICAgIGxldCBtaW5wb2ludCwgbWF4cG9pbnQ7XG4gICAgICBsZXQgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgbGV0IG51bXZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgaWYgKG51bXZlcnRpY2VzID09PSAwKSB7XG4gICAgICAgIG1pbnBvaW50ID0gbmV3IFZlY3RvcjNEKDAsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlucG9pbnQgPSB2ZXJ0aWNlc1swXS5wb3M7XG4gICAgICB9XG4gICAgICBtYXhwb2ludCA9IG1pbnBvaW50O1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW12ZXJ0aWNlczsgaSsrKSB7XG4gICAgICAgIGxldCBwb2ludCA9IHZlcnRpY2VzW2ldLnBvcztcbiAgICAgICAgbWlucG9pbnQgPSBtaW5wb2ludC5taW4ocG9pbnQpO1xuICAgICAgICBtYXhwb2ludCA9IG1heHBvaW50Lm1heChwb2ludCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlZEJvdW5kaW5nQm94ID0gW21pbnBvaW50LCBtYXhwb2ludF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlZEJvdW5kaW5nQm94O1xuICB9LFxuXG4gIGZsaXBwZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgbmV3dmVydGljZXMgPSB0aGlzLnZlcnRpY2VzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYuZmxpcHBlZCgpO1xuICAgIH0pO1xuICAgIG5ld3ZlcnRpY2VzLnJldmVyc2UoKTtcbiAgICBsZXQgbmV3cGxhbmUgPSB0aGlzLnBsYW5lLmZsaXBwZWQoKTtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24obmV3dmVydGljZXMsIHRoaXMuc2hhcmVkLCBuZXdwbGFuZSk7XG4gIH0sXG5cbiAgLy8gQWZmaW5lIHRyYW5zZm9ybWF0aW9uIG9mIHBvbHlnb24uIFJldHVybnMgYSBuZXcgUG9seWdvblxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICBsZXQgbmV3dmVydGljZXMgPSB0aGlzLnZlcnRpY2VzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYudHJhbnNmb3JtKG1hdHJpeDR4NCk7XG4gICAgfSk7XG4gICAgbGV0IG5ld3BsYW5lID0gdGhpcy5wbGFuZS50cmFuc2Zvcm0obWF0cml4NHg0KTtcbiAgICBpZiAobWF0cml4NHg0LmlzTWlycm9yaW5nKCkpIHtcbiAgICAgIC8vIG5lZWQgdG8gcmV2ZXJzZSB0aGUgdmVydGV4IG9yZGVyXG4gICAgICAvLyBpbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgaW5zaWRlL291dHNpZGUgb3JpZW50YXRpb246XG4gICAgICBuZXd2ZXJ0aWNlcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9seWdvbihuZXd2ZXJ0aWNlcywgdGhpcy5zaGFyZWQsIG5ld3BsYW5lKTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIGxldCByZXN1bHQgPSAnUG9seWdvbiBwbGFuZTogJyArIHRoaXMucGxhbmUudG9TdHJpbmcoKSArICdcXG4nO1xuICAgIHRoaXMudmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgIHJlc3VsdCArPSAnICAnICsgdmVydGV4LnRvU3RyaW5nKCkgKyAnXFxuJztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8vIHByb2plY3QgdGhlIDNEIHBvbHlnb24gb250byBhIHBsYW5lXG4gIHByb2plY3RUb09ydGhvTm9ybWFsQmFzaXM6IGZ1bmN0aW9uIChvcnRob2Jhc2lzKSB7XG4gICAgY29uc3QgQ0FHID0gcmVxdWlyZSgnLi4vQ0FHJyk7XG4gICAgY29uc3QgeyBmcm9tUG9pbnRzTm9DaGVjayB9ID0gcmVxdWlyZSgnLi4vQ0FHRmFjdG9yaWVzJyk7IC8vIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICAgIGxldCBwb2ludHMyZCA9IHRoaXMudmVydGljZXMubWFwKGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgIHJldHVybiBvcnRob2Jhc2lzLnRvMkQodmVydGV4LnBvcyk7XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzdWx0ID0gZnJvbVBvaW50c05vQ2hlY2socG9pbnRzMmQpO1xuICAgIGxldCBhcmVhID0gcmVzdWx0LmFyZWEoKTtcbiAgICBpZiAoTWF0aC5hYnMoYXJlYSkgPCBhcmVhRVBTKSB7XG4gICAgICAvLyB0aGUgcG9seWdvbiB3YXMgcGVycGVuZGljdWxhciB0byB0aGUgb3J0aG5vcm1hbCBwbGFuZS4gVGhlIHJlc3VsdGluZyAyRCBwb2x5Z29uIHdvdWxkIGJlIGRlZ2VuZXJhdGVcbiAgICAgIC8vIHJldHVybiBhbiBlbXB0eSBhcmVhIGluc3RlYWQ6XG4gICAgICByZXN1bHQgPSBuZXcgQ0FHKCk7XG4gICAgfSBlbHNlIGlmIChhcmVhIDwgMCkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZsaXBwZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvLyBBTElBUyBPTkxZISFcbiAgc29saWRGcm9tU2xpY2VzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGNvbnN0IHNvbGlkRnJvbVNsaWNlcyA9IHJlcXVpcmUoJy4uLy4uL2FwaS9zb2xpZEZyb21TbGljZXMnKTtcbiAgICByZXR1cm4gc29saWRGcm9tU2xpY2VzKHRoaXMsIG9wdGlvbnMpO1xuICB9LFxufTtcblxuLy8gY3JlYXRlIGZyb20gYW4gdW50eXBlZCBvYmplY3Qgd2l0aCBpZGVudGljYWwgcHJvcGVydHkgbmFtZXM6XG5Qb2x5Z29uLmZyb21PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGNvbnN0IFBsYW5lID0gcmVxdWlyZSgnLi9QbGFuZScpOyAvLyBGSVhNRTogY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gIGxldCB2ZXJ0aWNlcyA9IG9iai52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gVmVydGV4LmZyb21PYmplY3Qodik7XG4gIH0pO1xuICBsZXQgc2hhcmVkID0gUG9seWdvbi5TaGFyZWQuZnJvbU9iamVjdChvYmouc2hhcmVkKTtcbiAgbGV0IHBsYW5lID0gUGxhbmUuZnJvbU9iamVjdChvYmoucGxhbmUpO1xuICByZXR1cm4gbmV3IFBvbHlnb24odmVydGljZXMsIHNoYXJlZCwgcGxhbmUpO1xufTtcblxuLyoqIENyZWF0ZSBhIHBvbHlnb24gZnJvbSB0aGUgZ2l2ZW4gcG9pbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXlbXX0gcG9pbnRzIC0gbGlzdCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7UG9seWdvbi5TaGFyZWR9IFtzaGFyZWQ9ZGVmYXVsdFNoYXJlZF0gLSBzaGFyZWQgcHJvcGVydHkgdG8gYXBwbHlcbiAqIEBwYXJhbSB7UGxhbmV9IFtwbGFuZV0gLSBwbGFuZSBvZiB0aGUgcG9seWdvblxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBwb2ludHMgPSBbXG4gKiAgIFswLCAgMCwgMF0sXG4gKiAgIFswLCAxMCwgMF0sXG4gKiAgIFswLCAxMCwgMTBdXG4gKiBdXG4gKiBsZXQgb2JzZXJ2ZWQgPSBDU0cuUG9seWdvbi5jcmVhdGVGcm9tUG9pbnRzKHBvaW50cylcbiAqL1xuUG9seWdvbi5jcmVhdGVGcm9tUG9pbnRzID0gZnVuY3Rpb24gKHBvaW50cywgc2hhcmVkLCBwbGFuZSkge1xuICAvLyBGSVhNRSA6IHRoaXMgY2lyY3VsYXIgZGVwZW5kZW5jeSBkb2VzIG5vdCB3b3JrICFcbiAgLy8gY29uc3Qge2Zyb21Qb2ludHN9ID0gcmVxdWlyZSgnLi9wb2x5Z29uM0ZhY3RvcmllcycpXG4gIC8vIHJldHVybiBmcm9tUG9pbnRzKHBvaW50cywgc2hhcmVkLCBwbGFuZSlcbiAgbGV0IHZlcnRpY2VzID0gW107XG4gIHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICBsZXQgdmVjID0gbmV3IFZlY3RvcjNEKHApO1xuICAgIGxldCB2ZXJ0ZXggPSBuZXcgVmVydGV4KHZlYyk7XG4gICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuICB9KTtcbiAgbGV0IHBvbHlnb247XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHBvbHlnb24gPSBuZXcgUG9seWdvbih2ZXJ0aWNlcywgc2hhcmVkKTtcbiAgfSBlbHNlIHtcbiAgICBwb2x5Z29uID0gbmV3IFBvbHlnb24odmVydGljZXMsIHNoYXJlZCwgcGxhbmUpO1xuICB9XG4gIHJldHVybiBwb2x5Z29uO1xufTtcblxuUG9seWdvbi52ZXJ0aWNlc0NvbnZleCA9IGZ1bmN0aW9uICh2ZXJ0aWNlcywgcGxhbmVub3JtYWwpIHtcbiAgbGV0IG51bXZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuICBpZiAobnVtdmVydGljZXMgPiAyKSB7XG4gICAgbGV0IHByZXZwcmV2cG9zID0gdmVydGljZXNbbnVtdmVydGljZXMgLSAyXS5wb3M7XG4gICAgbGV0IHByZXZwb3MgPSB2ZXJ0aWNlc1tudW12ZXJ0aWNlcyAtIDFdLnBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXZlcnRpY2VzOyBpKyspIHtcbiAgICAgIGxldCBwb3MgPSB2ZXJ0aWNlc1tpXS5wb3M7XG4gICAgICBpZiAoIVBvbHlnb24uaXNDb252ZXhQb2ludChwcmV2cHJldnBvcywgcHJldnBvcywgcG9zLCBwbGFuZW5vcm1hbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcHJldnByZXZwb3MgPSBwcmV2cG9zO1xuICAgICAgcHJldnBvcyA9IHBvcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBjYWxjdWxhdGUgd2hldGhlciB0aHJlZSBwb2ludHMgZm9ybSBhIGNvbnZleCBjb3JuZXJcbi8vICBwcmV2cG9pbnQsIHBvaW50LCBuZXh0cG9pbnQ6IHRoZSAzIGNvb3JkaW5hdGVzIChWZWN0b3IzRCBpbnN0YW5jZXMpXG4vLyAgbm9ybWFsOiB0aGUgbm9ybWFsIHZlY3RvciBvZiB0aGUgcGxhbmVcblBvbHlnb24uaXNDb252ZXhQb2ludCA9IGZ1bmN0aW9uIChwcmV2cG9pbnQsIHBvaW50LCBuZXh0cG9pbnQsIG5vcm1hbCkge1xuICBsZXQgY3Jvc3Nwcm9kdWN0ID0gcG9pbnQubWludXMocHJldnBvaW50KS5jcm9zcyhuZXh0cG9pbnQubWludXMocG9pbnQpKTtcbiAgbGV0IGNyb3NzZG90bm9ybWFsID0gY3Jvc3Nwcm9kdWN0LmRvdChub3JtYWwpO1xuICByZXR1cm4gY3Jvc3Nkb3Rub3JtYWwgPj0gMDtcbn07XG5cblBvbHlnb24uaXNTdHJpY3RseUNvbnZleFBvaW50ID0gZnVuY3Rpb24gKHByZXZwb2ludCwgcG9pbnQsIG5leHRwb2ludCwgbm9ybWFsKSB7XG4gIGxldCBjcm9zc3Byb2R1Y3QgPSBwb2ludC5taW51cyhwcmV2cG9pbnQpLmNyb3NzKG5leHRwb2ludC5taW51cyhwb2ludCkpO1xuICBsZXQgY3Jvc3Nkb3Rub3JtYWwgPSBjcm9zc3Byb2R1Y3QuZG90KG5vcm1hbCk7XG4gIHJldHVybiBjcm9zc2RvdG5vcm1hbCA+PSBFUFM7XG59O1xuXG4vKiogQ2xhc3MgUG9seWdvbi5TaGFyZWRcbiAqIEhvbGRzIHRoZSBzaGFyZWQgcHJvcGVydGllcyBmb3IgZWFjaCBwb2x5Z29uIChDdXJyZW50bHkgb25seSBjb2xvcikuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXlbXX0gY29sb3IgLSBhcnJheSBjb250YWluaW5nIFJHQkEgdmFsdWVzLCBvciBudWxsXG4gKlxuICogQGV4YW1wbGVcbiAqICAgbGV0IHNoYXJlZCA9IG5ldyBDU0cuUG9seWdvbi5TaGFyZWQoWzAsIDAsIDAsIDFdKVxuICovXG5Qb2x5Z29uLlNoYXJlZCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICBpZiAoY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChjb2xvci5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIDQgZWxlbWVudCBhcnJheScpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNvbG9yID0gY29sb3I7XG59O1xuXG5Qb2x5Z29uLlNoYXJlZC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gbmV3IFBvbHlnb24uU2hhcmVkKG9iai5jb2xvcik7XG59O1xuXG4vKiogQ3JlYXRlIFBvbHlnb24uU2hhcmVkIGZyb20gY29sb3IgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHIgLSB2YWx1ZSBvZiBSRUQgY29tcG9uZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZyAtIHZhbHVlIG9mIEdSRUVOIGNvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGIgLSB2YWx1ZSBvZiBCTFVFIGNvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IFthXSAtIHZhbHVlIG9mIEFMUEhBIGNvbXBvbmVudFxuICogQHBhcmFtIHtBcnJheVtdfSBbY29sb3JdIC0gT1IgYXJyYXkgY29udGFpbmluZyBSR0IgdmFsdWVzIChvcHRpb25hbCBBbHBoYSlcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHMxID0gUG9seWdvbi5TaGFyZWQuZnJvbUNvbG9yKDAsMCwwKVxuICogbGV0IHMyID0gUG9seWdvbi5TaGFyZWQuZnJvbUNvbG9yKFswLDAsMCwxXSlcbiAqL1xuUG9seWdvbi5TaGFyZWQuZnJvbUNvbG9yID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgbGV0IGNvbG9yO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbG9yID0gYXJndW1lbnRzWzBdLnNsaWNlKCk7IC8vIG1ha2UgZGVlcCBjb3B5XG4gIH0gZWxzZSB7XG4gICAgY29sb3IgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29sb3IucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgY29sb3IucHVzaCgxKTtcbiAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnc2V0Q29sb3IgZXhwZWN0cyBlaXRoZXIgYW4gYXJyYXkgd2l0aCAzIG9yIDQgZWxlbWVudHMsIG9yIDMgb3IgNCBwYXJhbWV0ZXJzLidcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXcgUG9seWdvbi5TaGFyZWQoY29sb3IpO1xufTtcblxuUG9seWdvbi5TaGFyZWQucHJvdG90eXBlID0ge1xuICBnZXRUYWc6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy50YWc7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IGdldFRhZygpO1xuICAgICAgdGhpcy50YWcgPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIC8vIGdldCBhIHN0cmluZyB1bmlxdWVseSBpZGVudGlmeWluZyB0aGlzIG9iamVjdFxuICBnZXRIYXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbG9yKSByZXR1cm4gJ251bGwnO1xuICAgIHJldHVybiB0aGlzLmNvbG9yLmpvaW4oJy8nKTtcbiAgfSxcbn07XG5cblBvbHlnb24uZGVmYXVsdFNoYXJlZCA9IG5ldyBQb2x5Z29uLlNoYXJlZChudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/Polygon3.js\n");

/***/ }),

/***/ "./src/core/math/Side.js":
/*!*******************************!*\
  !*** ./src/core/math/Side.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\nconst Vertex = __webpack_require__(/*! ./Vertex2 */ \"./src/core/math/Vertex2.js\");\nconst Vertex3 = __webpack_require__(/*! ./Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Polygon = __webpack_require__(/*! ./Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst { getTag } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\n\nconst Side = function (vertex0, vertex1) {\n  if (!(vertex0 instanceof Vertex)) throw new Error('Assertion failed');\n  if (!(vertex1 instanceof Vertex)) throw new Error('Assertion failed');\n  this.vertex0 = vertex0;\n  this.vertex1 = vertex1;\n};\n\nSide.fromObject = function (obj) {\n  var vertex0 = Vertex.fromObject(obj.vertex0);\n  var vertex1 = Vertex.fromObject(obj.vertex1);\n  return new Side(vertex0, vertex1);\n};\n\nSide._fromFakePolygon = function (polygon) {\n  // this can happen based on union, seems to be residuals -\n  // return null and handle in caller\n  if (polygon.vertices.length < 4) {\n    return null;\n  }\n  var vert1Indices = [];\n  var pts2d = polygon.vertices\n    .filter(function (v, i) {\n      if (v.pos.z > 0) {\n        vert1Indices.push(i);\n        return true;\n      }\n      return false;\n    })\n    .map(function (v) {\n      return new Vector2D(v.pos.x, v.pos.y);\n    });\n  if (pts2d.length !== 2) {\n    throw new Error(\n      'Assertion failed: _fromFakePolygon: not enough points found'\n    );\n  }\n  var d = vert1Indices[1] - vert1Indices[0];\n  if (d === 1 || d === 3) {\n    if (d === 1) {\n      pts2d.reverse();\n    }\n  } else {\n    throw new Error(\n      'Assertion failed: _fromFakePolygon: unknown index ordering'\n    );\n  }\n  var result = new Side(new Vertex(pts2d[0]), new Vertex(pts2d[1]));\n  return result;\n};\n\nSide.prototype = {\n  toString: function () {\n    return this.vertex0 + ' -> ' + this.vertex1;\n  },\n\n  toPolygon3D: function (z0, z1) {\n    // console.log(this.vertex0.pos)\n    const vertices = [\n      new Vertex3(this.vertex0.pos.toVector3D(z0)),\n      new Vertex3(this.vertex1.pos.toVector3D(z0)),\n      new Vertex3(this.vertex1.pos.toVector3D(z1)),\n      new Vertex3(this.vertex0.pos.toVector3D(z1)),\n    ];\n    return new Polygon(vertices);\n  },\n\n  transform: function (matrix4x4) {\n    var newp1 = this.vertex0.pos.transform(matrix4x4);\n    var newp2 = this.vertex1.pos.transform(matrix4x4);\n    return new Side(new Vertex(newp1), new Vertex(newp2));\n  },\n\n  flipped: function () {\n    return new Side(this.vertex1, this.vertex0);\n  },\n\n  direction: function () {\n    return this.vertex1.pos.minus(this.vertex0.pos);\n  },\n\n  getTag: function () {\n    var result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n\n  lengthSquared: function () {\n    let x = this.vertex1.pos.x - this.vertex0.pos.x;\n    let y = this.vertex1.pos.y - this.vertex0.pos.y;\n    return x * x + y * y;\n  },\n\n  length: function () {\n    return Math.sqrt(this.lengthSquared());\n  },\n};\n\nmodule.exports = Side;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1NpZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9tYXRoL1NpZGUuanM/ZWM3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4vVmVjdG9yMicpO1xuY29uc3QgVmVydGV4ID0gcmVxdWlyZSgnLi9WZXJ0ZXgyJyk7XG5jb25zdCBWZXJ0ZXgzID0gcmVxdWlyZSgnLi9WZXJ0ZXgzJyk7XG5jb25zdCBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uMycpO1xuY29uc3QgeyBnZXRUYWcgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG5jb25zdCBTaWRlID0gZnVuY3Rpb24gKHZlcnRleDAsIHZlcnRleDEpIHtcbiAgaWYgKCEodmVydGV4MCBpbnN0YW5jZW9mIFZlcnRleCkpIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICBpZiAoISh2ZXJ0ZXgxIGluc3RhbmNlb2YgVmVydGV4KSkgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIHRoaXMudmVydGV4MCA9IHZlcnRleDA7XG4gIHRoaXMudmVydGV4MSA9IHZlcnRleDE7XG59O1xuXG5TaWRlLmZyb21PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciB2ZXJ0ZXgwID0gVmVydGV4LmZyb21PYmplY3Qob2JqLnZlcnRleDApO1xuICB2YXIgdmVydGV4MSA9IFZlcnRleC5mcm9tT2JqZWN0KG9iai52ZXJ0ZXgxKTtcbiAgcmV0dXJuIG5ldyBTaWRlKHZlcnRleDAsIHZlcnRleDEpO1xufTtcblxuU2lkZS5fZnJvbUZha2VQb2x5Z29uID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgLy8gdGhpcyBjYW4gaGFwcGVuIGJhc2VkIG9uIHVuaW9uLCBzZWVtcyB0byBiZSByZXNpZHVhbHMgLVxuICAvLyByZXR1cm4gbnVsbCBhbmQgaGFuZGxlIGluIGNhbGxlclxuICBpZiAocG9seWdvbi52ZXJ0aWNlcy5sZW5ndGggPCA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHZlcnQxSW5kaWNlcyA9IFtdO1xuICB2YXIgcHRzMmQgPSBwb2x5Z29uLnZlcnRpY2VzXG4gICAgLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xuICAgICAgaWYgKHYucG9zLnogPiAwKSB7XG4gICAgICAgIHZlcnQxSW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yMkQodi5wb3MueCwgdi5wb3MueSk7XG4gICAgfSk7XG4gIGlmIChwdHMyZC5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQXNzZXJ0aW9uIGZhaWxlZDogX2Zyb21GYWtlUG9seWdvbjogbm90IGVub3VnaCBwb2ludHMgZm91bmQnXG4gICAgKTtcbiAgfVxuICB2YXIgZCA9IHZlcnQxSW5kaWNlc1sxXSAtIHZlcnQxSW5kaWNlc1swXTtcbiAgaWYgKGQgPT09IDEgfHwgZCA9PT0gMykge1xuICAgIGlmIChkID09PSAxKSB7XG4gICAgICBwdHMyZC5yZXZlcnNlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdBc3NlcnRpb24gZmFpbGVkOiBfZnJvbUZha2VQb2x5Z29uOiB1bmtub3duIGluZGV4IG9yZGVyaW5nJ1xuICAgICk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBTaWRlKG5ldyBWZXJ0ZXgocHRzMmRbMF0pLCBuZXcgVmVydGV4KHB0czJkWzFdKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5TaWRlLnByb3RvdHlwZSA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0ZXgwICsgJyAtPiAnICsgdGhpcy52ZXJ0ZXgxO1xuICB9LFxuXG4gIHRvUG9seWdvbjNEOiBmdW5jdGlvbiAoejAsIHoxKSB7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy52ZXJ0ZXgwLnBvcylcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtcbiAgICAgIG5ldyBWZXJ0ZXgzKHRoaXMudmVydGV4MC5wb3MudG9WZWN0b3IzRCh6MCkpLFxuICAgICAgbmV3IFZlcnRleDModGhpcy52ZXJ0ZXgxLnBvcy50b1ZlY3RvcjNEKHowKSksXG4gICAgICBuZXcgVmVydGV4Myh0aGlzLnZlcnRleDEucG9zLnRvVmVjdG9yM0QoejEpKSxcbiAgICAgIG5ldyBWZXJ0ZXgzKHRoaXMudmVydGV4MC5wb3MudG9WZWN0b3IzRCh6MSkpLFxuICAgIF07XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHZlcnRpY2VzKTtcbiAgfSxcblxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICB2YXIgbmV3cDEgPSB0aGlzLnZlcnRleDAucG9zLnRyYW5zZm9ybShtYXRyaXg0eDQpO1xuICAgIHZhciBuZXdwMiA9IHRoaXMudmVydGV4MS5wb3MudHJhbnNmb3JtKG1hdHJpeDR4NCk7XG4gICAgcmV0dXJuIG5ldyBTaWRlKG5ldyBWZXJ0ZXgobmV3cDEpLCBuZXcgVmVydGV4KG5ld3AyKSk7XG4gIH0sXG5cbiAgZmxpcHBlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU2lkZSh0aGlzLnZlcnRleDEsIHRoaXMudmVydGV4MCk7XG4gIH0sXG5cbiAgZGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVydGV4MS5wb3MubWludXModGhpcy52ZXJ0ZXgwLnBvcyk7XG4gIH0sXG5cbiAgZ2V0VGFnOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudGFnO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBnZXRUYWcoKTtcbiAgICAgIHRoaXMudGFnID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGxlbmd0aFNxdWFyZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgeCA9IHRoaXMudmVydGV4MS5wb3MueCAtIHRoaXMudmVydGV4MC5wb3MueDtcbiAgICBsZXQgeSA9IHRoaXMudmVydGV4MS5wb3MueSAtIHRoaXMudmVydGV4MC5wb3MueTtcbiAgICByZXR1cm4geCAqIHggKyB5ICogeTtcbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3F1YXJlZCgpKTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lkZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/Side.js\n");

/***/ }),

/***/ "./src/core/math/Vector2.js":
/*!**********************************!*\
  !*** ./src/core/math/Vector2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { IsFloat } = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n\n/** Class Vector2D\n * Represents a 2D vector with X, Y coordinates\n * @constructor\n *\n * @example\n * new CSG.Vector2D(1, 2);\n * new CSG.Vector2D([1, 2]);\n * new CSG.Vector2D({ x: 1, y: 2});\n */\nconst Vector2D = function (x, y) {\n  if (arguments.length === 2) {\n    this._x = parseFloat(x);\n    this._y = parseFloat(y);\n  } else {\n    var ok = true;\n    if (arguments.length === 1) {\n      if (typeof x === 'object') {\n        if (x instanceof Vector2D) {\n          this._x = x._x;\n          this._y = x._y;\n        } else if (x instanceof Array) {\n          this._x = parseFloat(x[0]);\n          this._y = parseFloat(x[1]);\n        } else if ('x' in x && 'y' in x) {\n          this._x = parseFloat(x.x);\n          this._y = parseFloat(x.y);\n        } else ok = false;\n      } else {\n        var v = parseFloat(x);\n        this._x = v;\n        this._y = v;\n      }\n    } else ok = false;\n    if (ok) {\n      if (!IsFloat(this._x) || !IsFloat(this._y)) ok = false;\n    }\n    if (!ok) {\n      throw new Error('wrong arguments');\n    }\n  }\n};\n\nVector2D.fromAngle = function (radians) {\n  return Vector2D.fromAngleRadians(radians);\n};\n\nVector2D.fromAngleDegrees = function (degrees) {\n  var radians = (Math.PI * degrees) / 180;\n  return Vector2D.fromAngleRadians(radians);\n};\n\nVector2D.fromAngleRadians = function (radians) {\n  return Vector2D.Create(Math.cos(radians), Math.sin(radians));\n};\n\n// This does the same as new Vector2D(x,y) but it doesn't go through the constructor\n// and the parameters are not validated. Is much faster.\nVector2D.Create = function (x, y) {\n  var result = Object.create(Vector2D.prototype);\n  result._x = x;\n  result._y = y;\n  return result;\n};\n\nVector2D.prototype = {\n  get x() {\n    return this._x;\n  },\n  get y() {\n    return this._y;\n  },\n\n  set x(v) {\n    throw new Error('Vector2D is immutable');\n  },\n  set y(v) {\n    throw new Error('Vector2D is immutable');\n  },\n\n  // extend to a 3D vector by adding a z coordinate:\n  toVector3D: function (z) {\n    const Vector3D = __webpack_require__(/*! ./Vector3 */ \"./src/core/math/Vector3.js\"); // FIXME: circular dependencies Vector2 => Vector3 => Vector2\n    return new Vector3D(this._x, this._y, z);\n  },\n\n  equals: function (a) {\n    return this._x === a._x && this._y === a._y;\n  },\n\n  clone: function () {\n    return Vector2D.Create(this._x, this._y);\n  },\n\n  negated: function () {\n    return Vector2D.Create(-this._x, -this._y);\n  },\n\n  plus: function (a) {\n    return Vector2D.Create(this._x + a._x, this._y + a._y);\n  },\n\n  minus: function (a) {\n    return Vector2D.Create(this._x - a._x, this._y - a._y);\n  },\n\n  times: function (a) {\n    return Vector2D.Create(this._x * a, this._y * a);\n  },\n\n  dividedBy: function (a) {\n    return Vector2D.Create(this._x / a, this._y / a);\n  },\n\n  dot: function (a) {\n    return this._x * a._x + this._y * a._y;\n  },\n\n  lerp: function (a, t) {\n    return this.plus(a.minus(this).times(t));\n  },\n\n  length: function () {\n    return Math.sqrt(this.dot(this));\n  },\n\n  distanceTo: function (a) {\n    return this.minus(a).length();\n  },\n\n  distanceToSquared: function (a) {\n    return this.minus(a).lengthSquared();\n  },\n\n  lengthSquared: function () {\n    return this.dot(this);\n  },\n\n  unit: function () {\n    return this.dividedBy(this.length());\n  },\n\n  cross: function (a) {\n    return this._x * a._y - this._y * a._x;\n  },\n\n  // returns the vector rotated by 90 degrees clockwise\n  normal: function () {\n    return Vector2D.Create(this._y, -this._x);\n  },\n\n  // Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)\n  // Returns a new Vector2D\n  multiply4x4: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x2Vector(this);\n  },\n\n  transform: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x2Vector(this);\n  },\n\n  angle: function () {\n    return this.angleRadians();\n  },\n\n  angleDegrees: function () {\n    var radians = this.angleRadians();\n    return (180 * radians) / Math.PI;\n  },\n\n  angleRadians: function () {\n    // y=sin, x=cos\n    return Math.atan2(this._y, this._x);\n  },\n\n  min: function (p) {\n    return Vector2D.Create(Math.min(this._x, p._x), Math.min(this._y, p._y));\n  },\n\n  max: function (p) {\n    return Vector2D.Create(Math.max(this._x, p._x), Math.max(this._y, p._y));\n  },\n\n  toString: function () {\n    return '(' + this._x.toFixed(5) + ', ' + this._y.toFixed(5) + ')';\n  },\n\n  abs: function () {\n    return Vector2D.Create(Math.abs(this._x), Math.abs(this._y));\n  },\n};\n\nmodule.exports = Vector2D;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1ZlY3RvcjIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9tYXRoL1ZlY3RvcjIuanM/ZmY4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IElzRmxvYXQgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKiBDbGFzcyBWZWN0b3IyRFxuICogUmVwcmVzZW50cyBhIDJEIHZlY3RvciB3aXRoIFgsIFkgY29vcmRpbmF0ZXNcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBleGFtcGxlXG4gKiBuZXcgQ1NHLlZlY3RvcjJEKDEsIDIpO1xuICogbmV3IENTRy5WZWN0b3IyRChbMSwgMl0pO1xuICogbmV3IENTRy5WZWN0b3IyRCh7IHg6IDEsIHk6IDJ9KTtcbiAqL1xuY29uc3QgVmVjdG9yMkQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMuX3ggPSBwYXJzZUZsb2F0KHgpO1xuICAgIHRoaXMuX3kgPSBwYXJzZUZsb2F0KHkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvayA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBWZWN0b3IyRCkge1xuICAgICAgICAgIHRoaXMuX3ggPSB4Ll94O1xuICAgICAgICAgIHRoaXMuX3kgPSB4Ll95O1xuICAgICAgICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHRoaXMuX3ggPSBwYXJzZUZsb2F0KHhbMF0pO1xuICAgICAgICAgIHRoaXMuX3kgPSBwYXJzZUZsb2F0KHhbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKCd4JyBpbiB4ICYmICd5JyBpbiB4KSB7XG4gICAgICAgICAgdGhpcy5feCA9IHBhcnNlRmxvYXQoeC54KTtcbiAgICAgICAgICB0aGlzLl95ID0gcGFyc2VGbG9hdCh4LnkpO1xuICAgICAgICB9IGVsc2Ugb2sgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2ID0gcGFyc2VGbG9hdCh4KTtcbiAgICAgICAgdGhpcy5feCA9IHY7XG4gICAgICAgIHRoaXMuX3kgPSB2O1xuICAgICAgfVxuICAgIH0gZWxzZSBvayA9IGZhbHNlO1xuICAgIGlmIChvaykge1xuICAgICAgaWYgKCFJc0Zsb2F0KHRoaXMuX3gpIHx8ICFJc0Zsb2F0KHRoaXMuX3kpKSBvayA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgfVxufTtcblxuVmVjdG9yMkQuZnJvbUFuZ2xlID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgcmV0dXJuIFZlY3RvcjJELmZyb21BbmdsZVJhZGlhbnMocmFkaWFucyk7XG59O1xuXG5WZWN0b3IyRC5mcm9tQW5nbGVEZWdyZWVzID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcbiAgdmFyIHJhZGlhbnMgPSAoTWF0aC5QSSAqIGRlZ3JlZXMpIC8gMTgwO1xuICByZXR1cm4gVmVjdG9yMkQuZnJvbUFuZ2xlUmFkaWFucyhyYWRpYW5zKTtcbn07XG5cblZlY3RvcjJELmZyb21BbmdsZVJhZGlhbnMgPSBmdW5jdGlvbiAocmFkaWFucykge1xuICByZXR1cm4gVmVjdG9yMkQuQ3JlYXRlKE1hdGguY29zKHJhZGlhbnMpLCBNYXRoLnNpbihyYWRpYW5zKSk7XG59O1xuXG4vLyBUaGlzIGRvZXMgdGhlIHNhbWUgYXMgbmV3IFZlY3RvcjJEKHgseSkgYnV0IGl0IGRvZXNuJ3QgZ28gdGhyb3VnaCB0aGUgY29uc3RydWN0b3Jcbi8vIGFuZCB0aGUgcGFyYW1ldGVycyBhcmUgbm90IHZhbGlkYXRlZC4gSXMgbXVjaCBmYXN0ZXIuXG5WZWN0b3IyRC5DcmVhdGUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShWZWN0b3IyRC5wcm90b3R5cGUpO1xuICByZXN1bHQuX3ggPSB4O1xuICByZXN1bHQuX3kgPSB5O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVmVjdG9yMkQucHJvdG90eXBlID0ge1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfSxcbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH0sXG5cbiAgc2V0IHgodikge1xuICAgIHRocm93IG5ldyBFcnJvcignVmVjdG9yMkQgaXMgaW1tdXRhYmxlJyk7XG4gIH0sXG4gIHNldCB5KHYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlY3RvcjJEIGlzIGltbXV0YWJsZScpO1xuICB9LFxuXG4gIC8vIGV4dGVuZCB0byBhIDNEIHZlY3RvciBieSBhZGRpbmcgYSB6IGNvb3JkaW5hdGU6XG4gIHRvVmVjdG9yM0Q6IGZ1bmN0aW9uICh6KSB7XG4gICAgY29uc3QgVmVjdG9yM0QgPSByZXF1aXJlKCcuL1ZlY3RvcjMnKTsgLy8gRklYTUU6IGNpcmN1bGFyIGRlcGVuZGVuY2llcyBWZWN0b3IyID0+IFZlY3RvcjMgPT4gVmVjdG9yMlxuICAgIHJldHVybiBuZXcgVmVjdG9yM0QodGhpcy5feCwgdGhpcy5feSwgeik7XG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiB0aGlzLl94ID09PSBhLl94ICYmIHRoaXMuX3kgPT09IGEuX3k7XG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVmVjdG9yMkQuQ3JlYXRlKHRoaXMuX3gsIHRoaXMuX3kpO1xuICB9LFxuXG4gIG5lZ2F0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVmVjdG9yMkQuQ3JlYXRlKC10aGlzLl94LCAtdGhpcy5feSk7XG4gIH0sXG5cbiAgcGx1czogZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gVmVjdG9yMkQuQ3JlYXRlKHRoaXMuX3ggKyBhLl94LCB0aGlzLl95ICsgYS5feSk7XG4gIH0sXG5cbiAgbWludXM6IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFZlY3RvcjJELkNyZWF0ZSh0aGlzLl94IC0gYS5feCwgdGhpcy5feSAtIGEuX3kpO1xuICB9LFxuXG4gIHRpbWVzOiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBWZWN0b3IyRC5DcmVhdGUodGhpcy5feCAqIGEsIHRoaXMuX3kgKiBhKTtcbiAgfSxcblxuICBkaXZpZGVkQnk6IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFZlY3RvcjJELkNyZWF0ZSh0aGlzLl94IC8gYSwgdGhpcy5feSAvIGEpO1xuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gdGhpcy5feCAqIGEuX3ggKyB0aGlzLl95ICogYS5feTtcbiAgfSxcblxuICBsZXJwOiBmdW5jdGlvbiAoYSwgdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXMoYS5taW51cyh0aGlzKS50aW1lcyh0KSk7XG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRvdCh0aGlzKSk7XG4gIH0sXG5cbiAgZGlzdGFuY2VUbzogZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gdGhpcy5taW51cyhhKS5sZW5ndGgoKTtcbiAgfSxcblxuICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gdGhpcy5taW51cyhhKS5sZW5ndGhTcXVhcmVkKCk7XG4gIH0sXG5cbiAgbGVuZ3RoU3F1YXJlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTtcbiAgfSxcblxuICB1bml0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlZEJ5KHRoaXMubGVuZ3RoKCkpO1xuICB9LFxuXG4gIGNyb3NzOiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiB0aGlzLl94ICogYS5feSAtIHRoaXMuX3kgKiBhLl94O1xuICB9LFxuXG4gIC8vIHJldHVybnMgdGhlIHZlY3RvciByb3RhdGVkIGJ5IDkwIGRlZ3JlZXMgY2xvY2t3aXNlXG4gIG5vcm1hbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBWZWN0b3IyRC5DcmVhdGUodGhpcy5feSwgLXRoaXMuX3gpO1xuICB9LFxuXG4gIC8vIFJpZ2h0IG11bHRpcGx5IGJ5IGEgNHg0IG1hdHJpeCAodGhlIHZlY3RvciBpcyBpbnRlcnByZXRlZCBhcyBhIHJvdyB2ZWN0b3IpXG4gIC8vIFJldHVybnMgYSBuZXcgVmVjdG9yMkRcbiAgbXVsdGlwbHk0eDQ6IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICByZXR1cm4gbWF0cml4NHg0LmxlZnRNdWx0aXBseTF4MlZlY3Rvcih0aGlzKTtcbiAgfSxcblxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICByZXR1cm4gbWF0cml4NHg0LmxlZnRNdWx0aXBseTF4MlZlY3Rvcih0aGlzKTtcbiAgfSxcblxuICBhbmdsZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmFuZ2xlUmFkaWFucygpO1xuICB9LFxuXG4gIGFuZ2xlRGVncmVlczogZnVuY3Rpb24gKCkge1xuICAgIHZhciByYWRpYW5zID0gdGhpcy5hbmdsZVJhZGlhbnMoKTtcbiAgICByZXR1cm4gKDE4MCAqIHJhZGlhbnMpIC8gTWF0aC5QSTtcbiAgfSxcblxuICBhbmdsZVJhZGlhbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB5PXNpbiwgeD1jb3NcbiAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLl95LCB0aGlzLl94KTtcbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIFZlY3RvcjJELkNyZWF0ZShNYXRoLm1pbih0aGlzLl94LCBwLl94KSwgTWF0aC5taW4odGhpcy5feSwgcC5feSkpO1xuICB9LFxuXG4gIG1heDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gVmVjdG9yMkQuQ3JlYXRlKE1hdGgubWF4KHRoaXMuX3gsIHAuX3gpLCBNYXRoLm1heCh0aGlzLl95LCBwLl95KSk7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJygnICsgdGhpcy5feC50b0ZpeGVkKDUpICsgJywgJyArIHRoaXMuX3kudG9GaXhlZCg1KSArICcpJztcbiAgfSxcblxuICBhYnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVmVjdG9yMkQuQ3JlYXRlKE1hdGguYWJzKHRoaXMuX3gpLCBNYXRoLmFicyh0aGlzLl95KSk7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjJEO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/math/Vector2.js\n");

/***/ }),

/***/ "./src/core/math/Vector3.js":
/*!**********************************!*\
  !*** ./src/core/math/Vector3.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { IsFloat } = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\nconst Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\n\n/** Class Vector3D\n * Represents a 3D vector with X, Y, Z coordinates.\n * @constructor\n *\n * @example\n * new CSG.Vector3D(1, 2, 3);\n * new CSG.Vector3D([1, 2, 3]);\n * new CSG.Vector3D({ x: 1, y: 2, z: 3 });\n * new CSG.Vector3D(1, 2); // assumes z=0\n * new CSG.Vector3D([1, 2]); // assumes z=0\n */\nconst Vector3D = function (x, y, z) {\n  if (arguments.length === 3) {\n    this._x = parseFloat(x);\n    this._y = parseFloat(y);\n    this._z = parseFloat(z);\n  } else if (arguments.length === 2) {\n    this._x = parseFloat(x);\n    this._y = parseFloat(y);\n    this._z = 0;\n  } else {\n    var ok = true;\n    if (arguments.length === 1) {\n      if (typeof x === 'object') {\n        if (x instanceof Vector3D) {\n          this._x = x._x;\n          this._y = x._y;\n          this._z = x._z;\n        } else if (x instanceof Vector2D) {\n          this._x = x._x;\n          this._y = x._y;\n          this._z = 0;\n        } else if (x instanceof Array) {\n          if (x.length < 2 || x.length > 3) {\n            ok = false;\n          } else {\n            this._x = parseFloat(x[0]);\n            this._y = parseFloat(x[1]);\n            if (x.length === 3) {\n              this._z = parseFloat(x[2]);\n            } else {\n              this._z = 0;\n            }\n          }\n        } else if ('x' in x && 'y' in x) {\n          this._x = parseFloat(x.x);\n          this._y = parseFloat(x.y);\n          if ('z' in x) {\n            this._z = parseFloat(x.z);\n          } else {\n            this._z = 0;\n          }\n        } else if ('_x' in x && '_y' in x) {\n          this._x = parseFloat(x._x);\n          this._y = parseFloat(x._y);\n          if ('_z' in x) {\n            this._z = parseFloat(x._z);\n          } else {\n            this._z = 0;\n          }\n        } else ok = false;\n      } else {\n        var v = parseFloat(x);\n        this._x = v;\n        this._y = v;\n        this._z = v;\n      }\n    } else ok = false;\n    if (ok) {\n      if (!IsFloat(this._x) || !IsFloat(this._y) || !IsFloat(this._z))\n        ok = false;\n    } else {\n      throw new Error('wrong arguments');\n    }\n  }\n};\n\n// This does the same as new Vector3D(x,y,z) but it doesn't go through the constructor\n// and the parameters are not validated. Is much faster.\nVector3D.Create = function (x, y, z) {\n  var result = Object.create(Vector3D.prototype);\n  result._x = x;\n  result._y = y;\n  result._z = z;\n  return result;\n};\n\nVector3D.prototype = {\n  get x() {\n    return this._x;\n  },\n  get y() {\n    return this._y;\n  },\n  get z() {\n    return this._z;\n  },\n\n  set x(v) {\n    throw new Error('Vector3D is immutable');\n  },\n  set y(v) {\n    throw new Error('Vector3D is immutable');\n  },\n  set z(v) {\n    throw new Error('Vector3D is immutable');\n  },\n\n  clone: function () {\n    return Vector3D.Create(this._x, this._y, this._z);\n  },\n\n  negated: function () {\n    return Vector3D.Create(-this._x, -this._y, -this._z);\n  },\n\n  abs: function () {\n    return Vector3D.Create(\n      Math.abs(this._x),\n      Math.abs(this._y),\n      Math.abs(this._z)\n    );\n  },\n\n  plus: function (a) {\n    return Vector3D.Create(this._x + a._x, this._y + a._y, this._z + a._z);\n  },\n\n  minus: function (a) {\n    return Vector3D.Create(this._x - a._x, this._y - a._y, this._z - a._z);\n  },\n\n  times: function (a) {\n    return Vector3D.Create(this._x * a, this._y * a, this._z * a);\n  },\n\n  dividedBy: function (a) {\n    return Vector3D.Create(this._x / a, this._y / a, this._z / a);\n  },\n\n  dot: function (a) {\n    return this._x * a._x + this._y * a._y + this._z * a._z;\n  },\n\n  lerp: function (a, t) {\n    return this.plus(a.minus(this).times(t));\n  },\n\n  lengthSquared: function () {\n    return this.dot(this);\n  },\n\n  length: function () {\n    return Math.sqrt(this.lengthSquared());\n  },\n\n  unit: function () {\n    return this.dividedBy(this.length());\n  },\n\n  cross: function (a) {\n    return Vector3D.Create(\n      this._y * a._z - this._z * a._y,\n      this._z * a._x - this._x * a._z,\n      this._x * a._y - this._y * a._x\n    );\n  },\n\n  distanceTo: function (a) {\n    return this.minus(a).length();\n  },\n\n  distanceToSquared: function (a) {\n    return this.minus(a).lengthSquared();\n  },\n\n  equals: function (a) {\n    return this._x === a._x && this._y === a._y && this._z === a._z;\n  },\n\n  // Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)\n  // Returns a new Vector3D\n  multiply4x4: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x3Vector(this);\n  },\n\n  transform: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x3Vector(this);\n  },\n\n  toString: function () {\n    return (\n      '(' +\n      this._x.toFixed(5) +\n      ', ' +\n      this._y.toFixed(5) +\n      ', ' +\n      this._z.toFixed(5) +\n      ')'\n    );\n  },\n\n  // find a vector that is somewhat perpendicular to this one\n  randomNonParallelVector: function () {\n    var abs = this.abs();\n    if (abs._x <= abs._y && abs._x <= abs._z) {\n      return Vector3D.Create(1, 0, 0);\n    } else if (abs._y <= abs._x && abs._y <= abs._z) {\n      return Vector3D.Create(0, 1, 0);\n    } else {\n      return Vector3D.Create(0, 0, 1);\n    }\n  },\n\n  min: function (p) {\n    return Vector3D.Create(\n      Math.min(this._x, p._x),\n      Math.min(this._y, p._y),\n      Math.min(this._z, p._z)\n    );\n  },\n\n  max: function (p) {\n    return Vector3D.Create(\n      Math.max(this._x, p._x),\n      Math.max(this._y, p._y),\n      Math.max(this._z, p._z)\n    );\n  },\n};\n\nmodule.exports = Vector3D;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1ZlY3RvcjMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9tYXRoL1ZlY3RvcjMuanM/ODAyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IElzRmxvYXQgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4vVmVjdG9yMicpO1xuXG4vKiogQ2xhc3MgVmVjdG9yM0RcbiAqIFJlcHJlc2VudHMgYSAzRCB2ZWN0b3Igd2l0aCBYLCBZLCBaIGNvb3JkaW5hdGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQGV4YW1wbGVcbiAqIG5ldyBDU0cuVmVjdG9yM0QoMSwgMiwgMyk7XG4gKiBuZXcgQ1NHLlZlY3RvcjNEKFsxLCAyLCAzXSk7XG4gKiBuZXcgQ1NHLlZlY3RvcjNEKHsgeDogMSwgeTogMiwgejogMyB9KTtcbiAqIG5ldyBDU0cuVmVjdG9yM0QoMSwgMik7IC8vIGFzc3VtZXMgej0wXG4gKiBuZXcgQ1NHLlZlY3RvcjNEKFsxLCAyXSk7IC8vIGFzc3VtZXMgej0wXG4gKi9cbmNvbnN0IFZlY3RvcjNEID0gZnVuY3Rpb24gKHgsIHksIHopIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB0aGlzLl94ID0gcGFyc2VGbG9hdCh4KTtcbiAgICB0aGlzLl95ID0gcGFyc2VGbG9hdCh5KTtcbiAgICB0aGlzLl96ID0gcGFyc2VGbG9hdCh6KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5feCA9IHBhcnNlRmxvYXQoeCk7XG4gICAgdGhpcy5feSA9IHBhcnNlRmxvYXQoeSk7XG4gICAgdGhpcy5feiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9rID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFZlY3RvcjNEKSB7XG4gICAgICAgICAgdGhpcy5feCA9IHguX3g7XG4gICAgICAgICAgdGhpcy5feSA9IHguX3k7XG4gICAgICAgICAgdGhpcy5feiA9IHguX3o7XG4gICAgICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFZlY3RvcjJEKSB7XG4gICAgICAgICAgdGhpcy5feCA9IHguX3g7XG4gICAgICAgICAgdGhpcy5feSA9IHguX3k7XG4gICAgICAgICAgdGhpcy5feiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgaWYgKHgubGVuZ3RoIDwgMiB8fCB4Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBwYXJzZUZsb2F0KHhbMF0pO1xuICAgICAgICAgICAgdGhpcy5feSA9IHBhcnNlRmxvYXQoeFsxXSk7XG4gICAgICAgICAgICBpZiAoeC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgdGhpcy5feiA9IHBhcnNlRmxvYXQoeFsyXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ3gnIGluIHggJiYgJ3knIGluIHgpIHtcbiAgICAgICAgICB0aGlzLl94ID0gcGFyc2VGbG9hdCh4LngpO1xuICAgICAgICAgIHRoaXMuX3kgPSBwYXJzZUZsb2F0KHgueSk7XG4gICAgICAgICAgaWYgKCd6JyBpbiB4KSB7XG4gICAgICAgICAgICB0aGlzLl96ID0gcGFyc2VGbG9hdCh4LnopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ194JyBpbiB4ICYmICdfeScgaW4geCkge1xuICAgICAgICAgIHRoaXMuX3ggPSBwYXJzZUZsb2F0KHguX3gpO1xuICAgICAgICAgIHRoaXMuX3kgPSBwYXJzZUZsb2F0KHguX3kpO1xuICAgICAgICAgIGlmICgnX3onIGluIHgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ogPSBwYXJzZUZsb2F0KHguX3opO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBvayA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHYgPSBwYXJzZUZsb2F0KHgpO1xuICAgICAgICB0aGlzLl94ID0gdjtcbiAgICAgICAgdGhpcy5feSA9IHY7XG4gICAgICAgIHRoaXMuX3ogPSB2O1xuICAgICAgfVxuICAgIH0gZWxzZSBvayA9IGZhbHNlO1xuICAgIGlmIChvaykge1xuICAgICAgaWYgKCFJc0Zsb2F0KHRoaXMuX3gpIHx8ICFJc0Zsb2F0KHRoaXMuX3kpIHx8ICFJc0Zsb2F0KHRoaXMuX3opKVxuICAgICAgICBvayA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gVGhpcyBkb2VzIHRoZSBzYW1lIGFzIG5ldyBWZWN0b3IzRCh4LHkseikgYnV0IGl0IGRvZXNuJ3QgZ28gdGhyb3VnaCB0aGUgY29uc3RydWN0b3Jcbi8vIGFuZCB0aGUgcGFyYW1ldGVycyBhcmUgbm90IHZhbGlkYXRlZC4gSXMgbXVjaCBmYXN0ZXIuXG5WZWN0b3IzRC5DcmVhdGUgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShWZWN0b3IzRC5wcm90b3R5cGUpO1xuICByZXN1bHQuX3ggPSB4O1xuICByZXN1bHQuX3kgPSB5O1xuICByZXN1bHQuX3ogPSB6O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVmVjdG9yM0QucHJvdG90eXBlID0ge1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfSxcbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH0sXG4gIGdldCB6KCkge1xuICAgIHJldHVybiB0aGlzLl96O1xuICB9LFxuXG4gIHNldCB4KHYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlY3RvcjNEIGlzIGltbXV0YWJsZScpO1xuICB9LFxuICBzZXQgeSh2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWZWN0b3IzRCBpcyBpbW11dGFibGUnKTtcbiAgfSxcbiAgc2V0IHoodikge1xuICAgIHRocm93IG5ldyBFcnJvcignVmVjdG9yM0QgaXMgaW1tdXRhYmxlJyk7XG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVmVjdG9yM0QuQ3JlYXRlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3opO1xuICB9LFxuXG4gIG5lZ2F0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVmVjdG9yM0QuQ3JlYXRlKC10aGlzLl94LCAtdGhpcy5feSwgLXRoaXMuX3opO1xuICB9LFxuXG4gIGFiczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBWZWN0b3IzRC5DcmVhdGUoXG4gICAgICBNYXRoLmFicyh0aGlzLl94KSxcbiAgICAgIE1hdGguYWJzKHRoaXMuX3kpLFxuICAgICAgTWF0aC5hYnModGhpcy5feilcbiAgICApO1xuICB9LFxuXG4gIHBsdXM6IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFZlY3RvcjNELkNyZWF0ZSh0aGlzLl94ICsgYS5feCwgdGhpcy5feSArIGEuX3ksIHRoaXMuX3ogKyBhLl96KTtcbiAgfSxcblxuICBtaW51czogZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gVmVjdG9yM0QuQ3JlYXRlKHRoaXMuX3ggLSBhLl94LCB0aGlzLl95IC0gYS5feSwgdGhpcy5feiAtIGEuX3opO1xuICB9LFxuXG4gIHRpbWVzOiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBWZWN0b3IzRC5DcmVhdGUodGhpcy5feCAqIGEsIHRoaXMuX3kgKiBhLCB0aGlzLl96ICogYSk7XG4gIH0sXG5cbiAgZGl2aWRlZEJ5OiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBWZWN0b3IzRC5DcmVhdGUodGhpcy5feCAvIGEsIHRoaXMuX3kgLyBhLCB0aGlzLl96IC8gYSk7XG4gIH0sXG5cbiAgZG90OiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiB0aGlzLl94ICogYS5feCArIHRoaXMuX3kgKiBhLl95ICsgdGhpcy5feiAqIGEuX3o7XG4gIH0sXG5cbiAgbGVycDogZnVuY3Rpb24gKGEsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGEubWludXModGhpcykudGltZXModCkpO1xuICB9LFxuXG4gIGxlbmd0aFNxdWFyZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kb3QodGhpcyk7XG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxdWFyZWQoKSk7XG4gIH0sXG5cbiAgdW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpdmlkZWRCeSh0aGlzLmxlbmd0aCgpKTtcbiAgfSxcblxuICBjcm9zczogZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gVmVjdG9yM0QuQ3JlYXRlKFxuICAgICAgdGhpcy5feSAqIGEuX3ogLSB0aGlzLl96ICogYS5feSxcbiAgICAgIHRoaXMuX3ogKiBhLl94IC0gdGhpcy5feCAqIGEuX3osXG4gICAgICB0aGlzLl94ICogYS5feSAtIHRoaXMuX3kgKiBhLl94XG4gICAgKTtcbiAgfSxcblxuICBkaXN0YW5jZVRvOiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiB0aGlzLm1pbnVzKGEpLmxlbmd0aCgpO1xuICB9LFxuXG4gIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiB0aGlzLm1pbnVzKGEpLmxlbmd0aFNxdWFyZWQoKTtcbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggPT09IGEuX3ggJiYgdGhpcy5feSA9PT0gYS5feSAmJiB0aGlzLl96ID09PSBhLl96O1xuICB9LFxuXG4gIC8vIFJpZ2h0IG11bHRpcGx5IGJ5IGEgNHg0IG1hdHJpeCAodGhlIHZlY3RvciBpcyBpbnRlcnByZXRlZCBhcyBhIHJvdyB2ZWN0b3IpXG4gIC8vIFJldHVybnMgYSBuZXcgVmVjdG9yM0RcbiAgbXVsdGlwbHk0eDQ6IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICByZXR1cm4gbWF0cml4NHg0LmxlZnRNdWx0aXBseTF4M1ZlY3Rvcih0aGlzKTtcbiAgfSxcblxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICByZXR1cm4gbWF0cml4NHg0LmxlZnRNdWx0aXBseTF4M1ZlY3Rvcih0aGlzKTtcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICAnKCcgK1xuICAgICAgdGhpcy5feC50b0ZpeGVkKDUpICtcbiAgICAgICcsICcgK1xuICAgICAgdGhpcy5feS50b0ZpeGVkKDUpICtcbiAgICAgICcsICcgK1xuICAgICAgdGhpcy5fei50b0ZpeGVkKDUpICtcbiAgICAgICcpJ1xuICAgICk7XG4gIH0sXG5cbiAgLy8gZmluZCBhIHZlY3RvciB0aGF0IGlzIHNvbWV3aGF0IHBlcnBlbmRpY3VsYXIgdG8gdGhpcyBvbmVcbiAgcmFuZG9tTm9uUGFyYWxsZWxWZWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWJzID0gdGhpcy5hYnMoKTtcbiAgICBpZiAoYWJzLl94IDw9IGFicy5feSAmJiBhYnMuX3ggPD0gYWJzLl96KSB7XG4gICAgICByZXR1cm4gVmVjdG9yM0QuQ3JlYXRlKDEsIDAsIDApO1xuICAgIH0gZWxzZSBpZiAoYWJzLl95IDw9IGFicy5feCAmJiBhYnMuX3kgPD0gYWJzLl96KSB7XG4gICAgICByZXR1cm4gVmVjdG9yM0QuQ3JlYXRlKDAsIDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gVmVjdG9yM0QuQ3JlYXRlKDAsIDAsIDEpO1xuICAgIH1cbiAgfSxcblxuICBtaW46IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIFZlY3RvcjNELkNyZWF0ZShcbiAgICAgIE1hdGgubWluKHRoaXMuX3gsIHAuX3gpLFxuICAgICAgTWF0aC5taW4odGhpcy5feSwgcC5feSksXG4gICAgICBNYXRoLm1pbih0aGlzLl96LCBwLl96KVxuICAgICk7XG4gIH0sXG5cbiAgbWF4OiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBWZWN0b3IzRC5DcmVhdGUoXG4gICAgICBNYXRoLm1heCh0aGlzLl94LCBwLl94KSxcbiAgICAgIE1hdGgubWF4KHRoaXMuX3ksIHAuX3kpLFxuICAgICAgTWF0aC5tYXgodGhpcy5feiwgcC5feilcbiAgICApO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3IzRDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/math/Vector3.js\n");

/***/ }),

/***/ "./src/core/math/Vertex2.js":
/*!**********************************!*\
  !*** ./src/core/math/Vertex2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\nconst { getTag } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\n\nconst Vertex = function (pos) {\n  this.pos = pos;\n};\n\nVertex.fromObject = function (obj) {\n  return new Vertex(new Vector2D(obj.pos._x, obj.pos._y));\n};\n\nVertex.prototype = {\n  toString: function () {\n    return '(' + this.pos.x.toFixed(5) + ',' + this.pos.y.toFixed(5) + ')';\n  },\n  getTag: function () {\n    var result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n};\n\nmodule.exports = Vertex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1ZlcnRleDIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9tYXRoL1ZlcnRleDIuanM/NmZmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4vVmVjdG9yMicpO1xuY29uc3QgeyBnZXRUYWcgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG5jb25zdCBWZXJ0ZXggPSBmdW5jdGlvbiAocG9zKSB7XG4gIHRoaXMucG9zID0gcG9zO1xufTtcblxuVmVydGV4LmZyb21PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBuZXcgVmVydGV4KG5ldyBWZWN0b3IyRChvYmoucG9zLl94LCBvYmoucG9zLl95KSk7XG59O1xuXG5WZXJ0ZXgucHJvdG90eXBlID0ge1xuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnKCcgKyB0aGlzLnBvcy54LnRvRml4ZWQoNSkgKyAnLCcgKyB0aGlzLnBvcy55LnRvRml4ZWQoNSkgKyAnKSc7XG4gIH0sXG4gIGdldFRhZzogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnRhZztcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gZ2V0VGFnKCk7XG4gICAgICB0aGlzLnRhZyA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGV4O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/math/Vertex2.js\n");

/***/ }),

/***/ "./src/core/math/Vertex3.js":
/*!**********************************!*\
  !*** ./src/core/math/Vertex3.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ./Vector3 */ \"./src/core/math/Vector3.js\");\nconst { getTag } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\n\n// # class Vertex\n// Represents a vertex of a polygon. Use your own vertex class instead of this\n// one to provide additional features like texture coordinates and vertex\n// colors. Custom vertex classes need to provide a `pos` property\n// `flipped()`, and `interpolate()` methods that behave analogous to the ones\n// FIXME: And a lot MORE (see plane.fromVector3Ds for ex) ! This is fragile code\n// defined by `Vertex`.\nconst Vertex = function (pos) {\n  this.pos = pos;\n};\n\n// create from an untyped object with identical property names:\nVertex.fromObject = function (obj) {\n  var pos = new Vector3D(obj.pos);\n  return new Vertex(pos);\n};\n\nVertex.prototype = {\n  // Return a vertex with all orientation-specific data (e.g. vertex normal) flipped. Called when the\n  // orientation of a polygon is flipped.\n  flipped: function () {\n    return this;\n  },\n\n  getTag: function () {\n    var result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n\n  // Create a new vertex between this vertex and `other` by linearly\n  // interpolating all properties using a parameter of `t`. Subclasses should\n  // override this to interpolate additional properties.\n  interpolate: function (other, t) {\n    var newpos = this.pos.lerp(other.pos, t);\n    return new Vertex(newpos);\n  },\n\n  // Affine transformation of vertex. Returns a new Vertex\n  transform: function (matrix4x4) {\n    var newpos = this.pos.multiply4x4(matrix4x4);\n    return new Vertex(newpos);\n  },\n\n  toString: function () {\n    return this.pos.toString();\n  },\n};\n\nmodule.exports = Vertex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL1ZlcnRleDMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS9tYXRoL1ZlcnRleDMuanM/NGQ0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IzRCA9IHJlcXVpcmUoJy4vVmVjdG9yMycpO1xuY29uc3QgeyBnZXRUYWcgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG4vLyAjIGNsYXNzIFZlcnRleFxuLy8gUmVwcmVzZW50cyBhIHZlcnRleCBvZiBhIHBvbHlnb24uIFVzZSB5b3VyIG93biB2ZXJ0ZXggY2xhc3MgaW5zdGVhZCBvZiB0aGlzXG4vLyBvbmUgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIGZlYXR1cmVzIGxpa2UgdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgdmVydGV4XG4vLyBjb2xvcnMuIEN1c3RvbSB2ZXJ0ZXggY2xhc3NlcyBuZWVkIHRvIHByb3ZpZGUgYSBgcG9zYCBwcm9wZXJ0eVxuLy8gYGZsaXBwZWQoKWAsIGFuZCBgaW50ZXJwb2xhdGUoKWAgbWV0aG9kcyB0aGF0IGJlaGF2ZSBhbmFsb2dvdXMgdG8gdGhlIG9uZXNcbi8vIEZJWE1FOiBBbmQgYSBsb3QgTU9SRSAoc2VlIHBsYW5lLmZyb21WZWN0b3IzRHMgZm9yIGV4KSAhIFRoaXMgaXMgZnJhZ2lsZSBjb2RlXG4vLyBkZWZpbmVkIGJ5IGBWZXJ0ZXhgLlxuY29uc3QgVmVydGV4ID0gZnVuY3Rpb24gKHBvcykge1xuICB0aGlzLnBvcyA9IHBvcztcbn07XG5cbi8vIGNyZWF0ZSBmcm9tIGFuIHVudHlwZWQgb2JqZWN0IHdpdGggaWRlbnRpY2FsIHByb3BlcnR5IG5hbWVzOlxuVmVydGV4LmZyb21PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBwb3MgPSBuZXcgVmVjdG9yM0Qob2JqLnBvcyk7XG4gIHJldHVybiBuZXcgVmVydGV4KHBvcyk7XG59O1xuXG5WZXJ0ZXgucHJvdG90eXBlID0ge1xuICAvLyBSZXR1cm4gYSB2ZXJ0ZXggd2l0aCBhbGwgb3JpZW50YXRpb24tc3BlY2lmaWMgZGF0YSAoZS5nLiB2ZXJ0ZXggbm9ybWFsKSBmbGlwcGVkLiBDYWxsZWQgd2hlbiB0aGVcbiAgLy8gb3JpZW50YXRpb24gb2YgYSBwb2x5Z29uIGlzIGZsaXBwZWQuXG4gIGZsaXBwZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBnZXRUYWc6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy50YWc7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IGdldFRhZygpO1xuICAgICAgdGhpcy50YWcgPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHZlcnRleCBiZXR3ZWVuIHRoaXMgdmVydGV4IGFuZCBgb3RoZXJgIGJ5IGxpbmVhcmx5XG4gIC8vIGludGVycG9sYXRpbmcgYWxsIHByb3BlcnRpZXMgdXNpbmcgYSBwYXJhbWV0ZXIgb2YgYHRgLiBTdWJjbGFzc2VzIHNob3VsZFxuICAvLyBvdmVycmlkZSB0aGlzIHRvIGludGVycG9sYXRlIGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChvdGhlciwgdCkge1xuICAgIHZhciBuZXdwb3MgPSB0aGlzLnBvcy5sZXJwKG90aGVyLnBvcywgdCk7XG4gICAgcmV0dXJuIG5ldyBWZXJ0ZXgobmV3cG9zKTtcbiAgfSxcblxuICAvLyBBZmZpbmUgdHJhbnNmb3JtYXRpb24gb2YgdmVydGV4LiBSZXR1cm5zIGEgbmV3IFZlcnRleFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChtYXRyaXg0eDQpIHtcbiAgICB2YXIgbmV3cG9zID0gdGhpcy5wb3MubXVsdGlwbHk0eDQobWF0cml4NHg0KTtcbiAgICByZXR1cm4gbmV3IFZlcnRleChuZXdwb3MpO1xuICB9LFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zLnRvU3RyaW5nKCk7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnRleDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/Vertex3.js\n");

/***/ }),

/***/ "./src/core/math/lineUtils.js":
/*!************************************!*\
  !*** ./src/core/math/lineUtils.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst { solve2Linear } = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\n\n// see if the line between p0start and p0end intersects with the line between p1start and p1end\n// returns true if the lines strictly intersect, the end points are not counted!\nconst linesIntersect = function (p0start, p0end, p1start, p1end) {\n  if (p0end.equals(p1start) || p1end.equals(p0start)) {\n    let d = p1end\n      .minus(p1start)\n      .unit()\n      .plus(p0end.minus(p0start).unit())\n      .length();\n    if (d < EPS) {\n      return true;\n    }\n  } else {\n    let d0 = p0end.minus(p0start);\n    let d1 = p1end.minus(p1start);\n    // FIXME These epsilons need review and testing\n    if (Math.abs(d0.cross(d1)) < 1e-9) return false; // lines are parallel\n    let alphas = solve2Linear(\n      -d0.x,\n      d1.x,\n      -d0.y,\n      d1.y,\n      p0start.x - p1start.x,\n      p0start.y - p1start.y\n    );\n    if (\n      alphas[0] > 1e-6 &&\n      alphas[0] < 0.999999 &&\n      alphas[1] > 1e-5 &&\n      alphas[1] < 0.999999\n    )\n      return true;\n    // if( (alphas[0] >= 0) && (alphas[0] <= 1) && (alphas[1] >= 0) && (alphas[1] <= 1) ) return true;\n  }\n  return false;\n};\n\nmodule.exports = { linesIntersect };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL2xpbmVVdGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL21hdGgvbGluZVV0aWxzLmpzPzRjZTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBFUFMgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgeyBzb2x2ZTJMaW5lYXIgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8vIHNlZSBpZiB0aGUgbGluZSBiZXR3ZWVuIHAwc3RhcnQgYW5kIHAwZW5kIGludGVyc2VjdHMgd2l0aCB0aGUgbGluZSBiZXR3ZWVuIHAxc3RhcnQgYW5kIHAxZW5kXG4vLyByZXR1cm5zIHRydWUgaWYgdGhlIGxpbmVzIHN0cmljdGx5IGludGVyc2VjdCwgdGhlIGVuZCBwb2ludHMgYXJlIG5vdCBjb3VudGVkIVxuY29uc3QgbGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiAocDBzdGFydCwgcDBlbmQsIHAxc3RhcnQsIHAxZW5kKSB7XG4gIGlmIChwMGVuZC5lcXVhbHMocDFzdGFydCkgfHwgcDFlbmQuZXF1YWxzKHAwc3RhcnQpKSB7XG4gICAgbGV0IGQgPSBwMWVuZFxuICAgICAgLm1pbnVzKHAxc3RhcnQpXG4gICAgICAudW5pdCgpXG4gICAgICAucGx1cyhwMGVuZC5taW51cyhwMHN0YXJ0KS51bml0KCkpXG4gICAgICAubGVuZ3RoKCk7XG4gICAgaWYgKGQgPCBFUFMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgZDAgPSBwMGVuZC5taW51cyhwMHN0YXJ0KTtcbiAgICBsZXQgZDEgPSBwMWVuZC5taW51cyhwMXN0YXJ0KTtcbiAgICAvLyBGSVhNRSBUaGVzZSBlcHNpbG9ucyBuZWVkIHJldmlldyBhbmQgdGVzdGluZ1xuICAgIGlmIChNYXRoLmFicyhkMC5jcm9zcyhkMSkpIDwgMWUtOSkgcmV0dXJuIGZhbHNlOyAvLyBsaW5lcyBhcmUgcGFyYWxsZWxcbiAgICBsZXQgYWxwaGFzID0gc29sdmUyTGluZWFyKFxuICAgICAgLWQwLngsXG4gICAgICBkMS54LFxuICAgICAgLWQwLnksXG4gICAgICBkMS55LFxuICAgICAgcDBzdGFydC54IC0gcDFzdGFydC54LFxuICAgICAgcDBzdGFydC55IC0gcDFzdGFydC55XG4gICAgKTtcbiAgICBpZiAoXG4gICAgICBhbHBoYXNbMF0gPiAxZS02ICYmXG4gICAgICBhbHBoYXNbMF0gPCAwLjk5OTk5OSAmJlxuICAgICAgYWxwaGFzWzFdID4gMWUtNSAmJlxuICAgICAgYWxwaGFzWzFdIDwgMC45OTk5OTlcbiAgICApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBpZiggKGFscGhhc1swXSA+PSAwKSAmJiAoYWxwaGFzWzBdIDw9IDEpICYmIChhbHBoYXNbMV0gPj0gMCkgJiYgKGFscGhhc1sxXSA8PSAxKSApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBsaW5lc0ludGVyc2VjdCB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/math/lineUtils.js\n");

/***/ }),

/***/ "./src/core/math/reTesselateCoplanarPolygons.js":
/*!******************************************************!*\
  !*** ./src/core/math/reTesselateCoplanarPolygons.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst OrthoNormalBasis = __webpack_require__(/*! ./OrthoNormalBasis */ \"./src/core/math/OrthoNormalBasis.js\");\nconst {\n  interpolateBetween2DPointsForY,\n  insertSorted,\n  fnNumberSort,\n} = __webpack_require__(/*! ../utils */ \"./src/core/utils.js\");\nconst Vertex = __webpack_require__(/*! ./Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Vector2D = __webpack_require__(/*! ./Vector2 */ \"./src/core/math/Vector2.js\");\nconst Line2D = __webpack_require__(/*! ./Line2 */ \"./src/core/math/Line2.js\");\nconst Polygon = __webpack_require__(/*! ./Polygon3 */ \"./src/core/math/Polygon3.js\");\n\n// Retesselation function for a set of coplanar polygons. See the introduction at the top of\n// this file.\nconst reTesselateCoplanarPolygons = function (sourcepolygons, destpolygons) {\n  let numpolygons = sourcepolygons.length;\n  if (numpolygons > 0) {\n    let plane = sourcepolygons[0].plane;\n    let shared = sourcepolygons[0].shared;\n    let orthobasis = new OrthoNormalBasis(plane);\n    let polygonvertices2d = []; // array of array of Vector2D\n    let polygontopvertexindexes = []; // array of indexes of topmost vertex per polygon\n    let topy2polygonindexes = {};\n    let ycoordinatetopolygonindexes = {};\n\n    let xcoordinatebins = {};\n    let ycoordinatebins = {};\n\n    // convert all polygon vertices to 2D\n    // Make a list of all encountered y coordinates\n    // And build a map of all polygons that have a vertex at a certain y coordinate:\n    let ycoordinateBinningFactor = (1.0 / EPS) * 10;\n    for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {\n      let poly3d = sourcepolygons[polygonindex];\n      let vertices2d = [];\n      let numvertices = poly3d.vertices.length;\n      let minindex = -1;\n      if (numvertices > 0) {\n        let miny, maxy, maxindex;\n        for (let i = 0; i < numvertices; i++) {\n          let pos2d = orthobasis.to2D(poly3d.vertices[i].pos);\n          // perform binning of y coordinates: If we have multiple vertices very\n          // close to each other, give them the same y coordinate:\n          let ycoordinatebin = Math.floor(pos2d.y * ycoordinateBinningFactor);\n          let newy;\n          if (ycoordinatebin in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin];\n          } else if (ycoordinatebin + 1 in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin + 1];\n          } else if (ycoordinatebin - 1 in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin - 1];\n          } else {\n            newy = pos2d.y;\n            ycoordinatebins[ycoordinatebin] = pos2d.y;\n          }\n          pos2d = Vector2D.Create(pos2d.x, newy);\n          vertices2d.push(pos2d);\n          let y = pos2d.y;\n          if (i === 0 || y < miny) {\n            miny = y;\n            minindex = i;\n          }\n          if (i === 0 || y > maxy) {\n            maxy = y;\n            maxindex = i;\n          }\n          if (!(y in ycoordinatetopolygonindexes)) {\n            ycoordinatetopolygonindexes[y] = {};\n          }\n          ycoordinatetopolygonindexes[y][polygonindex] = true;\n        }\n        if (miny >= maxy) {\n          // degenerate polygon, all vertices have same y coordinate. Just ignore it from now:\n          vertices2d = [];\n          numvertices = 0;\n          minindex = -1;\n        } else {\n          if (!(miny in topy2polygonindexes)) {\n            topy2polygonindexes[miny] = [];\n          }\n          topy2polygonindexes[miny].push(polygonindex);\n        }\n      } // if(numvertices > 0)\n      // reverse the vertex order:\n      vertices2d.reverse();\n      minindex = numvertices - minindex - 1;\n      polygonvertices2d.push(vertices2d);\n      polygontopvertexindexes.push(minindex);\n    }\n    let ycoordinates = [];\n    for (let ycoordinate in ycoordinatetopolygonindexes)\n      ycoordinates.push(ycoordinate);\n    ycoordinates.sort(fnNumberSort);\n\n    // Now we will iterate over all y coordinates, from lowest to highest y coordinate\n    // activepolygons: source polygons that are 'active', i.e. intersect with our y coordinate\n    //   Is sorted so the polygons are in left to right order\n    // Each element in activepolygons has these properties:\n    //        polygonindex: the index of the source polygon (i.e. an index into the sourcepolygons\n    //                      and polygonvertices2d arrays)\n    //        leftvertexindex: the index of the vertex at the left side of the polygon (lowest x)\n    //                         that is at or just above the current y coordinate\n    //        rightvertexindex: dito at right hand side of polygon\n    //        topleft, bottomleft: coordinates of the left side of the polygon crossing the current y coordinate\n    //        topright, bottomright: coordinates of the right hand side of the polygon crossing the current y coordinate\n    let activepolygons = [];\n    let prevoutpolygonrow = [];\n    for (let yindex = 0; yindex < ycoordinates.length; yindex++) {\n      let newoutpolygonrow = [];\n      let ycoordinate_as_string = ycoordinates[yindex];\n      let ycoordinate = Number(ycoordinate_as_string);\n\n      // update activepolygons for this y coordinate:\n      // - Remove any polygons that end at this y coordinate\n      // - update leftvertexindex and rightvertexindex (which point to the current vertex index\n      //   at the the left and right side of the polygon\n      // Iterate over all polygons that have a corner at this y coordinate:\n      let polygonindexeswithcorner =\n        ycoordinatetopolygonindexes[ycoordinate_as_string];\n      for (\n        let activepolygonindex = 0;\n        activepolygonindex < activepolygons.length;\n        ++activepolygonindex\n      ) {\n        let activepolygon = activepolygons[activepolygonindex];\n        let polygonindex = activepolygon.polygonindex;\n        if (polygonindexeswithcorner[polygonindex]) {\n          // this active polygon has a corner at this y coordinate:\n          let vertices2d = polygonvertices2d[polygonindex];\n          let numvertices = vertices2d.length;\n          let newleftvertexindex = activepolygon.leftvertexindex;\n          let newrightvertexindex = activepolygon.rightvertexindex;\n          // See if we need to increase leftvertexindex or decrease rightvertexindex:\n          while (true) {\n            let nextleftvertexindex = newleftvertexindex + 1;\n            if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n            if (vertices2d[nextleftvertexindex].y !== ycoordinate) break;\n            newleftvertexindex = nextleftvertexindex;\n          }\n          let nextrightvertexindex = newrightvertexindex - 1;\n          if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n          if (vertices2d[nextrightvertexindex].y === ycoordinate) {\n            newrightvertexindex = nextrightvertexindex;\n          }\n          if (\n            newleftvertexindex !== activepolygon.leftvertexindex &&\n            newleftvertexindex === newrightvertexindex\n          ) {\n            // We have increased leftvertexindex or decreased rightvertexindex, and now they point to the same vertex\n            // This means that this is the bottom point of the polygon. We'll remove it:\n            activepolygons.splice(activepolygonindex, 1);\n            --activepolygonindex;\n          } else {\n            activepolygon.leftvertexindex = newleftvertexindex;\n            activepolygon.rightvertexindex = newrightvertexindex;\n            activepolygon.topleft = vertices2d[newleftvertexindex];\n            activepolygon.topright = vertices2d[newrightvertexindex];\n            let nextleftvertexindex = newleftvertexindex + 1;\n            if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n            activepolygon.bottomleft = vertices2d[nextleftvertexindex];\n            let nextrightvertexindex = newrightvertexindex - 1;\n            if (nextrightvertexindex < 0)\n              nextrightvertexindex = numvertices - 1;\n            activepolygon.bottomright = vertices2d[nextrightvertexindex];\n          }\n        } // if polygon has corner here\n      } // for activepolygonindex\n      let nextycoordinate;\n      if (yindex >= ycoordinates.length - 1) {\n        // last row, all polygons must be finished here:\n        activepolygons = [];\n        nextycoordinate = null;\n      } // yindex < ycoordinates.length-1\n      else {\n        nextycoordinate = Number(ycoordinates[yindex + 1]);\n        let middleycoordinate = 0.5 * (ycoordinate + nextycoordinate);\n        // update activepolygons by adding any polygons that start here:\n        let startingpolygonindexes = topy2polygonindexes[ycoordinate_as_string];\n        for (let polygonindex_key in startingpolygonindexes) {\n          let polygonindex = startingpolygonindexes[polygonindex_key];\n          let vertices2d = polygonvertices2d[polygonindex];\n          let numvertices = vertices2d.length;\n          let topvertexindex = polygontopvertexindexes[polygonindex];\n          // the top of the polygon may be a horizontal line. In that case topvertexindex can point to any point on this line.\n          // Find the left and right topmost vertices which have the current y coordinate:\n          let topleftvertexindex = topvertexindex;\n          while (true) {\n            let i = topleftvertexindex + 1;\n            if (i >= numvertices) i = 0;\n            if (vertices2d[i].y !== ycoordinate) break;\n            if (i === topvertexindex) break; // should not happen, but just to prevent endless loops\n            topleftvertexindex = i;\n          }\n          let toprightvertexindex = topvertexindex;\n          while (true) {\n            let i = toprightvertexindex - 1;\n            if (i < 0) i = numvertices - 1;\n            if (vertices2d[i].y !== ycoordinate) break;\n            if (i === topleftvertexindex) break; // should not happen, but just to prevent endless loops\n            toprightvertexindex = i;\n          }\n          let nextleftvertexindex = topleftvertexindex + 1;\n          if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n          let nextrightvertexindex = toprightvertexindex - 1;\n          if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n          let newactivepolygon = {\n            polygonindex: polygonindex,\n            leftvertexindex: topleftvertexindex,\n            rightvertexindex: toprightvertexindex,\n            topleft: vertices2d[topleftvertexindex],\n            topright: vertices2d[toprightvertexindex],\n            bottomleft: vertices2d[nextleftvertexindex],\n            bottomright: vertices2d[nextrightvertexindex],\n          };\n          insertSorted(activepolygons, newactivepolygon, function (el1, el2) {\n            let x1 = interpolateBetween2DPointsForY(\n              el1.topleft,\n              el1.bottomleft,\n              middleycoordinate\n            );\n            let x2 = interpolateBetween2DPointsForY(\n              el2.topleft,\n              el2.bottomleft,\n              middleycoordinate\n            );\n            if (x1 > x2) return 1;\n            if (x1 < x2) return -1;\n            return 0;\n          });\n        } // for(let polygonindex in startingpolygonindexes)\n      } //  yindex < ycoordinates.length-1\n      // if( (yindex === ycoordinates.length-1) || (nextycoordinate - ycoordinate > EPS) )\n      if (true) {\n        // Now activepolygons is up to date\n        // Build the output polygons for the next row in newoutpolygonrow:\n        for (let activepolygonKey in activepolygons) {\n          let activepolygon = activepolygons[activepolygonKey];\n          let polygonindex = activepolygon.polygonindex;\n          let vertices2d = polygonvertices2d[polygonindex];\n          let numvertices = vertices2d.length;\n\n          let x = interpolateBetween2DPointsForY(\n            activepolygon.topleft,\n            activepolygon.bottomleft,\n            ycoordinate\n          );\n          let topleft = Vector2D.Create(x, ycoordinate);\n          x = interpolateBetween2DPointsForY(\n            activepolygon.topright,\n            activepolygon.bottomright,\n            ycoordinate\n          );\n          let topright = Vector2D.Create(x, ycoordinate);\n          x = interpolateBetween2DPointsForY(\n            activepolygon.topleft,\n            activepolygon.bottomleft,\n            nextycoordinate\n          );\n          let bottomleft = Vector2D.Create(x, nextycoordinate);\n          x = interpolateBetween2DPointsForY(\n            activepolygon.topright,\n            activepolygon.bottomright,\n            nextycoordinate\n          );\n          let bottomright = Vector2D.Create(x, nextycoordinate);\n          let outpolygon = {\n            topleft: topleft,\n            topright: topright,\n            bottomleft: bottomleft,\n            bottomright: bottomright,\n            leftline: Line2D.fromPoints(topleft, bottomleft),\n            rightline: Line2D.fromPoints(bottomright, topright),\n          };\n          if (newoutpolygonrow.length > 0) {\n            let prevoutpolygon = newoutpolygonrow[newoutpolygonrow.length - 1];\n            let d1 = outpolygon.topleft.distanceTo(prevoutpolygon.topright);\n            let d2 = outpolygon.bottomleft.distanceTo(\n              prevoutpolygon.bottomright\n            );\n            if (d1 < EPS && d2 < EPS) {\n              // we can join this polygon with the one to the left:\n              outpolygon.topleft = prevoutpolygon.topleft;\n              outpolygon.leftline = prevoutpolygon.leftline;\n              outpolygon.bottomleft = prevoutpolygon.bottomleft;\n              newoutpolygonrow.splice(newoutpolygonrow.length - 1, 1);\n            }\n          }\n          newoutpolygonrow.push(outpolygon);\n        } // for(activepolygon in activepolygons)\n        if (yindex > 0) {\n          // try to match the new polygons against the previous row:\n          let prevcontinuedindexes = {};\n          let matchedindexes = {};\n          for (let i = 0; i < newoutpolygonrow.length; i++) {\n            let thispolygon = newoutpolygonrow[i];\n            for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {\n              if (!matchedindexes[ii]) {\n                // not already processed?\n                // We have a match if the sidelines are equal or if the top coordinates\n                // are on the sidelines of the previous polygon\n                let prevpolygon = prevoutpolygonrow[ii];\n                if (\n                  prevpolygon.bottomleft.distanceTo(thispolygon.topleft) < EPS\n                ) {\n                  if (\n                    prevpolygon.bottomright.distanceTo(thispolygon.topright) <\n                    EPS\n                  ) {\n                    // Yes, the top of this polygon matches the bottom of the previous:\n                    matchedindexes[ii] = true;\n                    // Now check if the joined polygon would remain convex:\n                    let d1 =\n                      thispolygon.leftline.direction().x -\n                      prevpolygon.leftline.direction().x;\n                    let d2 =\n                      thispolygon.rightline.direction().x -\n                      prevpolygon.rightline.direction().x;\n                    let leftlinecontinues = Math.abs(d1) < EPS;\n                    let rightlinecontinues = Math.abs(d2) < EPS;\n                    let leftlineisconvex = leftlinecontinues || d1 >= 0;\n                    let rightlineisconvex = rightlinecontinues || d2 >= 0;\n                    if (leftlineisconvex && rightlineisconvex) {\n                      // yes, both sides have convex corners:\n                      // This polygon will continue the previous polygon\n                      thispolygon.outpolygon = prevpolygon.outpolygon;\n                      thispolygon.leftlinecontinues = leftlinecontinues;\n                      thispolygon.rightlinecontinues = rightlinecontinues;\n                      prevcontinuedindexes[ii] = true;\n                    }\n                    break;\n                  }\n                }\n              } // if(!prevcontinuedindexes[ii])\n            } // for ii\n          } // for i\n          for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {\n            if (!prevcontinuedindexes[ii]) {\n              // polygon ends here\n              // Finish the polygon with the last point(s):\n              let prevpolygon = prevoutpolygonrow[ii];\n              prevpolygon.outpolygon.rightpoints.push(prevpolygon.bottomright);\n              if (\n                prevpolygon.bottomright.distanceTo(prevpolygon.bottomleft) > EPS\n              ) {\n                // polygon ends with a horizontal line:\n                prevpolygon.outpolygon.leftpoints.push(prevpolygon.bottomleft);\n              }\n              // reverse the left half so we get a counterclockwise circle:\n              prevpolygon.outpolygon.leftpoints.reverse();\n              let points2d = prevpolygon.outpolygon.rightpoints.concat(\n                prevpolygon.outpolygon.leftpoints\n              );\n              let vertices3d = [];\n              points2d.map(function (point2d) {\n                let point3d = orthobasis.to3D(point2d);\n                let vertex3d = new Vertex(point3d);\n                vertices3d.push(vertex3d);\n              });\n              let polygon = new Polygon(vertices3d, shared, plane);\n              destpolygons.push(polygon);\n            }\n          }\n        } // if(yindex > 0)\n        for (let i = 0; i < newoutpolygonrow.length; i++) {\n          let thispolygon = newoutpolygonrow[i];\n          if (!thispolygon.outpolygon) {\n            // polygon starts here:\n            thispolygon.outpolygon = {\n              leftpoints: [],\n              rightpoints: [],\n            };\n            thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);\n            if (thispolygon.topleft.distanceTo(thispolygon.topright) > EPS) {\n              // we have a horizontal line at the top:\n              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);\n            }\n          } else {\n            // continuation of a previous row\n            if (!thispolygon.leftlinecontinues) {\n              thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);\n            }\n            if (!thispolygon.rightlinecontinues) {\n              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);\n            }\n          }\n        }\n        prevoutpolygonrow = newoutpolygonrow;\n      }\n    } // for yindex\n  } // if(numpolygons > 0)\n};\n\nmodule.exports = reTesselateCoplanarPolygons;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tYXRoL3JlVGVzc2VsYXRlQ29wbGFuYXJQb2x5Z29ucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL21hdGgvcmVUZXNzZWxhdGVDb3BsYW5hclBvbHlnb25zLmpzP2NhZjgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBFUFMgfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgT3J0aG9Ob3JtYWxCYXNpcyA9IHJlcXVpcmUoJy4vT3J0aG9Ob3JtYWxCYXNpcycpO1xuY29uc3Qge1xuICBpbnRlcnBvbGF0ZUJldHdlZW4yRFBvaW50c0ZvclksXG4gIGluc2VydFNvcnRlZCxcbiAgZm5OdW1iZXJTb3J0LFxufSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBWZXJ0ZXggPSByZXF1aXJlKCcuL1ZlcnRleDMnKTtcbmNvbnN0IFZlY3RvcjJEID0gcmVxdWlyZSgnLi9WZWN0b3IyJyk7XG5jb25zdCBMaW5lMkQgPSByZXF1aXJlKCcuL0xpbmUyJyk7XG5jb25zdCBQb2x5Z29uID0gcmVxdWlyZSgnLi9Qb2x5Z29uMycpO1xuXG4vLyBSZXRlc3NlbGF0aW9uIGZ1bmN0aW9uIGZvciBhIHNldCBvZiBjb3BsYW5hciBwb2x5Z29ucy4gU2VlIHRoZSBpbnRyb2R1Y3Rpb24gYXQgdGhlIHRvcCBvZlxuLy8gdGhpcyBmaWxlLlxuY29uc3QgcmVUZXNzZWxhdGVDb3BsYW5hclBvbHlnb25zID0gZnVuY3Rpb24gKHNvdXJjZXBvbHlnb25zLCBkZXN0cG9seWdvbnMpIHtcbiAgbGV0IG51bXBvbHlnb25zID0gc291cmNlcG9seWdvbnMubGVuZ3RoO1xuICBpZiAobnVtcG9seWdvbnMgPiAwKSB7XG4gICAgbGV0IHBsYW5lID0gc291cmNlcG9seWdvbnNbMF0ucGxhbmU7XG4gICAgbGV0IHNoYXJlZCA9IHNvdXJjZXBvbHlnb25zWzBdLnNoYXJlZDtcbiAgICBsZXQgb3J0aG9iYXNpcyA9IG5ldyBPcnRob05vcm1hbEJhc2lzKHBsYW5lKTtcbiAgICBsZXQgcG9seWdvbnZlcnRpY2VzMmQgPSBbXTsgLy8gYXJyYXkgb2YgYXJyYXkgb2YgVmVjdG9yMkRcbiAgICBsZXQgcG9seWdvbnRvcHZlcnRleGluZGV4ZXMgPSBbXTsgLy8gYXJyYXkgb2YgaW5kZXhlcyBvZiB0b3Btb3N0IHZlcnRleCBwZXIgcG9seWdvblxuICAgIGxldCB0b3B5MnBvbHlnb25pbmRleGVzID0ge307XG4gICAgbGV0IHljb29yZGluYXRldG9wb2x5Z29uaW5kZXhlcyA9IHt9O1xuXG4gICAgbGV0IHhjb29yZGluYXRlYmlucyA9IHt9O1xuICAgIGxldCB5Y29vcmRpbmF0ZWJpbnMgPSB7fTtcblxuICAgIC8vIGNvbnZlcnQgYWxsIHBvbHlnb24gdmVydGljZXMgdG8gMkRcbiAgICAvLyBNYWtlIGEgbGlzdCBvZiBhbGwgZW5jb3VudGVyZWQgeSBjb29yZGluYXRlc1xuICAgIC8vIEFuZCBidWlsZCBhIG1hcCBvZiBhbGwgcG9seWdvbnMgdGhhdCBoYXZlIGEgdmVydGV4IGF0IGEgY2VydGFpbiB5IGNvb3JkaW5hdGU6XG4gICAgbGV0IHljb29yZGluYXRlQmlubmluZ0ZhY3RvciA9ICgxLjAgLyBFUFMpICogMTA7XG4gICAgZm9yIChsZXQgcG9seWdvbmluZGV4ID0gMDsgcG9seWdvbmluZGV4IDwgbnVtcG9seWdvbnM7IHBvbHlnb25pbmRleCsrKSB7XG4gICAgICBsZXQgcG9seTNkID0gc291cmNlcG9seWdvbnNbcG9seWdvbmluZGV4XTtcbiAgICAgIGxldCB2ZXJ0aWNlczJkID0gW107XG4gICAgICBsZXQgbnVtdmVydGljZXMgPSBwb2x5M2QudmVydGljZXMubGVuZ3RoO1xuICAgICAgbGV0IG1pbmluZGV4ID0gLTE7XG4gICAgICBpZiAobnVtdmVydGljZXMgPiAwKSB7XG4gICAgICAgIGxldCBtaW55LCBtYXh5LCBtYXhpbmRleDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW12ZXJ0aWNlczsgaSsrKSB7XG4gICAgICAgICAgbGV0IHBvczJkID0gb3J0aG9iYXNpcy50bzJEKHBvbHkzZC52ZXJ0aWNlc1tpXS5wb3MpO1xuICAgICAgICAgIC8vIHBlcmZvcm0gYmlubmluZyBvZiB5IGNvb3JkaW5hdGVzOiBJZiB3ZSBoYXZlIG11bHRpcGxlIHZlcnRpY2VzIHZlcnlcbiAgICAgICAgICAvLyBjbG9zZSB0byBlYWNoIG90aGVyLCBnaXZlIHRoZW0gdGhlIHNhbWUgeSBjb29yZGluYXRlOlxuICAgICAgICAgIGxldCB5Y29vcmRpbmF0ZWJpbiA9IE1hdGguZmxvb3IocG9zMmQueSAqIHljb29yZGluYXRlQmlubmluZ0ZhY3Rvcik7XG4gICAgICAgICAgbGV0IG5ld3k7XG4gICAgICAgICAgaWYgKHljb29yZGluYXRlYmluIGluIHljb29yZGluYXRlYmlucykge1xuICAgICAgICAgICAgbmV3eSA9IHljb29yZGluYXRlYmluc1t5Y29vcmRpbmF0ZWJpbl07XG4gICAgICAgICAgfSBlbHNlIGlmICh5Y29vcmRpbmF0ZWJpbiArIDEgaW4geWNvb3JkaW5hdGViaW5zKSB7XG4gICAgICAgICAgICBuZXd5ID0geWNvb3JkaW5hdGViaW5zW3ljb29yZGluYXRlYmluICsgMV07XG4gICAgICAgICAgfSBlbHNlIGlmICh5Y29vcmRpbmF0ZWJpbiAtIDEgaW4geWNvb3JkaW5hdGViaW5zKSB7XG4gICAgICAgICAgICBuZXd5ID0geWNvb3JkaW5hdGViaW5zW3ljb29yZGluYXRlYmluIC0gMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld3kgPSBwb3MyZC55O1xuICAgICAgICAgICAgeWNvb3JkaW5hdGViaW5zW3ljb29yZGluYXRlYmluXSA9IHBvczJkLnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvczJkID0gVmVjdG9yMkQuQ3JlYXRlKHBvczJkLngsIG5ld3kpO1xuICAgICAgICAgIHZlcnRpY2VzMmQucHVzaChwb3MyZCk7XG4gICAgICAgICAgbGV0IHkgPSBwb3MyZC55O1xuICAgICAgICAgIGlmIChpID09PSAwIHx8IHkgPCBtaW55KSB7XG4gICAgICAgICAgICBtaW55ID0geTtcbiAgICAgICAgICAgIG1pbmluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDAgfHwgeSA+IG1heHkpIHtcbiAgICAgICAgICAgIG1heHkgPSB5O1xuICAgICAgICAgICAgbWF4aW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISh5IGluIHljb29yZGluYXRldG9wb2x5Z29uaW5kZXhlcykpIHtcbiAgICAgICAgICAgIHljb29yZGluYXRldG9wb2x5Z29uaW5kZXhlc1t5XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB5Y29vcmRpbmF0ZXRvcG9seWdvbmluZGV4ZXNbeV1bcG9seWdvbmluZGV4XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbnkgPj0gbWF4eSkge1xuICAgICAgICAgIC8vIGRlZ2VuZXJhdGUgcG9seWdvbiwgYWxsIHZlcnRpY2VzIGhhdmUgc2FtZSB5IGNvb3JkaW5hdGUuIEp1c3QgaWdub3JlIGl0IGZyb20gbm93OlxuICAgICAgICAgIHZlcnRpY2VzMmQgPSBbXTtcbiAgICAgICAgICBudW12ZXJ0aWNlcyA9IDA7XG4gICAgICAgICAgbWluaW5kZXggPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIShtaW55IGluIHRvcHkycG9seWdvbmluZGV4ZXMpKSB7XG4gICAgICAgICAgICB0b3B5MnBvbHlnb25pbmRleGVzW21pbnldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvcHkycG9seWdvbmluZGV4ZXNbbWlueV0ucHVzaChwb2x5Z29uaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmKG51bXZlcnRpY2VzID4gMClcbiAgICAgIC8vIHJldmVyc2UgdGhlIHZlcnRleCBvcmRlcjpcbiAgICAgIHZlcnRpY2VzMmQucmV2ZXJzZSgpO1xuICAgICAgbWluaW5kZXggPSBudW12ZXJ0aWNlcyAtIG1pbmluZGV4IC0gMTtcbiAgICAgIHBvbHlnb252ZXJ0aWNlczJkLnB1c2godmVydGljZXMyZCk7XG4gICAgICBwb2x5Z29udG9wdmVydGV4aW5kZXhlcy5wdXNoKG1pbmluZGV4KTtcbiAgICB9XG4gICAgbGV0IHljb29yZGluYXRlcyA9IFtdO1xuICAgIGZvciAobGV0IHljb29yZGluYXRlIGluIHljb29yZGluYXRldG9wb2x5Z29uaW5kZXhlcylcbiAgICAgIHljb29yZGluYXRlcy5wdXNoKHljb29yZGluYXRlKTtcbiAgICB5Y29vcmRpbmF0ZXMuc29ydChmbk51bWJlclNvcnQpO1xuXG4gICAgLy8gTm93IHdlIHdpbGwgaXRlcmF0ZSBvdmVyIGFsbCB5IGNvb3JkaW5hdGVzLCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0IHkgY29vcmRpbmF0ZVxuICAgIC8vIGFjdGl2ZXBvbHlnb25zOiBzb3VyY2UgcG9seWdvbnMgdGhhdCBhcmUgJ2FjdGl2ZScsIGkuZS4gaW50ZXJzZWN0IHdpdGggb3VyIHkgY29vcmRpbmF0ZVxuICAgIC8vICAgSXMgc29ydGVkIHNvIHRoZSBwb2x5Z29ucyBhcmUgaW4gbGVmdCB0byByaWdodCBvcmRlclxuICAgIC8vIEVhY2ggZWxlbWVudCBpbiBhY3RpdmVwb2x5Z29ucyBoYXMgdGhlc2UgcHJvcGVydGllczpcbiAgICAvLyAgICAgICAgcG9seWdvbmluZGV4OiB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBwb2x5Z29uIChpLmUuIGFuIGluZGV4IGludG8gdGhlIHNvdXJjZXBvbHlnb25zXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgYW5kIHBvbHlnb252ZXJ0aWNlczJkIGFycmF5cylcbiAgICAvLyAgICAgICAgbGVmdHZlcnRleGluZGV4OiB0aGUgaW5kZXggb2YgdGhlIHZlcnRleCBhdCB0aGUgbGVmdCBzaWRlIG9mIHRoZSBwb2x5Z29uIChsb3dlc3QgeClcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IGlzIGF0IG9yIGp1c3QgYWJvdmUgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG4gICAgLy8gICAgICAgIHJpZ2h0dmVydGV4aW5kZXg6IGRpdG8gYXQgcmlnaHQgaGFuZCBzaWRlIG9mIHBvbHlnb25cbiAgICAvLyAgICAgICAgdG9wbGVmdCwgYm90dG9tbGVmdDogY29vcmRpbmF0ZXMgb2YgdGhlIGxlZnQgc2lkZSBvZiB0aGUgcG9seWdvbiBjcm9zc2luZyB0aGUgY3VycmVudCB5IGNvb3JkaW5hdGVcbiAgICAvLyAgICAgICAgdG9wcmlnaHQsIGJvdHRvbXJpZ2h0OiBjb29yZGluYXRlcyBvZiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBwb2x5Z29uIGNyb3NzaW5nIHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuICAgIGxldCBhY3RpdmVwb2x5Z29ucyA9IFtdO1xuICAgIGxldCBwcmV2b3V0cG9seWdvbnJvdyA9IFtdO1xuICAgIGZvciAobGV0IHlpbmRleCA9IDA7IHlpbmRleCA8IHljb29yZGluYXRlcy5sZW5ndGg7IHlpbmRleCsrKSB7XG4gICAgICBsZXQgbmV3b3V0cG9seWdvbnJvdyA9IFtdO1xuICAgICAgbGV0IHljb29yZGluYXRlX2FzX3N0cmluZyA9IHljb29yZGluYXRlc1t5aW5kZXhdO1xuICAgICAgbGV0IHljb29yZGluYXRlID0gTnVtYmVyKHljb29yZGluYXRlX2FzX3N0cmluZyk7XG5cbiAgICAgIC8vIHVwZGF0ZSBhY3RpdmVwb2x5Z29ucyBmb3IgdGhpcyB5IGNvb3JkaW5hdGU6XG4gICAgICAvLyAtIFJlbW92ZSBhbnkgcG9seWdvbnMgdGhhdCBlbmQgYXQgdGhpcyB5IGNvb3JkaW5hdGVcbiAgICAgIC8vIC0gdXBkYXRlIGxlZnR2ZXJ0ZXhpbmRleCBhbmQgcmlnaHR2ZXJ0ZXhpbmRleCAod2hpY2ggcG9pbnQgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGluZGV4XG4gICAgICAvLyAgIGF0IHRoZSB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgcG9seWdvblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBwb2x5Z29ucyB0aGF0IGhhdmUgYSBjb3JuZXIgYXQgdGhpcyB5IGNvb3JkaW5hdGU6XG4gICAgICBsZXQgcG9seWdvbmluZGV4ZXN3aXRoY29ybmVyID1cbiAgICAgICAgeWNvb3JkaW5hdGV0b3BvbHlnb25pbmRleGVzW3ljb29yZGluYXRlX2FzX3N0cmluZ107XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgYWN0aXZlcG9seWdvbmluZGV4ID0gMDtcbiAgICAgICAgYWN0aXZlcG9seWdvbmluZGV4IDwgYWN0aXZlcG9seWdvbnMubGVuZ3RoO1xuICAgICAgICArK2FjdGl2ZXBvbHlnb25pbmRleFxuICAgICAgKSB7XG4gICAgICAgIGxldCBhY3RpdmVwb2x5Z29uID0gYWN0aXZlcG9seWdvbnNbYWN0aXZlcG9seWdvbmluZGV4XTtcbiAgICAgICAgbGV0IHBvbHlnb25pbmRleCA9IGFjdGl2ZXBvbHlnb24ucG9seWdvbmluZGV4O1xuICAgICAgICBpZiAocG9seWdvbmluZGV4ZXN3aXRoY29ybmVyW3BvbHlnb25pbmRleF0pIHtcbiAgICAgICAgICAvLyB0aGlzIGFjdGl2ZSBwb2x5Z29uIGhhcyBhIGNvcm5lciBhdCB0aGlzIHkgY29vcmRpbmF0ZTpcbiAgICAgICAgICBsZXQgdmVydGljZXMyZCA9IHBvbHlnb252ZXJ0aWNlczJkW3BvbHlnb25pbmRleF07XG4gICAgICAgICAgbGV0IG51bXZlcnRpY2VzID0gdmVydGljZXMyZC5sZW5ndGg7XG4gICAgICAgICAgbGV0IG5ld2xlZnR2ZXJ0ZXhpbmRleCA9IGFjdGl2ZXBvbHlnb24ubGVmdHZlcnRleGluZGV4O1xuICAgICAgICAgIGxldCBuZXdyaWdodHZlcnRleGluZGV4ID0gYWN0aXZlcG9seWdvbi5yaWdodHZlcnRleGluZGV4O1xuICAgICAgICAgIC8vIFNlZSBpZiB3ZSBuZWVkIHRvIGluY3JlYXNlIGxlZnR2ZXJ0ZXhpbmRleCBvciBkZWNyZWFzZSByaWdodHZlcnRleGluZGV4OlxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQgbmV4dGxlZnR2ZXJ0ZXhpbmRleCA9IG5ld2xlZnR2ZXJ0ZXhpbmRleCArIDE7XG4gICAgICAgICAgICBpZiAobmV4dGxlZnR2ZXJ0ZXhpbmRleCA+PSBudW12ZXJ0aWNlcykgbmV4dGxlZnR2ZXJ0ZXhpbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAodmVydGljZXMyZFtuZXh0bGVmdHZlcnRleGluZGV4XS55ICE9PSB5Y29vcmRpbmF0ZSkgYnJlYWs7XG4gICAgICAgICAgICBuZXdsZWZ0dmVydGV4aW5kZXggPSBuZXh0bGVmdHZlcnRleGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbmV4dHJpZ2h0dmVydGV4aW5kZXggPSBuZXdyaWdodHZlcnRleGluZGV4IC0gMTtcbiAgICAgICAgICBpZiAobmV4dHJpZ2h0dmVydGV4aW5kZXggPCAwKSBuZXh0cmlnaHR2ZXJ0ZXhpbmRleCA9IG51bXZlcnRpY2VzIC0gMTtcbiAgICAgICAgICBpZiAodmVydGljZXMyZFtuZXh0cmlnaHR2ZXJ0ZXhpbmRleF0ueSA9PT0geWNvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgIG5ld3JpZ2h0dmVydGV4aW5kZXggPSBuZXh0cmlnaHR2ZXJ0ZXhpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmV3bGVmdHZlcnRleGluZGV4ICE9PSBhY3RpdmVwb2x5Z29uLmxlZnR2ZXJ0ZXhpbmRleCAmJlxuICAgICAgICAgICAgbmV3bGVmdHZlcnRleGluZGV4ID09PSBuZXdyaWdodHZlcnRleGluZGV4XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGluY3JlYXNlZCBsZWZ0dmVydGV4aW5kZXggb3IgZGVjcmVhc2VkIHJpZ2h0dmVydGV4aW5kZXgsIGFuZCBub3cgdGhleSBwb2ludCB0byB0aGUgc2FtZSB2ZXJ0ZXhcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGlzIGlzIHRoZSBib3R0b20gcG9pbnQgb2YgdGhlIHBvbHlnb24uIFdlJ2xsIHJlbW92ZSBpdDpcbiAgICAgICAgICAgIGFjdGl2ZXBvbHlnb25zLnNwbGljZShhY3RpdmVwb2x5Z29uaW5kZXgsIDEpO1xuICAgICAgICAgICAgLS1hY3RpdmVwb2x5Z29uaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZXBvbHlnb24ubGVmdHZlcnRleGluZGV4ID0gbmV3bGVmdHZlcnRleGluZGV4O1xuICAgICAgICAgICAgYWN0aXZlcG9seWdvbi5yaWdodHZlcnRleGluZGV4ID0gbmV3cmlnaHR2ZXJ0ZXhpbmRleDtcbiAgICAgICAgICAgIGFjdGl2ZXBvbHlnb24udG9wbGVmdCA9IHZlcnRpY2VzMmRbbmV3bGVmdHZlcnRleGluZGV4XTtcbiAgICAgICAgICAgIGFjdGl2ZXBvbHlnb24udG9wcmlnaHQgPSB2ZXJ0aWNlczJkW25ld3JpZ2h0dmVydGV4aW5kZXhdO1xuICAgICAgICAgICAgbGV0IG5leHRsZWZ0dmVydGV4aW5kZXggPSBuZXdsZWZ0dmVydGV4aW5kZXggKyAxO1xuICAgICAgICAgICAgaWYgKG5leHRsZWZ0dmVydGV4aW5kZXggPj0gbnVtdmVydGljZXMpIG5leHRsZWZ0dmVydGV4aW5kZXggPSAwO1xuICAgICAgICAgICAgYWN0aXZlcG9seWdvbi5ib3R0b21sZWZ0ID0gdmVydGljZXMyZFtuZXh0bGVmdHZlcnRleGluZGV4XTtcbiAgICAgICAgICAgIGxldCBuZXh0cmlnaHR2ZXJ0ZXhpbmRleCA9IG5ld3JpZ2h0dmVydGV4aW5kZXggLSAxO1xuICAgICAgICAgICAgaWYgKG5leHRyaWdodHZlcnRleGluZGV4IDwgMClcbiAgICAgICAgICAgICAgbmV4dHJpZ2h0dmVydGV4aW5kZXggPSBudW12ZXJ0aWNlcyAtIDE7XG4gICAgICAgICAgICBhY3RpdmVwb2x5Z29uLmJvdHRvbXJpZ2h0ID0gdmVydGljZXMyZFtuZXh0cmlnaHR2ZXJ0ZXhpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHBvbHlnb24gaGFzIGNvcm5lciBoZXJlXG4gICAgICB9IC8vIGZvciBhY3RpdmVwb2x5Z29uaW5kZXhcbiAgICAgIGxldCBuZXh0eWNvb3JkaW5hdGU7XG4gICAgICBpZiAoeWluZGV4ID49IHljb29yZGluYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIGxhc3Qgcm93LCBhbGwgcG9seWdvbnMgbXVzdCBiZSBmaW5pc2hlZCBoZXJlOlxuICAgICAgICBhY3RpdmVwb2x5Z29ucyA9IFtdO1xuICAgICAgICBuZXh0eWNvb3JkaW5hdGUgPSBudWxsO1xuICAgICAgfSAvLyB5aW5kZXggPCB5Y29vcmRpbmF0ZXMubGVuZ3RoLTFcbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXh0eWNvb3JkaW5hdGUgPSBOdW1iZXIoeWNvb3JkaW5hdGVzW3lpbmRleCArIDFdKTtcbiAgICAgICAgbGV0IG1pZGRsZXljb29yZGluYXRlID0gMC41ICogKHljb29yZGluYXRlICsgbmV4dHljb29yZGluYXRlKTtcbiAgICAgICAgLy8gdXBkYXRlIGFjdGl2ZXBvbHlnb25zIGJ5IGFkZGluZyBhbnkgcG9seWdvbnMgdGhhdCBzdGFydCBoZXJlOlxuICAgICAgICBsZXQgc3RhcnRpbmdwb2x5Z29uaW5kZXhlcyA9IHRvcHkycG9seWdvbmluZGV4ZXNbeWNvb3JkaW5hdGVfYXNfc3RyaW5nXTtcbiAgICAgICAgZm9yIChsZXQgcG9seWdvbmluZGV4X2tleSBpbiBzdGFydGluZ3BvbHlnb25pbmRleGVzKSB7XG4gICAgICAgICAgbGV0IHBvbHlnb25pbmRleCA9IHN0YXJ0aW5ncG9seWdvbmluZGV4ZXNbcG9seWdvbmluZGV4X2tleV07XG4gICAgICAgICAgbGV0IHZlcnRpY2VzMmQgPSBwb2x5Z29udmVydGljZXMyZFtwb2x5Z29uaW5kZXhdO1xuICAgICAgICAgIGxldCBudW12ZXJ0aWNlcyA9IHZlcnRpY2VzMmQubGVuZ3RoO1xuICAgICAgICAgIGxldCB0b3B2ZXJ0ZXhpbmRleCA9IHBvbHlnb250b3B2ZXJ0ZXhpbmRleGVzW3BvbHlnb25pbmRleF07XG4gICAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgcG9seWdvbiBtYXkgYmUgYSBob3Jpem9udGFsIGxpbmUuIEluIHRoYXQgY2FzZSB0b3B2ZXJ0ZXhpbmRleCBjYW4gcG9pbnQgdG8gYW55IHBvaW50IG9uIHRoaXMgbGluZS5cbiAgICAgICAgICAvLyBGaW5kIHRoZSBsZWZ0IGFuZCByaWdodCB0b3Btb3N0IHZlcnRpY2VzIHdoaWNoIGhhdmUgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlOlxuICAgICAgICAgIGxldCB0b3BsZWZ0dmVydGV4aW5kZXggPSB0b3B2ZXJ0ZXhpbmRleDtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGkgPSB0b3BsZWZ0dmVydGV4aW5kZXggKyAxO1xuICAgICAgICAgICAgaWYgKGkgPj0gbnVtdmVydGljZXMpIGkgPSAwO1xuICAgICAgICAgICAgaWYgKHZlcnRpY2VzMmRbaV0ueSAhPT0geWNvb3JkaW5hdGUpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGkgPT09IHRvcHZlcnRleGluZGV4KSBicmVhazsgLy8gc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCBqdXN0IHRvIHByZXZlbnQgZW5kbGVzcyBsb29wc1xuICAgICAgICAgICAgdG9wbGVmdHZlcnRleGluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHRvcHJpZ2h0dmVydGV4aW5kZXggPSB0b3B2ZXJ0ZXhpbmRleDtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGkgPSB0b3ByaWdodHZlcnRleGluZGV4IC0gMTtcbiAgICAgICAgICAgIGlmIChpIDwgMCkgaSA9IG51bXZlcnRpY2VzIC0gMTtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlczJkW2ldLnkgIT09IHljb29yZGluYXRlKSBicmVhaztcbiAgICAgICAgICAgIGlmIChpID09PSB0b3BsZWZ0dmVydGV4aW5kZXgpIGJyZWFrOyAvLyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IGp1c3QgdG8gcHJldmVudCBlbmRsZXNzIGxvb3BzXG4gICAgICAgICAgICB0b3ByaWdodHZlcnRleGluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG5leHRsZWZ0dmVydGV4aW5kZXggPSB0b3BsZWZ0dmVydGV4aW5kZXggKyAxO1xuICAgICAgICAgIGlmIChuZXh0bGVmdHZlcnRleGluZGV4ID49IG51bXZlcnRpY2VzKSBuZXh0bGVmdHZlcnRleGluZGV4ID0gMDtcbiAgICAgICAgICBsZXQgbmV4dHJpZ2h0dmVydGV4aW5kZXggPSB0b3ByaWdodHZlcnRleGluZGV4IC0gMTtcbiAgICAgICAgICBpZiAobmV4dHJpZ2h0dmVydGV4aW5kZXggPCAwKSBuZXh0cmlnaHR2ZXJ0ZXhpbmRleCA9IG51bXZlcnRpY2VzIC0gMTtcbiAgICAgICAgICBsZXQgbmV3YWN0aXZlcG9seWdvbiA9IHtcbiAgICAgICAgICAgIHBvbHlnb25pbmRleDogcG9seWdvbmluZGV4LFxuICAgICAgICAgICAgbGVmdHZlcnRleGluZGV4OiB0b3BsZWZ0dmVydGV4aW5kZXgsXG4gICAgICAgICAgICByaWdodHZlcnRleGluZGV4OiB0b3ByaWdodHZlcnRleGluZGV4LFxuICAgICAgICAgICAgdG9wbGVmdDogdmVydGljZXMyZFt0b3BsZWZ0dmVydGV4aW5kZXhdLFxuICAgICAgICAgICAgdG9wcmlnaHQ6IHZlcnRpY2VzMmRbdG9wcmlnaHR2ZXJ0ZXhpbmRleF0sXG4gICAgICAgICAgICBib3R0b21sZWZ0OiB2ZXJ0aWNlczJkW25leHRsZWZ0dmVydGV4aW5kZXhdLFxuICAgICAgICAgICAgYm90dG9tcmlnaHQ6IHZlcnRpY2VzMmRbbmV4dHJpZ2h0dmVydGV4aW5kZXhdLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaW5zZXJ0U29ydGVkKGFjdGl2ZXBvbHlnb25zLCBuZXdhY3RpdmVwb2x5Z29uLCBmdW5jdGlvbiAoZWwxLCBlbDIpIHtcbiAgICAgICAgICAgIGxldCB4MSA9IGludGVycG9sYXRlQmV0d2VlbjJEUG9pbnRzRm9yWShcbiAgICAgICAgICAgICAgZWwxLnRvcGxlZnQsXG4gICAgICAgICAgICAgIGVsMS5ib3R0b21sZWZ0LFxuICAgICAgICAgICAgICBtaWRkbGV5Y29vcmRpbmF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCB4MiA9IGludGVycG9sYXRlQmV0d2VlbjJEUG9pbnRzRm9yWShcbiAgICAgICAgICAgICAgZWwyLnRvcGxlZnQsXG4gICAgICAgICAgICAgIGVsMi5ib3R0b21sZWZ0LFxuICAgICAgICAgICAgICBtaWRkbGV5Y29vcmRpbmF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh4MSA+IHgyKSByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmICh4MSA8IHgyKSByZXR1cm4gLTE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBmb3IobGV0IHBvbHlnb25pbmRleCBpbiBzdGFydGluZ3BvbHlnb25pbmRleGVzKVxuICAgICAgfSAvLyAgeWluZGV4IDwgeWNvb3JkaW5hdGVzLmxlbmd0aC0xXG4gICAgICAvLyBpZiggKHlpbmRleCA9PT0geWNvb3JkaW5hdGVzLmxlbmd0aC0xKSB8fCAobmV4dHljb29yZGluYXRlIC0geWNvb3JkaW5hdGUgPiBFUFMpIClcbiAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgIC8vIE5vdyBhY3RpdmVwb2x5Z29ucyBpcyB1cCB0byBkYXRlXG4gICAgICAgIC8vIEJ1aWxkIHRoZSBvdXRwdXQgcG9seWdvbnMgZm9yIHRoZSBuZXh0IHJvdyBpbiBuZXdvdXRwb2x5Z29ucm93OlxuICAgICAgICBmb3IgKGxldCBhY3RpdmVwb2x5Z29uS2V5IGluIGFjdGl2ZXBvbHlnb25zKSB7XG4gICAgICAgICAgbGV0IGFjdGl2ZXBvbHlnb24gPSBhY3RpdmVwb2x5Z29uc1thY3RpdmVwb2x5Z29uS2V5XTtcbiAgICAgICAgICBsZXQgcG9seWdvbmluZGV4ID0gYWN0aXZlcG9seWdvbi5wb2x5Z29uaW5kZXg7XG4gICAgICAgICAgbGV0IHZlcnRpY2VzMmQgPSBwb2x5Z29udmVydGljZXMyZFtwb2x5Z29uaW5kZXhdO1xuICAgICAgICAgIGxldCBudW12ZXJ0aWNlcyA9IHZlcnRpY2VzMmQubGVuZ3RoO1xuXG4gICAgICAgICAgbGV0IHggPSBpbnRlcnBvbGF0ZUJldHdlZW4yRFBvaW50c0ZvclkoXG4gICAgICAgICAgICBhY3RpdmVwb2x5Z29uLnRvcGxlZnQsXG4gICAgICAgICAgICBhY3RpdmVwb2x5Z29uLmJvdHRvbWxlZnQsXG4gICAgICAgICAgICB5Y29vcmRpbmF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHRvcGxlZnQgPSBWZWN0b3IyRC5DcmVhdGUoeCwgeWNvb3JkaW5hdGUpO1xuICAgICAgICAgIHggPSBpbnRlcnBvbGF0ZUJldHdlZW4yRFBvaW50c0ZvclkoXG4gICAgICAgICAgICBhY3RpdmVwb2x5Z29uLnRvcHJpZ2h0LFxuICAgICAgICAgICAgYWN0aXZlcG9seWdvbi5ib3R0b21yaWdodCxcbiAgICAgICAgICAgIHljb29yZGluYXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgdG9wcmlnaHQgPSBWZWN0b3IyRC5DcmVhdGUoeCwgeWNvb3JkaW5hdGUpO1xuICAgICAgICAgIHggPSBpbnRlcnBvbGF0ZUJldHdlZW4yRFBvaW50c0ZvclkoXG4gICAgICAgICAgICBhY3RpdmVwb2x5Z29uLnRvcGxlZnQsXG4gICAgICAgICAgICBhY3RpdmVwb2x5Z29uLmJvdHRvbWxlZnQsXG4gICAgICAgICAgICBuZXh0eWNvb3JkaW5hdGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBib3R0b21sZWZ0ID0gVmVjdG9yMkQuQ3JlYXRlKHgsIG5leHR5Y29vcmRpbmF0ZSk7XG4gICAgICAgICAgeCA9IGludGVycG9sYXRlQmV0d2VlbjJEUG9pbnRzRm9yWShcbiAgICAgICAgICAgIGFjdGl2ZXBvbHlnb24udG9wcmlnaHQsXG4gICAgICAgICAgICBhY3RpdmVwb2x5Z29uLmJvdHRvbXJpZ2h0LFxuICAgICAgICAgICAgbmV4dHljb29yZGluYXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgYm90dG9tcmlnaHQgPSBWZWN0b3IyRC5DcmVhdGUoeCwgbmV4dHljb29yZGluYXRlKTtcbiAgICAgICAgICBsZXQgb3V0cG9seWdvbiA9IHtcbiAgICAgICAgICAgIHRvcGxlZnQ6IHRvcGxlZnQsXG4gICAgICAgICAgICB0b3ByaWdodDogdG9wcmlnaHQsXG4gICAgICAgICAgICBib3R0b21sZWZ0OiBib3R0b21sZWZ0LFxuICAgICAgICAgICAgYm90dG9tcmlnaHQ6IGJvdHRvbXJpZ2h0LFxuICAgICAgICAgICAgbGVmdGxpbmU6IExpbmUyRC5mcm9tUG9pbnRzKHRvcGxlZnQsIGJvdHRvbWxlZnQpLFxuICAgICAgICAgICAgcmlnaHRsaW5lOiBMaW5lMkQuZnJvbVBvaW50cyhib3R0b21yaWdodCwgdG9wcmlnaHQpLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG5ld291dHBvbHlnb25yb3cubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHByZXZvdXRwb2x5Z29uID0gbmV3b3V0cG9seWdvbnJvd1tuZXdvdXRwb2x5Z29ucm93Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGV0IGQxID0gb3V0cG9seWdvbi50b3BsZWZ0LmRpc3RhbmNlVG8ocHJldm91dHBvbHlnb24udG9wcmlnaHQpO1xuICAgICAgICAgICAgbGV0IGQyID0gb3V0cG9seWdvbi5ib3R0b21sZWZ0LmRpc3RhbmNlVG8oXG4gICAgICAgICAgICAgIHByZXZvdXRwb2x5Z29uLmJvdHRvbXJpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGQxIDwgRVBTICYmIGQyIDwgRVBTKSB7XG4gICAgICAgICAgICAgIC8vIHdlIGNhbiBqb2luIHRoaXMgcG9seWdvbiB3aXRoIHRoZSBvbmUgdG8gdGhlIGxlZnQ6XG4gICAgICAgICAgICAgIG91dHBvbHlnb24udG9wbGVmdCA9IHByZXZvdXRwb2x5Z29uLnRvcGxlZnQ7XG4gICAgICAgICAgICAgIG91dHBvbHlnb24ubGVmdGxpbmUgPSBwcmV2b3V0cG9seWdvbi5sZWZ0bGluZTtcbiAgICAgICAgICAgICAgb3V0cG9seWdvbi5ib3R0b21sZWZ0ID0gcHJldm91dHBvbHlnb24uYm90dG9tbGVmdDtcbiAgICAgICAgICAgICAgbmV3b3V0cG9seWdvbnJvdy5zcGxpY2UobmV3b3V0cG9seWdvbnJvdy5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3b3V0cG9seWdvbnJvdy5wdXNoKG91dHBvbHlnb24pO1xuICAgICAgICB9IC8vIGZvcihhY3RpdmVwb2x5Z29uIGluIGFjdGl2ZXBvbHlnb25zKVxuICAgICAgICBpZiAoeWluZGV4ID4gMCkge1xuICAgICAgICAgIC8vIHRyeSB0byBtYXRjaCB0aGUgbmV3IHBvbHlnb25zIGFnYWluc3QgdGhlIHByZXZpb3VzIHJvdzpcbiAgICAgICAgICBsZXQgcHJldmNvbnRpbnVlZGluZGV4ZXMgPSB7fTtcbiAgICAgICAgICBsZXQgbWF0Y2hlZGluZGV4ZXMgPSB7fTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld291dHBvbHlnb25yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aGlzcG9seWdvbiA9IG5ld291dHBvbHlnb25yb3dbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcHJldm91dHBvbHlnb25yb3cubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghbWF0Y2hlZGluZGV4ZXNbaWldKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJvY2Vzc2VkP1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaCBpZiB0aGUgc2lkZWxpbmVzIGFyZSBlcXVhbCBvciBpZiB0aGUgdG9wIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIG9uIHRoZSBzaWRlbGluZXMgb2YgdGhlIHByZXZpb3VzIHBvbHlnb25cbiAgICAgICAgICAgICAgICBsZXQgcHJldnBvbHlnb24gPSBwcmV2b3V0cG9seWdvbnJvd1tpaV07XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgcHJldnBvbHlnb24uYm90dG9tbGVmdC5kaXN0YW5jZVRvKHRoaXNwb2x5Z29uLnRvcGxlZnQpIDwgRVBTXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHByZXZwb2x5Z29uLmJvdHRvbXJpZ2h0LmRpc3RhbmNlVG8odGhpc3BvbHlnb24udG9wcmlnaHQpIDxcbiAgICAgICAgICAgICAgICAgICAgRVBTXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWWVzLCB0aGUgdG9wIG9mIHRoaXMgcG9seWdvbiBtYXRjaGVzIHRoZSBib3R0b20gb2YgdGhlIHByZXZpb3VzOlxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkaW5kZXhlc1tpaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIGpvaW5lZCBwb2x5Z29uIHdvdWxkIHJlbWFpbiBjb252ZXg6XG4gICAgICAgICAgICAgICAgICAgIGxldCBkMSA9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpc3BvbHlnb24ubGVmdGxpbmUuZGlyZWN0aW9uKCkueCAtXG4gICAgICAgICAgICAgICAgICAgICAgcHJldnBvbHlnb24ubGVmdGxpbmUuZGlyZWN0aW9uKCkueDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQyID1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzcG9seWdvbi5yaWdodGxpbmUuZGlyZWN0aW9uKCkueCAtXG4gICAgICAgICAgICAgICAgICAgICAgcHJldnBvbHlnb24ucmlnaHRsaW5lLmRpcmVjdGlvbigpLng7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0bGluZWNvbnRpbnVlcyA9IE1hdGguYWJzKGQxKSA8IEVQUztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0bGluZWNvbnRpbnVlcyA9IE1hdGguYWJzKGQyKSA8IEVQUztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnRsaW5laXNjb252ZXggPSBsZWZ0bGluZWNvbnRpbnVlcyB8fCBkMSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRsaW5laXNjb252ZXggPSByaWdodGxpbmVjb250aW51ZXMgfHwgZDIgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRsaW5laXNjb252ZXggJiYgcmlnaHRsaW5laXNjb252ZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyB5ZXMsIGJvdGggc2lkZXMgaGF2ZSBjb252ZXggY29ybmVyczpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBvbHlnb24gd2lsbCBjb250aW51ZSB0aGUgcHJldmlvdXMgcG9seWdvblxuICAgICAgICAgICAgICAgICAgICAgIHRoaXNwb2x5Z29uLm91dHBvbHlnb24gPSBwcmV2cG9seWdvbi5vdXRwb2x5Z29uO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXNwb2x5Z29uLmxlZnRsaW5lY29udGludWVzID0gbGVmdGxpbmVjb250aW51ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpc3BvbHlnb24ucmlnaHRsaW5lY29udGludWVzID0gcmlnaHRsaW5lY29udGludWVzO1xuICAgICAgICAgICAgICAgICAgICAgIHByZXZjb250aW51ZWRpbmRleGVzW2lpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIGlmKCFwcmV2Y29udGludWVkaW5kZXhlc1tpaV0pXG4gICAgICAgICAgICB9IC8vIGZvciBpaVxuICAgICAgICAgIH0gLy8gZm9yIGlcbiAgICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcHJldm91dHBvbHlnb25yb3cubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXByZXZjb250aW51ZWRpbmRleGVzW2lpXSkge1xuICAgICAgICAgICAgICAvLyBwb2x5Z29uIGVuZHMgaGVyZVxuICAgICAgICAgICAgICAvLyBGaW5pc2ggdGhlIHBvbHlnb24gd2l0aCB0aGUgbGFzdCBwb2ludChzKTpcbiAgICAgICAgICAgICAgbGV0IHByZXZwb2x5Z29uID0gcHJldm91dHBvbHlnb25yb3dbaWldO1xuICAgICAgICAgICAgICBwcmV2cG9seWdvbi5vdXRwb2x5Z29uLnJpZ2h0cG9pbnRzLnB1c2gocHJldnBvbHlnb24uYm90dG9tcmlnaHQpO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcHJldnBvbHlnb24uYm90dG9tcmlnaHQuZGlzdGFuY2VUbyhwcmV2cG9seWdvbi5ib3R0b21sZWZ0KSA+IEVQU1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBwb2x5Z29uIGVuZHMgd2l0aCBhIGhvcml6b250YWwgbGluZTpcbiAgICAgICAgICAgICAgICBwcmV2cG9seWdvbi5vdXRwb2x5Z29uLmxlZnRwb2ludHMucHVzaChwcmV2cG9seWdvbi5ib3R0b21sZWZ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyByZXZlcnNlIHRoZSBsZWZ0IGhhbGYgc28gd2UgZ2V0IGEgY291bnRlcmNsb2Nrd2lzZSBjaXJjbGU6XG4gICAgICAgICAgICAgIHByZXZwb2x5Z29uLm91dHBvbHlnb24ubGVmdHBvaW50cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgIGxldCBwb2ludHMyZCA9IHByZXZwb2x5Z29uLm91dHBvbHlnb24ucmlnaHRwb2ludHMuY29uY2F0KFxuICAgICAgICAgICAgICAgIHByZXZwb2x5Z29uLm91dHBvbHlnb24ubGVmdHBvaW50c1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsZXQgdmVydGljZXMzZCA9IFtdO1xuICAgICAgICAgICAgICBwb2ludHMyZC5tYXAoZnVuY3Rpb24gKHBvaW50MmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnQzZCA9IG9ydGhvYmFzaXMudG8zRChwb2ludDJkKTtcbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4M2QgPSBuZXcgVmVydGV4KHBvaW50M2QpO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzM2QucHVzaCh2ZXJ0ZXgzZCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsZXQgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHZlcnRpY2VzM2QsIHNoYXJlZCwgcGxhbmUpO1xuICAgICAgICAgICAgICBkZXN0cG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYoeWluZGV4ID4gMClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdvdXRwb2x5Z29ucm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHRoaXNwb2x5Z29uID0gbmV3b3V0cG9seWdvbnJvd1tpXTtcbiAgICAgICAgICBpZiAoIXRoaXNwb2x5Z29uLm91dHBvbHlnb24pIHtcbiAgICAgICAgICAgIC8vIHBvbHlnb24gc3RhcnRzIGhlcmU6XG4gICAgICAgICAgICB0aGlzcG9seWdvbi5vdXRwb2x5Z29uID0ge1xuICAgICAgICAgICAgICBsZWZ0cG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgcmlnaHRwb2ludHM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNwb2x5Z29uLm91dHBvbHlnb24ubGVmdHBvaW50cy5wdXNoKHRoaXNwb2x5Z29uLnRvcGxlZnQpO1xuICAgICAgICAgICAgaWYgKHRoaXNwb2x5Z29uLnRvcGxlZnQuZGlzdGFuY2VUbyh0aGlzcG9seWdvbi50b3ByaWdodCkgPiBFUFMpIHtcbiAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIGhvcml6b250YWwgbGluZSBhdCB0aGUgdG9wOlxuICAgICAgICAgICAgICB0aGlzcG9seWdvbi5vdXRwb2x5Z29uLnJpZ2h0cG9pbnRzLnB1c2godGhpc3BvbHlnb24udG9wcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb250aW51YXRpb24gb2YgYSBwcmV2aW91cyByb3dcbiAgICAgICAgICAgIGlmICghdGhpc3BvbHlnb24ubGVmdGxpbmVjb250aW51ZXMpIHtcbiAgICAgICAgICAgICAgdGhpc3BvbHlnb24ub3V0cG9seWdvbi5sZWZ0cG9pbnRzLnB1c2godGhpc3BvbHlnb24udG9wbGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXNwb2x5Z29uLnJpZ2h0bGluZWNvbnRpbnVlcykge1xuICAgICAgICAgICAgICB0aGlzcG9seWdvbi5vdXRwb2x5Z29uLnJpZ2h0cG9pbnRzLnB1c2godGhpc3BvbHlnb24udG9wcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2b3V0cG9seWdvbnJvdyA9IG5ld291dHBvbHlnb25yb3c7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgeWluZGV4XG4gIH0gLy8gaWYobnVtcG9seWdvbnMgPiAwKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZVRlc3NlbGF0ZUNvcGxhbmFyUG9seWdvbnM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/math/reTesselateCoplanarPolygons.js\n");

/***/ }),

/***/ "./src/core/mutators.js":
/*!******************************!*\
  !*** ./src/core/mutators.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Matrix4x4 = __webpack_require__(/*! ./math/Matrix4 */ \"./src/core/math/Matrix4.js\");\nconst Vector3D = __webpack_require__(/*! ./math/Vector3 */ \"./src/core/math/Vector3.js\");\nconst Plane = __webpack_require__(/*! ./math/Plane */ \"./src/core/math/Plane.js\");\n\n// Add several convenience methods to the classes that support a transform() method:\nconst addTransformationMethodsToPrototype = function (prot) {\n  prot.mirrored = function (plane) {\n    return this.transform(Matrix4x4.mirroring(plane));\n  };\n\n  prot.mirroredX = function () {\n    let plane = new Plane(Vector3D.Create(1, 0, 0), 0);\n    return this.mirrored(plane);\n  };\n\n  prot.mirroredY = function () {\n    let plane = new Plane(Vector3D.Create(0, 1, 0), 0);\n    return this.mirrored(plane);\n  };\n\n  prot.mirroredZ = function () {\n    let plane = new Plane(Vector3D.Create(0, 0, 1), 0);\n    return this.mirrored(plane);\n  };\n\n  prot.translate = function (v) {\n    return this.transform(Matrix4x4.translation(v));\n  };\n\n  prot.scale = function (f) {\n    return this.transform(Matrix4x4.scaling(f));\n  };\n\n  prot.rotateX = function (deg) {\n    return this.transform(Matrix4x4.rotationX(deg));\n  };\n\n  prot.rotateY = function (deg) {\n    return this.transform(Matrix4x4.rotationY(deg));\n  };\n\n  prot.rotateZ = function (deg) {\n    return this.transform(Matrix4x4.rotationZ(deg));\n  };\n\n  prot.rotate = function (rotationCenter, rotationAxis, degrees) {\n    return this.transform(\n      Matrix4x4.rotation(rotationCenter, rotationAxis, degrees)\n    );\n  };\n\n  prot.rotateEulerAngles = function (alpha, beta, gamma, position) {\n    position = position || [0, 0, 0];\n\n    let Rz1 = Matrix4x4.rotationZ(alpha);\n    let Rx = Matrix4x4.rotationX(beta);\n    let Rz2 = Matrix4x4.rotationZ(gamma);\n    let T = Matrix4x4.translation(new Vector3D(position));\n\n    return this.transform(Rz2.multiply(Rx).multiply(Rz1).multiply(T));\n  };\n};\n\n// TODO: consider generalization and adding to addTransformationMethodsToPrototype\nconst addCenteringToPrototype = function (prot, axes) {\n  prot.center = function (cAxes) {\n    cAxes = Array.prototype.map.call(arguments, function (a) {\n      return a; // .toLowerCase();\n    });\n    // no args: center on all axes\n    if (!cAxes.length) {\n      cAxes = axes.slice();\n    }\n    let b = this.getBounds();\n    return this.translate(\n      axes.map(function (a) {\n        return cAxes.indexOf(a) > -1 ? -(b[0][a] + b[1][a]) / 2 : 0;\n      })\n    );\n  };\n};\nmodule.exports = {\n  addTransformationMethodsToPrototype,\n  addCenteringToPrototype,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9tdXRhdG9ycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL211dGF0b3JzLmpzPzMwODIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTWF0cml4NHg0ID0gcmVxdWlyZSgnLi9tYXRoL01hdHJpeDQnKTtcbmNvbnN0IFZlY3RvcjNEID0gcmVxdWlyZSgnLi9tYXRoL1ZlY3RvcjMnKTtcbmNvbnN0IFBsYW5lID0gcmVxdWlyZSgnLi9tYXRoL1BsYW5lJyk7XG5cbi8vIEFkZCBzZXZlcmFsIGNvbnZlbmllbmNlIG1ldGhvZHMgdG8gdGhlIGNsYXNzZXMgdGhhdCBzdXBwb3J0IGEgdHJhbnNmb3JtKCkgbWV0aG9kOlxuY29uc3QgYWRkVHJhbnNmb3JtYXRpb25NZXRob2RzVG9Qcm90b3R5cGUgPSBmdW5jdGlvbiAocHJvdCkge1xuICBwcm90Lm1pcnJvcmVkID0gZnVuY3Rpb24gKHBsYW5lKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5taXJyb3JpbmcocGxhbmUpKTtcbiAgfTtcblxuICBwcm90Lm1pcnJvcmVkWCA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcGxhbmUgPSBuZXcgUGxhbmUoVmVjdG9yM0QuQ3JlYXRlKDEsIDAsIDApLCAwKTtcbiAgICByZXR1cm4gdGhpcy5taXJyb3JlZChwbGFuZSk7XG4gIH07XG5cbiAgcHJvdC5taXJyb3JlZFkgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHBsYW5lID0gbmV3IFBsYW5lKFZlY3RvcjNELkNyZWF0ZSgwLCAxLCAwKSwgMCk7XG4gICAgcmV0dXJuIHRoaXMubWlycm9yZWQocGxhbmUpO1xuICB9O1xuXG4gIHByb3QubWlycm9yZWRaID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBwbGFuZSA9IG5ldyBQbGFuZShWZWN0b3IzRC5DcmVhdGUoMCwgMCwgMSksIDApO1xuICAgIHJldHVybiB0aGlzLm1pcnJvcmVkKHBsYW5lKTtcbiAgfTtcblxuICBwcm90LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC50cmFuc2xhdGlvbih2KSk7XG4gIH07XG5cbiAgcHJvdC5zY2FsZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5zY2FsaW5nKGYpKTtcbiAgfTtcblxuICBwcm90LnJvdGF0ZVggPSBmdW5jdGlvbiAoZGVnKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKE1hdHJpeDR4NC5yb3RhdGlvblgoZGVnKSk7XG4gIH07XG5cbiAgcHJvdC5yb3RhdGVZID0gZnVuY3Rpb24gKGRlZykge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShNYXRyaXg0eDQucm90YXRpb25ZKGRlZykpO1xuICB9O1xuXG4gIHByb3Qucm90YXRlWiA9IGZ1bmN0aW9uIChkZWcpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oTWF0cml4NHg0LnJvdGF0aW9uWihkZWcpKTtcbiAgfTtcblxuICBwcm90LnJvdGF0ZSA9IGZ1bmN0aW9uIChyb3RhdGlvbkNlbnRlciwgcm90YXRpb25BeGlzLCBkZWdyZWVzKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKFxuICAgICAgTWF0cml4NHg0LnJvdGF0aW9uKHJvdGF0aW9uQ2VudGVyLCByb3RhdGlvbkF4aXMsIGRlZ3JlZXMpXG4gICAgKTtcbiAgfTtcblxuICBwcm90LnJvdGF0ZUV1bGVyQW5nbGVzID0gZnVuY3Rpb24gKGFscGhhLCBiZXRhLCBnYW1tYSwgcG9zaXRpb24pIHtcbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IFswLCAwLCAwXTtcblxuICAgIGxldCBSejEgPSBNYXRyaXg0eDQucm90YXRpb25aKGFscGhhKTtcbiAgICBsZXQgUnggPSBNYXRyaXg0eDQucm90YXRpb25YKGJldGEpO1xuICAgIGxldCBSejIgPSBNYXRyaXg0eDQucm90YXRpb25aKGdhbW1hKTtcbiAgICBsZXQgVCA9IE1hdHJpeDR4NC50cmFuc2xhdGlvbihuZXcgVmVjdG9yM0QocG9zaXRpb24pKTtcblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShSejIubXVsdGlwbHkoUngpLm11bHRpcGx5KFJ6MSkubXVsdGlwbHkoVCkpO1xuICB9O1xufTtcblxuLy8gVE9ETzogY29uc2lkZXIgZ2VuZXJhbGl6YXRpb24gYW5kIGFkZGluZyB0byBhZGRUcmFuc2Zvcm1hdGlvbk1ldGhvZHNUb1Byb3RvdHlwZVxuY29uc3QgYWRkQ2VudGVyaW5nVG9Qcm90b3R5cGUgPSBmdW5jdGlvbiAocHJvdCwgYXhlcykge1xuICBwcm90LmNlbnRlciA9IGZ1bmN0aW9uIChjQXhlcykge1xuICAgIGNBeGVzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBhOyAvLyAudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgICAvLyBubyBhcmdzOiBjZW50ZXIgb24gYWxsIGF4ZXNcbiAgICBpZiAoIWNBeGVzLmxlbmd0aCkge1xuICAgICAgY0F4ZXMgPSBheGVzLnNsaWNlKCk7XG4gICAgfVxuICAgIGxldCBiID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoXG4gICAgICBheGVzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gY0F4ZXMuaW5kZXhPZihhKSA+IC0xID8gLShiWzBdW2FdICsgYlsxXVthXSkgLyAyIDogMDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkVHJhbnNmb3JtYXRpb25NZXRob2RzVG9Qcm90b3R5cGUsXG4gIGFkZENlbnRlcmluZ1RvUHJvdG90eXBlLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/mutators.js\n");

/***/ }),

/***/ "./src/core/trees.js":
/*!***************************!*\
  !*** ./src/core/trees.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { _CSGDEBUG, EPS } = __webpack_require__(/*! ./constants */ \"./src/core/constants.js\");\nconst Vertex = __webpack_require__(/*! ./math/Vertex3 */ \"./src/core/math/Vertex3.js\");\nconst Polygon = __webpack_require__(/*! ./math/Polygon3 */ \"./src/core/math/Polygon3.js\");\n\n// Returns object:\n// .type:\n//   0: coplanar-front\n//   1: coplanar-back\n//   2: front\n//   3: back\n//   4: spanning\n// In case the polygon is spanning, returns:\n// .front: a Polygon of the front part\n// .back: a Polygon of the back part\n\nlet splitPolygonByPlaneCount = 0;\n\nfunction splitPolygonByPlane(plane, polygon) {\n  let result = {\n    type: null,\n    front: null,\n    back: null,\n  };\n  // cache in local lets (speedup):\n  let planenormal = plane.normal;\n  let vertices = polygon.vertices;\n  let numvertices = vertices.length;\n  if (polygon.plane.equals(plane)) {\n    result.type = 0;\n  } else {\n    let thisw = plane.w;\n    let hasfront = false;\n    let hasback = false;\n    let vertexIsBack = [];\n    let MINEPS = -EPS;\n    for (let i = 0; i < numvertices; i++) {\n      let t = planenormal.dot(vertices[i].pos) - thisw;\n      let isback = t < 0;\n      vertexIsBack.push(isback);\n      if (t > EPS) hasfront = true;\n      if (t < MINEPS) hasback = true;\n    }\n    if (!hasfront && !hasback) {\n      // all points coplanar\n      let t = planenormal.dot(polygon.plane.normal);\n      result.type = t >= 0 ? 0 : 1;\n    } else if (!hasback) {\n      result.type = 2;\n    } else if (!hasfront) {\n      result.type = 3;\n    } else {\n      // spanning\n      result.type = 4;\n      let frontvertices = [];\n      let backvertices = [];\n      let isback = vertexIsBack[0];\n      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n        let vertex = vertices[vertexindex];\n        let nextvertexindex = vertexindex + 1;\n        if (nextvertexindex >= numvertices) nextvertexindex = 0;\n        let nextisback = vertexIsBack[nextvertexindex];\n        if (isback === nextisback) {\n          // line segment is on one side of the plane:\n          if (isback) {\n            backvertices.push(vertex);\n          } else {\n            frontvertices.push(vertex);\n          }\n        } else {\n          // line segment intersects plane:\n          let point = vertex.pos;\n          let nextpoint = vertices[nextvertexindex].pos;\n          let intersectionpoint = plane.splitLineBetweenPoints(\n            point,\n            nextpoint\n          );\n          let intersectionvertex = new Vertex(intersectionpoint);\n          if (isback) {\n            backvertices.push(vertex);\n            backvertices.push(intersectionvertex);\n            frontvertices.push(intersectionvertex);\n          } else {\n            frontvertices.push(vertex);\n            frontvertices.push(intersectionvertex);\n            backvertices.push(intersectionvertex);\n          }\n        }\n        isback = nextisback;\n      } // for vertexindex\n      // remove duplicate vertices:\n      let EPS_SQUARED = EPS * EPS;\n      if (backvertices.length >= 3) {\n        let prevvertex = backvertices[backvertices.length - 1];\n        for (\n          let vertexindex = 0;\n          vertexindex < backvertices.length;\n          vertexindex++\n        ) {\n          let vertex = backvertices[vertexindex];\n          if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {\n            backvertices.splice(vertexindex, 1);\n            vertexindex--;\n          }\n          prevvertex = vertex;\n        }\n      }\n      if (frontvertices.length >= 3) {\n        let prevvertex = frontvertices[frontvertices.length - 1];\n        for (\n          let vertexindex = 0;\n          vertexindex < frontvertices.length;\n          vertexindex++\n        ) {\n          let vertex = frontvertices[vertexindex];\n          if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {\n            frontvertices.splice(vertexindex, 1);\n            vertexindex--;\n          }\n          prevvertex = vertex;\n        }\n      }\n      if (frontvertices.length >= 3) {\n        result.front = new Polygon(\n          frontvertices,\n          polygon.shared,\n          polygon.plane\n        );\n      }\n      if (backvertices.length >= 3) {\n        result.back = new Polygon(backvertices, polygon.shared, polygon.plane);\n      }\n    }\n  }\n  return result;\n}\n\n// # class PolygonTreeNode\n// This class manages hierarchical splits of polygons\n// At the top is a root node which doesn hold a polygon, only child PolygonTreeNodes\n// Below that are zero or more 'top' nodes; each holds a polygon. The polygons can be in different planes\n// splitByPlane() splits a node by a plane. If the plane intersects the polygon, two new child nodes\n// are created holding the splitted polygon.\n// getPolygons() retrieves the polygon from the tree. If for PolygonTreeNode the polygon is split but\n// the two split parts (child nodes) are still intact, then the unsplit polygon is returned.\n// This ensures that we can safely split a polygon into many fragments. If the fragments are untouched,\n//  getPolygons() will return the original unsplit polygon instead of the fragments.\n// remove() removes a polygon from the tree. Once a polygon is removed, the parent polygons are invalidated\n// since they are no longer intact.\n// constructor creates the root node:\nconst PolygonTreeNode = function () {\n  this.parent = null;\n  this.children = [];\n  this.polygon = null;\n  this.removed = false;\n};\n\nPolygonTreeNode.prototype = {\n  // fill the tree with polygons. Should be called on the root node only; child nodes must\n  // always be a derivate (split) of the parent node.\n  addPolygons: function (polygons) {\n    // new polygons can only be added to root node; children can only be splitted polygons\n    if (!this.isRootNode()) {\n      throw new Error('Assertion failed');\n    }\n    let _this = this;\n    polygons.map(function (polygon) {\n      _this.addChild(polygon);\n    });\n  },\n\n  // remove a node\n  // - the siblings become toplevel nodes\n  // - the parent is removed recursively\n  remove: function () {\n    if (!this.removed) {\n      this.removed = true;\n\n      if (_CSGDEBUG) {\n        if (this.isRootNode()) throw new Error('Assertion failed'); // can't remove root node\n        if (this.children.length) throw new Error('Assertion failed'); // we shouldn't remove nodes with children\n      }\n\n      // remove ourselves from the parent's children list:\n      let parentschildren = this.parent.children;\n      let i = parentschildren.indexOf(this);\n      if (i < 0) throw new Error('Assertion failed');\n      parentschildren.splice(i, 1);\n\n      // invalidate the parent's polygon, and of all parents above it:\n      this.parent.recursivelyInvalidatePolygon();\n    }\n  },\n\n  isRemoved: function () {\n    return this.removed;\n  },\n\n  isRootNode: function () {\n    return !this.parent;\n  },\n\n  // invert all polygons in the tree. Call on the root node\n  invert: function () {\n    if (!this.isRootNode()) throw new Error('Assertion failed'); // can only call this on the root node\n    this.invertSub();\n  },\n\n  getPolygon: function () {\n    if (!this.polygon) throw new Error('Assertion failed'); // doesn't have a polygon, which means that it has been broken down\n    return this.polygon;\n  },\n\n  getPolygons: function (result) {\n    let children = [this];\n    let queue = [children];\n    let i, j, l, node;\n    for (i = 0; i < queue.length; ++i) {\n      // queue size can change in loop, don't cache length\n      children = queue[i];\n      for (j = 0, l = children.length; j < l; j++) {\n        // ok to cache length\n        node = children[j];\n        if (node.polygon) {\n          // the polygon hasn't been broken yet. We can ignore the children and return our polygon:\n          result.push(node.polygon);\n        } else {\n          // our polygon has been split up and broken, so gather all subpolygons from the children\n          queue.push(node.children);\n        }\n      }\n    }\n  },\n\n  // split the node by a plane; add the resulting nodes to the frontnodes and backnodes array\n  // If the plane doesn't intersect the polygon, the 'this' object is added to one of the arrays\n  // If the plane does intersect the polygon, two new child nodes are created for the front and back fragments,\n  //  and added to both arrays.\n  splitByPlane: function (\n    plane,\n    coplanarfrontnodes,\n    coplanarbacknodes,\n    frontnodes,\n    backnodes\n  ) {\n    if (this.children.length) {\n      let queue = [this.children];\n      let i;\n      let j;\n      let l;\n      let node;\n      let nodes;\n      for (i = 0; i < queue.length; i++) {\n        // queue.length can increase, do not cache\n        nodes = queue[i];\n        for (j = 0, l = nodes.length; j < l; j++) {\n          // ok to cache length\n          node = nodes[j];\n          if (node.children.length) {\n            queue.push(node.children);\n          } else {\n            // no children. Split the polygon:\n            node._splitByPlane(\n              plane,\n              coplanarfrontnodes,\n              coplanarbacknodes,\n              frontnodes,\n              backnodes\n            );\n          }\n        }\n      }\n    } else {\n      this._splitByPlane(\n        plane,\n        coplanarfrontnodes,\n        coplanarbacknodes,\n        frontnodes,\n        backnodes\n      );\n    }\n  },\n\n  // only to be called for nodes with no children\n  _splitByPlane: function (\n    plane,\n    coplanarfrontnodes,\n    coplanarbacknodes,\n    frontnodes,\n    backnodes\n  ) {\n    let polygon = this.polygon;\n    if (polygon) {\n      if (++splitPolygonByPlaneCount % 1000 === 0) {\n        // console.log(`QQ/splitByPlane: ${splitPolygonByPlaneCount}`);\n      }\n      let bound = polygon.boundingSphere();\n      let sphereradius = bound[1] + EPS; // FIXME Why add imprecision?\n      let planenormal = plane.normal;\n      let spherecenter = bound[0];\n      let d = planenormal.dot(spherecenter) - plane.w;\n      if (d > sphereradius) {\n        frontnodes.push(this);\n      } else if (d < -sphereradius) {\n        backnodes.push(this);\n      } else {\n        let splitresult = splitPolygonByPlane(plane, polygon);\n        switch (splitresult.type) {\n          case 0:\n            // coplanar front:\n            coplanarfrontnodes.push(this);\n            break;\n\n          case 1:\n            // coplanar back:\n            coplanarbacknodes.push(this);\n            break;\n\n          case 2:\n            // front:\n            frontnodes.push(this);\n            break;\n\n          case 3:\n            // back:\n            backnodes.push(this);\n            break;\n\n          case 4:\n            // spanning:\n            if (splitresult.front) {\n              let frontnode = this.addChild(splitresult.front);\n              frontnodes.push(frontnode);\n            }\n            if (splitresult.back) {\n              let backnode = this.addChild(splitresult.back);\n              backnodes.push(backnode);\n            }\n            break;\n        }\n      }\n    }\n  },\n\n  // PRIVATE methods from here:\n  // add child to a node\n  // this should be called whenever the polygon is split\n  // a child should be created for every fragment of the split polygon\n  // returns the newly created child\n  addChild: function (polygon) {\n    let newchild = new PolygonTreeNode();\n    newchild.parent = this;\n    newchild.polygon = polygon;\n    this.children.push(newchild);\n    return newchild;\n  },\n\n  invertSub: function () {\n    let children = [this];\n    let queue = [children];\n    let i, j, l, node;\n    for (i = 0; i < queue.length; i++) {\n      children = queue[i];\n      for (j = 0, l = children.length; j < l; j++) {\n        node = children[j];\n        if (node.polygon) {\n          node.polygon = node.polygon.flipped();\n        }\n        queue.push(node.children);\n      }\n    }\n  },\n\n  recursivelyInvalidatePolygon: function () {\n    let node = this;\n    while (node.polygon) {\n      node.polygon = null;\n      if (node.parent) {\n        node = node.parent;\n      }\n    }\n  },\n};\n\n// # class Tree\n// This is the root of a BSP tree\n// We are using this separate class for the root of the tree, to hold the PolygonTreeNode root\n// The actual tree is kept in this.rootnode\nconst Tree = function (polygons) {\n  this.polygonTree = new PolygonTreeNode();\n  this.rootnode = new Node(null);\n  if (polygons) this.addPolygons(polygons);\n};\n\nTree.prototype = {\n  invert: function () {\n    this.polygonTree.invert();\n    this.rootnode.invert();\n  },\n\n  // Remove all polygons in this BSP tree that are inside the other BSP tree\n  // `tree`.\n  clipTo: function (tree, alsoRemovecoplanarFront) {\n    alsoRemovecoplanarFront = !!alsoRemovecoplanarFront;\n    this.rootnode.clipTo(tree, alsoRemovecoplanarFront);\n  },\n\n  allPolygons: function () {\n    let result = [];\n    this.polygonTree.getPolygons(result);\n    return result;\n  },\n\n  addPolygons: function (polygons) {\n    let _this = this;\n    let polygontreenodes = polygons.map(function (p) {\n      return _this.polygonTree.addChild(p);\n    });\n    this.rootnode.addPolygonTreeNodes(polygontreenodes);\n  },\n};\n\n// # class Node\n// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n// by picking a polygon to split along.\n// Polygons are not stored directly in the tree, but in PolygonTreeNodes, stored in\n// this.polygontreenodes. Those PolygonTreeNodes are children of the owning\n// Tree.polygonTree\n// This is not a leafy BSP tree since there is\n// no distinction between internal and leaf nodes.\nconst Node = function (parent) {\n  this.plane = null;\n  this.front = null;\n  this.back = null;\n  this.polygontreenodes = [];\n  this.parent = parent;\n};\n\nNode.prototype = {\n  // Convert solid space to empty space and empty space to solid space.\n  invert: function () {\n    let queue = [this];\n    let node;\n    for (let i = 0; i < queue.length; i++) {\n      node = queue[i];\n      if (node.plane) node.plane = node.plane.flipped();\n      if (node.front) queue.push(node.front);\n      if (node.back) queue.push(node.back);\n      let temp = node.front;\n      node.front = node.back;\n      node.back = temp;\n    }\n  },\n\n  // clip polygontreenodes to our plane\n  // calls remove() for all clipped PolygonTreeNodes\n  clipPolygons: function (polygontreenodes, alsoRemovecoplanarFront) {\n    let args = { node: this, polygontreenodes: polygontreenodes };\n    let node;\n    let stack = [];\n\n    do {\n      node = args.node;\n      polygontreenodes = args.polygontreenodes;\n\n      // begin \"function\"\n      if (node.plane) {\n        let backnodes = [];\n        let frontnodes = [];\n        let coplanarfrontnodes = alsoRemovecoplanarFront\n          ? backnodes\n          : frontnodes;\n        let plane = node.plane;\n        let numpolygontreenodes = polygontreenodes.length;\n        for (let i = 0; i < numpolygontreenodes; i++) {\n          let node1 = polygontreenodes[i];\n          if (!node1.isRemoved()) {\n            node1.splitByPlane(\n              plane,\n              coplanarfrontnodes,\n              backnodes,\n              frontnodes,\n              backnodes\n            );\n          }\n        }\n\n        if (node.front && frontnodes.length > 0) {\n          stack.push({ node: node.front, polygontreenodes: frontnodes });\n        }\n        let numbacknodes = backnodes.length;\n        if (node.back && numbacknodes > 0) {\n          stack.push({ node: node.back, polygontreenodes: backnodes });\n        } else {\n          // there's nothing behind this plane. Delete the nodes behind this plane:\n          for (let i = 0; i < numbacknodes; i++) {\n            backnodes[i].remove();\n          }\n        }\n      }\n      args = stack.pop();\n    } while (typeof args !== 'undefined');\n  },\n\n  // Remove all polygons in this BSP tree that are inside the other BSP tree\n  // `tree`.\n  clipTo: function (tree, alsoRemovecoplanarFront) {\n    let node = this;\n    let stack = [];\n    do {\n      if (node.polygontreenodes.length > 0) {\n        tree.rootnode.clipPolygons(\n          node.polygontreenodes,\n          alsoRemovecoplanarFront\n        );\n      }\n      if (node.front) stack.push(node.front);\n      if (node.back) stack.push(node.back);\n      node = stack.pop();\n    } while (typeof node !== 'undefined');\n  },\n\n  addPolygonTreeNodes: function (polygontreenodes) {\n    let args = { node: this, polygontreenodes: polygontreenodes };\n    let node;\n    let stack = [];\n    do {\n      node = args.node;\n      polygontreenodes = args.polygontreenodes;\n\n      if (polygontreenodes.length === 0) {\n        args = stack.pop();\n        continue;\n      }\n      let _this = node;\n      if (!node.plane) {\n        let bestplane = polygontreenodes[0].getPolygon().plane;\n        node.plane = bestplane;\n      }\n      let frontnodes = [];\n      let backnodes = [];\n\n      for (let i = 0, n = polygontreenodes.length; i < n; ++i) {\n        polygontreenodes[i].splitByPlane(\n          _this.plane,\n          _this.polygontreenodes,\n          backnodes,\n          frontnodes,\n          backnodes\n        );\n      }\n\n      if (frontnodes.length > 0) {\n        if (!node.front) node.front = new Node(node);\n        stack.push({ node: node.front, polygontreenodes: frontnodes });\n      }\n      if (backnodes.length > 0) {\n        if (!node.back) node.back = new Node(node);\n        stack.push({ node: node.back, polygontreenodes: backnodes });\n      }\n\n      args = stack.pop();\n    } while (typeof args !== 'undefined');\n  },\n\n  getParentPlaneNormals: function (normals, maxdepth) {\n    if (maxdepth > 0) {\n      if (this.parent) {\n        normals.push(this.parent.plane.normal);\n        this.parent.getParentPlaneNormals(normals, maxdepth - 1);\n      }\n    }\n  },\n};\n\nmodule.exports = Tree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS90cmVlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL3RyZWVzLmpzP2YxZjIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBfQ1NHREVCVUcsIEVQUyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IFZlcnRleCA9IHJlcXVpcmUoJy4vbWF0aC9WZXJ0ZXgzJyk7XG5jb25zdCBQb2x5Z29uID0gcmVxdWlyZSgnLi9tYXRoL1BvbHlnb24zJyk7XG5cbi8vIFJldHVybnMgb2JqZWN0OlxuLy8gLnR5cGU6XG4vLyAgIDA6IGNvcGxhbmFyLWZyb250XG4vLyAgIDE6IGNvcGxhbmFyLWJhY2tcbi8vICAgMjogZnJvbnRcbi8vICAgMzogYmFja1xuLy8gICA0OiBzcGFubmluZ1xuLy8gSW4gY2FzZSB0aGUgcG9seWdvbiBpcyBzcGFubmluZywgcmV0dXJuczpcbi8vIC5mcm9udDogYSBQb2x5Z29uIG9mIHRoZSBmcm9udCBwYXJ0XG4vLyAuYmFjazogYSBQb2x5Z29uIG9mIHRoZSBiYWNrIHBhcnRcblxubGV0IHNwbGl0UG9seWdvbkJ5UGxhbmVDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIHNwbGl0UG9seWdvbkJ5UGxhbmUocGxhbmUsIHBvbHlnb24pIHtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICB0eXBlOiBudWxsLFxuICAgIGZyb250OiBudWxsLFxuICAgIGJhY2s6IG51bGwsXG4gIH07XG4gIC8vIGNhY2hlIGluIGxvY2FsIGxldHMgKHNwZWVkdXApOlxuICBsZXQgcGxhbmVub3JtYWwgPSBwbGFuZS5ub3JtYWw7XG4gIGxldCB2ZXJ0aWNlcyA9IHBvbHlnb24udmVydGljZXM7XG4gIGxldCBudW12ZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgaWYgKHBvbHlnb24ucGxhbmUuZXF1YWxzKHBsYW5lKSkge1xuICAgIHJlc3VsdC50eXBlID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZXQgdGhpc3cgPSBwbGFuZS53O1xuICAgIGxldCBoYXNmcm9udCA9IGZhbHNlO1xuICAgIGxldCBoYXNiYWNrID0gZmFsc2U7XG4gICAgbGV0IHZlcnRleElzQmFjayA9IFtdO1xuICAgIGxldCBNSU5FUFMgPSAtRVBTO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtdmVydGljZXM7IGkrKykge1xuICAgICAgbGV0IHQgPSBwbGFuZW5vcm1hbC5kb3QodmVydGljZXNbaV0ucG9zKSAtIHRoaXN3O1xuICAgICAgbGV0IGlzYmFjayA9IHQgPCAwO1xuICAgICAgdmVydGV4SXNCYWNrLnB1c2goaXNiYWNrKTtcbiAgICAgIGlmICh0ID4gRVBTKSBoYXNmcm9udCA9IHRydWU7XG4gICAgICBpZiAodCA8IE1JTkVQUykgaGFzYmFjayA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaGFzZnJvbnQgJiYgIWhhc2JhY2spIHtcbiAgICAgIC8vIGFsbCBwb2ludHMgY29wbGFuYXJcbiAgICAgIGxldCB0ID0gcGxhbmVub3JtYWwuZG90KHBvbHlnb24ucGxhbmUubm9ybWFsKTtcbiAgICAgIHJlc3VsdC50eXBlID0gdCA+PSAwID8gMCA6IDE7XG4gICAgfSBlbHNlIGlmICghaGFzYmFjaykge1xuICAgICAgcmVzdWx0LnR5cGUgPSAyO1xuICAgIH0gZWxzZSBpZiAoIWhhc2Zyb250KSB7XG4gICAgICByZXN1bHQudHlwZSA9IDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNwYW5uaW5nXG4gICAgICByZXN1bHQudHlwZSA9IDQ7XG4gICAgICBsZXQgZnJvbnR2ZXJ0aWNlcyA9IFtdO1xuICAgICAgbGV0IGJhY2t2ZXJ0aWNlcyA9IFtdO1xuICAgICAgbGV0IGlzYmFjayA9IHZlcnRleElzQmFja1swXTtcbiAgICAgIGZvciAobGV0IHZlcnRleGluZGV4ID0gMDsgdmVydGV4aW5kZXggPCBudW12ZXJ0aWNlczsgdmVydGV4aW5kZXgrKykge1xuICAgICAgICBsZXQgdmVydGV4ID0gdmVydGljZXNbdmVydGV4aW5kZXhdO1xuICAgICAgICBsZXQgbmV4dHZlcnRleGluZGV4ID0gdmVydGV4aW5kZXggKyAxO1xuICAgICAgICBpZiAobmV4dHZlcnRleGluZGV4ID49IG51bXZlcnRpY2VzKSBuZXh0dmVydGV4aW5kZXggPSAwO1xuICAgICAgICBsZXQgbmV4dGlzYmFjayA9IHZlcnRleElzQmFja1tuZXh0dmVydGV4aW5kZXhdO1xuICAgICAgICBpZiAoaXNiYWNrID09PSBuZXh0aXNiYWNrKSB7XG4gICAgICAgICAgLy8gbGluZSBzZWdtZW50IGlzIG9uIG9uZSBzaWRlIG9mIHRoZSBwbGFuZTpcbiAgICAgICAgICBpZiAoaXNiYWNrKSB7XG4gICAgICAgICAgICBiYWNrdmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcm9udHZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGluZSBzZWdtZW50IGludGVyc2VjdHMgcGxhbmU6XG4gICAgICAgICAgbGV0IHBvaW50ID0gdmVydGV4LnBvcztcbiAgICAgICAgICBsZXQgbmV4dHBvaW50ID0gdmVydGljZXNbbmV4dHZlcnRleGluZGV4XS5wb3M7XG4gICAgICAgICAgbGV0IGludGVyc2VjdGlvbnBvaW50ID0gcGxhbmUuc3BsaXRMaW5lQmV0d2VlblBvaW50cyhcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgbmV4dHBvaW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgaW50ZXJzZWN0aW9udmVydGV4ID0gbmV3IFZlcnRleChpbnRlcnNlY3Rpb25wb2ludCk7XG4gICAgICAgICAgaWYgKGlzYmFjaykge1xuICAgICAgICAgICAgYmFja3ZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICAgICAgICAgIGJhY2t2ZXJ0aWNlcy5wdXNoKGludGVyc2VjdGlvbnZlcnRleCk7XG4gICAgICAgICAgICBmcm9udHZlcnRpY2VzLnB1c2goaW50ZXJzZWN0aW9udmVydGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbnR2ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XG4gICAgICAgICAgICBmcm9udHZlcnRpY2VzLnB1c2goaW50ZXJzZWN0aW9udmVydGV4KTtcbiAgICAgICAgICAgIGJhY2t2ZXJ0aWNlcy5wdXNoKGludGVyc2VjdGlvbnZlcnRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzYmFjayA9IG5leHRpc2JhY2s7XG4gICAgICB9IC8vIGZvciB2ZXJ0ZXhpbmRleFxuICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZSB2ZXJ0aWNlczpcbiAgICAgIGxldCBFUFNfU1FVQVJFRCA9IEVQUyAqIEVQUztcbiAgICAgIGlmIChiYWNrdmVydGljZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgbGV0IHByZXZ2ZXJ0ZXggPSBiYWNrdmVydGljZXNbYmFja3ZlcnRpY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKFxuICAgICAgICAgIGxldCB2ZXJ0ZXhpbmRleCA9IDA7XG4gICAgICAgICAgdmVydGV4aW5kZXggPCBiYWNrdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgIHZlcnRleGluZGV4KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGV0IHZlcnRleCA9IGJhY2t2ZXJ0aWNlc1t2ZXJ0ZXhpbmRleF07XG4gICAgICAgICAgaWYgKHZlcnRleC5wb3MuZGlzdGFuY2VUb1NxdWFyZWQocHJldnZlcnRleC5wb3MpIDwgRVBTX1NRVUFSRUQpIHtcbiAgICAgICAgICAgIGJhY2t2ZXJ0aWNlcy5zcGxpY2UodmVydGV4aW5kZXgsIDEpO1xuICAgICAgICAgICAgdmVydGV4aW5kZXgtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldnZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZyb250dmVydGljZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgbGV0IHByZXZ2ZXJ0ZXggPSBmcm9udHZlcnRpY2VzW2Zyb250dmVydGljZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgbGV0IHZlcnRleGluZGV4ID0gMDtcbiAgICAgICAgICB2ZXJ0ZXhpbmRleCA8IGZyb250dmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgIHZlcnRleGluZGV4KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGV0IHZlcnRleCA9IGZyb250dmVydGljZXNbdmVydGV4aW5kZXhdO1xuICAgICAgICAgIGlmICh2ZXJ0ZXgucG9zLmRpc3RhbmNlVG9TcXVhcmVkKHByZXZ2ZXJ0ZXgucG9zKSA8IEVQU19TUVVBUkVEKSB7XG4gICAgICAgICAgICBmcm9udHZlcnRpY2VzLnNwbGljZSh2ZXJ0ZXhpbmRleCwgMSk7XG4gICAgICAgICAgICB2ZXJ0ZXhpbmRleC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2dmVydGV4ID0gdmVydGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZnJvbnR2ZXJ0aWNlcy5sZW5ndGggPj0gMykge1xuICAgICAgICByZXN1bHQuZnJvbnQgPSBuZXcgUG9seWdvbihcbiAgICAgICAgICBmcm9udHZlcnRpY2VzLFxuICAgICAgICAgIHBvbHlnb24uc2hhcmVkLFxuICAgICAgICAgIHBvbHlnb24ucGxhbmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrdmVydGljZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmVzdWx0LmJhY2sgPSBuZXcgUG9seWdvbihiYWNrdmVydGljZXMsIHBvbHlnb24uc2hhcmVkLCBwb2x5Z29uLnBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gIyBjbGFzcyBQb2x5Z29uVHJlZU5vZGVcbi8vIFRoaXMgY2xhc3MgbWFuYWdlcyBoaWVyYXJjaGljYWwgc3BsaXRzIG9mIHBvbHlnb25zXG4vLyBBdCB0aGUgdG9wIGlzIGEgcm9vdCBub2RlIHdoaWNoIGRvZXNuIGhvbGQgYSBwb2x5Z29uLCBvbmx5IGNoaWxkIFBvbHlnb25UcmVlTm9kZXNcbi8vIEJlbG93IHRoYXQgYXJlIHplcm8gb3IgbW9yZSAndG9wJyBub2RlczsgZWFjaCBob2xkcyBhIHBvbHlnb24uIFRoZSBwb2x5Z29ucyBjYW4gYmUgaW4gZGlmZmVyZW50IHBsYW5lc1xuLy8gc3BsaXRCeVBsYW5lKCkgc3BsaXRzIGEgbm9kZSBieSBhIHBsYW5lLiBJZiB0aGUgcGxhbmUgaW50ZXJzZWN0cyB0aGUgcG9seWdvbiwgdHdvIG5ldyBjaGlsZCBub2Rlc1xuLy8gYXJlIGNyZWF0ZWQgaG9sZGluZyB0aGUgc3BsaXR0ZWQgcG9seWdvbi5cbi8vIGdldFBvbHlnb25zKCkgcmV0cmlldmVzIHRoZSBwb2x5Z29uIGZyb20gdGhlIHRyZWUuIElmIGZvciBQb2x5Z29uVHJlZU5vZGUgdGhlIHBvbHlnb24gaXMgc3BsaXQgYnV0XG4vLyB0aGUgdHdvIHNwbGl0IHBhcnRzIChjaGlsZCBub2RlcykgYXJlIHN0aWxsIGludGFjdCwgdGhlbiB0aGUgdW5zcGxpdCBwb2x5Z29uIGlzIHJldHVybmVkLlxuLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2UgY2FuIHNhZmVseSBzcGxpdCBhIHBvbHlnb24gaW50byBtYW55IGZyYWdtZW50cy4gSWYgdGhlIGZyYWdtZW50cyBhcmUgdW50b3VjaGVkLFxuLy8gIGdldFBvbHlnb25zKCkgd2lsbCByZXR1cm4gdGhlIG9yaWdpbmFsIHVuc3BsaXQgcG9seWdvbiBpbnN0ZWFkIG9mIHRoZSBmcmFnbWVudHMuXG4vLyByZW1vdmUoKSByZW1vdmVzIGEgcG9seWdvbiBmcm9tIHRoZSB0cmVlLiBPbmNlIGEgcG9seWdvbiBpcyByZW1vdmVkLCB0aGUgcGFyZW50IHBvbHlnb25zIGFyZSBpbnZhbGlkYXRlZFxuLy8gc2luY2UgdGhleSBhcmUgbm8gbG9uZ2VyIGludGFjdC5cbi8vIGNvbnN0cnVjdG9yIGNyZWF0ZXMgdGhlIHJvb3Qgbm9kZTpcbmNvbnN0IFBvbHlnb25UcmVlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMucG9seWdvbiA9IG51bGw7XG4gIHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xufTtcblxuUG9seWdvblRyZWVOb2RlLnByb3RvdHlwZSA9IHtcbiAgLy8gZmlsbCB0aGUgdHJlZSB3aXRoIHBvbHlnb25zLiBTaG91bGQgYmUgY2FsbGVkIG9uIHRoZSByb290IG5vZGUgb25seTsgY2hpbGQgbm9kZXMgbXVzdFxuICAvLyBhbHdheXMgYmUgYSBkZXJpdmF0ZSAoc3BsaXQpIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgYWRkUG9seWdvbnM6IGZ1bmN0aW9uIChwb2x5Z29ucykge1xuICAgIC8vIG5ldyBwb2x5Z29ucyBjYW4gb25seSBiZSBhZGRlZCB0byByb290IG5vZGU7IGNoaWxkcmVuIGNhbiBvbmx5IGJlIHNwbGl0dGVkIHBvbHlnb25zXG4gICAgaWYgKCF0aGlzLmlzUm9vdE5vZGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gICAgfVxuICAgIGxldCBfdGhpcyA9IHRoaXM7XG4gICAgcG9seWdvbnMubWFwKGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgICBfdGhpcy5hZGRDaGlsZChwb2x5Z29uKTtcbiAgICB9KTtcbiAgfSxcblxuICAvLyByZW1vdmUgYSBub2RlXG4gIC8vIC0gdGhlIHNpYmxpbmdzIGJlY29tZSB0b3BsZXZlbCBub2Rlc1xuICAvLyAtIHRoZSBwYXJlbnQgaXMgcmVtb3ZlZCByZWN1cnNpdmVseVxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMucmVtb3ZlZCkge1xuICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcblxuICAgICAgaWYgKF9DU0dERUJVRykge1xuICAgICAgICBpZiAodGhpcy5pc1Jvb3ROb2RlKCkpIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZCcpOyAvLyBjYW4ndCByZW1vdmUgcm9vdCBub2RlXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7IC8vIHdlIHNob3VsZG4ndCByZW1vdmUgbm9kZXMgd2l0aCBjaGlsZHJlblxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgb3Vyc2VsdmVzIGZyb20gdGhlIHBhcmVudCdzIGNoaWxkcmVuIGxpc3Q6XG4gICAgICBsZXQgcGFyZW50c2NoaWxkcmVuID0gdGhpcy5wYXJlbnQuY2hpbGRyZW47XG4gICAgICBsZXQgaSA9IHBhcmVudHNjaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGkgPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgICAgIHBhcmVudHNjaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgIC8vIGludmFsaWRhdGUgdGhlIHBhcmVudCdzIHBvbHlnb24sIGFuZCBvZiBhbGwgcGFyZW50cyBhYm92ZSBpdDpcbiAgICAgIHRoaXMucGFyZW50LnJlY3Vyc2l2ZWx5SW52YWxpZGF0ZVBvbHlnb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgaXNSZW1vdmVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlZDtcbiAgfSxcblxuICBpc1Jvb3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLnBhcmVudDtcbiAgfSxcblxuICAvLyBpbnZlcnQgYWxsIHBvbHlnb25zIGluIHRoZSB0cmVlLiBDYWxsIG9uIHRoZSByb290IG5vZGVcbiAgaW52ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUm9vdE5vZGUoKSkgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7IC8vIGNhbiBvbmx5IGNhbGwgdGhpcyBvbiB0aGUgcm9vdCBub2RlXG4gICAgdGhpcy5pbnZlcnRTdWIoKTtcbiAgfSxcblxuICBnZXRQb2x5Z29uOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnBvbHlnb24pIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZCcpOyAvLyBkb2Vzbid0IGhhdmUgYSBwb2x5Z29uLCB3aGljaCBtZWFucyB0aGF0IGl0IGhhcyBiZWVuIGJyb2tlbiBkb3duXG4gICAgcmV0dXJuIHRoaXMucG9seWdvbjtcbiAgfSxcblxuICBnZXRQb2x5Z29uczogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGxldCBjaGlsZHJlbiA9IFt0aGlzXTtcbiAgICBsZXQgcXVldWUgPSBbY2hpbGRyZW5dO1xuICAgIGxldCBpLCBqLCBsLCBub2RlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gcXVldWUgc2l6ZSBjYW4gY2hhbmdlIGluIGxvb3AsIGRvbid0IGNhY2hlIGxlbmd0aFxuICAgICAgY2hpbGRyZW4gPSBxdWV1ZVtpXTtcbiAgICAgIGZvciAoaiA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgLy8gb2sgdG8gY2FjaGUgbGVuZ3RoXG4gICAgICAgIG5vZGUgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKG5vZGUucG9seWdvbikge1xuICAgICAgICAgIC8vIHRoZSBwb2x5Z29uIGhhc24ndCBiZWVuIGJyb2tlbiB5ZXQuIFdlIGNhbiBpZ25vcmUgdGhlIGNoaWxkcmVuIGFuZCByZXR1cm4gb3VyIHBvbHlnb246XG4gICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5wb2x5Z29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXIgcG9seWdvbiBoYXMgYmVlbiBzcGxpdCB1cCBhbmQgYnJva2VuLCBzbyBnYXRoZXIgYWxsIHN1YnBvbHlnb25zIGZyb20gdGhlIGNoaWxkcmVuXG4gICAgICAgICAgcXVldWUucHVzaChub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBzcGxpdCB0aGUgbm9kZSBieSBhIHBsYW5lOyBhZGQgdGhlIHJlc3VsdGluZyBub2RlcyB0byB0aGUgZnJvbnRub2RlcyBhbmQgYmFja25vZGVzIGFycmF5XG4gIC8vIElmIHRoZSBwbGFuZSBkb2Vzbid0IGludGVyc2VjdCB0aGUgcG9seWdvbiwgdGhlICd0aGlzJyBvYmplY3QgaXMgYWRkZWQgdG8gb25lIG9mIHRoZSBhcnJheXNcbiAgLy8gSWYgdGhlIHBsYW5lIGRvZXMgaW50ZXJzZWN0IHRoZSBwb2x5Z29uLCB0d28gbmV3IGNoaWxkIG5vZGVzIGFyZSBjcmVhdGVkIGZvciB0aGUgZnJvbnQgYW5kIGJhY2sgZnJhZ21lbnRzLFxuICAvLyAgYW5kIGFkZGVkIHRvIGJvdGggYXJyYXlzLlxuICBzcGxpdEJ5UGxhbmU6IGZ1bmN0aW9uIChcbiAgICBwbGFuZSxcbiAgICBjb3BsYW5hcmZyb250bm9kZXMsXG4gICAgY29wbGFuYXJiYWNrbm9kZXMsXG4gICAgZnJvbnRub2RlcyxcbiAgICBiYWNrbm9kZXNcbiAgKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBsZXQgcXVldWUgPSBbdGhpcy5jaGlsZHJlbl07XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IGw7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGxldCBub2RlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBxdWV1ZS5sZW5ndGggY2FuIGluY3JlYXNlLCBkbyBub3QgY2FjaGVcbiAgICAgICAgbm9kZXMgPSBxdWV1ZVtpXTtcbiAgICAgICAgZm9yIChqID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgIC8vIG9rIHRvIGNhY2hlIGxlbmd0aFxuICAgICAgICAgIG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGNoaWxkcmVuLiBTcGxpdCB0aGUgcG9seWdvbjpcbiAgICAgICAgICAgIG5vZGUuX3NwbGl0QnlQbGFuZShcbiAgICAgICAgICAgICAgcGxhbmUsXG4gICAgICAgICAgICAgIGNvcGxhbmFyZnJvbnRub2RlcyxcbiAgICAgICAgICAgICAgY29wbGFuYXJiYWNrbm9kZXMsXG4gICAgICAgICAgICAgIGZyb250bm9kZXMsXG4gICAgICAgICAgICAgIGJhY2tub2Rlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3BsaXRCeVBsYW5lKFxuICAgICAgICBwbGFuZSxcbiAgICAgICAgY29wbGFuYXJmcm9udG5vZGVzLFxuICAgICAgICBjb3BsYW5hcmJhY2tub2RlcyxcbiAgICAgICAgZnJvbnRub2RlcyxcbiAgICAgICAgYmFja25vZGVzXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICAvLyBvbmx5IHRvIGJlIGNhbGxlZCBmb3Igbm9kZXMgd2l0aCBubyBjaGlsZHJlblxuICBfc3BsaXRCeVBsYW5lOiBmdW5jdGlvbiAoXG4gICAgcGxhbmUsXG4gICAgY29wbGFuYXJmcm9udG5vZGVzLFxuICAgIGNvcGxhbmFyYmFja25vZGVzLFxuICAgIGZyb250bm9kZXMsXG4gICAgYmFja25vZGVzXG4gICkge1xuICAgIGxldCBwb2x5Z29uID0gdGhpcy5wb2x5Z29uO1xuICAgIGlmIChwb2x5Z29uKSB7XG4gICAgICBpZiAoKytzcGxpdFBvbHlnb25CeVBsYW5lQ291bnQgJSAxMDAwID09PSAwKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBRUS9zcGxpdEJ5UGxhbmU6ICR7c3BsaXRQb2x5Z29uQnlQbGFuZUNvdW50fWApO1xuICAgICAgfVxuICAgICAgbGV0IGJvdW5kID0gcG9seWdvbi5ib3VuZGluZ1NwaGVyZSgpO1xuICAgICAgbGV0IHNwaGVyZXJhZGl1cyA9IGJvdW5kWzFdICsgRVBTOyAvLyBGSVhNRSBXaHkgYWRkIGltcHJlY2lzaW9uP1xuICAgICAgbGV0IHBsYW5lbm9ybWFsID0gcGxhbmUubm9ybWFsO1xuICAgICAgbGV0IHNwaGVyZWNlbnRlciA9IGJvdW5kWzBdO1xuICAgICAgbGV0IGQgPSBwbGFuZW5vcm1hbC5kb3Qoc3BoZXJlY2VudGVyKSAtIHBsYW5lLnc7XG4gICAgICBpZiAoZCA+IHNwaGVyZXJhZGl1cykge1xuICAgICAgICBmcm9udG5vZGVzLnB1c2godGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKGQgPCAtc3BoZXJlcmFkaXVzKSB7XG4gICAgICAgIGJhY2tub2Rlcy5wdXNoKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHNwbGl0cmVzdWx0ID0gc3BsaXRQb2x5Z29uQnlQbGFuZShwbGFuZSwgcG9seWdvbik7XG4gICAgICAgIHN3aXRjaCAoc3BsaXRyZXN1bHQudHlwZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIGNvcGxhbmFyIGZyb250OlxuICAgICAgICAgICAgY29wbGFuYXJmcm9udG5vZGVzLnB1c2godGhpcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIGNvcGxhbmFyIGJhY2s6XG4gICAgICAgICAgICBjb3BsYW5hcmJhY2tub2Rlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBmcm9udDpcbiAgICAgICAgICAgIGZyb250bm9kZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgLy8gYmFjazpcbiAgICAgICAgICAgIGJhY2tub2Rlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAvLyBzcGFubmluZzpcbiAgICAgICAgICAgIGlmIChzcGxpdHJlc3VsdC5mcm9udCkge1xuICAgICAgICAgICAgICBsZXQgZnJvbnRub2RlID0gdGhpcy5hZGRDaGlsZChzcGxpdHJlc3VsdC5mcm9udCk7XG4gICAgICAgICAgICAgIGZyb250bm9kZXMucHVzaChmcm9udG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwbGl0cmVzdWx0LmJhY2spIHtcbiAgICAgICAgICAgICAgbGV0IGJhY2tub2RlID0gdGhpcy5hZGRDaGlsZChzcGxpdHJlc3VsdC5iYWNrKTtcbiAgICAgICAgICAgICAgYmFja25vZGVzLnB1c2goYmFja25vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gUFJJVkFURSBtZXRob2RzIGZyb20gaGVyZTpcbiAgLy8gYWRkIGNoaWxkIHRvIGEgbm9kZVxuICAvLyB0aGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHBvbHlnb24gaXMgc3BsaXRcbiAgLy8gYSBjaGlsZCBzaG91bGQgYmUgY3JlYXRlZCBmb3IgZXZlcnkgZnJhZ21lbnQgb2YgdGhlIHNwbGl0IHBvbHlnb25cbiAgLy8gcmV0dXJucyB0aGUgbmV3bHkgY3JlYXRlZCBjaGlsZFxuICBhZGRDaGlsZDogZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICBsZXQgbmV3Y2hpbGQgPSBuZXcgUG9seWdvblRyZWVOb2RlKCk7XG4gICAgbmV3Y2hpbGQucGFyZW50ID0gdGhpcztcbiAgICBuZXdjaGlsZC5wb2x5Z29uID0gcG9seWdvbjtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2gobmV3Y2hpbGQpO1xuICAgIHJldHVybiBuZXdjaGlsZDtcbiAgfSxcblxuICBpbnZlcnRTdWI6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBbdGhpc107XG4gICAgbGV0IHF1ZXVlID0gW2NoaWxkcmVuXTtcbiAgICBsZXQgaSwgaiwgbCwgbm9kZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuID0gcXVldWVbaV07XG4gICAgICBmb3IgKGogPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKG5vZGUucG9seWdvbikge1xuICAgICAgICAgIG5vZGUucG9seWdvbiA9IG5vZGUucG9seWdvbi5mbGlwcGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUucHVzaChub2RlLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVjdXJzaXZlbHlJbnZhbGlkYXRlUG9seWdvbjogZnVuY3Rpb24gKCkge1xuICAgIGxldCBub2RlID0gdGhpcztcbiAgICB3aGlsZSAobm9kZS5wb2x5Z29uKSB7XG4gICAgICBub2RlLnBvbHlnb24gPSBudWxsO1xuICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59O1xuXG4vLyAjIGNsYXNzIFRyZWVcbi8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSBCU1AgdHJlZVxuLy8gV2UgYXJlIHVzaW5nIHRoaXMgc2VwYXJhdGUgY2xhc3MgZm9yIHRoZSByb290IG9mIHRoZSB0cmVlLCB0byBob2xkIHRoZSBQb2x5Z29uVHJlZU5vZGUgcm9vdFxuLy8gVGhlIGFjdHVhbCB0cmVlIGlzIGtlcHQgaW4gdGhpcy5yb290bm9kZVxuY29uc3QgVHJlZSA9IGZ1bmN0aW9uIChwb2x5Z29ucykge1xuICB0aGlzLnBvbHlnb25UcmVlID0gbmV3IFBvbHlnb25UcmVlTm9kZSgpO1xuICB0aGlzLnJvb3Rub2RlID0gbmV3IE5vZGUobnVsbCk7XG4gIGlmIChwb2x5Z29ucykgdGhpcy5hZGRQb2x5Z29ucyhwb2x5Z29ucyk7XG59O1xuXG5UcmVlLnByb3RvdHlwZSA9IHtcbiAgaW52ZXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wb2x5Z29uVHJlZS5pbnZlcnQoKTtcbiAgICB0aGlzLnJvb3Rub2RlLmludmVydCgpO1xuICB9LFxuXG4gIC8vIFJlbW92ZSBhbGwgcG9seWdvbnMgaW4gdGhpcyBCU1AgdHJlZSB0aGF0IGFyZSBpbnNpZGUgdGhlIG90aGVyIEJTUCB0cmVlXG4gIC8vIGB0cmVlYC5cbiAgY2xpcFRvOiBmdW5jdGlvbiAodHJlZSwgYWxzb1JlbW92ZWNvcGxhbmFyRnJvbnQpIHtcbiAgICBhbHNvUmVtb3ZlY29wbGFuYXJGcm9udCA9ICEhYWxzb1JlbW92ZWNvcGxhbmFyRnJvbnQ7XG4gICAgdGhpcy5yb290bm9kZS5jbGlwVG8odHJlZSwgYWxzb1JlbW92ZWNvcGxhbmFyRnJvbnQpO1xuICB9LFxuXG4gIGFsbFBvbHlnb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIHRoaXMucG9seWdvblRyZWUuZ2V0UG9seWdvbnMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGFkZFBvbHlnb25zOiBmdW5jdGlvbiAocG9seWdvbnMpIHtcbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBwb2x5Z29udHJlZW5vZGVzID0gcG9seWdvbnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gX3RoaXMucG9seWdvblRyZWUuYWRkQ2hpbGQocCk7XG4gICAgfSk7XG4gICAgdGhpcy5yb290bm9kZS5hZGRQb2x5Z29uVHJlZU5vZGVzKHBvbHlnb250cmVlbm9kZXMpO1xuICB9LFxufTtcblxuLy8gIyBjbGFzcyBOb2RlXG4vLyBIb2xkcyBhIG5vZGUgaW4gYSBCU1AgdHJlZS4gQSBCU1AgdHJlZSBpcyBidWlsdCBmcm9tIGEgY29sbGVjdGlvbiBvZiBwb2x5Z29uc1xuLy8gYnkgcGlja2luZyBhIHBvbHlnb24gdG8gc3BsaXQgYWxvbmcuXG4vLyBQb2x5Z29ucyBhcmUgbm90IHN0b3JlZCBkaXJlY3RseSBpbiB0aGUgdHJlZSwgYnV0IGluIFBvbHlnb25UcmVlTm9kZXMsIHN0b3JlZCBpblxuLy8gdGhpcy5wb2x5Z29udHJlZW5vZGVzLiBUaG9zZSBQb2x5Z29uVHJlZU5vZGVzIGFyZSBjaGlsZHJlbiBvZiB0aGUgb3duaW5nXG4vLyBUcmVlLnBvbHlnb25UcmVlXG4vLyBUaGlzIGlzIG5vdCBhIGxlYWZ5IEJTUCB0cmVlIHNpbmNlIHRoZXJlIGlzXG4vLyBubyBkaXN0aW5jdGlvbiBiZXR3ZWVuIGludGVybmFsIGFuZCBsZWFmIG5vZGVzLlxuY29uc3QgTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgdGhpcy5wbGFuZSA9IG51bGw7XG4gIHRoaXMuZnJvbnQgPSBudWxsO1xuICB0aGlzLmJhY2sgPSBudWxsO1xuICB0aGlzLnBvbHlnb250cmVlbm9kZXMgPSBbXTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZSA9IHtcbiAgLy8gQ29udmVydCBzb2xpZCBzcGFjZSB0byBlbXB0eSBzcGFjZSBhbmQgZW1wdHkgc3BhY2UgdG8gc29saWQgc3BhY2UuXG4gIGludmVydDogZnVuY3Rpb24gKCkge1xuICAgIGxldCBxdWV1ZSA9IFt0aGlzXTtcbiAgICBsZXQgbm9kZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gcXVldWVbaV07XG4gICAgICBpZiAobm9kZS5wbGFuZSkgbm9kZS5wbGFuZSA9IG5vZGUucGxhbmUuZmxpcHBlZCgpO1xuICAgICAgaWYgKG5vZGUuZnJvbnQpIHF1ZXVlLnB1c2gobm9kZS5mcm9udCk7XG4gICAgICBpZiAobm9kZS5iYWNrKSBxdWV1ZS5wdXNoKG5vZGUuYmFjayk7XG4gICAgICBsZXQgdGVtcCA9IG5vZGUuZnJvbnQ7XG4gICAgICBub2RlLmZyb250ID0gbm9kZS5iYWNrO1xuICAgICAgbm9kZS5iYWNrID0gdGVtcDtcbiAgICB9XG4gIH0sXG5cbiAgLy8gY2xpcCBwb2x5Z29udHJlZW5vZGVzIHRvIG91ciBwbGFuZVxuICAvLyBjYWxscyByZW1vdmUoKSBmb3IgYWxsIGNsaXBwZWQgUG9seWdvblRyZWVOb2Rlc1xuICBjbGlwUG9seWdvbnM6IGZ1bmN0aW9uIChwb2x5Z29udHJlZW5vZGVzLCBhbHNvUmVtb3ZlY29wbGFuYXJGcm9udCkge1xuICAgIGxldCBhcmdzID0geyBub2RlOiB0aGlzLCBwb2x5Z29udHJlZW5vZGVzOiBwb2x5Z29udHJlZW5vZGVzIH07XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IHN0YWNrID0gW107XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gYXJncy5ub2RlO1xuICAgICAgcG9seWdvbnRyZWVub2RlcyA9IGFyZ3MucG9seWdvbnRyZWVub2RlcztcblxuICAgICAgLy8gYmVnaW4gXCJmdW5jdGlvblwiXG4gICAgICBpZiAobm9kZS5wbGFuZSkge1xuICAgICAgICBsZXQgYmFja25vZGVzID0gW107XG4gICAgICAgIGxldCBmcm9udG5vZGVzID0gW107XG4gICAgICAgIGxldCBjb3BsYW5hcmZyb250bm9kZXMgPSBhbHNvUmVtb3ZlY29wbGFuYXJGcm9udFxuICAgICAgICAgID8gYmFja25vZGVzXG4gICAgICAgICAgOiBmcm9udG5vZGVzO1xuICAgICAgICBsZXQgcGxhbmUgPSBub2RlLnBsYW5lO1xuICAgICAgICBsZXQgbnVtcG9seWdvbnRyZWVub2RlcyA9IHBvbHlnb250cmVlbm9kZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXBvbHlnb250cmVlbm9kZXM7IGkrKykge1xuICAgICAgICAgIGxldCBub2RlMSA9IHBvbHlnb250cmVlbm9kZXNbaV07XG4gICAgICAgICAgaWYgKCFub2RlMS5pc1JlbW92ZWQoKSkge1xuICAgICAgICAgICAgbm9kZTEuc3BsaXRCeVBsYW5lKFxuICAgICAgICAgICAgICBwbGFuZSxcbiAgICAgICAgICAgICAgY29wbGFuYXJmcm9udG5vZGVzLFxuICAgICAgICAgICAgICBiYWNrbm9kZXMsXG4gICAgICAgICAgICAgIGZyb250bm9kZXMsXG4gICAgICAgICAgICAgIGJhY2tub2Rlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5mcm9udCAmJiBmcm9udG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHsgbm9kZTogbm9kZS5mcm9udCwgcG9seWdvbnRyZWVub2RlczogZnJvbnRub2RlcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtYmFja25vZGVzID0gYmFja25vZGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKG5vZGUuYmFjayAmJiBudW1iYWNrbm9kZXMgPiAwKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCh7IG5vZGU6IG5vZGUuYmFjaywgcG9seWdvbnRyZWVub2RlczogYmFja25vZGVzIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZXJlJ3Mgbm90aGluZyBiZWhpbmQgdGhpcyBwbGFuZS4gRGVsZXRlIHRoZSBub2RlcyBiZWhpbmQgdGhpcyBwbGFuZTpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJhY2tub2RlczsgaSsrKSB7XG4gICAgICAgICAgICBiYWNrbm9kZXNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzID0gc3RhY2sucG9wKCk7XG4gICAgfSB3aGlsZSAodHlwZW9mIGFyZ3MgIT09ICd1bmRlZmluZWQnKTtcbiAgfSxcblxuICAvLyBSZW1vdmUgYWxsIHBvbHlnb25zIGluIHRoaXMgQlNQIHRyZWUgdGhhdCBhcmUgaW5zaWRlIHRoZSBvdGhlciBCU1AgdHJlZVxuICAvLyBgdHJlZWAuXG4gIGNsaXBUbzogZnVuY3Rpb24gKHRyZWUsIGFsc29SZW1vdmVjb3BsYW5hckZyb250KSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGRvIHtcbiAgICAgIGlmIChub2RlLnBvbHlnb250cmVlbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0cmVlLnJvb3Rub2RlLmNsaXBQb2x5Z29ucyhcbiAgICAgICAgICBub2RlLnBvbHlnb250cmVlbm9kZXMsXG4gICAgICAgICAgYWxzb1JlbW92ZWNvcGxhbmFyRnJvbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmZyb250KSBzdGFjay5wdXNoKG5vZGUuZnJvbnQpO1xuICAgICAgaWYgKG5vZGUuYmFjaykgc3RhY2sucHVzaChub2RlLmJhY2spO1xuICAgICAgbm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgIH0gd2hpbGUgKHR5cGVvZiBub2RlICE9PSAndW5kZWZpbmVkJyk7XG4gIH0sXG5cbiAgYWRkUG9seWdvblRyZWVOb2RlczogZnVuY3Rpb24gKHBvbHlnb250cmVlbm9kZXMpIHtcbiAgICBsZXQgYXJncyA9IHsgbm9kZTogdGhpcywgcG9seWdvbnRyZWVub2RlczogcG9seWdvbnRyZWVub2RlcyB9O1xuICAgIGxldCBub2RlO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBhcmdzLm5vZGU7XG4gICAgICBwb2x5Z29udHJlZW5vZGVzID0gYXJncy5wb2x5Z29udHJlZW5vZGVzO1xuXG4gICAgICBpZiAocG9seWdvbnRyZWVub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYXJncyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBfdGhpcyA9IG5vZGU7XG4gICAgICBpZiAoIW5vZGUucGxhbmUpIHtcbiAgICAgICAgbGV0IGJlc3RwbGFuZSA9IHBvbHlnb250cmVlbm9kZXNbMF0uZ2V0UG9seWdvbigpLnBsYW5lO1xuICAgICAgICBub2RlLnBsYW5lID0gYmVzdHBsYW5lO1xuICAgICAgfVxuICAgICAgbGV0IGZyb250bm9kZXMgPSBbXTtcbiAgICAgIGxldCBiYWNrbm9kZXMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwb2x5Z29udHJlZW5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBwb2x5Z29udHJlZW5vZGVzW2ldLnNwbGl0QnlQbGFuZShcbiAgICAgICAgICBfdGhpcy5wbGFuZSxcbiAgICAgICAgICBfdGhpcy5wb2x5Z29udHJlZW5vZGVzLFxuICAgICAgICAgIGJhY2tub2RlcyxcbiAgICAgICAgICBmcm9udG5vZGVzLFxuICAgICAgICAgIGJhY2tub2Rlc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbnRub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghbm9kZS5mcm9udCkgbm9kZS5mcm9udCA9IG5ldyBOb2RlKG5vZGUpO1xuICAgICAgICBzdGFjay5wdXNoKHsgbm9kZTogbm9kZS5mcm9udCwgcG9seWdvbnRyZWVub2RlczogZnJvbnRub2RlcyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIW5vZGUuYmFjaykgbm9kZS5iYWNrID0gbmV3IE5vZGUobm9kZSk7XG4gICAgICAgIHN0YWNrLnB1c2goeyBub2RlOiBub2RlLmJhY2ssIHBvbHlnb250cmVlbm9kZXM6IGJhY2tub2RlcyB9KTtcbiAgICAgIH1cblxuICAgICAgYXJncyA9IHN0YWNrLnBvcCgpO1xuICAgIH0gd2hpbGUgKHR5cGVvZiBhcmdzICE9PSAndW5kZWZpbmVkJyk7XG4gIH0sXG5cbiAgZ2V0UGFyZW50UGxhbmVOb3JtYWxzOiBmdW5jdGlvbiAobm9ybWFscywgbWF4ZGVwdGgpIHtcbiAgICBpZiAobWF4ZGVwdGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgbm9ybWFscy5wdXNoKHRoaXMucGFyZW50LnBsYW5lLm5vcm1hbCk7XG4gICAgICAgIHRoaXMucGFyZW50LmdldFBhcmVudFBsYW5lTm9ybWFscyhub3JtYWxzLCBtYXhkZXB0aCAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/trees.js\n");

/***/ }),

/***/ "./src/core/utils.js":
/*!***************************!*\
  !*** ./src/core/utils.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function fnNumberSort(a, b) {\n  return a - b;\n}\n\nfunction fnSortByIndex(a, b) {\n  return a.index - b.index;\n}\n\nconst IsFloat = function (n) {\n  return !isNaN(n) || n === Infinity || n === -Infinity;\n};\n\nconst solve2Linear = function (a, b, c, d, u, v) {\n  let det = a * d - b * c;\n  let invdet = 1.0 / det;\n  let x = u * d - b * v;\n  let y = -u * c + a * v;\n  x *= invdet;\n  y *= invdet;\n  return [x, y];\n};\n\nfunction insertSorted(array, element, comparefunc) {\n  let leftbound = 0;\n  let rightbound = array.length;\n  while (rightbound > leftbound) {\n    let testindex = Math.floor((leftbound + rightbound) / 2);\n    let testelement = array[testindex];\n    let compareresult = comparefunc(element, testelement);\n    if (compareresult > 0) {\n      // element > testelement\n      leftbound = testindex + 1;\n    } else {\n      rightbound = testindex;\n    }\n  }\n  array.splice(leftbound, 0, element);\n}\n\n// Get the x coordinate of a point with a certain y coordinate, interpolated between two\n// points (CSG.Vector2D).\n// Interpolation is robust even if the points have the same y coordinate\nconst interpolateBetween2DPointsForY = function (point1, point2, y) {\n  let f1 = y - point1.y;\n  let f2 = point2.y - point1.y;\n  if (f2 < 0) {\n    f1 = -f1;\n    f2 = -f2;\n  }\n  let t;\n  if (f1 <= 0) {\n    t = 0.0;\n  } else if (f1 >= f2) {\n    t = 1.0;\n  } else if (f2 < 1e-10) {\n    // FIXME Should this be CSG.EPS?\n    t = 0.5;\n  } else {\n    t = f1 / f2;\n  }\n  let result = point1.x + t * (point2.x - point1.x);\n  return result;\n};\n\nfunction isCAG(object) {\n  // objects[i] instanceof CAG => NOT RELIABLE\n  // 'instanceof' causes huge issues when using objects from\n  // two different versions of CSG.js as they are not reckonized as one and the same\n  // so DO NOT use instanceof to detect matching types for CSG/CAG\n  if (!('sides' in object)) {\n    return false;\n  }\n  if (!('length' in object.sides)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isCSG(object) {\n  // objects[i] instanceof CSG => NOT RELIABLE\n  // 'instanceof' causes huge issues when using objects from\n  // two different versions of CSG.js as they are not reckonized as one and the same\n  // so DO NOT use instanceof to detect matching types for CSG/CAG\n  if (!('polygons' in object)) {\n    return false;\n  }\n  if (!('length' in object.polygons)) {\n    return false;\n  }\n  return true;\n}\n\nmodule.exports = {\n  fnNumberSort,\n  fnSortByIndex,\n  IsFloat,\n  solve2Linear,\n  insertSorted,\n  interpolateBetween2DPointsForY,\n  isCAG,\n  isCSG,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL3V0aWxzLmpzP2IxYzciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZm5OdW1iZXJTb3J0KGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBmblNvcnRCeUluZGV4KGEsIGIpIHtcbiAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xufVxuXG5jb25zdCBJc0Zsb2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuICFpc05hTihuKSB8fCBuID09PSBJbmZpbml0eSB8fCBuID09PSAtSW5maW5pdHk7XG59O1xuXG5jb25zdCBzb2x2ZTJMaW5lYXIgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgdSwgdikge1xuICBsZXQgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgbGV0IGludmRldCA9IDEuMCAvIGRldDtcbiAgbGV0IHggPSB1ICogZCAtIGIgKiB2O1xuICBsZXQgeSA9IC11ICogYyArIGEgKiB2O1xuICB4ICo9IGludmRldDtcbiAgeSAqPSBpbnZkZXQ7XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG5mdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYXJyYXksIGVsZW1lbnQsIGNvbXBhcmVmdW5jKSB7XG4gIGxldCBsZWZ0Ym91bmQgPSAwO1xuICBsZXQgcmlnaHRib3VuZCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKHJpZ2h0Ym91bmQgPiBsZWZ0Ym91bmQpIHtcbiAgICBsZXQgdGVzdGluZGV4ID0gTWF0aC5mbG9vcigobGVmdGJvdW5kICsgcmlnaHRib3VuZCkgLyAyKTtcbiAgICBsZXQgdGVzdGVsZW1lbnQgPSBhcnJheVt0ZXN0aW5kZXhdO1xuICAgIGxldCBjb21wYXJlcmVzdWx0ID0gY29tcGFyZWZ1bmMoZWxlbWVudCwgdGVzdGVsZW1lbnQpO1xuICAgIGlmIChjb21wYXJlcmVzdWx0ID4gMCkge1xuICAgICAgLy8gZWxlbWVudCA+IHRlc3RlbGVtZW50XG4gICAgICBsZWZ0Ym91bmQgPSB0ZXN0aW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodGJvdW5kID0gdGVzdGluZGV4O1xuICAgIH1cbiAgfVxuICBhcnJheS5zcGxpY2UobGVmdGJvdW5kLCAwLCBlbGVtZW50KTtcbn1cblxuLy8gR2V0IHRoZSB4IGNvb3JkaW5hdGUgb2YgYSBwb2ludCB3aXRoIGEgY2VydGFpbiB5IGNvb3JkaW5hdGUsIGludGVycG9sYXRlZCBiZXR3ZWVuIHR3b1xuLy8gcG9pbnRzIChDU0cuVmVjdG9yMkQpLlxuLy8gSW50ZXJwb2xhdGlvbiBpcyByb2J1c3QgZXZlbiBpZiB0aGUgcG9pbnRzIGhhdmUgdGhlIHNhbWUgeSBjb29yZGluYXRlXG5jb25zdCBpbnRlcnBvbGF0ZUJldHdlZW4yRFBvaW50c0ZvclkgPSBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIsIHkpIHtcbiAgbGV0IGYxID0geSAtIHBvaW50MS55O1xuICBsZXQgZjIgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICBpZiAoZjIgPCAwKSB7XG4gICAgZjEgPSAtZjE7XG4gICAgZjIgPSAtZjI7XG4gIH1cbiAgbGV0IHQ7XG4gIGlmIChmMSA8PSAwKSB7XG4gICAgdCA9IDAuMDtcbiAgfSBlbHNlIGlmIChmMSA+PSBmMikge1xuICAgIHQgPSAxLjA7XG4gIH0gZWxzZSBpZiAoZjIgPCAxZS0xMCkge1xuICAgIC8vIEZJWE1FIFNob3VsZCB0aGlzIGJlIENTRy5FUFM/XG4gICAgdCA9IDAuNTtcbiAgfSBlbHNlIHtcbiAgICB0ID0gZjEgLyBmMjtcbiAgfVxuICBsZXQgcmVzdWx0ID0gcG9pbnQxLnggKyB0ICogKHBvaW50Mi54IC0gcG9pbnQxLngpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gaXNDQUcob2JqZWN0KSB7XG4gIC8vIG9iamVjdHNbaV0gaW5zdGFuY2VvZiBDQUcgPT4gTk9UIFJFTElBQkxFXG4gIC8vICdpbnN0YW5jZW9mJyBjYXVzZXMgaHVnZSBpc3N1ZXMgd2hlbiB1c2luZyBvYmplY3RzIGZyb21cbiAgLy8gdHdvIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBDU0cuanMgYXMgdGhleSBhcmUgbm90IHJlY2tvbml6ZWQgYXMgb25lIGFuZCB0aGUgc2FtZVxuICAvLyBzbyBETyBOT1QgdXNlIGluc3RhbmNlb2YgdG8gZGV0ZWN0IG1hdGNoaW5nIHR5cGVzIGZvciBDU0cvQ0FHXG4gIGlmICghKCdzaWRlcycgaW4gb2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoISgnbGVuZ3RoJyBpbiBvYmplY3Quc2lkZXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQ1NHKG9iamVjdCkge1xuICAvLyBvYmplY3RzW2ldIGluc3RhbmNlb2YgQ1NHID0+IE5PVCBSRUxJQUJMRVxuICAvLyAnaW5zdGFuY2VvZicgY2F1c2VzIGh1Z2UgaXNzdWVzIHdoZW4gdXNpbmcgb2JqZWN0cyBmcm9tXG4gIC8vIHR3byBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgQ1NHLmpzIGFzIHRoZXkgYXJlIG5vdCByZWNrb25pemVkIGFzIG9uZSBhbmQgdGhlIHNhbWVcbiAgLy8gc28gRE8gTk9UIHVzZSBpbnN0YW5jZW9mIHRvIGRldGVjdCBtYXRjaGluZyB0eXBlcyBmb3IgQ1NHL0NBR1xuICBpZiAoISgncG9seWdvbnMnIGluIG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoJ2xlbmd0aCcgaW4gb2JqZWN0LnBvbHlnb25zKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZuTnVtYmVyU29ydCxcbiAgZm5Tb3J0QnlJbmRleCxcbiAgSXNGbG9hdCxcbiAgc29sdmUyTGluZWFyLFxuICBpbnNlcnRTb3J0ZWQsXG4gIGludGVycG9sYXRlQmV0d2VlbjJEUG9pbnRzRm9yWSxcbiAgaXNDQUcsXG4gIGlzQ1NHLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/utils.js\n");

/***/ }),

/***/ "./src/core/utils/cagMeasurements.js":
/*!*******************************************!*\
  !*** ./src/core/utils/cagMeasurements.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector2D = __webpack_require__(/*! ../math/Vector2 */ \"./src/core/math/Vector2.js\");\n\n// see http://local.wasp.uwa.edu.au/~pbourke/geometry/polyarea/ :\n// Area of the polygon. For a counter clockwise rotating polygon the area is positive, otherwise negative\n// Note(bebbi): this looks wrong. See polygon getArea()\nconst area = function (cag) {\n  let polygonArea = 0;\n  cag.sides.map(function (side) {\n    polygonArea += side.vertex0.pos.cross(side.vertex1.pos);\n  });\n  polygonArea *= 0.5;\n  return polygonArea;\n};\n\nconst getBounds = function (cag) {\n  let minpoint;\n  if (cag.sides.length === 0) {\n    minpoint = new Vector2D(0, 0);\n  } else {\n    minpoint = cag.sides[0].vertex0.pos;\n  }\n  let maxpoint = minpoint;\n  cag.sides.map(function (side) {\n    minpoint = minpoint.min(side.vertex0.pos);\n    minpoint = minpoint.min(side.vertex1.pos);\n    maxpoint = maxpoint.max(side.vertex0.pos);\n    maxpoint = maxpoint.max(side.vertex1.pos);\n  });\n  return [minpoint, maxpoint];\n};\n\nmodule.exports = { area, getBounds };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy9jYWdNZWFzdXJlbWVudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS91dGlscy9jYWdNZWFzdXJlbWVudHMuanM/ZDg3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IyRCA9IHJlcXVpcmUoJy4uL21hdGgvVmVjdG9yMicpO1xuXG4vLyBzZWUgaHR0cDovL2xvY2FsLndhc3AudXdhLmVkdS5hdS9+cGJvdXJrZS9nZW9tZXRyeS9wb2x5YXJlYS8gOlxuLy8gQXJlYSBvZiB0aGUgcG9seWdvbi4gRm9yIGEgY291bnRlciBjbG9ja3dpc2Ugcm90YXRpbmcgcG9seWdvbiB0aGUgYXJlYSBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIG5lZ2F0aXZlXG4vLyBOb3RlKGJlYmJpKTogdGhpcyBsb29rcyB3cm9uZy4gU2VlIHBvbHlnb24gZ2V0QXJlYSgpXG5jb25zdCBhcmVhID0gZnVuY3Rpb24gKGNhZykge1xuICBsZXQgcG9seWdvbkFyZWEgPSAwO1xuICBjYWcuc2lkZXMubWFwKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcG9seWdvbkFyZWEgKz0gc2lkZS52ZXJ0ZXgwLnBvcy5jcm9zcyhzaWRlLnZlcnRleDEucG9zKTtcbiAgfSk7XG4gIHBvbHlnb25BcmVhICo9IDAuNTtcbiAgcmV0dXJuIHBvbHlnb25BcmVhO1xufTtcblxuY29uc3QgZ2V0Qm91bmRzID0gZnVuY3Rpb24gKGNhZykge1xuICBsZXQgbWlucG9pbnQ7XG4gIGlmIChjYWcuc2lkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgbWlucG9pbnQgPSBuZXcgVmVjdG9yMkQoMCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgbWlucG9pbnQgPSBjYWcuc2lkZXNbMF0udmVydGV4MC5wb3M7XG4gIH1cbiAgbGV0IG1heHBvaW50ID0gbWlucG9pbnQ7XG4gIGNhZy5zaWRlcy5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICBtaW5wb2ludCA9IG1pbnBvaW50Lm1pbihzaWRlLnZlcnRleDAucG9zKTtcbiAgICBtaW5wb2ludCA9IG1pbnBvaW50Lm1pbihzaWRlLnZlcnRleDEucG9zKTtcbiAgICBtYXhwb2ludCA9IG1heHBvaW50Lm1heChzaWRlLnZlcnRleDAucG9zKTtcbiAgICBtYXhwb2ludCA9IG1heHBvaW50Lm1heChzaWRlLnZlcnRleDEucG9zKTtcbiAgfSk7XG4gIHJldHVybiBbbWlucG9pbnQsIG1heHBvaW50XTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBhcmVhLCBnZXRCb3VuZHMgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/utils/cagMeasurements.js\n");

/***/ }),

/***/ "./src/core/utils/cagValidation.js":
/*!*****************************************!*\
  !*** ./src/core/utils/cagValidation.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { areaEPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst { linesIntersect } = __webpack_require__(/*! ../math/lineUtils */ \"./src/core/math/lineUtils.js\");\n\n// check if we are a valid CAG (for debugging)\n// NOTE(bebbi) uneven side count doesn't work because rounding with EPS isn't taken into account\nconst isCAGValid = function (CAG) {\n  let errors = [];\n  if (CAG.isSelfIntersecting(true)) {\n    errors.push('Self intersects');\n  }\n  let pointcount = {};\n  CAG.sides.map(function (side) {\n    function mappoint(p) {\n      let tag = p.x + ' ' + p.y;\n      if (!(tag in pointcount)) pointcount[tag] = 0;\n      pointcount[tag]++;\n    }\n    mappoint(side.vertex0.pos);\n    mappoint(side.vertex1.pos);\n  });\n  for (let tag in pointcount) {\n    let count = pointcount[tag];\n    if (count & 1) {\n      errors.push('Uneven number of sides (' + count + ') for point ' + tag);\n    }\n  }\n  let area = CAG.area();\n  if (area < areaEPS) {\n    errors.push('Area is ' + area);\n  }\n  if (errors.length > 0) {\n    let ertxt = '';\n    errors.map(function (err) {\n      ertxt += err + '\\n';\n    });\n    throw new Error(ertxt);\n  }\n};\n\nconst isSelfIntersecting = function (cag, debug) {\n  let numsides = cag.sides.length;\n  for (let i = 0; i < numsides; i++) {\n    let side0 = cag.sides[i];\n    for (let ii = i + 1; ii < numsides; ii++) {\n      let side1 = cag.sides[ii];\n      if (\n        linesIntersect(\n          side0.vertex0.pos,\n          side0.vertex1.pos,\n          side1.vertex0.pos,\n          side1.vertex1.pos\n        )\n      ) {\n        if (debug) {\n          console.log('side ' + i + ': ' + side0);\n          console.log('side ' + ii + ': ' + side1);\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/** Check if the point stay inside the CAG shape\n * ray-casting algorithm based on :\n * https://github.com/substack/point-in-polygon/blob/master/index.js\n * http://www.ecse.rp1.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n * originaly writed for https://github.com/lautr3k/SLAcer.js/blob/dev/js/slacer/slicer.js#L82\n * @param {CAG} cag - CAG object\n * @param {Object} p0 - Vertex2 like object\n * @returns {Boolean}\n */\nconst hasPointInside = function (cag, p0) {\n  let p1 = null;\n  let p2 = null;\n  let inside = false;\n  cag.sides.forEach((side) => {\n    p1 = side.vertex0.pos;\n    p2 = side.vertex1.pos;\n    if (hasPointInside.c1(p0, p1, p2) && hasPointInside.c2(p0, p1, p2)) {\n      inside = !inside;\n    }\n  });\n  return inside;\n};\n\nhasPointInside.c1 = (p0, p1, p2) => p1.y > p0.y !== p2.y > p0.y;\nhasPointInside.c2 = (p0, p1, p2) =>\n  p0.x < ((p2.x - p1.x) * (p0.y - p1.y)) / (p2.y - p1.y) + p1.x;\n\n/** Check if all points from one CAG stay inside another CAG\n * @param {CAG} cag1 - CAG object\n * @param {Object} cag2 - CAG object\n * @returns {Boolean}\n */\nconst contains = function (cag1, cag2) {\n  for (let i = 0, il = cag2.sides.length; i < il; i++) {\n    if (!hasPointInside(cag1, cag2.sides[i].vertex0.pos)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = {\n  isCAGValid,\n  isSelfIntersecting,\n  hasPointInside,\n  contains,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy9jYWdWYWxpZGF0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvdXRpbHMvY2FnVmFsaWRhdGlvbi5qcz80ZDdjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYXJlYUVQUyB9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGxpbmVzSW50ZXJzZWN0IH0gPSByZXF1aXJlKCcuLi9tYXRoL2xpbmVVdGlscycpO1xuXG4vLyBjaGVjayBpZiB3ZSBhcmUgYSB2YWxpZCBDQUcgKGZvciBkZWJ1Z2dpbmcpXG4vLyBOT1RFKGJlYmJpKSB1bmV2ZW4gc2lkZSBjb3VudCBkb2Vzbid0IHdvcmsgYmVjYXVzZSByb3VuZGluZyB3aXRoIEVQUyBpc24ndCB0YWtlbiBpbnRvIGFjY291bnRcbmNvbnN0IGlzQ0FHVmFsaWQgPSBmdW5jdGlvbiAoQ0FHKSB7XG4gIGxldCBlcnJvcnMgPSBbXTtcbiAgaWYgKENBRy5pc1NlbGZJbnRlcnNlY3RpbmcodHJ1ZSkpIHtcbiAgICBlcnJvcnMucHVzaCgnU2VsZiBpbnRlcnNlY3RzJyk7XG4gIH1cbiAgbGV0IHBvaW50Y291bnQgPSB7fTtcbiAgQ0FHLnNpZGVzLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIGZ1bmN0aW9uIG1hcHBvaW50KHApIHtcbiAgICAgIGxldCB0YWcgPSBwLnggKyAnICcgKyBwLnk7XG4gICAgICBpZiAoISh0YWcgaW4gcG9pbnRjb3VudCkpIHBvaW50Y291bnRbdGFnXSA9IDA7XG4gICAgICBwb2ludGNvdW50W3RhZ10rKztcbiAgICB9XG4gICAgbWFwcG9pbnQoc2lkZS52ZXJ0ZXgwLnBvcyk7XG4gICAgbWFwcG9pbnQoc2lkZS52ZXJ0ZXgxLnBvcyk7XG4gIH0pO1xuICBmb3IgKGxldCB0YWcgaW4gcG9pbnRjb3VudCkge1xuICAgIGxldCBjb3VudCA9IHBvaW50Y291bnRbdGFnXTtcbiAgICBpZiAoY291bnQgJiAxKSB7XG4gICAgICBlcnJvcnMucHVzaCgnVW5ldmVuIG51bWJlciBvZiBzaWRlcyAoJyArIGNvdW50ICsgJykgZm9yIHBvaW50ICcgKyB0YWcpO1xuICAgIH1cbiAgfVxuICBsZXQgYXJlYSA9IENBRy5hcmVhKCk7XG4gIGlmIChhcmVhIDwgYXJlYUVQUykge1xuICAgIGVycm9ycy5wdXNoKCdBcmVhIGlzICcgKyBhcmVhKTtcbiAgfVxuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgZXJ0eHQgPSAnJztcbiAgICBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGVydHh0ICs9IGVyciArICdcXG4nO1xuICAgIH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnR4dCk7XG4gIH1cbn07XG5cbmNvbnN0IGlzU2VsZkludGVyc2VjdGluZyA9IGZ1bmN0aW9uIChjYWcsIGRlYnVnKSB7XG4gIGxldCBudW1zaWRlcyA9IGNhZy5zaWRlcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtc2lkZXM7IGkrKykge1xuICAgIGxldCBzaWRlMCA9IGNhZy5zaWRlc1tpXTtcbiAgICBmb3IgKGxldCBpaSA9IGkgKyAxOyBpaSA8IG51bXNpZGVzOyBpaSsrKSB7XG4gICAgICBsZXQgc2lkZTEgPSBjYWcuc2lkZXNbaWldO1xuICAgICAgaWYgKFxuICAgICAgICBsaW5lc0ludGVyc2VjdChcbiAgICAgICAgICBzaWRlMC52ZXJ0ZXgwLnBvcyxcbiAgICAgICAgICBzaWRlMC52ZXJ0ZXgxLnBvcyxcbiAgICAgICAgICBzaWRlMS52ZXJ0ZXgwLnBvcyxcbiAgICAgICAgICBzaWRlMS52ZXJ0ZXgxLnBvc1xuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ3NpZGUgJyArIGkgKyAnOiAnICsgc2lkZTApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzaWRlICcgKyBpaSArICc6ICcgKyBzaWRlMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKiBDaGVjayBpZiB0aGUgcG9pbnQgc3RheSBpbnNpZGUgdGhlIENBRyBzaGFwZVxuICogcmF5LWNhc3RpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9wb2ludC1pbi1wb2x5Z29uL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKiBodHRwOi8vd3d3LmVjc2UucnAxLmVkdS9Ib21lcGFnZXMvd3JmL1Jlc2VhcmNoL1Nob3J0X05vdGVzL3BucG9seS5odG1sXG4gKiBvcmlnaW5hbHkgd3JpdGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vbGF1dHIzay9TTEFjZXIuanMvYmxvYi9kZXYvanMvc2xhY2VyL3NsaWNlci5qcyNMODJcbiAqIEBwYXJhbSB7Q0FHfSBjYWcgLSBDQUcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcDAgLSBWZXJ0ZXgyIGxpa2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuY29uc3QgaGFzUG9pbnRJbnNpZGUgPSBmdW5jdGlvbiAoY2FnLCBwMCkge1xuICBsZXQgcDEgPSBudWxsO1xuICBsZXQgcDIgPSBudWxsO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGNhZy5zaWRlcy5mb3JFYWNoKChzaWRlKSA9PiB7XG4gICAgcDEgPSBzaWRlLnZlcnRleDAucG9zO1xuICAgIHAyID0gc2lkZS52ZXJ0ZXgxLnBvcztcbiAgICBpZiAoaGFzUG9pbnRJbnNpZGUuYzEocDAsIHAxLCBwMikgJiYgaGFzUG9pbnRJbnNpZGUuYzIocDAsIHAxLCBwMikpIHtcbiAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluc2lkZTtcbn07XG5cbmhhc1BvaW50SW5zaWRlLmMxID0gKHAwLCBwMSwgcDIpID0+IHAxLnkgPiBwMC55ICE9PSBwMi55ID4gcDAueTtcbmhhc1BvaW50SW5zaWRlLmMyID0gKHAwLCBwMSwgcDIpID0+XG4gIHAwLnggPCAoKHAyLnggLSBwMS54KSAqIChwMC55IC0gcDEueSkpIC8gKHAyLnkgLSBwMS55KSArIHAxLng7XG5cbi8qKiBDaGVjayBpZiBhbGwgcG9pbnRzIGZyb20gb25lIENBRyBzdGF5IGluc2lkZSBhbm90aGVyIENBR1xuICogQHBhcmFtIHtDQUd9IGNhZzEgLSBDQUcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gY2FnMiAtIENBRyBvYmplY3RcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5jb25zdCBjb250YWlucyA9IGZ1bmN0aW9uIChjYWcxLCBjYWcyKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGNhZzIuc2lkZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGlmICghaGFzUG9pbnRJbnNpZGUoY2FnMSwgY2FnMi5zaWRlc1tpXS52ZXJ0ZXgwLnBvcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNDQUdWYWxpZCxcbiAgaXNTZWxmSW50ZXJzZWN0aW5nLFxuICBoYXNQb2ludEluc2lkZSxcbiAgY29udGFpbnMsXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/utils/cagValidation.js\n");

/***/ }),

/***/ "./src/core/utils/canonicalize.js":
/*!****************************************!*\
  !*** ./src/core/utils/canonicalize.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst FuzzyCSGFactory = __webpack_require__(/*! ../FuzzyFactory3d */ \"./src/core/FuzzyFactory3d.js\");\nconst FuzzyCAGFactory = __webpack_require__(/*! ../FuzzyFactory2d */ \"./src/core/FuzzyFactory2d.js\");\nconst { fromPolygons } = __webpack_require__(/*! ../CSGFactories */ \"./src/core/CSGFactories.js\");\nconst { fromSides } = __webpack_require__(/*! ../CAGFactories */ \"./src/core/CAGFactories.js\");\n\n/**\n * Returns a cannoicalized version of the input csg/cag : ie every very close\n * points get deduplicated\n * @returns {CSG|CAG}\n * @example\n * let rawInput = someCSGORCAGMakingFunction()\n * let canonicalized= canonicalize(rawInput)\n */\nconst canonicalize = function (csgOrCAG, options) {\n  if (csgOrCAG.isCanonicalized) {\n    return csgOrCAG;\n  } else {\n    if ('sides' in csgOrCAG) {\n      return canonicalizeCAG(csgOrCAG, options);\n    } else {\n      return canonicalizeCSG(csgOrCAG, options);\n    }\n  }\n};\n\n/**\n * Returns a cannoicalized version of the input csg : ie every very close\n * points get deduplicated\n * @returns {CSG}\n * @example\n * let rawCSG = someCSGMakingFunction()\n * let canonicalizedCSG = canonicalize(rawCSG)\n */\nconst canonicalizeCSG = function (csg, options) {\n  if (csg.isCanonicalized) {\n    return csg;\n  } else {\n    const factory = new FuzzyCSGFactory();\n    let result = CSGFromCSGFuzzyFactory(factory, csg);\n    result.isCanonicalized = true;\n    result.isRetesselated = csg.isRetesselated;\n    result.properties = csg.properties; // keep original properties\n    return result;\n  }\n};\n\nconst canonicalizeCAG = function (cag, options) {\n  if (cag.isCanonicalized) {\n    return cag;\n  } else {\n    let factory = new FuzzyCAGFactory();\n    let result = CAGFromCAGFuzzyFactory(factory, cag);\n    result.isCanonicalized = true;\n    return result;\n  }\n};\n\nconst CSGFromCSGFuzzyFactory = function (factory, sourcecsg) {\n  let _this = factory;\n  let newpolygons = [];\n  sourcecsg.polygons.forEach(function (polygon) {\n    let newpolygon = _this.getPolygon(polygon);\n    // see getPolygon above: we may get a polygon with no vertices, discard it:\n    if (newpolygon.vertices.length >= 3) {\n      newpolygons.push(newpolygon);\n    }\n  });\n  return fromPolygons(newpolygons);\n};\n\nconst CAGFromCAGFuzzyFactory = function (factory, sourcecag) {\n  let _this = factory;\n  let newsides = sourcecag.sides\n    .map(function (side) {\n      return _this.getSide(side);\n    })\n    // remove bad sides (mostly a user input issue)\n    .filter(function (side) {\n      return side.length() > EPS;\n    });\n  return fromSides(newsides);\n};\n\nmodule.exports = canonicalize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy9jYW5vbmljYWxpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS91dGlscy9jYW5vbmljYWxpemUuanM/OWNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IEVQUyB9ID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5jb25zdCBGdXp6eUNTR0ZhY3RvcnkgPSByZXF1aXJlKCcuLi9GdXp6eUZhY3RvcnkzZCcpO1xuY29uc3QgRnV6enlDQUdGYWN0b3J5ID0gcmVxdWlyZSgnLi4vRnV6enlGYWN0b3J5MmQnKTtcbmNvbnN0IHsgZnJvbVBvbHlnb25zIH0gPSByZXF1aXJlKCcuLi9DU0dGYWN0b3JpZXMnKTtcbmNvbnN0IHsgZnJvbVNpZGVzIH0gPSByZXF1aXJlKCcuLi9DQUdGYWN0b3JpZXMnKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY2Fubm9pY2FsaXplZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dCBjc2cvY2FnIDogaWUgZXZlcnkgdmVyeSBjbG9zZVxuICogcG9pbnRzIGdldCBkZWR1cGxpY2F0ZWRcbiAqIEByZXR1cm5zIHtDU0d8Q0FHfVxuICogQGV4YW1wbGVcbiAqIGxldCByYXdJbnB1dCA9IHNvbWVDU0dPUkNBR01ha2luZ0Z1bmN0aW9uKClcbiAqIGxldCBjYW5vbmljYWxpemVkPSBjYW5vbmljYWxpemUocmF3SW5wdXQpXG4gKi9cbmNvbnN0IGNhbm9uaWNhbGl6ZSA9IGZ1bmN0aW9uIChjc2dPckNBRywgb3B0aW9ucykge1xuICBpZiAoY3NnT3JDQUcuaXNDYW5vbmljYWxpemVkKSB7XG4gICAgcmV0dXJuIGNzZ09yQ0FHO1xuICB9IGVsc2Uge1xuICAgIGlmICgnc2lkZXMnIGluIGNzZ09yQ0FHKSB7XG4gICAgICByZXR1cm4gY2Fub25pY2FsaXplQ0FHKGNzZ09yQ0FHLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbm9uaWNhbGl6ZUNTRyhjc2dPckNBRywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjYW5ub2ljYWxpemVkIHZlcnNpb24gb2YgdGhlIGlucHV0IGNzZyA6IGllIGV2ZXJ5IHZlcnkgY2xvc2VcbiAqIHBvaW50cyBnZXQgZGVkdXBsaWNhdGVkXG4gKiBAcmV0dXJucyB7Q1NHfVxuICogQGV4YW1wbGVcbiAqIGxldCByYXdDU0cgPSBzb21lQ1NHTWFraW5nRnVuY3Rpb24oKVxuICogbGV0IGNhbm9uaWNhbGl6ZWRDU0cgPSBjYW5vbmljYWxpemUocmF3Q1NHKVxuICovXG5jb25zdCBjYW5vbmljYWxpemVDU0cgPSBmdW5jdGlvbiAoY3NnLCBvcHRpb25zKSB7XG4gIGlmIChjc2cuaXNDYW5vbmljYWxpemVkKSB7XG4gICAgcmV0dXJuIGNzZztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmYWN0b3J5ID0gbmV3IEZ1enp5Q1NHRmFjdG9yeSgpO1xuICAgIGxldCByZXN1bHQgPSBDU0dGcm9tQ1NHRnV6enlGYWN0b3J5KGZhY3RvcnksIGNzZyk7XG4gICAgcmVzdWx0LmlzQ2Fub25pY2FsaXplZCA9IHRydWU7XG4gICAgcmVzdWx0LmlzUmV0ZXNzZWxhdGVkID0gY3NnLmlzUmV0ZXNzZWxhdGVkO1xuICAgIHJlc3VsdC5wcm9wZXJ0aWVzID0gY3NnLnByb3BlcnRpZXM7IC8vIGtlZXAgb3JpZ2luYWwgcHJvcGVydGllc1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbmNvbnN0IGNhbm9uaWNhbGl6ZUNBRyA9IGZ1bmN0aW9uIChjYWcsIG9wdGlvbnMpIHtcbiAgaWYgKGNhZy5pc0Nhbm9uaWNhbGl6ZWQpIHtcbiAgICByZXR1cm4gY2FnO1xuICB9IGVsc2Uge1xuICAgIGxldCBmYWN0b3J5ID0gbmV3IEZ1enp5Q0FHRmFjdG9yeSgpO1xuICAgIGxldCByZXN1bHQgPSBDQUdGcm9tQ0FHRnV6enlGYWN0b3J5KGZhY3RvcnksIGNhZyk7XG4gICAgcmVzdWx0LmlzQ2Fub25pY2FsaXplZCA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuY29uc3QgQ1NHRnJvbUNTR0Z1enp5RmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBzb3VyY2Vjc2cpIHtcbiAgbGV0IF90aGlzID0gZmFjdG9yeTtcbiAgbGV0IG5ld3BvbHlnb25zID0gW107XG4gIHNvdXJjZWNzZy5wb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgbGV0IG5ld3BvbHlnb24gPSBfdGhpcy5nZXRQb2x5Z29uKHBvbHlnb24pO1xuICAgIC8vIHNlZSBnZXRQb2x5Z29uIGFib3ZlOiB3ZSBtYXkgZ2V0IGEgcG9seWdvbiB3aXRoIG5vIHZlcnRpY2VzLCBkaXNjYXJkIGl0OlxuICAgIGlmIChuZXdwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBuZXdwb2x5Z29ucy5wdXNoKG5ld3BvbHlnb24pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmcm9tUG9seWdvbnMobmV3cG9seWdvbnMpO1xufTtcblxuY29uc3QgQ0FHRnJvbUNBR0Z1enp5RmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBzb3VyY2VjYWcpIHtcbiAgbGV0IF90aGlzID0gZmFjdG9yeTtcbiAgbGV0IG5ld3NpZGVzID0gc291cmNlY2FnLnNpZGVzXG4gICAgLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldFNpZGUoc2lkZSk7XG4gICAgfSlcbiAgICAvLyByZW1vdmUgYmFkIHNpZGVzIChtb3N0bHkgYSB1c2VyIGlucHV0IGlzc3VlKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJldHVybiBzaWRlLmxlbmd0aCgpID4gRVBTO1xuICAgIH0pO1xuICByZXR1cm4gZnJvbVNpZGVzKG5ld3NpZGVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2Fub25pY2FsaXplO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/utils/canonicalize.js\n");

/***/ }),

/***/ "./src/core/utils/csgMeasurements.js":
/*!*******************************************!*\
  !*** ./src/core/utils/csgMeasurements.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Vector3D = __webpack_require__(/*! ../math/Vector3 */ \"./src/core/math/Vector3.js\");\n\n/**\n * Returns an array of Vector3D, providing minimum coordinates and maximum coordinates\n * of this solid.\n * @returns {Vector3D[]}\n * @example\n * let bounds = A.getBounds()\n * let minX = bounds[0].x\n */\nconst bounds = function (csg) {\n  if (!csg.cachedBoundingBox) {\n    let minpoint = new Vector3D(0, 0, 0);\n    let maxpoint = new Vector3D(0, 0, 0);\n    let polygons = csg.polygons;\n    let numpolygons = polygons.length;\n    for (let i = 0; i < numpolygons; i++) {\n      let polygon = polygons[i];\n      let bounds = polygon.boundingBox();\n      if (i === 0) {\n        minpoint = bounds[0];\n        maxpoint = bounds[1];\n      } else {\n        minpoint = minpoint.min(bounds[0]);\n        maxpoint = maxpoint.max(bounds[1]);\n      }\n    }\n    // FIXME: not ideal, we are mutating the input, we need to move some of it out\n    csg.cachedBoundingBox = [minpoint, maxpoint];\n  }\n  return csg.cachedBoundingBox;\n};\n\nconst volume = function (csg) {\n  let result = csg.toTriangles().map(function (triPoly) {\n    return triPoly.getTetraFeatures(['volume']);\n  });\n  console.log('volume', result);\n};\n\nconst area = function (csg) {\n  let result = csg.toTriangles().map(function (triPoly) {\n    return triPoly.getTetraFeatures(['area']);\n  });\n  console.log('area', result);\n};\n\nmodule.exports = { bounds, volume, area };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy9jc2dNZWFzdXJlbWVudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcGkvLi9zcmMvY29yZS91dGlscy9jc2dNZWFzdXJlbWVudHMuanM/ZWFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZWN0b3IzRCA9IHJlcXVpcmUoJy4uL21hdGgvVmVjdG9yMycpO1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgVmVjdG9yM0QsIHByb3ZpZGluZyBtaW5pbXVtIGNvb3JkaW5hdGVzIGFuZCBtYXhpbXVtIGNvb3JkaW5hdGVzXG4gKiBvZiB0aGlzIHNvbGlkLlxuICogQHJldHVybnMge1ZlY3RvcjNEW119XG4gKiBAZXhhbXBsZVxuICogbGV0IGJvdW5kcyA9IEEuZ2V0Qm91bmRzKClcbiAqIGxldCBtaW5YID0gYm91bmRzWzBdLnhcbiAqL1xuY29uc3QgYm91bmRzID0gZnVuY3Rpb24gKGNzZykge1xuICBpZiAoIWNzZy5jYWNoZWRCb3VuZGluZ0JveCkge1xuICAgIGxldCBtaW5wb2ludCA9IG5ldyBWZWN0b3IzRCgwLCAwLCAwKTtcbiAgICBsZXQgbWF4cG9pbnQgPSBuZXcgVmVjdG9yM0QoMCwgMCwgMCk7XG4gICAgbGV0IHBvbHlnb25zID0gY3NnLnBvbHlnb25zO1xuICAgIGxldCBudW1wb2x5Z29ucyA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXBvbHlnb25zOyBpKyspIHtcbiAgICAgIGxldCBwb2x5Z29uID0gcG9seWdvbnNbaV07XG4gICAgICBsZXQgYm91bmRzID0gcG9seWdvbi5ib3VuZGluZ0JveCgpO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgbWlucG9pbnQgPSBib3VuZHNbMF07XG4gICAgICAgIG1heHBvaW50ID0gYm91bmRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlucG9pbnQgPSBtaW5wb2ludC5taW4oYm91bmRzWzBdKTtcbiAgICAgICAgbWF4cG9pbnQgPSBtYXhwb2ludC5tYXgoYm91bmRzWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRklYTUU6IG5vdCBpZGVhbCwgd2UgYXJlIG11dGF0aW5nIHRoZSBpbnB1dCwgd2UgbmVlZCB0byBtb3ZlIHNvbWUgb2YgaXQgb3V0XG4gICAgY3NnLmNhY2hlZEJvdW5kaW5nQm94ID0gW21pbnBvaW50LCBtYXhwb2ludF07XG4gIH1cbiAgcmV0dXJuIGNzZy5jYWNoZWRCb3VuZGluZ0JveDtcbn07XG5cbmNvbnN0IHZvbHVtZSA9IGZ1bmN0aW9uIChjc2cpIHtcbiAgbGV0IHJlc3VsdCA9IGNzZy50b1RyaWFuZ2xlcygpLm1hcChmdW5jdGlvbiAodHJpUG9seSkge1xuICAgIHJldHVybiB0cmlQb2x5LmdldFRldHJhRmVhdHVyZXMoWyd2b2x1bWUnXSk7XG4gIH0pO1xuICBjb25zb2xlLmxvZygndm9sdW1lJywgcmVzdWx0KTtcbn07XG5cbmNvbnN0IGFyZWEgPSBmdW5jdGlvbiAoY3NnKSB7XG4gIGxldCByZXN1bHQgPSBjc2cudG9UcmlhbmdsZXMoKS5tYXAoZnVuY3Rpb24gKHRyaVBvbHkpIHtcbiAgICByZXR1cm4gdHJpUG9seS5nZXRUZXRyYUZlYXR1cmVzKFsnYXJlYSddKTtcbiAgfSk7XG4gIGNvbnNvbGUubG9nKCdhcmVhJywgcmVzdWx0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBib3VuZHMsIHZvbHVtZSwgYXJlYSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/utils/csgMeasurements.js\n");

/***/ }),

/***/ "./src/core/utils/csgProjections.js":
/*!******************************************!*\
  !*** ./src/core/utils/csgProjections.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CAG = __webpack_require__(/*! ../CAG */ \"./src/core/CAG.js\"); // FIXME: circular dependency !\nconst { EPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\n\n// project the 3D CSG onto a plane\n// This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the\n// plane represented by the orthonormal basis\nconst projectToOrthoNormalBasis = function (csg, orthobasis) {\n  let cags = [];\n  csg.polygons\n    .filter(function (p) {\n      // only return polys in plane, others may disturb result\n      return (\n        p.plane.normal.minus(orthobasis.plane.normal).lengthSquared() <\n        EPS * EPS\n      );\n    })\n    .map(function (polygon) {\n      let cag = polygon.projectToOrthoNormalBasis(orthobasis);\n      if (cag.sides.length > 0) {\n        cags.push(cag);\n      }\n    });\n  let result = new CAG().union(cags);\n  return result;\n};\n\nmodule.exports = { projectToOrthoNormalBasis };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy9jc2dQcm9qZWN0aW9ucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL3V0aWxzL2NzZ1Byb2plY3Rpb25zLmpzPzg0YmUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0FHID0gcmVxdWlyZSgnLi4vQ0FHJyk7IC8vIEZJWE1FOiBjaXJjdWxhciBkZXBlbmRlbmN5ICFcbmNvbnN0IHsgRVBTIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxuLy8gcHJvamVjdCB0aGUgM0QgQ1NHIG9udG8gYSBwbGFuZVxuLy8gVGhpcyByZXR1cm5zIGEgMkQgQ0FHIHdpdGggdGhlICdzaGFkb3cnIHNoYXBlIG9mIHRoZSAzRCBzb2xpZCB3aGVuIHByb2plY3RlZCBvbnRvIHRoZVxuLy8gcGxhbmUgcmVwcmVzZW50ZWQgYnkgdGhlIG9ydGhvbm9ybWFsIGJhc2lzXG5jb25zdCBwcm9qZWN0VG9PcnRob05vcm1hbEJhc2lzID0gZnVuY3Rpb24gKGNzZywgb3J0aG9iYXNpcykge1xuICBsZXQgY2FncyA9IFtdO1xuICBjc2cucG9seWdvbnNcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAvLyBvbmx5IHJldHVybiBwb2x5cyBpbiBwbGFuZSwgb3RoZXJzIG1heSBkaXN0dXJiIHJlc3VsdFxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcC5wbGFuZS5ub3JtYWwubWludXMob3J0aG9iYXNpcy5wbGFuZS5ub3JtYWwpLmxlbmd0aFNxdWFyZWQoKSA8XG4gICAgICAgIEVQUyAqIEVQU1xuICAgICAgKTtcbiAgICB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICAgIGxldCBjYWcgPSBwb2x5Z29uLnByb2plY3RUb09ydGhvTm9ybWFsQmFzaXMob3J0aG9iYXNpcyk7XG4gICAgICBpZiAoY2FnLnNpZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2Fncy5wdXNoKGNhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIGxldCByZXN1bHQgPSBuZXcgQ0FHKCkudW5pb24oY2Fncyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcHJvamVjdFRvT3J0aG9Ob3JtYWxCYXNpcyB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/utils/csgProjections.js\n");

/***/ }),

/***/ "./src/core/utils/fixTJunctions.js":
/*!*****************************************!*\
  !*** ./src/core/utils/fixTJunctions.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EPS } = __webpack_require__(/*! ../constants */ \"./src/core/constants.js\");\nconst Polygon = __webpack_require__(/*! ../math/Polygon3 */ \"./src/core/math/Polygon3.js\");\nconst Plane = __webpack_require__(/*! ../math/Plane */ \"./src/core/math/Plane.js\");\n\nfunction addSide(\n  sidemap,\n  vertextag2sidestart,\n  vertextag2sideend,\n  vertex0,\n  vertex1,\n  polygonindex\n) {\n  let starttag = vertex0.getTag();\n  let endtag = vertex1.getTag();\n  if (starttag === endtag) throw new Error('Assertion failed');\n  let newsidetag = starttag + '/' + endtag;\n  let reversesidetag = endtag + '/' + starttag;\n  if (reversesidetag in sidemap) {\n    // we have a matching reverse oriented side.\n    // Instead of adding the new side, cancel out the reverse side:\n    // console.log(\"addSide(\"+newsidetag+\") has reverse side:\");\n    deleteSide(\n      sidemap,\n      vertextag2sidestart,\n      vertextag2sideend,\n      vertex1,\n      vertex0,\n      null\n    );\n    return null;\n  }\n  //  console.log(\"addSide(\"+newsidetag+\")\");\n  let newsideobj = {\n    vertex0: vertex0,\n    vertex1: vertex1,\n    polygonindex: polygonindex,\n  };\n  if (!(newsidetag in sidemap)) {\n    sidemap[newsidetag] = [newsideobj];\n  } else {\n    sidemap[newsidetag].push(newsideobj);\n  }\n  if (starttag in vertextag2sidestart) {\n    vertextag2sidestart[starttag].push(newsidetag);\n  } else {\n    vertextag2sidestart[starttag] = [newsidetag];\n  }\n  if (endtag in vertextag2sideend) {\n    vertextag2sideend[endtag].push(newsidetag);\n  } else {\n    vertextag2sideend[endtag] = [newsidetag];\n  }\n  return newsidetag;\n}\n\nfunction deleteSide(\n  sidemap,\n  vertextag2sidestart,\n  vertextag2sideend,\n  vertex0,\n  vertex1,\n  polygonindex\n) {\n  let starttag = vertex0.getTag();\n  let endtag = vertex1.getTag();\n  let sidetag = starttag + '/' + endtag;\n  // console.log(\"deleteSide(\"+sidetag+\")\");\n  if (!(sidetag in sidemap)) throw new Error('Assertion failed');\n  let idx = -1;\n  let sideobjs = sidemap[sidetag];\n  for (let i = 0; i < sideobjs.length; i++) {\n    let sideobj = sideobjs[i];\n    if (sideobj.vertex0 !== vertex0) continue;\n    if (sideobj.vertex1 !== vertex1) continue;\n    if (polygonindex !== null) {\n      if (sideobj.polygonindex !== polygonindex) continue;\n    }\n    idx = i;\n    break;\n  }\n  if (idx < 0) throw new Error('Assertion failed');\n  sideobjs.splice(idx, 1);\n  if (sideobjs.length === 0) {\n    delete sidemap[sidetag];\n  }\n  idx = vertextag2sidestart[starttag].indexOf(sidetag);\n  if (idx < 0) throw new Error('Assertion failed');\n  vertextag2sidestart[starttag].splice(idx, 1);\n  if (vertextag2sidestart[starttag].length === 0) {\n    delete vertextag2sidestart[starttag];\n  }\n\n  idx = vertextag2sideend[endtag].indexOf(sidetag);\n  if (idx < 0) throw new Error('Assertion failed');\n  vertextag2sideend[endtag].splice(idx, 1);\n  if (vertextag2sideend[endtag].length === 0) {\n    delete vertextag2sideend[endtag];\n  }\n}\n\n/*\n     fixTJunctions:\n\n     Suppose we have two polygons ACDB and EDGF:\n\n      A-----B\n      |     |\n      |     E--F\n      |     |  |\n      C-----D--G\n\n     Note that vertex E forms a T-junction on the side BD. In this case some STL slicers will complain\n     that the solid is not watertight. This is because the watertightness check is done by checking if\n     each side DE is matched by another side ED.\n\n     This function will return a new solid with ACDB replaced by ACDEB\n\n     Note that this can create polygons that are slightly non-convex (due to rounding errors). Therefore the result should\n     not be used for further CSG operations!\n*/\nconst fixTJunctions = function (fromPolygons, csg) {\n  csg = csg.canonicalized();\n  let sidemap = {};\n\n  // STEP 1\n  for (\n    let polygonindex = 0;\n    polygonindex < csg.polygons.length;\n    polygonindex++\n  ) {\n    let polygon = csg.polygons[polygonindex];\n    let numvertices = polygon.vertices.length;\n    // should be true\n    if (numvertices >= 3) {\n      let vertex = polygon.vertices[0];\n      let vertextag = vertex.getTag();\n      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n        let nextvertexindex = vertexindex + 1;\n        if (nextvertexindex === numvertices) nextvertexindex = 0;\n        let nextvertex = polygon.vertices[nextvertexindex];\n        let nextvertextag = nextvertex.getTag();\n        let sidetag = vertextag + '/' + nextvertextag;\n        let reversesidetag = nextvertextag + '/' + vertextag;\n        if (reversesidetag in sidemap) {\n          // this side matches the same side in another polygon. Remove from sidemap:\n          let ar = sidemap[reversesidetag];\n          ar.splice(-1, 1);\n          if (ar.length === 0) {\n            delete sidemap[reversesidetag];\n          }\n        } else {\n          let sideobj = {\n            vertex0: vertex,\n            vertex1: nextvertex,\n            polygonindex: polygonindex,\n          };\n          if (!(sidetag in sidemap)) {\n            sidemap[sidetag] = [sideobj];\n          } else {\n            sidemap[sidetag].push(sideobj);\n          }\n        }\n        vertex = nextvertex;\n        vertextag = nextvertextag;\n      }\n    }\n  }\n  // STEP 2\n  // now sidemap contains 'unmatched' sides\n  // i.e. side AB in one polygon does not have a matching side BA in another polygon\n  let vertextag2sidestart = {};\n  let vertextag2sideend = {};\n  let sidestocheck = {};\n  let sidemapisempty = true;\n  for (let sidetag in sidemap) {\n    sidemapisempty = false;\n    sidestocheck[sidetag] = true;\n    sidemap[sidetag].map(function (sideobj) {\n      let starttag = sideobj.vertex0.getTag();\n      let endtag = sideobj.vertex1.getTag();\n      if (starttag in vertextag2sidestart) {\n        vertextag2sidestart[starttag].push(sidetag);\n      } else {\n        vertextag2sidestart[starttag] = [sidetag];\n      }\n      if (endtag in vertextag2sideend) {\n        vertextag2sideend[endtag].push(sidetag);\n      } else {\n        vertextag2sideend[endtag] = [sidetag];\n      }\n    });\n  }\n\n  // STEP 3 : if sidemap is not empty\n  if (!sidemapisempty) {\n    // make a copy of the polygons array, since we are going to modify it:\n    let polygons = csg.polygons.slice(0);\n    while (true) {\n      let sidemapisempty = true;\n      for (let sidetag in sidemap) {\n        sidemapisempty = false;\n        sidestocheck[sidetag] = true;\n      }\n      if (sidemapisempty) break;\n      let donesomething = false;\n      while (true) {\n        let sidetagtocheck = null;\n        for (let sidetag in sidestocheck) {\n          sidetagtocheck = sidetag;\n          break; // FIXME  : say what now ?\n        }\n        if (sidetagtocheck === null) break; // sidestocheck is empty, we're done!\n        let donewithside = true;\n        if (sidetagtocheck in sidemap) {\n          let sideobjs = sidemap[sidetagtocheck];\n          if (sideobjs.length === 0) throw new Error('Assertion failed');\n          let sideobj = sideobjs[0];\n          for (let directionindex = 0; directionindex < 2; directionindex++) {\n            let startvertex =\n              directionindex === 0 ? sideobj.vertex0 : sideobj.vertex1;\n            let endvertex =\n              directionindex === 0 ? sideobj.vertex1 : sideobj.vertex0;\n            let startvertextag = startvertex.getTag();\n            let endvertextag = endvertex.getTag();\n            let matchingsides = [];\n            if (directionindex === 0) {\n              if (startvertextag in vertextag2sideend) {\n                matchingsides = vertextag2sideend[startvertextag];\n              }\n            } else {\n              if (startvertextag in vertextag2sidestart) {\n                matchingsides = vertextag2sidestart[startvertextag];\n              }\n            }\n            for (\n              let matchingsideindex = 0;\n              matchingsideindex < matchingsides.length;\n              matchingsideindex++\n            ) {\n              let matchingsidetag = matchingsides[matchingsideindex];\n              let matchingside = sidemap[matchingsidetag][0];\n              let matchingsidestartvertex =\n                directionindex === 0\n                  ? matchingside.vertex0\n                  : matchingside.vertex1;\n              let matchingsideendvertex =\n                directionindex === 0\n                  ? matchingside.vertex1\n                  : matchingside.vertex0;\n              let matchingsidestartvertextag = matchingsidestartvertex.getTag();\n              let matchingsideendvertextag = matchingsideendvertex.getTag();\n              if (matchingsideendvertextag !== startvertextag)\n                throw new Error('Assertion failed');\n              if (matchingsidestartvertextag === endvertextag) {\n                // matchingside cancels sidetagtocheck\n                deleteSide(\n                  sidemap,\n                  vertextag2sidestart,\n                  vertextag2sideend,\n                  startvertex,\n                  endvertex,\n                  null\n                );\n                deleteSide(\n                  sidemap,\n                  vertextag2sidestart,\n                  vertextag2sideend,\n                  endvertex,\n                  startvertex,\n                  null\n                );\n                donewithside = false;\n                directionindex = 2; // skip reverse direction check\n                donesomething = true;\n                break;\n              } else {\n                let startpos = startvertex.pos;\n                let endpos = endvertex.pos;\n                let checkpos = matchingsidestartvertex.pos;\n                let direction = checkpos.minus(startpos);\n                // Now we need to check if endpos is on the line startpos-checkpos:\n                let t =\n                  endpos.minus(startpos).dot(direction) /\n                  direction.dot(direction);\n                if (t > 0 && t < 1) {\n                  let closestpoint = startpos.plus(direction.times(t));\n                  let distancesquared = closestpoint.distanceToSquared(endpos);\n                  if (distancesquared < EPS * EPS) {\n                    // Yes it's a t-junction! We need to split matchingside in two:\n                    let polygonindex = matchingside.polygonindex;\n                    let polygon = polygons[polygonindex];\n                    // find the index of startvertextag in polygon:\n                    let insertionvertextag = matchingside.vertex1.getTag();\n                    let insertionvertextagindex = -1;\n                    for (let i = 0; i < polygon.vertices.length; i++) {\n                      if (polygon.vertices[i].getTag() === insertionvertextag) {\n                        insertionvertextagindex = i;\n                        break;\n                      }\n                    }\n                    if (insertionvertextagindex < 0)\n                      throw new Error('Assertion failed');\n                    // split the side by inserting the vertex:\n                    let newvertices = polygon.vertices.slice(0);\n                    newvertices.splice(insertionvertextagindex, 0, endvertex);\n                    let newpolygon = new Polygon(\n                      newvertices,\n                      polygon.shared /* polygon.plane */\n                    );\n\n                    // calculate plane with differents point\n                    if (isNaN(newpolygon.plane.w)) {\n                      let found = false;\n                      let loop = function (callback) {\n                        newpolygon.vertices.forEach(function (item) {\n                          if (found) return;\n                          callback(item);\n                        });\n                      };\n\n                      loop(function (a) {\n                        loop(function (b) {\n                          loop(function (c) {\n                            newpolygon.plane = Plane.fromPoints(\n                              a.pos,\n                              b.pos,\n                              c.pos\n                            );\n                            if (!isNaN(newpolygon.plane.w)) {\n                              found = true;\n                            }\n                          });\n                        });\n                      });\n                    }\n                    polygons[polygonindex] = newpolygon;\n                    // remove the original sides from our maps\n                    // deleteSide(sideobj.vertex0, sideobj.vertex1, null)\n                    deleteSide(\n                      sidemap,\n                      vertextag2sidestart,\n                      vertextag2sideend,\n                      matchingside.vertex0,\n                      matchingside.vertex1,\n                      polygonindex\n                    );\n                    let newsidetag1 = addSide(\n                      sidemap,\n                      vertextag2sidestart,\n                      vertextag2sideend,\n                      matchingside.vertex0,\n                      endvertex,\n                      polygonindex\n                    );\n                    let newsidetag2 = addSide(\n                      sidemap,\n                      vertextag2sidestart,\n                      vertextag2sideend,\n                      endvertex,\n                      matchingside.vertex1,\n                      polygonindex\n                    );\n                    if (newsidetag1 !== null) sidestocheck[newsidetag1] = true;\n                    if (newsidetag2 !== null) sidestocheck[newsidetag2] = true;\n                    donewithside = false;\n                    directionindex = 2; // skip reverse direction check\n                    donesomething = true;\n                    break;\n                  } // if(distancesquared < 1e-10)\n                } // if( (t > 0) && (t < 1) )\n              } // if(endingstidestartvertextag === endvertextag)\n            } // for matchingsideindex\n          } // for directionindex\n        } // if(sidetagtocheck in sidemap)\n        if (donewithside) {\n          delete sidestocheck[sidetagtocheck];\n        }\n      }\n      if (!donesomething) break;\n    }\n    let newcsg = fromPolygons(polygons);\n    newcsg.properties = csg.properties;\n    newcsg.isCanonicalized = true;\n    newcsg.isRetesselated = true;\n    csg = newcsg;\n  }\n\n  // FIXME : what is even the point of this ???\n  /* sidemapisempty = true\n  for (let sidetag in sidemap) {\n    sidemapisempty = false\n    break\n  }\n  */\n\n  return csg;\n};\n\nmodule.exports = fixTJunctions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy9maXhUSnVuY3Rpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvdXRpbHMvZml4VEp1bmN0aW9ucy5qcz81NjlmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgRVBTIH0gPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbmNvbnN0IFBvbHlnb24gPSByZXF1aXJlKCcuLi9tYXRoL1BvbHlnb24zJyk7XG5jb25zdCBQbGFuZSA9IHJlcXVpcmUoJy4uL21hdGgvUGxhbmUnKTtcblxuZnVuY3Rpb24gYWRkU2lkZShcbiAgc2lkZW1hcCxcbiAgdmVydGV4dGFnMnNpZGVzdGFydCxcbiAgdmVydGV4dGFnMnNpZGVlbmQsXG4gIHZlcnRleDAsXG4gIHZlcnRleDEsXG4gIHBvbHlnb25pbmRleFxuKSB7XG4gIGxldCBzdGFydHRhZyA9IHZlcnRleDAuZ2V0VGFnKCk7XG4gIGxldCBlbmR0YWcgPSB2ZXJ0ZXgxLmdldFRhZygpO1xuICBpZiAoc3RhcnR0YWcgPT09IGVuZHRhZykgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIGxldCBuZXdzaWRldGFnID0gc3RhcnR0YWcgKyAnLycgKyBlbmR0YWc7XG4gIGxldCByZXZlcnNlc2lkZXRhZyA9IGVuZHRhZyArICcvJyArIHN0YXJ0dGFnO1xuICBpZiAocmV2ZXJzZXNpZGV0YWcgaW4gc2lkZW1hcCkge1xuICAgIC8vIHdlIGhhdmUgYSBtYXRjaGluZyByZXZlcnNlIG9yaWVudGVkIHNpZGUuXG4gICAgLy8gSW5zdGVhZCBvZiBhZGRpbmcgdGhlIG5ldyBzaWRlLCBjYW5jZWwgb3V0IHRoZSByZXZlcnNlIHNpZGU6XG4gICAgLy8gY29uc29sZS5sb2coXCJhZGRTaWRlKFwiK25ld3NpZGV0YWcrXCIpIGhhcyByZXZlcnNlIHNpZGU6XCIpO1xuICAgIGRlbGV0ZVNpZGUoXG4gICAgICBzaWRlbWFwLFxuICAgICAgdmVydGV4dGFnMnNpZGVzdGFydCxcbiAgICAgIHZlcnRleHRhZzJzaWRlZW5kLFxuICAgICAgdmVydGV4MSxcbiAgICAgIHZlcnRleDAsXG4gICAgICBudWxsXG4gICAgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyAgY29uc29sZS5sb2coXCJhZGRTaWRlKFwiK25ld3NpZGV0YWcrXCIpXCIpO1xuICBsZXQgbmV3c2lkZW9iaiA9IHtcbiAgICB2ZXJ0ZXgwOiB2ZXJ0ZXgwLFxuICAgIHZlcnRleDE6IHZlcnRleDEsXG4gICAgcG9seWdvbmluZGV4OiBwb2x5Z29uaW5kZXgsXG4gIH07XG4gIGlmICghKG5ld3NpZGV0YWcgaW4gc2lkZW1hcCkpIHtcbiAgICBzaWRlbWFwW25ld3NpZGV0YWddID0gW25ld3NpZGVvYmpdO1xuICB9IGVsc2Uge1xuICAgIHNpZGVtYXBbbmV3c2lkZXRhZ10ucHVzaChuZXdzaWRlb2JqKTtcbiAgfVxuICBpZiAoc3RhcnR0YWcgaW4gdmVydGV4dGFnMnNpZGVzdGFydCkge1xuICAgIHZlcnRleHRhZzJzaWRlc3RhcnRbc3RhcnR0YWddLnB1c2gobmV3c2lkZXRhZyk7XG4gIH0gZWxzZSB7XG4gICAgdmVydGV4dGFnMnNpZGVzdGFydFtzdGFydHRhZ10gPSBbbmV3c2lkZXRhZ107XG4gIH1cbiAgaWYgKGVuZHRhZyBpbiB2ZXJ0ZXh0YWcyc2lkZWVuZCkge1xuICAgIHZlcnRleHRhZzJzaWRlZW5kW2VuZHRhZ10ucHVzaChuZXdzaWRldGFnKTtcbiAgfSBlbHNlIHtcbiAgICB2ZXJ0ZXh0YWcyc2lkZWVuZFtlbmR0YWddID0gW25ld3NpZGV0YWddO1xuICB9XG4gIHJldHVybiBuZXdzaWRldGFnO1xufVxuXG5mdW5jdGlvbiBkZWxldGVTaWRlKFxuICBzaWRlbWFwLFxuICB2ZXJ0ZXh0YWcyc2lkZXN0YXJ0LFxuICB2ZXJ0ZXh0YWcyc2lkZWVuZCxcbiAgdmVydGV4MCxcbiAgdmVydGV4MSxcbiAgcG9seWdvbmluZGV4XG4pIHtcbiAgbGV0IHN0YXJ0dGFnID0gdmVydGV4MC5nZXRUYWcoKTtcbiAgbGV0IGVuZHRhZyA9IHZlcnRleDEuZ2V0VGFnKCk7XG4gIGxldCBzaWRldGFnID0gc3RhcnR0YWcgKyAnLycgKyBlbmR0YWc7XG4gIC8vIGNvbnNvbGUubG9nKFwiZGVsZXRlU2lkZShcIitzaWRldGFnK1wiKVwiKTtcbiAgaWYgKCEoc2lkZXRhZyBpbiBzaWRlbWFwKSkgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIGxldCBpZHggPSAtMTtcbiAgbGV0IHNpZGVvYmpzID0gc2lkZW1hcFtzaWRldGFnXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBzaWRlb2JqID0gc2lkZW9ianNbaV07XG4gICAgaWYgKHNpZGVvYmoudmVydGV4MCAhPT0gdmVydGV4MCkgY29udGludWU7XG4gICAgaWYgKHNpZGVvYmoudmVydGV4MSAhPT0gdmVydGV4MSkgY29udGludWU7XG4gICAgaWYgKHBvbHlnb25pbmRleCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNpZGVvYmoucG9seWdvbmluZGV4ICE9PSBwb2x5Z29uaW5kZXgpIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZHggPSBpO1xuICAgIGJyZWFrO1xuICB9XG4gIGlmIChpZHggPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgc2lkZW9ianMuc3BsaWNlKGlkeCwgMSk7XG4gIGlmIChzaWRlb2Jqcy5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgc2lkZW1hcFtzaWRldGFnXTtcbiAgfVxuICBpZHggPSB2ZXJ0ZXh0YWcyc2lkZXN0YXJ0W3N0YXJ0dGFnXS5pbmRleE9mKHNpZGV0YWcpO1xuICBpZiAoaWR4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIHZlcnRleHRhZzJzaWRlc3RhcnRbc3RhcnR0YWddLnNwbGljZShpZHgsIDEpO1xuICBpZiAodmVydGV4dGFnMnNpZGVzdGFydFtzdGFydHRhZ10ubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHZlcnRleHRhZzJzaWRlc3RhcnRbc3RhcnR0YWddO1xuICB9XG5cbiAgaWR4ID0gdmVydGV4dGFnMnNpZGVlbmRbZW5kdGFnXS5pbmRleE9mKHNpZGV0YWcpO1xuICBpZiAoaWR4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIHZlcnRleHRhZzJzaWRlZW5kW2VuZHRhZ10uc3BsaWNlKGlkeCwgMSk7XG4gIGlmICh2ZXJ0ZXh0YWcyc2lkZWVuZFtlbmR0YWddLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSB2ZXJ0ZXh0YWcyc2lkZWVuZFtlbmR0YWddO1xuICB9XG59XG5cbi8qXG4gICAgIGZpeFRKdW5jdGlvbnM6XG5cbiAgICAgU3VwcG9zZSB3ZSBoYXZlIHR3byBwb2x5Z29ucyBBQ0RCIGFuZCBFREdGOlxuXG4gICAgICBBLS0tLS1CXG4gICAgICB8ICAgICB8XG4gICAgICB8ICAgICBFLS1GXG4gICAgICB8ICAgICB8ICB8XG4gICAgICBDLS0tLS1ELS1HXG5cbiAgICAgTm90ZSB0aGF0IHZlcnRleCBFIGZvcm1zIGEgVC1qdW5jdGlvbiBvbiB0aGUgc2lkZSBCRC4gSW4gdGhpcyBjYXNlIHNvbWUgU1RMIHNsaWNlcnMgd2lsbCBjb21wbGFpblxuICAgICB0aGF0IHRoZSBzb2xpZCBpcyBub3Qgd2F0ZXJ0aWdodC4gVGhpcyBpcyBiZWNhdXNlIHRoZSB3YXRlcnRpZ2h0bmVzcyBjaGVjayBpcyBkb25lIGJ5IGNoZWNraW5nIGlmXG4gICAgIGVhY2ggc2lkZSBERSBpcyBtYXRjaGVkIGJ5IGFub3RoZXIgc2lkZSBFRC5cblxuICAgICBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbmV3IHNvbGlkIHdpdGggQUNEQiByZXBsYWNlZCBieSBBQ0RFQlxuXG4gICAgIE5vdGUgdGhhdCB0aGlzIGNhbiBjcmVhdGUgcG9seWdvbnMgdGhhdCBhcmUgc2xpZ2h0bHkgbm9uLWNvbnZleCAoZHVlIHRvIHJvdW5kaW5nIGVycm9ycykuIFRoZXJlZm9yZSB0aGUgcmVzdWx0IHNob3VsZFxuICAgICBub3QgYmUgdXNlZCBmb3IgZnVydGhlciBDU0cgb3BlcmF0aW9ucyFcbiovXG5jb25zdCBmaXhUSnVuY3Rpb25zID0gZnVuY3Rpb24gKGZyb21Qb2x5Z29ucywgY3NnKSB7XG4gIGNzZyA9IGNzZy5jYW5vbmljYWxpemVkKCk7XG4gIGxldCBzaWRlbWFwID0ge307XG5cbiAgLy8gU1RFUCAxXG4gIGZvciAoXG4gICAgbGV0IHBvbHlnb25pbmRleCA9IDA7XG4gICAgcG9seWdvbmluZGV4IDwgY3NnLnBvbHlnb25zLmxlbmd0aDtcbiAgICBwb2x5Z29uaW5kZXgrK1xuICApIHtcbiAgICBsZXQgcG9seWdvbiA9IGNzZy5wb2x5Z29uc1twb2x5Z29uaW5kZXhdO1xuICAgIGxldCBudW12ZXJ0aWNlcyA9IHBvbHlnb24udmVydGljZXMubGVuZ3RoO1xuICAgIC8vIHNob3VsZCBiZSB0cnVlXG4gICAgaWYgKG51bXZlcnRpY2VzID49IDMpIHtcbiAgICAgIGxldCB2ZXJ0ZXggPSBwb2x5Z29uLnZlcnRpY2VzWzBdO1xuICAgICAgbGV0IHZlcnRleHRhZyA9IHZlcnRleC5nZXRUYWcoKTtcbiAgICAgIGZvciAobGV0IHZlcnRleGluZGV4ID0gMDsgdmVydGV4aW5kZXggPCBudW12ZXJ0aWNlczsgdmVydGV4aW5kZXgrKykge1xuICAgICAgICBsZXQgbmV4dHZlcnRleGluZGV4ID0gdmVydGV4aW5kZXggKyAxO1xuICAgICAgICBpZiAobmV4dHZlcnRleGluZGV4ID09PSBudW12ZXJ0aWNlcykgbmV4dHZlcnRleGluZGV4ID0gMDtcbiAgICAgICAgbGV0IG5leHR2ZXJ0ZXggPSBwb2x5Z29uLnZlcnRpY2VzW25leHR2ZXJ0ZXhpbmRleF07XG4gICAgICAgIGxldCBuZXh0dmVydGV4dGFnID0gbmV4dHZlcnRleC5nZXRUYWcoKTtcbiAgICAgICAgbGV0IHNpZGV0YWcgPSB2ZXJ0ZXh0YWcgKyAnLycgKyBuZXh0dmVydGV4dGFnO1xuICAgICAgICBsZXQgcmV2ZXJzZXNpZGV0YWcgPSBuZXh0dmVydGV4dGFnICsgJy8nICsgdmVydGV4dGFnO1xuICAgICAgICBpZiAocmV2ZXJzZXNpZGV0YWcgaW4gc2lkZW1hcCkge1xuICAgICAgICAgIC8vIHRoaXMgc2lkZSBtYXRjaGVzIHRoZSBzYW1lIHNpZGUgaW4gYW5vdGhlciBwb2x5Z29uLiBSZW1vdmUgZnJvbSBzaWRlbWFwOlxuICAgICAgICAgIGxldCBhciA9IHNpZGVtYXBbcmV2ZXJzZXNpZGV0YWddO1xuICAgICAgICAgIGFyLnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgaWYgKGFyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHNpZGVtYXBbcmV2ZXJzZXNpZGV0YWddO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgc2lkZW9iaiA9IHtcbiAgICAgICAgICAgIHZlcnRleDA6IHZlcnRleCxcbiAgICAgICAgICAgIHZlcnRleDE6IG5leHR2ZXJ0ZXgsXG4gICAgICAgICAgICBwb2x5Z29uaW5kZXg6IHBvbHlnb25pbmRleCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghKHNpZGV0YWcgaW4gc2lkZW1hcCkpIHtcbiAgICAgICAgICAgIHNpZGVtYXBbc2lkZXRhZ10gPSBbc2lkZW9ial07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZGVtYXBbc2lkZXRhZ10ucHVzaChzaWRlb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmVydGV4ID0gbmV4dHZlcnRleDtcbiAgICAgICAgdmVydGV4dGFnID0gbmV4dHZlcnRleHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gU1RFUCAyXG4gIC8vIG5vdyBzaWRlbWFwIGNvbnRhaW5zICd1bm1hdGNoZWQnIHNpZGVzXG4gIC8vIGkuZS4gc2lkZSBBQiBpbiBvbmUgcG9seWdvbiBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcgc2lkZSBCQSBpbiBhbm90aGVyIHBvbHlnb25cbiAgbGV0IHZlcnRleHRhZzJzaWRlc3RhcnQgPSB7fTtcbiAgbGV0IHZlcnRleHRhZzJzaWRlZW5kID0ge307XG4gIGxldCBzaWRlc3RvY2hlY2sgPSB7fTtcbiAgbGV0IHNpZGVtYXBpc2VtcHR5ID0gdHJ1ZTtcbiAgZm9yIChsZXQgc2lkZXRhZyBpbiBzaWRlbWFwKSB7XG4gICAgc2lkZW1hcGlzZW1wdHkgPSBmYWxzZTtcbiAgICBzaWRlc3RvY2hlY2tbc2lkZXRhZ10gPSB0cnVlO1xuICAgIHNpZGVtYXBbc2lkZXRhZ10ubWFwKGZ1bmN0aW9uIChzaWRlb2JqKSB7XG4gICAgICBsZXQgc3RhcnR0YWcgPSBzaWRlb2JqLnZlcnRleDAuZ2V0VGFnKCk7XG4gICAgICBsZXQgZW5kdGFnID0gc2lkZW9iai52ZXJ0ZXgxLmdldFRhZygpO1xuICAgICAgaWYgKHN0YXJ0dGFnIGluIHZlcnRleHRhZzJzaWRlc3RhcnQpIHtcbiAgICAgICAgdmVydGV4dGFnMnNpZGVzdGFydFtzdGFydHRhZ10ucHVzaChzaWRldGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnRleHRhZzJzaWRlc3RhcnRbc3RhcnR0YWddID0gW3NpZGV0YWddO1xuICAgICAgfVxuICAgICAgaWYgKGVuZHRhZyBpbiB2ZXJ0ZXh0YWcyc2lkZWVuZCkge1xuICAgICAgICB2ZXJ0ZXh0YWcyc2lkZWVuZFtlbmR0YWddLnB1c2goc2lkZXRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJ0ZXh0YWcyc2lkZWVuZFtlbmR0YWddID0gW3NpZGV0YWddO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gU1RFUCAzIDogaWYgc2lkZW1hcCBpcyBub3QgZW1wdHlcbiAgaWYgKCFzaWRlbWFwaXNlbXB0eSkge1xuICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBwb2x5Z29ucyBhcnJheSwgc2luY2Ugd2UgYXJlIGdvaW5nIHRvIG1vZGlmeSBpdDpcbiAgICBsZXQgcG9seWdvbnMgPSBjc2cucG9seWdvbnMuc2xpY2UoMCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCBzaWRlbWFwaXNlbXB0eSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBzaWRldGFnIGluIHNpZGVtYXApIHtcbiAgICAgICAgc2lkZW1hcGlzZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgc2lkZXN0b2NoZWNrW3NpZGV0YWddID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWRlbWFwaXNlbXB0eSkgYnJlYWs7XG4gICAgICBsZXQgZG9uZXNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHNpZGV0YWd0b2NoZWNrID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgc2lkZXRhZyBpbiBzaWRlc3RvY2hlY2spIHtcbiAgICAgICAgICBzaWRldGFndG9jaGVjayA9IHNpZGV0YWc7XG4gICAgICAgICAgYnJlYWs7IC8vIEZJWE1FICA6IHNheSB3aGF0IG5vdyA/XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZGV0YWd0b2NoZWNrID09PSBudWxsKSBicmVhazsgLy8gc2lkZXN0b2NoZWNrIGlzIGVtcHR5LCB3ZSdyZSBkb25lIVxuICAgICAgICBsZXQgZG9uZXdpdGhzaWRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNpZGV0YWd0b2NoZWNrIGluIHNpZGVtYXApIHtcbiAgICAgICAgICBsZXQgc2lkZW9ianMgPSBzaWRlbWFwW3NpZGV0YWd0b2NoZWNrXTtcbiAgICAgICAgICBpZiAoc2lkZW9ianMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICBsZXQgc2lkZW9iaiA9IHNpZGVvYmpzWzBdO1xuICAgICAgICAgIGZvciAobGV0IGRpcmVjdGlvbmluZGV4ID0gMDsgZGlyZWN0aW9uaW5kZXggPCAyOyBkaXJlY3Rpb25pbmRleCsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnR2ZXJ0ZXggPVxuICAgICAgICAgICAgICBkaXJlY3Rpb25pbmRleCA9PT0gMCA/IHNpZGVvYmoudmVydGV4MCA6IHNpZGVvYmoudmVydGV4MTtcbiAgICAgICAgICAgIGxldCBlbmR2ZXJ0ZXggPVxuICAgICAgICAgICAgICBkaXJlY3Rpb25pbmRleCA9PT0gMCA/IHNpZGVvYmoudmVydGV4MSA6IHNpZGVvYmoudmVydGV4MDtcbiAgICAgICAgICAgIGxldCBzdGFydHZlcnRleHRhZyA9IHN0YXJ0dmVydGV4LmdldFRhZygpO1xuICAgICAgICAgICAgbGV0IGVuZHZlcnRleHRhZyA9IGVuZHZlcnRleC5nZXRUYWcoKTtcbiAgICAgICAgICAgIGxldCBtYXRjaGluZ3NpZGVzID0gW107XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0dmVydGV4dGFnIGluIHZlcnRleHRhZzJzaWRlZW5kKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdzaWRlcyA9IHZlcnRleHRhZzJzaWRlZW5kW3N0YXJ0dmVydGV4dGFnXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0dmVydGV4dGFnIGluIHZlcnRleHRhZzJzaWRlc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ3NpZGVzID0gdmVydGV4dGFnMnNpZGVzdGFydFtzdGFydHZlcnRleHRhZ107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGxldCBtYXRjaGluZ3NpZGVpbmRleCA9IDA7XG4gICAgICAgICAgICAgIG1hdGNoaW5nc2lkZWluZGV4IDwgbWF0Y2hpbmdzaWRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIG1hdGNoaW5nc2lkZWluZGV4KytcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBsZXQgbWF0Y2hpbmdzaWRldGFnID0gbWF0Y2hpbmdzaWRlc1ttYXRjaGluZ3NpZGVpbmRleF07XG4gICAgICAgICAgICAgIGxldCBtYXRjaGluZ3NpZGUgPSBzaWRlbWFwW21hdGNoaW5nc2lkZXRhZ11bMF07XG4gICAgICAgICAgICAgIGxldCBtYXRjaGluZ3NpZGVzdGFydHZlcnRleCA9XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uaW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgID8gbWF0Y2hpbmdzaWRlLnZlcnRleDBcbiAgICAgICAgICAgICAgICAgIDogbWF0Y2hpbmdzaWRlLnZlcnRleDE7XG4gICAgICAgICAgICAgIGxldCBtYXRjaGluZ3NpZGVlbmR2ZXJ0ZXggPVxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbmluZGV4ID09PSAwXG4gICAgICAgICAgICAgICAgICA/IG1hdGNoaW5nc2lkZS52ZXJ0ZXgxXG4gICAgICAgICAgICAgICAgICA6IG1hdGNoaW5nc2lkZS52ZXJ0ZXgwO1xuICAgICAgICAgICAgICBsZXQgbWF0Y2hpbmdzaWRlc3RhcnR2ZXJ0ZXh0YWcgPSBtYXRjaGluZ3NpZGVzdGFydHZlcnRleC5nZXRUYWcoKTtcbiAgICAgICAgICAgICAgbGV0IG1hdGNoaW5nc2lkZWVuZHZlcnRleHRhZyA9IG1hdGNoaW5nc2lkZWVuZHZlcnRleC5nZXRUYWcoKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nc2lkZWVuZHZlcnRleHRhZyAhPT0gc3RhcnR2ZXJ0ZXh0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGluZ3NpZGVzdGFydHZlcnRleHRhZyA9PT0gZW5kdmVydGV4dGFnKSB7XG4gICAgICAgICAgICAgICAgLy8gbWF0Y2hpbmdzaWRlIGNhbmNlbHMgc2lkZXRhZ3RvY2hlY2tcbiAgICAgICAgICAgICAgICBkZWxldGVTaWRlKFxuICAgICAgICAgICAgICAgICAgc2lkZW1hcCxcbiAgICAgICAgICAgICAgICAgIHZlcnRleHRhZzJzaWRlc3RhcnQsXG4gICAgICAgICAgICAgICAgICB2ZXJ0ZXh0YWcyc2lkZWVuZCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0dmVydGV4LFxuICAgICAgICAgICAgICAgICAgZW5kdmVydGV4LFxuICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZGVsZXRlU2lkZShcbiAgICAgICAgICAgICAgICAgIHNpZGVtYXAsXG4gICAgICAgICAgICAgICAgICB2ZXJ0ZXh0YWcyc2lkZXN0YXJ0LFxuICAgICAgICAgICAgICAgICAgdmVydGV4dGFnMnNpZGVlbmQsXG4gICAgICAgICAgICAgICAgICBlbmR2ZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICBzdGFydHZlcnRleCxcbiAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvbmV3aXRoc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbmluZGV4ID0gMjsgLy8gc2tpcCByZXZlcnNlIGRpcmVjdGlvbiBjaGVja1xuICAgICAgICAgICAgICAgIGRvbmVzb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydHBvcyA9IHN0YXJ0dmVydGV4LnBvcztcbiAgICAgICAgICAgICAgICBsZXQgZW5kcG9zID0gZW5kdmVydGV4LnBvcztcbiAgICAgICAgICAgICAgICBsZXQgY2hlY2twb3MgPSBtYXRjaGluZ3NpZGVzdGFydHZlcnRleC5wb3M7XG4gICAgICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGNoZWNrcG9zLm1pbnVzKHN0YXJ0cG9zKTtcbiAgICAgICAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byBjaGVjayBpZiBlbmRwb3MgaXMgb24gdGhlIGxpbmUgc3RhcnRwb3MtY2hlY2twb3M6XG4gICAgICAgICAgICAgICAgbGV0IHQgPVxuICAgICAgICAgICAgICAgICAgZW5kcG9zLm1pbnVzKHN0YXJ0cG9zKS5kb3QoZGlyZWN0aW9uKSAvXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24uZG90KGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiAwICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY2xvc2VzdHBvaW50ID0gc3RhcnRwb3MucGx1cyhkaXJlY3Rpb24udGltZXModCkpO1xuICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlc3F1YXJlZCA9IGNsb3Nlc3Rwb2ludC5kaXN0YW5jZVRvU3F1YXJlZChlbmRwb3MpO1xuICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlc3F1YXJlZCA8IEVQUyAqIEVQUykge1xuICAgICAgICAgICAgICAgICAgICAvLyBZZXMgaXQncyBhIHQtanVuY3Rpb24hIFdlIG5lZWQgdG8gc3BsaXQgbWF0Y2hpbmdzaWRlIGluIHR3bzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvbHlnb25pbmRleCA9IG1hdGNoaW5nc2lkZS5wb2x5Z29uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2x5Z29uID0gcG9seWdvbnNbcG9seWdvbmluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2Ygc3RhcnR2ZXJ0ZXh0YWcgaW4gcG9seWdvbjpcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc2VydGlvbnZlcnRleHRhZyA9IG1hdGNoaW5nc2lkZS52ZXJ0ZXgxLmdldFRhZygpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0aW9udmVydGV4dGFnaW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlnb24udmVydGljZXNbaV0uZ2V0VGFnKCkgPT09IGluc2VydGlvbnZlcnRleHRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0aW9udmVydGV4dGFnaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnRpb252ZXJ0ZXh0YWdpbmRleCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBzaWRlIGJ5IGluc2VydGluZyB0aGUgdmVydGV4OlxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3dmVydGljZXMgPSBwb2x5Z29uLnZlcnRpY2VzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBuZXd2ZXJ0aWNlcy5zcGxpY2UoaW5zZXJ0aW9udmVydGV4dGFnaW5kZXgsIDAsIGVuZHZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdwb2x5Z29uID0gbmV3IFBvbHlnb24oXG4gICAgICAgICAgICAgICAgICAgICAgbmV3dmVydGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5zaGFyZWQgLyogcG9seWdvbi5wbGFuZSAqL1xuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwbGFuZSB3aXRoIGRpZmZlcmVudHMgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG5ld3BvbHlnb24ucGxhbmUudykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9vcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3cG9seWdvbi52ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICBsb29wKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwb2x5Z29uLnBsYW5lID0gUGxhbmUuZnJvbVBvaW50cyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihuZXdwb2x5Z29uLnBsYW5lLncpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25zW3BvbHlnb25pbmRleF0gPSBuZXdwb2x5Z29uO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIHNpZGVzIGZyb20gb3VyIG1hcHNcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlU2lkZShzaWRlb2JqLnZlcnRleDAsIHNpZGVvYmoudmVydGV4MSwgbnVsbClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlU2lkZShcbiAgICAgICAgICAgICAgICAgICAgICBzaWRlbWFwLFxuICAgICAgICAgICAgICAgICAgICAgIHZlcnRleHRhZzJzaWRlc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgdmVydGV4dGFnMnNpZGVlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdzaWRlLnZlcnRleDAsXG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdzaWRlLnZlcnRleDEsXG4gICAgICAgICAgICAgICAgICAgICAgcG9seWdvbmluZGV4XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdzaWRldGFnMSA9IGFkZFNpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgc2lkZW1hcCxcbiAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXh0YWcyc2lkZXN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHZlcnRleHRhZzJzaWRlZW5kLFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nc2lkZS52ZXJ0ZXgwLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZHZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld3NpZGV0YWcyID0gYWRkU2lkZShcbiAgICAgICAgICAgICAgICAgICAgICBzaWRlbWFwLFxuICAgICAgICAgICAgICAgICAgICAgIHZlcnRleHRhZzJzaWRlc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgdmVydGV4dGFnMnNpZGVlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kdmVydGV4LFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nc2lkZS52ZXJ0ZXgxLFxuICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25pbmRleFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3c2lkZXRhZzEgIT09IG51bGwpIHNpZGVzdG9jaGVja1tuZXdzaWRldGFnMV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3c2lkZXRhZzIgIT09IG51bGwpIHNpZGVzdG9jaGVja1tuZXdzaWRldGFnMl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkb25ld2l0aHNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uaW5kZXggPSAyOyAvLyBza2lwIHJldmVyc2UgZGlyZWN0aW9uIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGRvbmVzb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gLy8gaWYoZGlzdGFuY2VzcXVhcmVkIDwgMWUtMTApXG4gICAgICAgICAgICAgICAgfSAvLyBpZiggKHQgPiAwKSAmJiAodCA8IDEpIClcbiAgICAgICAgICAgICAgfSAvLyBpZihlbmRpbmdzdGlkZXN0YXJ0dmVydGV4dGFnID09PSBlbmR2ZXJ0ZXh0YWcpXG4gICAgICAgICAgICB9IC8vIGZvciBtYXRjaGluZ3NpZGVpbmRleFxuICAgICAgICAgIH0gLy8gZm9yIGRpcmVjdGlvbmluZGV4XG4gICAgICAgIH0gLy8gaWYoc2lkZXRhZ3RvY2hlY2sgaW4gc2lkZW1hcClcbiAgICAgICAgaWYgKGRvbmV3aXRoc2lkZSkge1xuICAgICAgICAgIGRlbGV0ZSBzaWRlc3RvY2hlY2tbc2lkZXRhZ3RvY2hlY2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRvbmVzb21ldGhpbmcpIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgbmV3Y3NnID0gZnJvbVBvbHlnb25zKHBvbHlnb25zKTtcbiAgICBuZXdjc2cucHJvcGVydGllcyA9IGNzZy5wcm9wZXJ0aWVzO1xuICAgIG5ld2NzZy5pc0Nhbm9uaWNhbGl6ZWQgPSB0cnVlO1xuICAgIG5ld2NzZy5pc1JldGVzc2VsYXRlZCA9IHRydWU7XG4gICAgY3NnID0gbmV3Y3NnO1xuICB9XG5cbiAgLy8gRklYTUUgOiB3aGF0IGlzIGV2ZW4gdGhlIHBvaW50IG9mIHRoaXMgPz8/XG4gIC8qIHNpZGVtYXBpc2VtcHR5ID0gdHJ1ZVxuICBmb3IgKGxldCBzaWRldGFnIGluIHNpZGVtYXApIHtcbiAgICBzaWRlbWFwaXNlbXB0eSA9IGZhbHNlXG4gICAgYnJlYWtcbiAgfVxuICAqL1xuXG4gIHJldHVybiBjc2c7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpeFRKdW5jdGlvbnM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/utils/fixTJunctions.js\n");

/***/ }),

/***/ "./src/core/utils/retesellate.js":
/*!***************************************!*\
  !*** ./src/core/utils/retesellate.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const FuzzyCSGFactory = __webpack_require__(/*! ../FuzzyFactory3d */ \"./src/core/FuzzyFactory3d.js\");\nconst reTesselateCoplanarPolygons = __webpack_require__(/*! ../math/reTesselateCoplanarPolygons */ \"./src/core/math/reTesselateCoplanarPolygons.js\");\nconst { fromPolygons } = __webpack_require__(/*! ../CSGFactories */ \"./src/core/CSGFactories.js\");\n\nconst reTesselate = function (csg) {\n  if (csg.isRetesselated) {\n    return csg;\n  } else {\n    let polygonsPerPlane = {};\n    let isCanonicalized = csg.isCanonicalized;\n    let fuzzyfactory = new FuzzyCSGFactory();\n    csg.polygons.map(function (polygon) {\n      let plane = polygon.plane;\n      let shared = polygon.shared;\n      if (!isCanonicalized) {\n        // in order to identify polygons having the same plane, we need to canonicalize the planes\n        // We don't have to do a full canonizalization (including vertices), to save time only do the planes and the shared data:\n        plane = fuzzyfactory.getPlane(plane);\n        shared = fuzzyfactory.getPolygonShared(shared);\n      }\n      let tag = plane.getTag() + '/' + shared.getTag();\n      if (!(tag in polygonsPerPlane)) {\n        polygonsPerPlane[tag] = [polygon];\n      } else {\n        polygonsPerPlane[tag].push(polygon);\n      }\n    });\n    let destpolygons = [];\n    for (let planetag in polygonsPerPlane) {\n      let sourcepolygons = polygonsPerPlane[planetag];\n      if (sourcepolygons.length < 2) {\n        destpolygons = destpolygons.concat(sourcepolygons);\n      } else {\n        let retesselayedpolygons = [];\n        reTesselateCoplanarPolygons(sourcepolygons, retesselayedpolygons);\n        destpolygons = destpolygons.concat(retesselayedpolygons);\n      }\n    }\n    let result = fromPolygons(destpolygons);\n    result.isRetesselated = true;\n    // result = result.canonicalized();\n    result.properties = csg.properties; // keep original properties\n    return result;\n  }\n};\n\nmodule.exports = reTesselate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy9yZXRlc2VsbGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwaS8uL3NyYy9jb3JlL3V0aWxzL3JldGVzZWxsYXRlLmpzPzIwYTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRnV6enlDU0dGYWN0b3J5ID0gcmVxdWlyZSgnLi4vRnV6enlGYWN0b3J5M2QnKTtcbmNvbnN0IHJlVGVzc2VsYXRlQ29wbGFuYXJQb2x5Z29ucyA9IHJlcXVpcmUoJy4uL21hdGgvcmVUZXNzZWxhdGVDb3BsYW5hclBvbHlnb25zJyk7XG5jb25zdCB7IGZyb21Qb2x5Z29ucyB9ID0gcmVxdWlyZSgnLi4vQ1NHRmFjdG9yaWVzJyk7XG5cbmNvbnN0IHJlVGVzc2VsYXRlID0gZnVuY3Rpb24gKGNzZykge1xuICBpZiAoY3NnLmlzUmV0ZXNzZWxhdGVkKSB7XG4gICAgcmV0dXJuIGNzZztcbiAgfSBlbHNlIHtcbiAgICBsZXQgcG9seWdvbnNQZXJQbGFuZSA9IHt9O1xuICAgIGxldCBpc0Nhbm9uaWNhbGl6ZWQgPSBjc2cuaXNDYW5vbmljYWxpemVkO1xuICAgIGxldCBmdXp6eWZhY3RvcnkgPSBuZXcgRnV6enlDU0dGYWN0b3J5KCk7XG4gICAgY3NnLnBvbHlnb25zLm1hcChmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgbGV0IHBsYW5lID0gcG9seWdvbi5wbGFuZTtcbiAgICAgIGxldCBzaGFyZWQgPSBwb2x5Z29uLnNoYXJlZDtcbiAgICAgIGlmICghaXNDYW5vbmljYWxpemVkKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGlkZW50aWZ5IHBvbHlnb25zIGhhdmluZyB0aGUgc2FtZSBwbGFuZSwgd2UgbmVlZCB0byBjYW5vbmljYWxpemUgdGhlIHBsYW5lc1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIGRvIGEgZnVsbCBjYW5vbml6YWxpemF0aW9uIChpbmNsdWRpbmcgdmVydGljZXMpLCB0byBzYXZlIHRpbWUgb25seSBkbyB0aGUgcGxhbmVzIGFuZCB0aGUgc2hhcmVkIGRhdGE6XG4gICAgICAgIHBsYW5lID0gZnV6enlmYWN0b3J5LmdldFBsYW5lKHBsYW5lKTtcbiAgICAgICAgc2hhcmVkID0gZnV6enlmYWN0b3J5LmdldFBvbHlnb25TaGFyZWQoc2hhcmVkKTtcbiAgICAgIH1cbiAgICAgIGxldCB0YWcgPSBwbGFuZS5nZXRUYWcoKSArICcvJyArIHNoYXJlZC5nZXRUYWcoKTtcbiAgICAgIGlmICghKHRhZyBpbiBwb2x5Z29uc1BlclBsYW5lKSkge1xuICAgICAgICBwb2x5Z29uc1BlclBsYW5lW3RhZ10gPSBbcG9seWdvbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2x5Z29uc1BlclBsYW5lW3RhZ10ucHVzaChwb2x5Z29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgZGVzdHBvbHlnb25zID0gW107XG4gICAgZm9yIChsZXQgcGxhbmV0YWcgaW4gcG9seWdvbnNQZXJQbGFuZSkge1xuICAgICAgbGV0IHNvdXJjZXBvbHlnb25zID0gcG9seWdvbnNQZXJQbGFuZVtwbGFuZXRhZ107XG4gICAgICBpZiAoc291cmNlcG9seWdvbnMubGVuZ3RoIDwgMikge1xuICAgICAgICBkZXN0cG9seWdvbnMgPSBkZXN0cG9seWdvbnMuY29uY2F0KHNvdXJjZXBvbHlnb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByZXRlc3NlbGF5ZWRwb2x5Z29ucyA9IFtdO1xuICAgICAgICByZVRlc3NlbGF0ZUNvcGxhbmFyUG9seWdvbnMoc291cmNlcG9seWdvbnMsIHJldGVzc2VsYXllZHBvbHlnb25zKTtcbiAgICAgICAgZGVzdHBvbHlnb25zID0gZGVzdHBvbHlnb25zLmNvbmNhdChyZXRlc3NlbGF5ZWRwb2x5Z29ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBmcm9tUG9seWdvbnMoZGVzdHBvbHlnb25zKTtcbiAgICByZXN1bHQuaXNSZXRlc3NlbGF0ZWQgPSB0cnVlO1xuICAgIC8vIHJlc3VsdCA9IHJlc3VsdC5jYW5vbmljYWxpemVkKCk7XG4gICAgcmVzdWx0LnByb3BlcnRpZXMgPSBjc2cucHJvcGVydGllczsgLy8ga2VlcCBvcmlnaW5hbCBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZVRlc3NlbGF0ZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/utils/retesellate.js\n");

/***/ }),

/***/ "./src/core/utils/toArray.js":
/*!***********************************!*\
  !*** ./src/core/utils/toArray.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* converts input data to array if it is not already an array */\nfunction toArray(data) {\n  if (!data) return [];\n  if (data.constructor !== Array) return [data];\n  return data;\n}\n\nmodule.exports = toArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy90b0FycmF5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2NvcmUvdXRpbHMvdG9BcnJheS5qcz8wZjM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGNvbnZlcnRzIGlucHV0IGRhdGEgdG8gYXJyYXkgaWYgaXQgaXMgbm90IGFscmVhZHkgYW4gYXJyYXkgKi9cbmZ1bmN0aW9uIHRvQXJyYXkoZGF0YSkge1xuICBpZiAoIWRhdGEpIHJldHVybiBbXTtcbiAgaWYgKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSByZXR1cm4gW2RhdGFdO1xuICByZXR1cm4gZGF0YTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/utils/toArray.js\n");

/***/ }),

/***/ "./src/fonts/single-line/hershey/simplex.js":
/*!**************************************************!*\
  !*** ./src/fonts/single-line/hershey/simplex.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// -- data source from from http://paulbourke.net/dataformats/hershey/\n// -- reduced to save some bytes...\n// { [ascii code]: [width, x, y, ...] } - undefined value as path separator\nmodule.exports = {\n  height: 14,\n  32: [16],\n  33: [10, 5, 21, 5, 7, , 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  34: [16, 4, 21, 4, 14, , 12, 21, 12, 14],\n  35: [21, 11, 25, 4, -7, , 17, 25, 10, -7, , 4, 12, 18, 12, , 3, 6, 17, 6],\n  36: [\n    20,\n    8,\n    25,\n    8,\n    -4,\n    ,\n    12,\n    25,\n    12,\n    -4,\n    ,\n    17,\n    18,\n    15,\n    20,\n    12,\n    21,\n    8,\n    21,\n    5,\n    20,\n    3,\n    18,\n    3,\n    16,\n    4,\n    14,\n    5,\n    13,\n    7,\n    12,\n    13,\n    10,\n    15,\n    9,\n    16,\n    8,\n    17,\n    6,\n    17,\n    3,\n    15,\n    1,\n    12,\n    0,\n    8,\n    0,\n    5,\n    1,\n    3,\n    3,\n  ],\n  37: [\n    24,\n    21,\n    21,\n    3,\n    0,\n    ,\n    8,\n    21,\n    10,\n    19,\n    10,\n    17,\n    9,\n    15,\n    7,\n    14,\n    5,\n    14,\n    3,\n    16,\n    3,\n    18,\n    4,\n    20,\n    6,\n    21,\n    8,\n    21,\n    10,\n    20,\n    13,\n    19,\n    16,\n    19,\n    19,\n    20,\n    21,\n    21,\n    ,\n    17,\n    7,\n    15,\n    6,\n    14,\n    4,\n    14,\n    2,\n    16,\n    0,\n    18,\n    0,\n    20,\n    1,\n    21,\n    3,\n    21,\n    5,\n    19,\n    7,\n    17,\n    7,\n  ],\n  38: [\n    26,\n    23,\n    12,\n    23,\n    13,\n    22,\n    14,\n    21,\n    14,\n    20,\n    13,\n    19,\n    11,\n    17,\n    6,\n    15,\n    3,\n    13,\n    1,\n    11,\n    0,\n    7,\n    0,\n    5,\n    1,\n    4,\n    2,\n    3,\n    4,\n    3,\n    6,\n    4,\n    8,\n    5,\n    9,\n    12,\n    13,\n    13,\n    14,\n    14,\n    16,\n    14,\n    18,\n    13,\n    20,\n    11,\n    21,\n    9,\n    20,\n    8,\n    18,\n    8,\n    16,\n    9,\n    13,\n    11,\n    10,\n    16,\n    3,\n    18,\n    1,\n    20,\n    0,\n    22,\n    0,\n    23,\n    1,\n    23,\n    2,\n  ],\n  39: [10, 5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15],\n  40: [\n    14,\n    11,\n    25,\n    9,\n    23,\n    7,\n    20,\n    5,\n    16,\n    4,\n    11,\n    4,\n    7,\n    5,\n    2,\n    7,\n    -2,\n    9,\n    -5,\n    11,\n    -7,\n  ],\n  41: [\n    14,\n    3,\n    25,\n    5,\n    23,\n    7,\n    20,\n    9,\n    16,\n    10,\n    11,\n    10,\n    7,\n    9,\n    2,\n    7,\n    -2,\n    5,\n    -5,\n    3,\n    -7,\n  ],\n  42: [16, 8, 21, 8, 9, , 3, 18, 13, 12, , 13, 18, 3, 12],\n  43: [26, 13, 18, 13, 0, , 4, 9, 22, 9],\n  44: [10, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4],\n  45: [26, 4, 9, 22, 9],\n  46: [10, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  47: [22, 20, 25, 2, -7],\n  48: [\n    20,\n    9,\n    21,\n    6,\n    20,\n    4,\n    17,\n    3,\n    12,\n    3,\n    9,\n    4,\n    4,\n    6,\n    1,\n    9,\n    0,\n    11,\n    0,\n    14,\n    1,\n    16,\n    4,\n    17,\n    9,\n    17,\n    12,\n    16,\n    17,\n    14,\n    20,\n    11,\n    21,\n    9,\n    21,\n  ],\n  49: [20, 6, 17, 8, 18, 11, 21, 11, 0],\n  50: [\n    20,\n    4,\n    16,\n    4,\n    17,\n    5,\n    19,\n    6,\n    20,\n    8,\n    21,\n    12,\n    21,\n    14,\n    20,\n    15,\n    19,\n    16,\n    17,\n    16,\n    15,\n    15,\n    13,\n    13,\n    10,\n    3,\n    0,\n    17,\n    0,\n  ],\n  51: [\n    20,\n    5,\n    21,\n    16,\n    21,\n    10,\n    13,\n    13,\n    13,\n    15,\n    12,\n    16,\n    11,\n    17,\n    8,\n    17,\n    6,\n    16,\n    3,\n    14,\n    1,\n    11,\n    0,\n    8,\n    0,\n    5,\n    1,\n    4,\n    2,\n    3,\n    4,\n  ],\n  52: [20, 13, 21, 3, 7, 18, 7, , 13, 21, 13, 0],\n  53: [\n    20,\n    15,\n    21,\n    5,\n    21,\n    4,\n    12,\n    5,\n    13,\n    8,\n    14,\n    11,\n    14,\n    14,\n    13,\n    16,\n    11,\n    17,\n    8,\n    17,\n    6,\n    16,\n    3,\n    14,\n    1,\n    11,\n    0,\n    8,\n    0,\n    5,\n    1,\n    4,\n    2,\n    3,\n    4,\n  ],\n  54: [\n    20,\n    16,\n    18,\n    15,\n    20,\n    12,\n    21,\n    10,\n    21,\n    7,\n    20,\n    5,\n    17,\n    4,\n    12,\n    4,\n    7,\n    5,\n    3,\n    7,\n    1,\n    10,\n    0,\n    11,\n    0,\n    14,\n    1,\n    16,\n    3,\n    17,\n    6,\n    17,\n    7,\n    16,\n    10,\n    14,\n    12,\n    11,\n    13,\n    10,\n    13,\n    7,\n    12,\n    5,\n    10,\n    4,\n    7,\n  ],\n  55: [20, 17, 21, 7, 0, , 3, 21, 17, 21],\n  56: [\n    20,\n    8,\n    21,\n    5,\n    20,\n    4,\n    18,\n    4,\n    16,\n    5,\n    14,\n    7,\n    13,\n    11,\n    12,\n    14,\n    11,\n    16,\n    9,\n    17,\n    7,\n    17,\n    4,\n    16,\n    2,\n    15,\n    1,\n    12,\n    0,\n    8,\n    0,\n    5,\n    1,\n    4,\n    2,\n    3,\n    4,\n    3,\n    7,\n    4,\n    9,\n    6,\n    11,\n    9,\n    12,\n    13,\n    13,\n    15,\n    14,\n    16,\n    16,\n    16,\n    18,\n    15,\n    20,\n    12,\n    21,\n    8,\n    21,\n  ],\n  57: [\n    20,\n    16,\n    14,\n    15,\n    11,\n    13,\n    9,\n    10,\n    8,\n    9,\n    8,\n    6,\n    9,\n    4,\n    11,\n    3,\n    14,\n    3,\n    15,\n    4,\n    18,\n    6,\n    20,\n    9,\n    21,\n    10,\n    21,\n    13,\n    20,\n    15,\n    18,\n    16,\n    14,\n    16,\n    9,\n    15,\n    4,\n    13,\n    1,\n    10,\n    0,\n    8,\n    0,\n    5,\n    1,\n    4,\n    3,\n  ],\n  58: [10, 5, 14, 4, 13, 5, 12, 6, 13, 5, 14, , 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  59: [\n    10,\n    5,\n    14,\n    4,\n    13,\n    5,\n    12,\n    6,\n    13,\n    5,\n    14,\n    ,\n    6,\n    1,\n    5,\n    0,\n    4,\n    1,\n    5,\n    2,\n    6,\n    1,\n    6,\n    -1,\n    5,\n    -3,\n    4,\n    -4,\n  ],\n  60: [24, 20, 18, 4, 9, 20, 0],\n  61: [26, 4, 12, 22, 12, , 4, 6, 22, 6],\n  62: [24, 4, 18, 20, 9, 4, 0],\n  63: [\n    18,\n    3,\n    16,\n    3,\n    17,\n    4,\n    19,\n    5,\n    20,\n    7,\n    21,\n    11,\n    21,\n    13,\n    20,\n    14,\n    19,\n    15,\n    17,\n    15,\n    15,\n    14,\n    13,\n    13,\n    12,\n    9,\n    10,\n    9,\n    7,\n    ,\n    9,\n    2,\n    8,\n    1,\n    9,\n    0,\n    10,\n    1,\n    9,\n    2,\n  ],\n  64: [\n    27,\n    18,\n    13,\n    17,\n    15,\n    15,\n    16,\n    12,\n    16,\n    10,\n    15,\n    9,\n    14,\n    8,\n    11,\n    8,\n    8,\n    9,\n    6,\n    11,\n    5,\n    14,\n    5,\n    16,\n    6,\n    17,\n    8,\n    ,\n    12,\n    16,\n    10,\n    14,\n    9,\n    11,\n    9,\n    8,\n    10,\n    6,\n    11,\n    5,\n    ,\n    18,\n    16,\n    17,\n    8,\n    17,\n    6,\n    19,\n    5,\n    21,\n    5,\n    23,\n    7,\n    24,\n    10,\n    24,\n    12,\n    23,\n    15,\n    22,\n    17,\n    20,\n    19,\n    18,\n    20,\n    15,\n    21,\n    12,\n    21,\n    9,\n    20,\n    7,\n    19,\n    5,\n    17,\n    4,\n    15,\n    3,\n    12,\n    3,\n    9,\n    4,\n    6,\n    5,\n    4,\n    7,\n    2,\n    9,\n    1,\n    12,\n    0,\n    15,\n    0,\n    18,\n    1,\n    20,\n    2,\n    21,\n    3,\n    ,\n    19,\n    16,\n    18,\n    8,\n    18,\n    6,\n    19,\n    5,\n  ],\n  65: [18, 9, 21, 1, 0, , 9, 21, 17, 0, , 4, 7, 14, 7],\n  66: [\n    21,\n    4,\n    21,\n    4,\n    0,\n    ,\n    4,\n    21,\n    13,\n    21,\n    16,\n    20,\n    17,\n    19,\n    18,\n    17,\n    18,\n    15,\n    17,\n    13,\n    16,\n    12,\n    13,\n    11,\n    ,\n    4,\n    11,\n    13,\n    11,\n    16,\n    10,\n    17,\n    9,\n    18,\n    7,\n    18,\n    4,\n    17,\n    2,\n    16,\n    1,\n    13,\n    0,\n    4,\n    0,\n  ],\n  67: [\n    21,\n    18,\n    16,\n    17,\n    18,\n    15,\n    20,\n    13,\n    21,\n    9,\n    21,\n    7,\n    20,\n    5,\n    18,\n    4,\n    16,\n    3,\n    13,\n    3,\n    8,\n    4,\n    5,\n    5,\n    3,\n    7,\n    1,\n    9,\n    0,\n    13,\n    0,\n    15,\n    1,\n    17,\n    3,\n    18,\n    5,\n  ],\n  68: [\n    21,\n    4,\n    21,\n    4,\n    0,\n    ,\n    4,\n    21,\n    11,\n    21,\n    14,\n    20,\n    16,\n    18,\n    17,\n    16,\n    18,\n    13,\n    18,\n    8,\n    17,\n    5,\n    16,\n    3,\n    14,\n    1,\n    11,\n    0,\n    4,\n    0,\n  ],\n  69: [19, 4, 21, 4, 0, , 4, 21, 17, 21, , 4, 11, 12, 11, , 4, 0, 17, 0],\n  70: [18, 4, 21, 4, 0, , 4, 21, 17, 21, , 4, 11, 12, 11],\n  71: [\n    21,\n    18,\n    16,\n    17,\n    18,\n    15,\n    20,\n    13,\n    21,\n    9,\n    21,\n    7,\n    20,\n    5,\n    18,\n    4,\n    16,\n    3,\n    13,\n    3,\n    8,\n    4,\n    5,\n    5,\n    3,\n    7,\n    1,\n    9,\n    0,\n    13,\n    0,\n    15,\n    1,\n    17,\n    3,\n    18,\n    5,\n    18,\n    8,\n    ,\n    13,\n    8,\n    18,\n    8,\n  ],\n  72: [22, 4, 21, 4, 0, , 18, 21, 18, 0, , 4, 11, 18, 11],\n  73: [8, 4, 21, 4, 0],\n  74: [16, 12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7],\n  75: [21, 4, 21, 4, 0, , 18, 21, 4, 7, , 9, 12, 18, 0],\n  76: [17, 4, 21, 4, 0, , 4, 0, 16, 0],\n  77: [24, 4, 21, 4, 0, , 4, 21, 12, 0, , 20, 21, 12, 0, , 20, 21, 20, 0],\n  78: [22, 4, 21, 4, 0, , 4, 21, 18, 0, , 18, 21, 18, 0],\n  79: [\n    22,\n    9,\n    21,\n    7,\n    20,\n    5,\n    18,\n    4,\n    16,\n    3,\n    13,\n    3,\n    8,\n    4,\n    5,\n    5,\n    3,\n    7,\n    1,\n    9,\n    0,\n    13,\n    0,\n    15,\n    1,\n    17,\n    3,\n    18,\n    5,\n    19,\n    8,\n    19,\n    13,\n    18,\n    16,\n    17,\n    18,\n    15,\n    20,\n    13,\n    21,\n    9,\n    21,\n  ],\n  80: [\n    21,\n    4,\n    21,\n    4,\n    0,\n    ,\n    4,\n    21,\n    13,\n    21,\n    16,\n    20,\n    17,\n    19,\n    18,\n    17,\n    18,\n    14,\n    17,\n    12,\n    16,\n    11,\n    13,\n    10,\n    4,\n    10,\n  ],\n  81: [\n    22,\n    9,\n    21,\n    7,\n    20,\n    5,\n    18,\n    4,\n    16,\n    3,\n    13,\n    3,\n    8,\n    4,\n    5,\n    5,\n    3,\n    7,\n    1,\n    9,\n    0,\n    13,\n    0,\n    15,\n    1,\n    17,\n    3,\n    18,\n    5,\n    19,\n    8,\n    19,\n    13,\n    18,\n    16,\n    17,\n    18,\n    15,\n    20,\n    13,\n    21,\n    9,\n    21,\n    ,\n    12,\n    4,\n    18,\n    -2,\n  ],\n  82: [\n    21,\n    4,\n    21,\n    4,\n    0,\n    ,\n    4,\n    21,\n    13,\n    21,\n    16,\n    20,\n    17,\n    19,\n    18,\n    17,\n    18,\n    15,\n    17,\n    13,\n    16,\n    12,\n    13,\n    11,\n    4,\n    11,\n    ,\n    11,\n    11,\n    18,\n    0,\n  ],\n  83: [\n    20,\n    17,\n    18,\n    15,\n    20,\n    12,\n    21,\n    8,\n    21,\n    5,\n    20,\n    3,\n    18,\n    3,\n    16,\n    4,\n    14,\n    5,\n    13,\n    7,\n    12,\n    13,\n    10,\n    15,\n    9,\n    16,\n    8,\n    17,\n    6,\n    17,\n    3,\n    15,\n    1,\n    12,\n    0,\n    8,\n    0,\n    5,\n    1,\n    3,\n    3,\n  ],\n  84: [16, 8, 21, 8, 0, , 1, 21, 15, 21],\n  85: [22, 4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21],\n  86: [18, 1, 21, 9, 0, , 17, 21, 9, 0],\n  87: [24, 2, 21, 7, 0, , 12, 21, 7, 0, , 12, 21, 17, 0, , 22, 21, 17, 0],\n  88: [20, 3, 21, 17, 0, , 17, 21, 3, 0],\n  89: [18, 1, 21, 9, 11, 9, 0, , 17, 21, 9, 11],\n  90: [20, 17, 21, 3, 0, , 3, 21, 17, 21, , 3, 0, 17, 0],\n  91: [14, 4, 25, 4, -7, , 5, 25, 5, -7, , 4, 25, 11, 25, , 4, -7, 11, -7],\n  92: [14, 0, 21, 14, -3],\n  93: [14, 9, 25, 9, -7, , 10, 25, 10, -7, , 3, 25, 10, 25, , 3, -7, 10, -7],\n  94: [16, 6, 15, 8, 18, 10, 15, , 3, 12, 8, 17, 13, 12, , 8, 17, 8, 0],\n  95: [16, 0, -2, 16, -2],\n  96: [10, 6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17],\n  97: [\n    19,\n    15,\n    14,\n    15,\n    0,\n    ,\n    15,\n    11,\n    13,\n    13,\n    11,\n    14,\n    8,\n    14,\n    6,\n    13,\n    4,\n    11,\n    3,\n    8,\n    3,\n    6,\n    4,\n    3,\n    6,\n    1,\n    8,\n    0,\n    11,\n    0,\n    13,\n    1,\n    15,\n    3,\n  ],\n  98: [\n    19,\n    4,\n    21,\n    4,\n    0,\n    ,\n    4,\n    11,\n    6,\n    13,\n    8,\n    14,\n    11,\n    14,\n    13,\n    13,\n    15,\n    11,\n    16,\n    8,\n    16,\n    6,\n    15,\n    3,\n    13,\n    1,\n    11,\n    0,\n    8,\n    0,\n    6,\n    1,\n    4,\n    3,\n  ],\n  99: [\n    18,\n    15,\n    11,\n    13,\n    13,\n    11,\n    14,\n    8,\n    14,\n    6,\n    13,\n    4,\n    11,\n    3,\n    8,\n    3,\n    6,\n    4,\n    3,\n    6,\n    1,\n    8,\n    0,\n    11,\n    0,\n    13,\n    1,\n    15,\n    3,\n  ],\n  100: [\n    19,\n    15,\n    21,\n    15,\n    0,\n    ,\n    15,\n    11,\n    13,\n    13,\n    11,\n    14,\n    8,\n    14,\n    6,\n    13,\n    4,\n    11,\n    3,\n    8,\n    3,\n    6,\n    4,\n    3,\n    6,\n    1,\n    8,\n    0,\n    11,\n    0,\n    13,\n    1,\n    15,\n    3,\n  ],\n  101: [\n    18,\n    3,\n    8,\n    15,\n    8,\n    15,\n    10,\n    14,\n    12,\n    13,\n    13,\n    11,\n    14,\n    8,\n    14,\n    6,\n    13,\n    4,\n    11,\n    3,\n    8,\n    3,\n    6,\n    4,\n    3,\n    6,\n    1,\n    8,\n    0,\n    11,\n    0,\n    13,\n    1,\n    15,\n    3,\n  ],\n  102: [12, 10, 21, 8, 21, 6, 20, 5, 17, 5, 0, , 2, 14, 9, 14],\n  103: [\n    19,\n    15,\n    14,\n    15,\n    -2,\n    14,\n    -5,\n    13,\n    -6,\n    11,\n    -7,\n    8,\n    -7,\n    6,\n    -6,\n    ,\n    15,\n    11,\n    13,\n    13,\n    11,\n    14,\n    8,\n    14,\n    6,\n    13,\n    4,\n    11,\n    3,\n    8,\n    3,\n    6,\n    4,\n    3,\n    6,\n    1,\n    8,\n    0,\n    11,\n    0,\n    13,\n    1,\n    15,\n    3,\n  ],\n  104: [19, 4, 21, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],\n  105: [8, 3, 21, 4, 20, 5, 21, 4, 22, 3, 21, , 4, 14, 4, 0],\n  106: [\n    10,\n    5,\n    21,\n    6,\n    20,\n    7,\n    21,\n    6,\n    22,\n    5,\n    21,\n    ,\n    6,\n    14,\n    6,\n    -3,\n    5,\n    -6,\n    3,\n    -7,\n    1,\n    -7,\n  ],\n  107: [17, 4, 21, 4, 0, , 14, 14, 4, 4, , 8, 8, 15, 0],\n  108: [8, 4, 21, 4, 0],\n  109: [\n    30,\n    4,\n    14,\n    4,\n    0,\n    ,\n    4,\n    10,\n    7,\n    13,\n    9,\n    14,\n    12,\n    14,\n    14,\n    13,\n    15,\n    10,\n    15,\n    0,\n    ,\n    15,\n    10,\n    18,\n    13,\n    20,\n    14,\n    23,\n    14,\n    25,\n    13,\n    26,\n    10,\n    26,\n    0,\n  ],\n  110: [19, 4, 14, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],\n  111: [\n    19,\n    8,\n    14,\n    6,\n    13,\n    4,\n    11,\n    3,\n    8,\n    3,\n    6,\n    4,\n    3,\n    6,\n    1,\n    8,\n    0,\n    11,\n    0,\n    13,\n    1,\n    15,\n    3,\n    16,\n    6,\n    16,\n    8,\n    15,\n    11,\n    13,\n    13,\n    11,\n    14,\n    8,\n    14,\n  ],\n  112: [\n    19,\n    4,\n    14,\n    4,\n    -7,\n    ,\n    4,\n    11,\n    6,\n    13,\n    8,\n    14,\n    11,\n    14,\n    13,\n    13,\n    15,\n    11,\n    16,\n    8,\n    16,\n    6,\n    15,\n    3,\n    13,\n    1,\n    11,\n    0,\n    8,\n    0,\n    6,\n    1,\n    4,\n    3,\n  ],\n  113: [\n    19,\n    15,\n    14,\n    15,\n    -7,\n    ,\n    15,\n    11,\n    13,\n    13,\n    11,\n    14,\n    8,\n    14,\n    6,\n    13,\n    4,\n    11,\n    3,\n    8,\n    3,\n    6,\n    4,\n    3,\n    6,\n    1,\n    8,\n    0,\n    11,\n    0,\n    13,\n    1,\n    15,\n    3,\n  ],\n  114: [13, 4, 14, 4, 0, , 4, 8, 5, 11, 7, 13, 9, 14, 12, 14],\n  115: [\n    17,\n    14,\n    11,\n    13,\n    13,\n    10,\n    14,\n    7,\n    14,\n    4,\n    13,\n    3,\n    11,\n    4,\n    9,\n    6,\n    8,\n    11,\n    7,\n    13,\n    6,\n    14,\n    4,\n    14,\n    3,\n    13,\n    1,\n    10,\n    0,\n    7,\n    0,\n    4,\n    1,\n    3,\n    3,\n  ],\n  116: [12, 5, 21, 5, 4, 6, 1, 8, 0, 10, 0, , 2, 14, 9, 14],\n  117: [19, 4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, , 15, 14, 15, 0],\n  118: [16, 2, 14, 8, 0, , 14, 14, 8, 0],\n  119: [22, 3, 14, 7, 0, , 11, 14, 7, 0, , 11, 14, 15, 0, , 19, 14, 15, 0],\n  120: [17, 3, 14, 14, 0, , 14, 14, 3, 0],\n  121: [16, 2, 14, 8, 0, , 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7],\n  122: [17, 14, 14, 3, 0, , 3, 14, 14, 14, , 3, 0, 14, 0],\n  123: [\n    14,\n    9,\n    25,\n    7,\n    24,\n    6,\n    23,\n    5,\n    21,\n    5,\n    19,\n    6,\n    17,\n    7,\n    16,\n    8,\n    14,\n    8,\n    12,\n    6,\n    10,\n    ,\n    7,\n    24,\n    6,\n    22,\n    6,\n    20,\n    7,\n    18,\n    8,\n    17,\n    9,\n    15,\n    9,\n    13,\n    8,\n    11,\n    4,\n    9,\n    8,\n    7,\n    9,\n    5,\n    9,\n    3,\n    8,\n    1,\n    7,\n    0,\n    6,\n    -2,\n    6,\n    -4,\n    7,\n    -6,\n    ,\n    6,\n    8,\n    8,\n    6,\n    8,\n    4,\n    7,\n    2,\n    6,\n    1,\n    5,\n    -1,\n    5,\n    -3,\n    6,\n    -5,\n    7,\n    -6,\n    9,\n    -7,\n  ],\n  124: [8, 4, 25, 4, -7],\n  125: [\n    14,\n    5,\n    25,\n    7,\n    24,\n    8,\n    23,\n    9,\n    21,\n    9,\n    19,\n    8,\n    17,\n    7,\n    16,\n    6,\n    14,\n    6,\n    12,\n    8,\n    10,\n    ,\n    7,\n    24,\n    8,\n    22,\n    8,\n    20,\n    7,\n    18,\n    6,\n    17,\n    5,\n    15,\n    5,\n    13,\n    6,\n    11,\n    10,\n    9,\n    6,\n    7,\n    5,\n    5,\n    5,\n    3,\n    6,\n    1,\n    7,\n    0,\n    8,\n    -2,\n    8,\n    -4,\n    7,\n    -6,\n    ,\n    8,\n    8,\n    6,\n    6,\n    6,\n    4,\n    7,\n    2,\n    8,\n    1,\n    9,\n    -1,\n    9,\n    -3,\n    8,\n    -5,\n    7,\n    -6,\n    5,\n    -7,\n  ],\n  126: [\n    24,\n    3,\n    6,\n    3,\n    8,\n    4,\n    11,\n    6,\n    12,\n    8,\n    12,\n    10,\n    11,\n    14,\n    8,\n    16,\n    7,\n    18,\n    7,\n    20,\n    8,\n    21,\n    10,\n    ,\n    3,\n    8,\n    4,\n    10,\n    6,\n    11,\n    8,\n    11,\n    10,\n    10,\n    14,\n    7,\n    16,\n    6,\n    18,\n    6,\n    20,\n    7,\n    21,\n    10,\n    21,\n    12,\n  ],\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZm9udHMvc2luZ2xlLWxpbmUvaGVyc2hleS9zaW1wbGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBpLy4vc3JjL2ZvbnRzL3NpbmdsZS1saW5lL2hlcnNoZXkvc2ltcGxleC5qcz85ZWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIC0tIGRhdGEgc291cmNlIGZyb20gZnJvbSBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZGF0YWZvcm1hdHMvaGVyc2hleS9cbi8vIC0tIHJlZHVjZWQgdG8gc2F2ZSBzb21lIGJ5dGVzLi4uXG4vLyB7IFthc2NpaSBjb2RlXTogW3dpZHRoLCB4LCB5LCAuLi5dIH0gLSB1bmRlZmluZWQgdmFsdWUgYXMgcGF0aCBzZXBhcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0ge1xuICBoZWlnaHQ6IDE0LFxuICAzMjogWzE2XSxcbiAgMzM6IFsxMCwgNSwgMjEsIDUsIDcsICwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl0sXG4gIDM0OiBbMTYsIDQsIDIxLCA0LCAxNCwgLCAxMiwgMjEsIDEyLCAxNF0sXG4gIDM1OiBbMjEsIDExLCAyNSwgNCwgLTcsICwgMTcsIDI1LCAxMCwgLTcsICwgNCwgMTIsIDE4LCAxMiwgLCAzLCA2LCAxNywgNl0sXG4gIDM2OiBbXG4gICAgMjAsXG4gICAgOCxcbiAgICAyNSxcbiAgICA4LFxuICAgIC00LFxuICAgICxcbiAgICAxMixcbiAgICAyNSxcbiAgICAxMixcbiAgICAtNCxcbiAgICAsXG4gICAgMTcsXG4gICAgMTgsXG4gICAgMTUsXG4gICAgMjAsXG4gICAgMTIsXG4gICAgMjEsXG4gICAgOCxcbiAgICAyMSxcbiAgICA1LFxuICAgIDIwLFxuICAgIDMsXG4gICAgMTgsXG4gICAgMyxcbiAgICAxNixcbiAgICA0LFxuICAgIDE0LFxuICAgIDUsXG4gICAgMTMsXG4gICAgNyxcbiAgICAxMixcbiAgICAxMyxcbiAgICAxMCxcbiAgICAxNSxcbiAgICA5LFxuICAgIDE2LFxuICAgIDgsXG4gICAgMTcsXG4gICAgNixcbiAgICAxNyxcbiAgICAzLFxuICAgIDE1LFxuICAgIDEsXG4gICAgMTIsXG4gICAgMCxcbiAgICA4LFxuICAgIDAsXG4gICAgNSxcbiAgICAxLFxuICAgIDMsXG4gICAgMyxcbiAgXSxcbiAgMzc6IFtcbiAgICAyNCxcbiAgICAyMSxcbiAgICAyMSxcbiAgICAzLFxuICAgIDAsXG4gICAgLFxuICAgIDgsXG4gICAgMjEsXG4gICAgMTAsXG4gICAgMTksXG4gICAgMTAsXG4gICAgMTcsXG4gICAgOSxcbiAgICAxNSxcbiAgICA3LFxuICAgIDE0LFxuICAgIDUsXG4gICAgMTQsXG4gICAgMyxcbiAgICAxNixcbiAgICAzLFxuICAgIDE4LFxuICAgIDQsXG4gICAgMjAsXG4gICAgNixcbiAgICAyMSxcbiAgICA4LFxuICAgIDIxLFxuICAgIDEwLFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDE5LFxuICAgIDE2LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDIwLFxuICAgIDIxLFxuICAgIDIxLFxuICAgICxcbiAgICAxNyxcbiAgICA3LFxuICAgIDE1LFxuICAgIDYsXG4gICAgMTQsXG4gICAgNCxcbiAgICAxNCxcbiAgICAyLFxuICAgIDE2LFxuICAgIDAsXG4gICAgMTgsXG4gICAgMCxcbiAgICAyMCxcbiAgICAxLFxuICAgIDIxLFxuICAgIDMsXG4gICAgMjEsXG4gICAgNSxcbiAgICAxOSxcbiAgICA3LFxuICAgIDE3LFxuICAgIDcsXG4gIF0sXG4gIDM4OiBbXG4gICAgMjYsXG4gICAgMjMsXG4gICAgMTIsXG4gICAgMjMsXG4gICAgMTMsXG4gICAgMjIsXG4gICAgMTQsXG4gICAgMjEsXG4gICAgMTQsXG4gICAgMjAsXG4gICAgMTMsXG4gICAgMTksXG4gICAgMTEsXG4gICAgMTcsXG4gICAgNixcbiAgICAxNSxcbiAgICAzLFxuICAgIDEzLFxuICAgIDEsXG4gICAgMTEsXG4gICAgMCxcbiAgICA3LFxuICAgIDAsXG4gICAgNSxcbiAgICAxLFxuICAgIDQsXG4gICAgMixcbiAgICAzLFxuICAgIDQsXG4gICAgMyxcbiAgICA2LFxuICAgIDQsXG4gICAgOCxcbiAgICA1LFxuICAgIDksXG4gICAgMTIsXG4gICAgMTMsXG4gICAgMTMsXG4gICAgMTQsXG4gICAgMTQsXG4gICAgMTYsXG4gICAgMTQsXG4gICAgMTgsXG4gICAgMTMsXG4gICAgMjAsXG4gICAgMTEsXG4gICAgMjEsXG4gICAgOSxcbiAgICAyMCxcbiAgICA4LFxuICAgIDE4LFxuICAgIDgsXG4gICAgMTYsXG4gICAgOSxcbiAgICAxMyxcbiAgICAxMSxcbiAgICAxMCxcbiAgICAxNixcbiAgICAzLFxuICAgIDE4LFxuICAgIDEsXG4gICAgMjAsXG4gICAgMCxcbiAgICAyMixcbiAgICAwLFxuICAgIDIzLFxuICAgIDEsXG4gICAgMjMsXG4gICAgMixcbiAgXSxcbiAgMzk6IFsxMCwgNSwgMTksIDQsIDIwLCA1LCAyMSwgNiwgMjAsIDYsIDE4LCA1LCAxNiwgNCwgMTVdLFxuICA0MDogW1xuICAgIDE0LFxuICAgIDExLFxuICAgIDI1LFxuICAgIDksXG4gICAgMjMsXG4gICAgNyxcbiAgICAyMCxcbiAgICA1LFxuICAgIDE2LFxuICAgIDQsXG4gICAgMTEsXG4gICAgNCxcbiAgICA3LFxuICAgIDUsXG4gICAgMixcbiAgICA3LFxuICAgIC0yLFxuICAgIDksXG4gICAgLTUsXG4gICAgMTEsXG4gICAgLTcsXG4gIF0sXG4gIDQxOiBbXG4gICAgMTQsXG4gICAgMyxcbiAgICAyNSxcbiAgICA1LFxuICAgIDIzLFxuICAgIDcsXG4gICAgMjAsXG4gICAgOSxcbiAgICAxNixcbiAgICAxMCxcbiAgICAxMSxcbiAgICAxMCxcbiAgICA3LFxuICAgIDksXG4gICAgMixcbiAgICA3LFxuICAgIC0yLFxuICAgIDUsXG4gICAgLTUsXG4gICAgMyxcbiAgICAtNyxcbiAgXSxcbiAgNDI6IFsxNiwgOCwgMjEsIDgsIDksICwgMywgMTgsIDEzLCAxMiwgLCAxMywgMTgsIDMsIDEyXSxcbiAgNDM6IFsyNiwgMTMsIDE4LCAxMywgMCwgLCA0LCA5LCAyMiwgOV0sXG4gIDQ0OiBbMTAsIDYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdLFxuICA0NTogWzI2LCA0LCA5LCAyMiwgOV0sXG4gIDQ2OiBbMTAsIDUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdLFxuICA0NzogWzIyLCAyMCwgMjUsIDIsIC03XSxcbiAgNDg6IFtcbiAgICAyMCxcbiAgICA5LFxuICAgIDIxLFxuICAgIDYsXG4gICAgMjAsXG4gICAgNCxcbiAgICAxNyxcbiAgICAzLFxuICAgIDEyLFxuICAgIDMsXG4gICAgOSxcbiAgICA0LFxuICAgIDQsXG4gICAgNixcbiAgICAxLFxuICAgIDksXG4gICAgMCxcbiAgICAxMSxcbiAgICAwLFxuICAgIDE0LFxuICAgIDEsXG4gICAgMTYsXG4gICAgNCxcbiAgICAxNyxcbiAgICA5LFxuICAgIDE3LFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDE3LFxuICAgIDE0LFxuICAgIDIwLFxuICAgIDExLFxuICAgIDIxLFxuICAgIDksXG4gICAgMjEsXG4gIF0sXG4gIDQ5OiBbMjAsIDYsIDE3LCA4LCAxOCwgMTEsIDIxLCAxMSwgMF0sXG4gIDUwOiBbXG4gICAgMjAsXG4gICAgNCxcbiAgICAxNixcbiAgICA0LFxuICAgIDE3LFxuICAgIDUsXG4gICAgMTksXG4gICAgNixcbiAgICAyMCxcbiAgICA4LFxuICAgIDIxLFxuICAgIDEyLFxuICAgIDIxLFxuICAgIDE0LFxuICAgIDIwLFxuICAgIDE1LFxuICAgIDE5LFxuICAgIDE2LFxuICAgIDE3LFxuICAgIDE2LFxuICAgIDE1LFxuICAgIDE1LFxuICAgIDEzLFxuICAgIDEzLFxuICAgIDEwLFxuICAgIDMsXG4gICAgMCxcbiAgICAxNyxcbiAgICAwLFxuICBdLFxuICA1MTogW1xuICAgIDIwLFxuICAgIDUsXG4gICAgMjEsXG4gICAgMTYsXG4gICAgMjEsXG4gICAgMTAsXG4gICAgMTMsXG4gICAgMTMsXG4gICAgMTMsXG4gICAgMTUsXG4gICAgMTIsXG4gICAgMTYsXG4gICAgMTEsXG4gICAgMTcsXG4gICAgOCxcbiAgICAxNyxcbiAgICA2LFxuICAgIDE2LFxuICAgIDMsXG4gICAgMTQsXG4gICAgMSxcbiAgICAxMSxcbiAgICAwLFxuICAgIDgsXG4gICAgMCxcbiAgICA1LFxuICAgIDEsXG4gICAgNCxcbiAgICAyLFxuICAgIDMsXG4gICAgNCxcbiAgXSxcbiAgNTI6IFsyMCwgMTMsIDIxLCAzLCA3LCAxOCwgNywgLCAxMywgMjEsIDEzLCAwXSxcbiAgNTM6IFtcbiAgICAyMCxcbiAgICAxNSxcbiAgICAyMSxcbiAgICA1LFxuICAgIDIxLFxuICAgIDQsXG4gICAgMTIsXG4gICAgNSxcbiAgICAxMyxcbiAgICA4LFxuICAgIDE0LFxuICAgIDExLFxuICAgIDE0LFxuICAgIDE0LFxuICAgIDEzLFxuICAgIDE2LFxuICAgIDExLFxuICAgIDE3LFxuICAgIDgsXG4gICAgMTcsXG4gICAgNixcbiAgICAxNixcbiAgICAzLFxuICAgIDE0LFxuICAgIDEsXG4gICAgMTEsXG4gICAgMCxcbiAgICA4LFxuICAgIDAsXG4gICAgNSxcbiAgICAxLFxuICAgIDQsXG4gICAgMixcbiAgICAzLFxuICAgIDQsXG4gIF0sXG4gIDU0OiBbXG4gICAgMjAsXG4gICAgMTYsXG4gICAgMTgsXG4gICAgMTUsXG4gICAgMjAsXG4gICAgMTIsXG4gICAgMjEsXG4gICAgMTAsXG4gICAgMjEsXG4gICAgNyxcbiAgICAyMCxcbiAgICA1LFxuICAgIDE3LFxuICAgIDQsXG4gICAgMTIsXG4gICAgNCxcbiAgICA3LFxuICAgIDUsXG4gICAgMyxcbiAgICA3LFxuICAgIDEsXG4gICAgMTAsXG4gICAgMCxcbiAgICAxMSxcbiAgICAwLFxuICAgIDE0LFxuICAgIDEsXG4gICAgMTYsXG4gICAgMyxcbiAgICAxNyxcbiAgICA2LFxuICAgIDE3LFxuICAgIDcsXG4gICAgMTYsXG4gICAgMTAsXG4gICAgMTQsXG4gICAgMTIsXG4gICAgMTEsXG4gICAgMTMsXG4gICAgMTAsXG4gICAgMTMsXG4gICAgNyxcbiAgICAxMixcbiAgICA1LFxuICAgIDEwLFxuICAgIDQsXG4gICAgNyxcbiAgXSxcbiAgNTU6IFsyMCwgMTcsIDIxLCA3LCAwLCAsIDMsIDIxLCAxNywgMjFdLFxuICA1NjogW1xuICAgIDIwLFxuICAgIDgsXG4gICAgMjEsXG4gICAgNSxcbiAgICAyMCxcbiAgICA0LFxuICAgIDE4LFxuICAgIDQsXG4gICAgMTYsXG4gICAgNSxcbiAgICAxNCxcbiAgICA3LFxuICAgIDEzLFxuICAgIDExLFxuICAgIDEyLFxuICAgIDE0LFxuICAgIDExLFxuICAgIDE2LFxuICAgIDksXG4gICAgMTcsXG4gICAgNyxcbiAgICAxNyxcbiAgICA0LFxuICAgIDE2LFxuICAgIDIsXG4gICAgMTUsXG4gICAgMSxcbiAgICAxMixcbiAgICAwLFxuICAgIDgsXG4gICAgMCxcbiAgICA1LFxuICAgIDEsXG4gICAgNCxcbiAgICAyLFxuICAgIDMsXG4gICAgNCxcbiAgICAzLFxuICAgIDcsXG4gICAgNCxcbiAgICA5LFxuICAgIDYsXG4gICAgMTEsXG4gICAgOSxcbiAgICAxMixcbiAgICAxMyxcbiAgICAxMyxcbiAgICAxNSxcbiAgICAxNCxcbiAgICAxNixcbiAgICAxNixcbiAgICAxNixcbiAgICAxOCxcbiAgICAxNSxcbiAgICAyMCxcbiAgICAxMixcbiAgICAyMSxcbiAgICA4LFxuICAgIDIxLFxuICBdLFxuICA1NzogW1xuICAgIDIwLFxuICAgIDE2LFxuICAgIDE0LFxuICAgIDE1LFxuICAgIDExLFxuICAgIDEzLFxuICAgIDksXG4gICAgMTAsXG4gICAgOCxcbiAgICA5LFxuICAgIDgsXG4gICAgNixcbiAgICA5LFxuICAgIDQsXG4gICAgMTEsXG4gICAgMyxcbiAgICAxNCxcbiAgICAzLFxuICAgIDE1LFxuICAgIDQsXG4gICAgMTgsXG4gICAgNixcbiAgICAyMCxcbiAgICA5LFxuICAgIDIxLFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDEzLFxuICAgIDIwLFxuICAgIDE1LFxuICAgIDE4LFxuICAgIDE2LFxuICAgIDE0LFxuICAgIDE2LFxuICAgIDksXG4gICAgMTUsXG4gICAgNCxcbiAgICAxMyxcbiAgICAxLFxuICAgIDEwLFxuICAgIDAsXG4gICAgOCxcbiAgICAwLFxuICAgIDUsXG4gICAgMSxcbiAgICA0LFxuICAgIDMsXG4gIF0sXG4gIDU4OiBbMTAsIDUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXSxcbiAgNTk6IFtcbiAgICAxMCxcbiAgICA1LFxuICAgIDE0LFxuICAgIDQsXG4gICAgMTMsXG4gICAgNSxcbiAgICAxMixcbiAgICA2LFxuICAgIDEzLFxuICAgIDUsXG4gICAgMTQsXG4gICAgLFxuICAgIDYsXG4gICAgMSxcbiAgICA1LFxuICAgIDAsXG4gICAgNCxcbiAgICAxLFxuICAgIDUsXG4gICAgMixcbiAgICA2LFxuICAgIDEsXG4gICAgNixcbiAgICAtMSxcbiAgICA1LFxuICAgIC0zLFxuICAgIDQsXG4gICAgLTQsXG4gIF0sXG4gIDYwOiBbMjQsIDIwLCAxOCwgNCwgOSwgMjAsIDBdLFxuICA2MTogWzI2LCA0LCAxMiwgMjIsIDEyLCAsIDQsIDYsIDIyLCA2XSxcbiAgNjI6IFsyNCwgNCwgMTgsIDIwLCA5LCA0LCAwXSxcbiAgNjM6IFtcbiAgICAxOCxcbiAgICAzLFxuICAgIDE2LFxuICAgIDMsXG4gICAgMTcsXG4gICAgNCxcbiAgICAxOSxcbiAgICA1LFxuICAgIDIwLFxuICAgIDcsXG4gICAgMjEsXG4gICAgMTEsXG4gICAgMjEsXG4gICAgMTMsXG4gICAgMjAsXG4gICAgMTQsXG4gICAgMTksXG4gICAgMTUsXG4gICAgMTcsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgMTQsXG4gICAgMTMsXG4gICAgMTMsXG4gICAgMTIsXG4gICAgOSxcbiAgICAxMCxcbiAgICA5LFxuICAgIDcsXG4gICAgLFxuICAgIDksXG4gICAgMixcbiAgICA4LFxuICAgIDEsXG4gICAgOSxcbiAgICAwLFxuICAgIDEwLFxuICAgIDEsXG4gICAgOSxcbiAgICAyLFxuICBdLFxuICA2NDogW1xuICAgIDI3LFxuICAgIDE4LFxuICAgIDEzLFxuICAgIDE3LFxuICAgIDE1LFxuICAgIDE1LFxuICAgIDE2LFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEwLFxuICAgIDE1LFxuICAgIDksXG4gICAgMTQsXG4gICAgOCxcbiAgICAxMSxcbiAgICA4LFxuICAgIDgsXG4gICAgOSxcbiAgICA2LFxuICAgIDExLFxuICAgIDUsXG4gICAgMTQsXG4gICAgNSxcbiAgICAxNixcbiAgICA2LFxuICAgIDE3LFxuICAgIDgsXG4gICAgLFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEwLFxuICAgIDE0LFxuICAgIDksXG4gICAgMTEsXG4gICAgOSxcbiAgICA4LFxuICAgIDEwLFxuICAgIDYsXG4gICAgMTEsXG4gICAgNSxcbiAgICAsXG4gICAgMTgsXG4gICAgMTYsXG4gICAgMTcsXG4gICAgOCxcbiAgICAxNyxcbiAgICA2LFxuICAgIDE5LFxuICAgIDUsXG4gICAgMjEsXG4gICAgNSxcbiAgICAyMyxcbiAgICA3LFxuICAgIDI0LFxuICAgIDEwLFxuICAgIDI0LFxuICAgIDEyLFxuICAgIDIzLFxuICAgIDE1LFxuICAgIDIyLFxuICAgIDE3LFxuICAgIDIwLFxuICAgIDE5LFxuICAgIDE4LFxuICAgIDIwLFxuICAgIDE1LFxuICAgIDIxLFxuICAgIDEyLFxuICAgIDIxLFxuICAgIDksXG4gICAgMjAsXG4gICAgNyxcbiAgICAxOSxcbiAgICA1LFxuICAgIDE3LFxuICAgIDQsXG4gICAgMTUsXG4gICAgMyxcbiAgICAxMixcbiAgICAzLFxuICAgIDksXG4gICAgNCxcbiAgICA2LFxuICAgIDUsXG4gICAgNCxcbiAgICA3LFxuICAgIDIsXG4gICAgOSxcbiAgICAxLFxuICAgIDEyLFxuICAgIDAsXG4gICAgMTUsXG4gICAgMCxcbiAgICAxOCxcbiAgICAxLFxuICAgIDIwLFxuICAgIDIsXG4gICAgMjEsXG4gICAgMyxcbiAgICAsXG4gICAgMTksXG4gICAgMTYsXG4gICAgMTgsXG4gICAgOCxcbiAgICAxOCxcbiAgICA2LFxuICAgIDE5LFxuICAgIDUsXG4gIF0sXG4gIDY1OiBbMTgsIDksIDIxLCAxLCAwLCAsIDksIDIxLCAxNywgMCwgLCA0LCA3LCAxNCwgN10sXG4gIDY2OiBbXG4gICAgMjEsXG4gICAgNCxcbiAgICAyMSxcbiAgICA0LFxuICAgIDAsXG4gICAgLFxuICAgIDQsXG4gICAgMjEsXG4gICAgMTMsXG4gICAgMjEsXG4gICAgMTYsXG4gICAgMjAsXG4gICAgMTcsXG4gICAgMTksXG4gICAgMTgsXG4gICAgMTcsXG4gICAgMTgsXG4gICAgMTUsXG4gICAgMTcsXG4gICAgMTMsXG4gICAgMTYsXG4gICAgMTIsXG4gICAgMTMsXG4gICAgMTEsXG4gICAgLFxuICAgIDQsXG4gICAgMTEsXG4gICAgMTMsXG4gICAgMTEsXG4gICAgMTYsXG4gICAgMTAsXG4gICAgMTcsXG4gICAgOSxcbiAgICAxOCxcbiAgICA3LFxuICAgIDE4LFxuICAgIDQsXG4gICAgMTcsXG4gICAgMixcbiAgICAxNixcbiAgICAxLFxuICAgIDEzLFxuICAgIDAsXG4gICAgNCxcbiAgICAwLFxuICBdLFxuICA2NzogW1xuICAgIDIxLFxuICAgIDE4LFxuICAgIDE2LFxuICAgIDE3LFxuICAgIDE4LFxuICAgIDE1LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDIxLFxuICAgIDksXG4gICAgMjEsXG4gICAgNyxcbiAgICAyMCxcbiAgICA1LFxuICAgIDE4LFxuICAgIDQsXG4gICAgMTYsXG4gICAgMyxcbiAgICAxMyxcbiAgICAzLFxuICAgIDgsXG4gICAgNCxcbiAgICA1LFxuICAgIDUsXG4gICAgMyxcbiAgICA3LFxuICAgIDEsXG4gICAgOSxcbiAgICAwLFxuICAgIDEzLFxuICAgIDAsXG4gICAgMTUsXG4gICAgMSxcbiAgICAxNyxcbiAgICAzLFxuICAgIDE4LFxuICAgIDUsXG4gIF0sXG4gIDY4OiBbXG4gICAgMjEsXG4gICAgNCxcbiAgICAyMSxcbiAgICA0LFxuICAgIDAsXG4gICAgLFxuICAgIDQsXG4gICAgMjEsXG4gICAgMTEsXG4gICAgMjEsXG4gICAgMTQsXG4gICAgMjAsXG4gICAgMTYsXG4gICAgMTgsXG4gICAgMTcsXG4gICAgMTYsXG4gICAgMTgsXG4gICAgMTMsXG4gICAgMTgsXG4gICAgOCxcbiAgICAxNyxcbiAgICA1LFxuICAgIDE2LFxuICAgIDMsXG4gICAgMTQsXG4gICAgMSxcbiAgICAxMSxcbiAgICAwLFxuICAgIDQsXG4gICAgMCxcbiAgXSxcbiAgNjk6IFsxOSwgNCwgMjEsIDQsIDAsICwgNCwgMjEsIDE3LCAyMSwgLCA0LCAxMSwgMTIsIDExLCAsIDQsIDAsIDE3LCAwXSxcbiAgNzA6IFsxOCwgNCwgMjEsIDQsIDAsICwgNCwgMjEsIDE3LCAyMSwgLCA0LCAxMSwgMTIsIDExXSxcbiAgNzE6IFtcbiAgICAyMSxcbiAgICAxOCxcbiAgICAxNixcbiAgICAxNyxcbiAgICAxOCxcbiAgICAxNSxcbiAgICAyMCxcbiAgICAxMyxcbiAgICAyMSxcbiAgICA5LFxuICAgIDIxLFxuICAgIDcsXG4gICAgMjAsXG4gICAgNSxcbiAgICAxOCxcbiAgICA0LFxuICAgIDE2LFxuICAgIDMsXG4gICAgMTMsXG4gICAgMyxcbiAgICA4LFxuICAgIDQsXG4gICAgNSxcbiAgICA1LFxuICAgIDMsXG4gICAgNyxcbiAgICAxLFxuICAgIDksXG4gICAgMCxcbiAgICAxMyxcbiAgICAwLFxuICAgIDE1LFxuICAgIDEsXG4gICAgMTcsXG4gICAgMyxcbiAgICAxOCxcbiAgICA1LFxuICAgIDE4LFxuICAgIDgsXG4gICAgLFxuICAgIDEzLFxuICAgIDgsXG4gICAgMTgsXG4gICAgOCxcbiAgXSxcbiAgNzI6IFsyMiwgNCwgMjEsIDQsIDAsICwgMTgsIDIxLCAxOCwgMCwgLCA0LCAxMSwgMTgsIDExXSxcbiAgNzM6IFs4LCA0LCAyMSwgNCwgMF0sXG4gIDc0OiBbMTYsIDEyLCAyMSwgMTIsIDUsIDExLCAyLCAxMCwgMSwgOCwgMCwgNiwgMCwgNCwgMSwgMywgMiwgMiwgNSwgMiwgN10sXG4gIDc1OiBbMjEsIDQsIDIxLCA0LCAwLCAsIDE4LCAyMSwgNCwgNywgLCA5LCAxMiwgMTgsIDBdLFxuICA3NjogWzE3LCA0LCAyMSwgNCwgMCwgLCA0LCAwLCAxNiwgMF0sXG4gIDc3OiBbMjQsIDQsIDIxLCA0LCAwLCAsIDQsIDIxLCAxMiwgMCwgLCAyMCwgMjEsIDEyLCAwLCAsIDIwLCAyMSwgMjAsIDBdLFxuICA3ODogWzIyLCA0LCAyMSwgNCwgMCwgLCA0LCAyMSwgMTgsIDAsICwgMTgsIDIxLCAxOCwgMF0sXG4gIDc5OiBbXG4gICAgMjIsXG4gICAgOSxcbiAgICAyMSxcbiAgICA3LFxuICAgIDIwLFxuICAgIDUsXG4gICAgMTgsXG4gICAgNCxcbiAgICAxNixcbiAgICAzLFxuICAgIDEzLFxuICAgIDMsXG4gICAgOCxcbiAgICA0LFxuICAgIDUsXG4gICAgNSxcbiAgICAzLFxuICAgIDcsXG4gICAgMSxcbiAgICA5LFxuICAgIDAsXG4gICAgMTMsXG4gICAgMCxcbiAgICAxNSxcbiAgICAxLFxuICAgIDE3LFxuICAgIDMsXG4gICAgMTgsXG4gICAgNSxcbiAgICAxOSxcbiAgICA4LFxuICAgIDE5LFxuICAgIDEzLFxuICAgIDE4LFxuICAgIDE2LFxuICAgIDE3LFxuICAgIDE4LFxuICAgIDE1LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDIxLFxuICAgIDksXG4gICAgMjEsXG4gIF0sXG4gIDgwOiBbXG4gICAgMjEsXG4gICAgNCxcbiAgICAyMSxcbiAgICA0LFxuICAgIDAsXG4gICAgLFxuICAgIDQsXG4gICAgMjEsXG4gICAgMTMsXG4gICAgMjEsXG4gICAgMTYsXG4gICAgMjAsXG4gICAgMTcsXG4gICAgMTksXG4gICAgMTgsXG4gICAgMTcsXG4gICAgMTgsXG4gICAgMTQsXG4gICAgMTcsXG4gICAgMTIsXG4gICAgMTYsXG4gICAgMTEsXG4gICAgMTMsXG4gICAgMTAsXG4gICAgNCxcbiAgICAxMCxcbiAgXSxcbiAgODE6IFtcbiAgICAyMixcbiAgICA5LFxuICAgIDIxLFxuICAgIDcsXG4gICAgMjAsXG4gICAgNSxcbiAgICAxOCxcbiAgICA0LFxuICAgIDE2LFxuICAgIDMsXG4gICAgMTMsXG4gICAgMyxcbiAgICA4LFxuICAgIDQsXG4gICAgNSxcbiAgICA1LFxuICAgIDMsXG4gICAgNyxcbiAgICAxLFxuICAgIDksXG4gICAgMCxcbiAgICAxMyxcbiAgICAwLFxuICAgIDE1LFxuICAgIDEsXG4gICAgMTcsXG4gICAgMyxcbiAgICAxOCxcbiAgICA1LFxuICAgIDE5LFxuICAgIDgsXG4gICAgMTksXG4gICAgMTMsXG4gICAgMTgsXG4gICAgMTYsXG4gICAgMTcsXG4gICAgMTgsXG4gICAgMTUsXG4gICAgMjAsXG4gICAgMTMsXG4gICAgMjEsXG4gICAgOSxcbiAgICAyMSxcbiAgICAsXG4gICAgMTIsXG4gICAgNCxcbiAgICAxOCxcbiAgICAtMixcbiAgXSxcbiAgODI6IFtcbiAgICAyMSxcbiAgICA0LFxuICAgIDIxLFxuICAgIDQsXG4gICAgMCxcbiAgICAsXG4gICAgNCxcbiAgICAyMSxcbiAgICAxMyxcbiAgICAyMSxcbiAgICAxNixcbiAgICAyMCxcbiAgICAxNyxcbiAgICAxOSxcbiAgICAxOCxcbiAgICAxNyxcbiAgICAxOCxcbiAgICAxNSxcbiAgICAxNyxcbiAgICAxMyxcbiAgICAxNixcbiAgICAxMixcbiAgICAxMyxcbiAgICAxMSxcbiAgICA0LFxuICAgIDExLFxuICAgICxcbiAgICAxMSxcbiAgICAxMSxcbiAgICAxOCxcbiAgICAwLFxuICBdLFxuICA4MzogW1xuICAgIDIwLFxuICAgIDE3LFxuICAgIDE4LFxuICAgIDE1LFxuICAgIDIwLFxuICAgIDEyLFxuICAgIDIxLFxuICAgIDgsXG4gICAgMjEsXG4gICAgNSxcbiAgICAyMCxcbiAgICAzLFxuICAgIDE4LFxuICAgIDMsXG4gICAgMTYsXG4gICAgNCxcbiAgICAxNCxcbiAgICA1LFxuICAgIDEzLFxuICAgIDcsXG4gICAgMTIsXG4gICAgMTMsXG4gICAgMTAsXG4gICAgMTUsXG4gICAgOSxcbiAgICAxNixcbiAgICA4LFxuICAgIDE3LFxuICAgIDYsXG4gICAgMTcsXG4gICAgMyxcbiAgICAxNSxcbiAgICAxLFxuICAgIDEyLFxuICAgIDAsXG4gICAgOCxcbiAgICAwLFxuICAgIDUsXG4gICAgMSxcbiAgICAzLFxuICAgIDMsXG4gIF0sXG4gIDg0OiBbMTYsIDgsIDIxLCA4LCAwLCAsIDEsIDIxLCAxNSwgMjFdLFxuICA4NTogWzIyLCA0LCAyMSwgNCwgNiwgNSwgMywgNywgMSwgMTAsIDAsIDEyLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA2LCAxOCwgMjFdLFxuICA4NjogWzE4LCAxLCAyMSwgOSwgMCwgLCAxNywgMjEsIDksIDBdLFxuICA4NzogWzI0LCAyLCAyMSwgNywgMCwgLCAxMiwgMjEsIDcsIDAsICwgMTIsIDIxLCAxNywgMCwgLCAyMiwgMjEsIDE3LCAwXSxcbiAgODg6IFsyMCwgMywgMjEsIDE3LCAwLCAsIDE3LCAyMSwgMywgMF0sXG4gIDg5OiBbMTgsIDEsIDIxLCA5LCAxMSwgOSwgMCwgLCAxNywgMjEsIDksIDExXSxcbiAgOTA6IFsyMCwgMTcsIDIxLCAzLCAwLCAsIDMsIDIxLCAxNywgMjEsICwgMywgMCwgMTcsIDBdLFxuICA5MTogWzE0LCA0LCAyNSwgNCwgLTcsICwgNSwgMjUsIDUsIC03LCAsIDQsIDI1LCAxMSwgMjUsICwgNCwgLTcsIDExLCAtN10sXG4gIDkyOiBbMTQsIDAsIDIxLCAxNCwgLTNdLFxuICA5MzogWzE0LCA5LCAyNSwgOSwgLTcsICwgMTAsIDI1LCAxMCwgLTcsICwgMywgMjUsIDEwLCAyNSwgLCAzLCAtNywgMTAsIC03XSxcbiAgOTQ6IFsxNiwgNiwgMTUsIDgsIDE4LCAxMCwgMTUsICwgMywgMTIsIDgsIDE3LCAxMywgMTIsICwgOCwgMTcsIDgsIDBdLFxuICA5NTogWzE2LCAwLCAtMiwgMTYsIC0yXSxcbiAgOTY6IFsxMCwgNiwgMjEsIDUsIDIwLCA0LCAxOCwgNCwgMTYsIDUsIDE1LCA2LCAxNiwgNSwgMTddLFxuICA5NzogW1xuICAgIDE5LFxuICAgIDE1LFxuICAgIDE0LFxuICAgIDE1LFxuICAgIDAsXG4gICAgLFxuICAgIDE1LFxuICAgIDExLFxuICAgIDEzLFxuICAgIDEzLFxuICAgIDExLFxuICAgIDE0LFxuICAgIDgsXG4gICAgMTQsXG4gICAgNixcbiAgICAxMyxcbiAgICA0LFxuICAgIDExLFxuICAgIDMsXG4gICAgOCxcbiAgICAzLFxuICAgIDYsXG4gICAgNCxcbiAgICAzLFxuICAgIDYsXG4gICAgMSxcbiAgICA4LFxuICAgIDAsXG4gICAgMTEsXG4gICAgMCxcbiAgICAxMyxcbiAgICAxLFxuICAgIDE1LFxuICAgIDMsXG4gIF0sXG4gIDk4OiBbXG4gICAgMTksXG4gICAgNCxcbiAgICAyMSxcbiAgICA0LFxuICAgIDAsXG4gICAgLFxuICAgIDQsXG4gICAgMTEsXG4gICAgNixcbiAgICAxMyxcbiAgICA4LFxuICAgIDE0LFxuICAgIDExLFxuICAgIDE0LFxuICAgIDEzLFxuICAgIDEzLFxuICAgIDE1LFxuICAgIDExLFxuICAgIDE2LFxuICAgIDgsXG4gICAgMTYsXG4gICAgNixcbiAgICAxNSxcbiAgICAzLFxuICAgIDEzLFxuICAgIDEsXG4gICAgMTEsXG4gICAgMCxcbiAgICA4LFxuICAgIDAsXG4gICAgNixcbiAgICAxLFxuICAgIDQsXG4gICAgMyxcbiAgXSxcbiAgOTk6IFtcbiAgICAxOCxcbiAgICAxNSxcbiAgICAxMSxcbiAgICAxMyxcbiAgICAxMyxcbiAgICAxMSxcbiAgICAxNCxcbiAgICA4LFxuICAgIDE0LFxuICAgIDYsXG4gICAgMTMsXG4gICAgNCxcbiAgICAxMSxcbiAgICAzLFxuICAgIDgsXG4gICAgMyxcbiAgICA2LFxuICAgIDQsXG4gICAgMyxcbiAgICA2LFxuICAgIDEsXG4gICAgOCxcbiAgICAwLFxuICAgIDExLFxuICAgIDAsXG4gICAgMTMsXG4gICAgMSxcbiAgICAxNSxcbiAgICAzLFxuICBdLFxuICAxMDA6IFtcbiAgICAxOSxcbiAgICAxNSxcbiAgICAyMSxcbiAgICAxNSxcbiAgICAwLFxuICAgICxcbiAgICAxNSxcbiAgICAxMSxcbiAgICAxMyxcbiAgICAxMyxcbiAgICAxMSxcbiAgICAxNCxcbiAgICA4LFxuICAgIDE0LFxuICAgIDYsXG4gICAgMTMsXG4gICAgNCxcbiAgICAxMSxcbiAgICAzLFxuICAgIDgsXG4gICAgMyxcbiAgICA2LFxuICAgIDQsXG4gICAgMyxcbiAgICA2LFxuICAgIDEsXG4gICAgOCxcbiAgICAwLFxuICAgIDExLFxuICAgIDAsXG4gICAgMTMsXG4gICAgMSxcbiAgICAxNSxcbiAgICAzLFxuICBdLFxuICAxMDE6IFtcbiAgICAxOCxcbiAgICAzLFxuICAgIDgsXG4gICAgMTUsXG4gICAgOCxcbiAgICAxNSxcbiAgICAxMCxcbiAgICAxNCxcbiAgICAxMixcbiAgICAxMyxcbiAgICAxMyxcbiAgICAxMSxcbiAgICAxNCxcbiAgICA4LFxuICAgIDE0LFxuICAgIDYsXG4gICAgMTMsXG4gICAgNCxcbiAgICAxMSxcbiAgICAzLFxuICAgIDgsXG4gICAgMyxcbiAgICA2LFxuICAgIDQsXG4gICAgMyxcbiAgICA2LFxuICAgIDEsXG4gICAgOCxcbiAgICAwLFxuICAgIDExLFxuICAgIDAsXG4gICAgMTMsXG4gICAgMSxcbiAgICAxNSxcbiAgICAzLFxuICBdLFxuICAxMDI6IFsxMiwgMTAsIDIxLCA4LCAyMSwgNiwgMjAsIDUsIDE3LCA1LCAwLCAsIDIsIDE0LCA5LCAxNF0sXG4gIDEwMzogW1xuICAgIDE5LFxuICAgIDE1LFxuICAgIDE0LFxuICAgIDE1LFxuICAgIC0yLFxuICAgIDE0LFxuICAgIC01LFxuICAgIDEzLFxuICAgIC02LFxuICAgIDExLFxuICAgIC03LFxuICAgIDgsXG4gICAgLTcsXG4gICAgNixcbiAgICAtNixcbiAgICAsXG4gICAgMTUsXG4gICAgMTEsXG4gICAgMTMsXG4gICAgMTMsXG4gICAgMTEsXG4gICAgMTQsXG4gICAgOCxcbiAgICAxNCxcbiAgICA2LFxuICAgIDEzLFxuICAgIDQsXG4gICAgMTEsXG4gICAgMyxcbiAgICA4LFxuICAgIDMsXG4gICAgNixcbiAgICA0LFxuICAgIDMsXG4gICAgNixcbiAgICAxLFxuICAgIDgsXG4gICAgMCxcbiAgICAxMSxcbiAgICAwLFxuICAgIDEzLFxuICAgIDEsXG4gICAgMTUsXG4gICAgMyxcbiAgXSxcbiAgMTA0OiBbMTksIDQsIDIxLCA0LCAwLCAsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXSxcbiAgMTA1OiBbOCwgMywgMjEsIDQsIDIwLCA1LCAyMSwgNCwgMjIsIDMsIDIxLCAsIDQsIDE0LCA0LCAwXSxcbiAgMTA2OiBbXG4gICAgMTAsXG4gICAgNSxcbiAgICAyMSxcbiAgICA2LFxuICAgIDIwLFxuICAgIDcsXG4gICAgMjEsXG4gICAgNixcbiAgICAyMixcbiAgICA1LFxuICAgIDIxLFxuICAgICxcbiAgICA2LFxuICAgIDE0LFxuICAgIDYsXG4gICAgLTMsXG4gICAgNSxcbiAgICAtNixcbiAgICAzLFxuICAgIC03LFxuICAgIDEsXG4gICAgLTcsXG4gIF0sXG4gIDEwNzogWzE3LCA0LCAyMSwgNCwgMCwgLCAxNCwgMTQsIDQsIDQsICwgOCwgOCwgMTUsIDBdLFxuICAxMDg6IFs4LCA0LCAyMSwgNCwgMF0sXG4gIDEwOTogW1xuICAgIDMwLFxuICAgIDQsXG4gICAgMTQsXG4gICAgNCxcbiAgICAwLFxuICAgICxcbiAgICA0LFxuICAgIDEwLFxuICAgIDcsXG4gICAgMTMsXG4gICAgOSxcbiAgICAxNCxcbiAgICAxMixcbiAgICAxNCxcbiAgICAxNCxcbiAgICAxMyxcbiAgICAxNSxcbiAgICAxMCxcbiAgICAxNSxcbiAgICAwLFxuICAgICxcbiAgICAxNSxcbiAgICAxMCxcbiAgICAxOCxcbiAgICAxMyxcbiAgICAyMCxcbiAgICAxNCxcbiAgICAyMyxcbiAgICAxNCxcbiAgICAyNSxcbiAgICAxMyxcbiAgICAyNixcbiAgICAxMCxcbiAgICAyNixcbiAgICAwLFxuICBdLFxuICAxMTA6IFsxOSwgNCwgMTQsIDQsIDAsICwgNCwgMTAsIDcsIDEzLCA5LCAxNCwgMTIsIDE0LCAxNCwgMTMsIDE1LCAxMCwgMTUsIDBdLFxuICAxMTE6IFtcbiAgICAxOSxcbiAgICA4LFxuICAgIDE0LFxuICAgIDYsXG4gICAgMTMsXG4gICAgNCxcbiAgICAxMSxcbiAgICAzLFxuICAgIDgsXG4gICAgMyxcbiAgICA2LFxuICAgIDQsXG4gICAgMyxcbiAgICA2LFxuICAgIDEsXG4gICAgOCxcbiAgICAwLFxuICAgIDExLFxuICAgIDAsXG4gICAgMTMsXG4gICAgMSxcbiAgICAxNSxcbiAgICAzLFxuICAgIDE2LFxuICAgIDYsXG4gICAgMTYsXG4gICAgOCxcbiAgICAxNSxcbiAgICAxMSxcbiAgICAxMyxcbiAgICAxMyxcbiAgICAxMSxcbiAgICAxNCxcbiAgICA4LFxuICAgIDE0LFxuICBdLFxuICAxMTI6IFtcbiAgICAxOSxcbiAgICA0LFxuICAgIDE0LFxuICAgIDQsXG4gICAgLTcsXG4gICAgLFxuICAgIDQsXG4gICAgMTEsXG4gICAgNixcbiAgICAxMyxcbiAgICA4LFxuICAgIDE0LFxuICAgIDExLFxuICAgIDE0LFxuICAgIDEzLFxuICAgIDEzLFxuICAgIDE1LFxuICAgIDExLFxuICAgIDE2LFxuICAgIDgsXG4gICAgMTYsXG4gICAgNixcbiAgICAxNSxcbiAgICAzLFxuICAgIDEzLFxuICAgIDEsXG4gICAgMTEsXG4gICAgMCxcbiAgICA4LFxuICAgIDAsXG4gICAgNixcbiAgICAxLFxuICAgIDQsXG4gICAgMyxcbiAgXSxcbiAgMTEzOiBbXG4gICAgMTksXG4gICAgMTUsXG4gICAgMTQsXG4gICAgMTUsXG4gICAgLTcsXG4gICAgLFxuICAgIDE1LFxuICAgIDExLFxuICAgIDEzLFxuICAgIDEzLFxuICAgIDExLFxuICAgIDE0LFxuICAgIDgsXG4gICAgMTQsXG4gICAgNixcbiAgICAxMyxcbiAgICA0LFxuICAgIDExLFxuICAgIDMsXG4gICAgOCxcbiAgICAzLFxuICAgIDYsXG4gICAgNCxcbiAgICAzLFxuICAgIDYsXG4gICAgMSxcbiAgICA4LFxuICAgIDAsXG4gICAgMTEsXG4gICAgMCxcbiAgICAxMyxcbiAgICAxLFxuICAgIDE1LFxuICAgIDMsXG4gIF0sXG4gIDExNDogWzEzLCA0LCAxNCwgNCwgMCwgLCA0LCA4LCA1LCAxMSwgNywgMTMsIDksIDE0LCAxMiwgMTRdLFxuICAxMTU6IFtcbiAgICAxNyxcbiAgICAxNCxcbiAgICAxMSxcbiAgICAxMyxcbiAgICAxMyxcbiAgICAxMCxcbiAgICAxNCxcbiAgICA3LFxuICAgIDE0LFxuICAgIDQsXG4gICAgMTMsXG4gICAgMyxcbiAgICAxMSxcbiAgICA0LFxuICAgIDksXG4gICAgNixcbiAgICA4LFxuICAgIDExLFxuICAgIDcsXG4gICAgMTMsXG4gICAgNixcbiAgICAxNCxcbiAgICA0LFxuICAgIDE0LFxuICAgIDMsXG4gICAgMTMsXG4gICAgMSxcbiAgICAxMCxcbiAgICAwLFxuICAgIDcsXG4gICAgMCxcbiAgICA0LFxuICAgIDEsXG4gICAgMyxcbiAgICAzLFxuICBdLFxuICAxMTY6IFsxMiwgNSwgMjEsIDUsIDQsIDYsIDEsIDgsIDAsIDEwLCAwLCAsIDIsIDE0LCA5LCAxNF0sXG4gIDExNzogWzE5LCA0LCAxNCwgNCwgNCwgNSwgMSwgNywgMCwgMTAsIDAsIDEyLCAxLCAxNSwgNCwgLCAxNSwgMTQsIDE1LCAwXSxcbiAgMTE4OiBbMTYsIDIsIDE0LCA4LCAwLCAsIDE0LCAxNCwgOCwgMF0sXG4gIDExOTogWzIyLCAzLCAxNCwgNywgMCwgLCAxMSwgMTQsIDcsIDAsICwgMTEsIDE0LCAxNSwgMCwgLCAxOSwgMTQsIDE1LCAwXSxcbiAgMTIwOiBbMTcsIDMsIDE0LCAxNCwgMCwgLCAxNCwgMTQsIDMsIDBdLFxuICAxMjE6IFsxNiwgMiwgMTQsIDgsIDAsICwgMTQsIDE0LCA4LCAwLCA2LCAtNCwgNCwgLTYsIDIsIC03LCAxLCAtN10sXG4gIDEyMjogWzE3LCAxNCwgMTQsIDMsIDAsICwgMywgMTQsIDE0LCAxNCwgLCAzLCAwLCAxNCwgMF0sXG4gIDEyMzogW1xuICAgIDE0LFxuICAgIDksXG4gICAgMjUsXG4gICAgNyxcbiAgICAyNCxcbiAgICA2LFxuICAgIDIzLFxuICAgIDUsXG4gICAgMjEsXG4gICAgNSxcbiAgICAxOSxcbiAgICA2LFxuICAgIDE3LFxuICAgIDcsXG4gICAgMTYsXG4gICAgOCxcbiAgICAxNCxcbiAgICA4LFxuICAgIDEyLFxuICAgIDYsXG4gICAgMTAsXG4gICAgLFxuICAgIDcsXG4gICAgMjQsXG4gICAgNixcbiAgICAyMixcbiAgICA2LFxuICAgIDIwLFxuICAgIDcsXG4gICAgMTgsXG4gICAgOCxcbiAgICAxNyxcbiAgICA5LFxuICAgIDE1LFxuICAgIDksXG4gICAgMTMsXG4gICAgOCxcbiAgICAxMSxcbiAgICA0LFxuICAgIDksXG4gICAgOCxcbiAgICA3LFxuICAgIDksXG4gICAgNSxcbiAgICA5LFxuICAgIDMsXG4gICAgOCxcbiAgICAxLFxuICAgIDcsXG4gICAgMCxcbiAgICA2LFxuICAgIC0yLFxuICAgIDYsXG4gICAgLTQsXG4gICAgNyxcbiAgICAtNixcbiAgICAsXG4gICAgNixcbiAgICA4LFxuICAgIDgsXG4gICAgNixcbiAgICA4LFxuICAgIDQsXG4gICAgNyxcbiAgICAyLFxuICAgIDYsXG4gICAgMSxcbiAgICA1LFxuICAgIC0xLFxuICAgIDUsXG4gICAgLTMsXG4gICAgNixcbiAgICAtNSxcbiAgICA3LFxuICAgIC02LFxuICAgIDksXG4gICAgLTcsXG4gIF0sXG4gIDEyNDogWzgsIDQsIDI1LCA0LCAtN10sXG4gIDEyNTogW1xuICAgIDE0LFxuICAgIDUsXG4gICAgMjUsXG4gICAgNyxcbiAgICAyNCxcbiAgICA4LFxuICAgIDIzLFxuICAgIDksXG4gICAgMjEsXG4gICAgOSxcbiAgICAxOSxcbiAgICA4LFxuICAgIDE3LFxuICAgIDcsXG4gICAgMTYsXG4gICAgNixcbiAgICAxNCxcbiAgICA2LFxuICAgIDEyLFxuICAgIDgsXG4gICAgMTAsXG4gICAgLFxuICAgIDcsXG4gICAgMjQsXG4gICAgOCxcbiAgICAyMixcbiAgICA4LFxuICAgIDIwLFxuICAgIDcsXG4gICAgMTgsXG4gICAgNixcbiAgICAxNyxcbiAgICA1LFxuICAgIDE1LFxuICAgIDUsXG4gICAgMTMsXG4gICAgNixcbiAgICAxMSxcbiAgICAxMCxcbiAgICA5LFxuICAgIDYsXG4gICAgNyxcbiAgICA1LFxuICAgIDUsXG4gICAgNSxcbiAgICAzLFxuICAgIDYsXG4gICAgMSxcbiAgICA3LFxuICAgIDAsXG4gICAgOCxcbiAgICAtMixcbiAgICA4LFxuICAgIC00LFxuICAgIDcsXG4gICAgLTYsXG4gICAgLFxuICAgIDgsXG4gICAgOCxcbiAgICA2LFxuICAgIDYsXG4gICAgNixcbiAgICA0LFxuICAgIDcsXG4gICAgMixcbiAgICA4LFxuICAgIDEsXG4gICAgOSxcbiAgICAtMSxcbiAgICA5LFxuICAgIC0zLFxuICAgIDgsXG4gICAgLTUsXG4gICAgNyxcbiAgICAtNixcbiAgICA1LFxuICAgIC03LFxuICBdLFxuICAxMjY6IFtcbiAgICAyNCxcbiAgICAzLFxuICAgIDYsXG4gICAgMyxcbiAgICA4LFxuICAgIDQsXG4gICAgMTEsXG4gICAgNixcbiAgICAxMixcbiAgICA4LFxuICAgIDEyLFxuICAgIDEwLFxuICAgIDExLFxuICAgIDE0LFxuICAgIDgsXG4gICAgMTYsXG4gICAgNyxcbiAgICAxOCxcbiAgICA3LFxuICAgIDIwLFxuICAgIDgsXG4gICAgMjEsXG4gICAgMTAsXG4gICAgLFxuICAgIDMsXG4gICAgOCxcbiAgICA0LFxuICAgIDEwLFxuICAgIDYsXG4gICAgMTEsXG4gICAgOCxcbiAgICAxMSxcbiAgICAxMCxcbiAgICAxMCxcbiAgICAxNCxcbiAgICA3LFxuICAgIDE2LFxuICAgIDYsXG4gICAgMTgsXG4gICAgNixcbiAgICAyMCxcbiAgICA3LFxuICAgIDIxLFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDEyLFxuICBdLFxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/fonts/single-line/hershey/simplex.js\n");

/***/ })

/******/ });
});
});

var api$1 = unwrapExports(api);

export default api$1;
